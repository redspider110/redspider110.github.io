<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Bitmap 相关]]></title>
    <url>%2F2019%2F07%2F22%2F0118-android-bitmap%2F</url>
    <content type="text"><![CDATA[Android Bitmap 占用内存大小、优化方案等等。 BitmapFactory.OptionsBitmapFactory 在解码生成 Bitmap 时，会通过 Options 的各种参数来做控制。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class Options &#123; public Options() &#123; inScaled = true; inPremultiplied = true; &#125; // 如果设置了，重用该位图的存储空间 public Bitmap inBitmap; // 返回的 Bitmap 是否可操作 public boolean inMutable; // 设置为 true ，不会将 bitmap 加载到内存！解码时返回的 bitmap 是 null // 但是能通过 Options.out*** 获取图片的大小等 public boolean inJustDecodeBounds; // 采样率，值为接近 2 的指数幂 public int inSampleSize; // 色彩模式，默认为 ARGB_8888 public Bitmap.Config inPreferredConfig = Bitmap.Config.ARGB_8888; public ColorSpace inPreferredColorSpace = null; // 透明通道，默认为 true ，表示 bitmap 中添加透明通道 public boolean inPremultiplied; // 位图的像素密度，即每英寸有多少个像素；通常为资源文件所在目录对应 density // 也就是说资源文件放到不同的 drawable-**** 目录下，这个值是不一样的 public int inDensity; // 绘制位图屏幕的密度；通常为显示这张图片手机的 density // 也就是说不同手机显示时，这个值是不一样的 public int inTargetDensity; // 正在使用的实际屏幕的像素密度；暂时没发现在哪会用到 public int inScreenDensity; // 是否缩放 public boolean inScaled; // 解码后可以拿到原始图片的宽高、类型等属性 public int outWidth; public int outHeight; public String outMimeType; public Bitmap.Config outConfig; public ColorSpace outColorSpace; // 解码时临时存储数组 public byte[] inTempStorage; // 下面几个已经废弃 public boolean inDither; public boolean inPurgeable; public boolean inInputShareable; public boolean inPreferQualityOverSpeed; public boolean mCancel;&#125; 重要属性 inJustDecodeBounds设置为 true 时，不会为图片分配内存，解码时返回为 null 没有 bitmap ，但是会设置 Options.out*** 相关属性；即将被解码图片的属性读出来，而不生成 Bitmap 也不加载到内存。在被读取图片尺寸很大或者存储大小非常大时，通常通过该属性预读取图片相关参数，避免直接加载引起 OOM 。 inSampleSize采样率，值为最接近接近 2 的指数幂。即采样后得到的图片大小为原始宽高的 1/inSampleSize 。比如原始图片大小为 100*100 ，采样率为 4，最终生成大小为 25*25 ，整个像素大小减小到 1/16 。常用于压缩大尺寸图片。 inPreferredConfig色彩模式，默认为 ARGB_8888 ，即 4 字节存储。可以在解码前通过设置 Config 来决定使用几字节存储。常用于压缩图片存储空间，采用 RGB_565 模式。 inMutable是否可操作标记。比如返回的 Bitmap 会通过 Canvas 重新绘制，必须设置为 true ，否则会抛出异常 Immutable bitmap passed to Canvas constructor 。 inScaled, inDensity, inTargetDensity表示图片是否被缩放；如果设置为缩放，缩放比例为 scale = inTargetDensity/inDensity ，其中 inTargetDensity 表示当前显示图片手机的密度， inDensity 为资源文件所在 drawable- 目录对应的密度；通常只有从资源文件中加载 Bitmap 时，这几个字段才会生效；如果是直接从 Asserts 或者本地文件等等中加载，是不会有影响的。 outWidth, outHeight表示解码一张图片时，获取图片原始的宽、高、类型等信息。 色彩模式 Bitmap.Config色彩模式，表示 Bitmap 由哪些颜色组成，并占用几位内存： 12345678910public enum Config &#123; ALPHA_8 (1), RGB_565 (3), @Deprecated ARGB_4444 (4), ARGB_8888 (5), RGBA_F16 (6), HARDWARE (7); ...&#125; 常见色彩模式及对应描述： Config 占用内存字节(byte) 描述 ALPHA_8 1 单透明通道，只由透明度组成 RGB_565 2 由 RGB 三色组成，分别占 5, 6, 5 位 ARGB_4444 4 已废弃 ARGB_8888 4 24 位真彩色，由透明度 RGB 四部分组成 RGBA_F16 8 Android8.0新增（更丰富的色彩表现HDR） HARDWARE Special Android 8.0 新增 （Bitmap直接存储在graphic memory） 密度 Density当前设备密度当前设备密度主要由显示屏的参数等决定，通常显示设备 LCD 的规格书中，会明确指出屏幕尺寸（ 3.5 寸）、分辨率 320*480 、能显示多少种颜色 65K colors 等等，但并没有给出具体的 dpi, density, densityDpi ；这些密度相关值都是在软件代码中设置的，而软件的主要依据是屏幕分辨率的宽度。Android 中通常是使用 ro.sf.lcd_density 属性来记录当前显示屏对应的密度值的，可以在下列任意一个文件中设置（高通平台）： 12device/qcom/common/init/init_msm***.cdevice/qcom/common/rootdir/etc/init.qcom.***.sh 以 init_msm8916.c 文件为例： 123456789101112131415161718192021222324252627#define VIRTUAL_SIZE "/sys/class/graphics/fb0/virtual_size"...void init_msm_properties(unsigned long msm_id, unsigned long msm_ver, char *board_type)&#123; int rc; unsigned long virtual_size = 0; ... // 获取分辨率，并取出宽度 rc = read_file2(VIRTUAL_SIZE, str, sizeof(str)); if (rc) &#123; virtual_size = strtoul(str, NULL, 0); &#125; if(virtual_size &gt;= 1080) &#123; property_set(PROP_LCDDENSITY, "480"); &#125; else if (virtual_size &gt;= 720) &#123; // For 720x1280 resolution // 当前分辨率为 720*2880 ，设置密度为 320 property_set(PROP_LCDDENSITY, "320"); &#125; else if (virtual_size &gt;= 480) &#123; // For 480x854 resolution QRD. property_set(PROP_LCDDENSITY, "240"); &#125; else property_set(PROP_LCDDENSITY, "320"); ...&#125; 以 init.qcom.early_boot.sh 文件为例： 123456789101112131415161718192021222324252627// 从 virtual_size 读取分辨率，并获取宽度值if [ -f /sys/class/graphics/fb0/virtual_size ]; then res=`cat /sys/class/graphics/fb0/virtual_size` 2&gt; /dev/null fb_width=$&#123;res%,*&#125;fi...// 根据宽度来设置密度，比如当前显示设备为 720*2880 ，则密度设置为 320function set_density_by_fb() &#123; #put default density based on width if [ -z $fb_width ]; then setprop ro.sf.lcd_density 320 else if [ $fb_width -ge 1440 ]; then setprop ro.sf.lcd_density 560 elif [ $fb_width -ge 1080 ]; then setprop ro.sf.lcd_density 480 elif [ $fb_width -ge 720 ]; then setprop ro.sf.lcd_density 320 #for 720X1280 resolution elif [ $fb_width -ge 480 ]; then setprop ro.sf.lcd_density 240 #for 480X854 QRD resolution else setprop ro.sf.lcd_density 160 fi fi&#125; 在 DisplayMetrics 中，默认的 density, densityDpi 都是根据这个属性来设置默认值的： 12345678910111213141516171819202122232425public class DisplayMetrics &#123; ... public float density; public int densityDpi; @Deprecated public static int DENSITY_DEVICE = getDeviceDensity(); public static final int DENSITY_DEVICE_STABLE = getDeviceDensity(); public void setToDefaults() &#123; ... // 默认值 density = DENSITY_DEVICE / (float) DENSITY_DEFAULT; densityDpi = DENSITY_DEVICE; scaledDensity = density; xdpi = DENSITY_DEVICE; ydpi = DENSITY_DEVICE; ... &#125; private static int getDeviceDensity() &#123; return SystemProperties.getInt("qemu.sf.lcd_density", SystemProperties.getInt("ro.sf.lcd_density", DENSITY_DEFAULT)); &#125; 结论： Android 系统会根据显示设备分辨率的宽度，来设置对应的 lcd_density 属性， DisplayMetrics 中会根据这个属性值来设置系统的 density, densityDpi ，而这两个值决定了资源文件中位图缩放的比例。 资源文件对应密度资源文件存放在不同的目录 mdpi, hdpi 等，对应的密度信息如下： DensityDpi res Density 120dpi ldpi 0.75 160dpi mdpi 1 240dpi hdpi 1.5 320dpi xhdpi 2 480dpi xxhdpi 3 640dpi xxxhdpi 4 参考：Android 官网-支持不同的像素密度 ，这些资源目录对应的 DensityDpi 的值是固定的，源码中以常量方式存在： 123456789101112131415public class DisplayMetrics &#123; // res 下的标准密度 public static final int DENSITY_LOW = 120; public static final int DENSITY_MEDIUM = 160; public static final int DENSITY_HIGH = 240; public static final int DENSITY_XHIGH = 320; public static final int DENSITY_XXHIGH = 480; public static final int DENSITY_XXXHIGH = 640; public static final int DENSITY_DEFAULT = DENSITY_MEDIUM; // 其他密度 public static final int DENSITY_TV = 213; public static final int DENSITY_260 = 260; ...&#125; 其中 160dpi 为标准密度，即 density=1 ； Density 的计算方式是当前 DensityDpi 和标准密度的比值：比如 XXHIGH ，其 Density=480/160=3 。dp 与 px 的换算公式为： px = dp * Density ；因此资源位图如果没有以正确的尺寸放到对应合适的 drawable- 目录下，会出现位图缩放，导致失真、模糊等等。比如一张 48*48 的位图，放于 drawable-mdpi 中，它在 densityDpi=160 的设备中将会无缩放直接显示；但是它在 densityDpi=320 的设备中，在同样大小的 ImageView 中显示，则需要将图片放大到 2 倍，如果图片细节处理不好，放大后可能会出现模糊；这种情况下，需要 UI 工程师提供一张对应的 96*96 位图放到 drawable-xhdpi 目录下就不会缩放了。对于 48*48 的位图，在不同密度的屏幕上正确显示，需要的尺寸及存放目录如下： 分辨率 drawable 目录 36x36 ldpi 48x48 mdpi 72x72 hdpi 96x96 xhdpi 144x144 xxhdpi 192x192 xxxhdpi Bitmap 的内存内存计算获取 Bitmap 占用内存的大小，对应方法如下： 123// Bitmap.javapublic final int getByteCount() &#123;...&#125;public final int getAllocationByteCount() &#123;...&#125; 其中，如果设置了 BitmapFactory.Options.inBitmap 即采用 Bitmap 内存复用时， getByteCount 表示新增内存空间大小；否则两者相等，都表示 Bitmap 实际占用内存空间大小。计算方式：Bitmap内存 ≈ 像素数据总大小 = 横向像素值 * 纵向像素值 * 每个像素的内存 ，其中： 每个像素占用内存由色彩模式决定，即 Bitmap.Config ；在 BitmapFactory 解码时，可以指定 Options.inPreferredConfig 来设置对应的色彩模式。默认为 ARGB_8888 即 4 字节，通常可以使用 RGB_565 即 2 字节来压缩。 横向像素值/纵向像素值大致的计算方式为 dstWidth = srcWidth*scale ；其中缩放比例 scale = inTargetDensity / inDensity 。如果需要更精确的计算，参考 BitmapFactory.cpp::doDecode 源码： 12345678// BitmapFactory.cpp::doDecode// Scale is necessary due to density differences.if (scale != 1.0f) &#123; willScale = true; // 先乘以缩放系数，再加上 0.5 ，最后转为整型 scaledWidth = static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); scaledHeight = static_cast&lt;int&gt;(scaledHeight * scale + 0.5f);&#125; 这个缩放只对通过资源文件 drawable- *生成 Bitmap 时有效，即通过 `BitmapFactory.decodeResource相关代码，才会使用缩放；其他方法解码时不会使用缩放，即scale` 为 1 。 资源文件占用的内存加载资源文件在内存当中占用的大小取决于以下几点： 色彩模式 采样率 资源文件存放的目录 inDensity ，即 hdpi,xxhdpi,mdpi 等 目标显示屏幕 inTargetDensity 比如一张 720x1080 大小的图片，放在 drawable-xhdpi 目录下（即 inDensity = 320 ），使用 BitmapFactory.decodeResource 来解码生成 Bitmap ，分别在不同手机上占用内存空间大小： 在 720x1080 手机 inTargetDensity = 320 上加载，图片不会被压缩 在 480x800 手机 inTargetDensity = 240 上加载，缩放率 scale=240/320=3/4 在 1080x1920 手机 inTargetDensity = 480 上加载，缩放率 scale=480/320=3/2 Bitmap 内存回收 Android 2.3.3(API 10) 及以下的系统在 2.3 以下的系统中， Bitmap 的像素数据是存储在 native 中， Bitmap 对象是存储在 Java 堆中的，所以在回收 Bitmap 时，需要回收两个部分的空间： native 和 Java 堆。即先调用 recycle() 释放 native 中 Bitmap 的像素数据，再对 Bitmap 对象置 null ，保证 GC 对 Bitmap 对象的回收。 Android 3.0(API 11) 及以上的系统在 3.0 以上的系统中， Bitmap 的像素数据和对象本身都是存储在 Java 堆中的，无需主动调用 recycle() ，只需将对象置 null ，由 GC 自动管理。 Bitmap 内存复用从 Android3.0 开始，在 Bitmap 中引入了一个新的字段 BitmapFactory.Options.inBitmap ，设置此字段为 true 后，解码方法会尝试复用一张存在的 Bitmap 。这意味着 Bitmap 的内存被复用，避免了内存的回收及申请过程，显然性能表现更佳。Android4.4(API 19) 之前只有格式为 jpg, png ，同等宽高（要求苛刻）， inSampleSize 为 1 的 Bitmap 才可以复用。从 Android4.4(API 19) 开始被复用的 Bitmap 的内存大于需要新申请内存的 Bitmap 的内存就可以了。 加载大图片根据计算公式：Bitmap 占用内存的大小主要由图片分辨率等决定（和图片文件大小有几兆无关，它只是占用 ROM ，不是 RAM ），因此加载大图片前可以先读取图片的宽高等信息，再计算采样率，最后再加载缩放到指定大小。为了避免 OOM 异常，最好在解析每张图片的时候都先检查一下图片的大小，以下几个因素是我们需要考虑的： 预估一下加载整张图片所需占用的内存 为了加载这一张图片你所愿意提供多少内存 用于展示这张图片的控件的实际大小 当前设备的屏幕尺寸和分辨率 需要注意的是，如果使用 InputStream 解码获取 Bitmap ，因为流的特性，只能读取一次；所以如果多次读取同一张图，可以使用文件描述符等来实现。 获取 ImageView如果 ImageView 设置为自适应或者匹配屏幕大小，在没有完成加载前，读取到的宽高为 0 ，因此可以先获取当前手机屏幕分辨率，给出一个预估值。 获取图片宽高分辨率BitmapFactory.Options.inJustDecodeBounds 设置为 true ，解码时仅读取图片宽高等信息，不会将图片加载到内存。 123456BitmapFactory.Options options = new BitmapFactory.Options();options.inJustDecodeBounds = true; // 不将图片加载到内存，仅读取图片信息BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor() , null, options); // 这次解码，返回的 Bitmap 为空Log.d(TAG, " width = " + options.outWidth + ", height = " + options.outHeight); // outWidth, outHeight 即为图片分辨率 计算采样率 inSampleSize根据给定的宽高信息，计算被加载图片最合适的采样率。 12345678910111213141516private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; final int width = options.outWidth; final int height = options.outHeight; int inSampleSize = 1; if (height &gt; reqHeight || width &gt; reqWidth) &#123; //使用需要的宽高的最大值来计算比率 final int suitedValue = reqHeight &gt; reqWidth ? reqHeight : reqWidth; final int heightRatio = Math.round((float) height / (float) suitedValue); final int widthRatio = Math.round((float) width / (float) suitedValue); inSampleSize = heightRatio &gt; widthRatio ? heightRatio : widthRatio;//用最大 &#125; return inSampleSize;&#125; 指定采样率初步加载图片根据计算出来的采样率，初步加载图片。 123456789options.inSampleSize = calculateInSampleSize(options, size.x, size.y);options.inJustDecodeBounds = false; // 设置为 false 加载到内存并生成 Bitmapoptions.inMutable = true;options.inPreferredConfig = Bitmap.Config.RGB_565;Bitmap display = BitmapFactory.decodeFileDescriptor( pfd.getFileDescriptor(), null, options);// 输出实际加载后的图片分辨率Log.d(TAG, "display.width = " + display.getWidth() + ", display.height = " + display.getHeight()); 缩放到指定大小根据给定的 Bitmap ，以及指定的大小，使用 createScaledBitmap 来创建缩放后的 Bitmap 。 1Bitmap detectBitmap = Bitmap.createScaledBitmap(src, dstX, dstY, false); 设置 inMutable 的几种方式 BitmapFactory.Options.inMutable = true Bitmap.copy(null, true) 后续 Matrix 矩阵 大图小用用采样，小图大用用矩阵 BitmapRegionDecoderBitmapRegionDecoder 分区域加载：public Bitmap decodeRegion(Rect rect, BitmapFactory.Options options) {...} 指定区域加载图片，不用通过采样率压缩。 参考文档 浅谈BitmapFactory.Options 根据ImageView的大小来压缩Bitmap，避免OOM Android 开发绕不过的坑：你的 Bitmap 究竟占多大内存 Android性能优化：Bitmap详解&amp;你的Bitmap占多大内存 图片加载和Bitmap的内存优化 鸿洋：Android 高清加载巨图方案]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MTCNN 人脸检测]]></title>
    <url>%2F2019%2F06%2F03%2F0117-dl-mtcnn%2F</url>
    <content type="text"><![CDATA[MTCNN 人脸检测关键 5 点：眼、鼻、嘴。 概述MTCNN 人脸检测模型由中国科学院深圳先进技术研究院，在 2016 年发布，通过三个网络级联实现人脸 5 个关键点（双眼、鼻、嘴）的定位检测；大致检测流程如下： 相关资源 人脸识别中 MTCNN 多任务卷积论文：Multi-Task Convolutional Neural Network for Pose-Invariant Face Recognition MTCNN 实现人脸关键点检测论文：Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks 论文作者 kpzhang93 代码仓库，包含最新的论文和代码：Github上官方代码实现 Facenet 中基于 kpzhang93 提供的数据对齐人脸：Facenet 中使用 TensorFlow 实现的 MTCNN 基于 davidsandberg/facenet 提供的数据，转换为 TensorFlow 中的模型 pb 文件：vcvycy: MTCNN-TensorFlow-freeze-model vcvycy 基于上面的模型 pb 文件，在 Android 上的实现：MTCNN TensorFlow mobile 参考 kpzhang93 的论文，自己准备数据，基于 TensorFlow 的实现完整的 MTCNN 并生成模型：AITTSMD: MTCNN-TensorFlow 基于 AITTSMD 训练的数据转换为 tflite：pb 转 tflite WIDERFACE 人脸数据集，常用于自己训练模型：WIDERFACE data 人脸和关键 5 点数据集，需要翻墙下载（已下载到个人网盘）：Deep Convolutional Network Cascade for Facial Point Detection 几个名词 Bounding box regression边框回归，预测的框有可能不是完整的被检测到的物体，需要微调到到真实大小的框，这个预测框转换为真实框的过程叫做边框回归。 IoUIoU: Intersec over Union 交并比，也就是重叠度，计算的是预测框和真实框的交集和并集的比值，当 IoU 大于某个阈值（0.5）时，就认为预测框是正确的。常用于评价定位算法是否精准。 NMSNMS: Non Maximum Suppression 非极大值抑制，即只保留局部最大值，用于去掉重复的检测框，只保留局部最好的检测框，即检测分数最高的框。 模型结构模型结构图 有三个独立的网络构成： P-Net, R-Net, O-Net 。 P-NetP-Net: Proposal Network ，是全卷积网络，因此可以接受任意尺寸的输入图片，这里假定输入大小为 12*12*3 ： 第一层：使用 10 个 3*3*3 的卷积核，滑动步长为 1 ， padding 为 VALID ，卷积输出大小为 10*10*10 ；再经过 2*2 的池化核，滑动步长为 2 的 Max Pooling ，生成 10 个 5*5 的特征图 第二层：使用 16 个 3*3*10 的卷积核，滑动步长为 1 ， padding 为 VALID ，生成 16 个 3*3 的特征图 第三层：使用 32 个 3*3*16 的卷积核，滑动步长为 1 ， padding 为 VALID ，生成 32 个 1*1 的特征图 对于这 32 个 1*1 的特征图，训练时分三部分并行处理：分类 face classification ， 回归框判断 bounding box regression ，轮廓点定位 Facial landmark localization 分类 face classification ： 使用 2 个 1*1*32 的卷积核，生成 2 个 1*1 的特征图用于分类 回归框判断 bounding box regression ：使用 4 个 1*1*32 的卷积核，生成 4 个 1*1 的特征图用于回归框判断 轮廓点定位 Facial landmark localization ：使用 10 个 1*1*32 的卷积核，生成 10 个 1*1 的特征图用于人脸轮廓点的定位 R-NetR-Net: Refine Network ，该网络先通过卷积然后再做全连接，也是分成三部分处理； R-Net 的输入为固定大小 24*24*3 ，但是输入个数由 P-Net 输出的候选框个数决定。当 P-Net 处理完图像后，得到的候选回归框通过 NMS 去除冗余，并将候选框调整为正方形区域；从原始图片中截取出候选框大小的图片，并缩放为 24*24 大小，作为 R-Net 的输入，每个 24*24*3 大小的候选框会经过 R-Net 处理： 第一层：使用 28 个 3*3*3 的卷积核，输出大小为 22*22*28 ；再经过 3*3 的池化核，滑动步长为 2 的最大池化，生成 28 个 11*11 的特征图 第二层：使用 48 个 3*3*28 的卷积核，输出大小为 9*9*48 ；再经过 3*3 的池化核，滑动步长为 2 的最大池化，生成 48 个 4*4 的特征图 第三层：使用 64 个 2*2*48 的卷积核，生成 64 个 3*3 的特征图 第四层：全连接层，64 个 3*3 的特征图喂入全连接层后，输出大小为 128 ；训练时，从这里分成三部分处理：分类 face classification ， 回归框判断 bounding box regression ，轮廓点定位 Facial landmark localization 分类 face classification ：全连接输入大小为 128 ，输出为人脸的 2 分类结果 回归框判断 bounding box regression ：全连接输入大小为 128 ，输出为大小为 4 的回归框判断结果 轮廓点定位 Facial landmark localization ：全连接输入大小为 128 ，输出为大小为 10 的轮廓点定位 O-NetO-Net: Output Network ，该网络和 R-Net 很类似； O-Net 的输入为固定大小 48*48*3 ，但是输入个数由 R-Net 输出的候选框个数决定。当 R-Net 处理完图像后，得到的候选回归框通过 NMS 去除冗余；从原始图片中截取出候选框大小的图片，并调整为 48*48 大小，作为 O-Net 的输入，每个 48*48*3 大小的候选框会经过 O-Net 处理： 第一层：使用 32 个 3*3*3 的卷积核，输出大小为 46*46*32 ；再经过 3*3 的池化核，滑动步长为 2 的最大池化，生成 32 个 23*23 的特征图 第二层：使用 64 个 3*3*32 的卷积核，输出大小为 21*21*64 ；再经过 3*3 的池化核，滑动步长为 2 的最大池化，生成 64 个 10*10 的特征图 第三层：使用 64 个 3*3*64 的卷积核，输出大小为 8*8*64 ；再经过 2*2 的池化核，滑动步长为 2 的最大池化，生成 64 个 4*4 的特征图 第四层：使用 128 个 2*2*64 的卷积核，生成 128 个 3*3 的特征图 第五层：全连接层，128 个 3*3 的特征图喂入全连接层后，输出大小为 256 ；训练时，从这里分成三部分处理：分类 face classification ， 回归框判断 bounding box regression ，轮廓点定位 Facial landmark localization 分类 face classification ：全连接输入大小为 256 ，输出为人脸的 2 分类结果 回归框判断 bounding box regression ：全连接输入大小为 256 ，输出为大小为 4 的回归框判断结果 轮廓点定位 Facial landmark localization ：全连接输入大小为 256 ，输出为大小为 10 的轮廓点定位 损失函数三个网络的损失函数分别为： P-Net 损失函数为二分类交叉熵 R-Net, O-Net 损失函数都为 L2 均方差 多任务训练时，不是每个示例的都需要使用三种损失函数，在 P-Net, R-Net 中， α 分类、候选框、定位的值为 1, 0.5, 0.5 ；在 O-Net 中， α 分类、候选框、定位的值为 1, 0.5, 1 ；对于 β∈(0,1) 。 模型小结 三个网络的卷积核的滑动步长都为 1 ， padding 都为 VALID 卷积后面激活函数为 PReLU 三个网络池化核滑动步长都为 2 三个网络的输出都为三部分：分类 face classification ， 回归框判断 bounding box regression ，轮廓点定位 Facial landmark localization ，但只有 O-Net 的轮廓定位点是有效的 P-Net 使用了 1*1 的卷积来代替全连接，好处是输入可以是任意尺寸 2 个人脸分类结果：第二个表示是人脸的分数 4 个回归框结果：分别对应回归框映射时左上右下映射参数 10 个轮廓点定位：表示 5 个关键点（左眼，右眼、鼻、嘴左边、嘴右边）的坐标，其中第 1 个和第 6 个表示左眼坐标，第 2 个和第 7 个表示右眼坐标，以此类推 参考文档 MTCNN（Multi-task convolutional neural networks）人脸对齐 人脸检测：MTCNN 边框回归(Bounding Box Regression)详解 目标检测之 IoU NMS——非极大值抑制 MTCNN人脸检测—RNet网络训练]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow 相关]]></title>
    <url>%2F2019%2F05%2F27%2F0116-dl-tensorflow%2F</url>
    <content type="text"><![CDATA[TensorFlow 安装，运行，实现常见神经网络模型。 TensorFlow 是 Google 开源库，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。 TensorFlow 官网 github TensorFlow 官方在线模拟器 环境搭建参考官网提供的环境搭建方法： TensorFlow install 。 安装可以在 Ubuntu 系统的 python 环境中运行 TensorFlow ，主要有两种安装方式： pippip install tensorflow 安装最新稳定的 CPU-only 包。 docker基于 docker 运行 TensorFlow 容器， docker 提供了虚拟技术，能和本地环境隔离，推荐使用这种方式；安装好 docker 环境后，下载镜像 docker pull tensorflow/tensorflow 。 运行基于 docker 运行 TensorFlow 容器，有多种 tag 可选，参考 docker tensorflow 官网 ；这里使用 python 3 和 Jupyter Notebook 来运行环境： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263xmt@server138:~/share$ docker run -it --rm -v /home/xmt/share/notebooks:/tf/notebooks -p 8888:8888 tensorflow/tensorflow:latest-py3-jupyterUnable to find image &apos;tensorflow/tensorflow:latest-py3-jupyter&apos; locallylatest-py3-jupyter: Pulling from tensorflow/tensorflow7e6591854262: Already exists089d60cb4e0a: Already exists9c461696bc09: Already exists45085432511a: Already exists29303e8416d5: Pull complete12bb05a3cac8: Pull completefe293195091d: Pull complete22d8b84cd8f1: Pull completeb816d6e919ba: Pull complete0a5fb8dc4fa0: Pull completea7dc31fab397: Pull completed406455f6d9f: Pull completecb88aeed8681: Pull complete2c6b687d0099: Pull complete49f54073aeda: Pull completeacd118762b5b: Pull completeb9384d74861e: Pull complete65bee665f5e0: Pull complete818ff729acb5: Pull complete26046fcf0a8f: Pull complete6e2e469b2c13: Pull completeDigest: sha256:875bc50785ee24c69b8dbc3700bb090d5c126458d4a1d761aada539124adbcbcStatus: Downloaded newer image for tensorflow/tensorflow:latest-py3-jupyter________ __________________ __/__________________________________ ____/__ /________ ____ / _ _ \_ __ \_ ___/ __ \_ ___/_ /_ __ /_ __ \_ | /| / /_ / / __/ / / /(__ )/ /_/ / / _ __/ _ / / /_/ /_ |/ |/ //_/ \___//_/ /_//____/ \____//_/ /_/ /_/ \____/____/|__/WARNING: You are running this container as root, which can cause new files inmounted volumes to be created as the root user on your host machine.To avoid this, run the container by specifying your user&apos;s userid:$ docker run -u $(id -u):$(id -g) args...[I 07:37:05.926 NotebookApp] Writing notebook server cookie secret to /root/.local/share/jupyter/runtime/notebook_cookie_secretjupyter_http_over_ws extension initialized. Listening on /http_over_websocket[I 07:37:07.164 NotebookApp] Serving notebooks from local directory: /tf[I 07:37:07.164 NotebookApp] The Jupyter Notebook is running at:[I 07:37:07.164 NotebookApp] http://(5cb2948c32fc or 127.0.0.1):8888/?token=a1127a74507b98306346cf77a70c6b814ac08a21ccdceea2[I 07:37:07.164 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).[C 07:37:07.168 NotebookApp] To access the notebook, open this file in a browser: file:///root/.local/share/jupyter/runtime/nbserver-11-open.html Or copy and paste one of these URLs: http://(5cb2948c32fc or 127.0.0.1):8888/?token=a1127a74507b98306346cf77a70c6b814ac08a21ccdceea2[I 07:39:18.476 NotebookApp] 302 GET / (10.20.153.40) 1.46ms[I 07:39:18.483 NotebookApp] 302 GET /tree? (10.20.153.40) 1.64ms[W 07:39:27.698 NotebookApp] Not allowing login redirect to &apos;/tree?&apos;[I 07:39:27.699 NotebookApp] 302 POST /login?next=%2Ftree%3F (10.20.153.40) 4.62ms[I 07:39:27.706 NotebookApp] 302 GET / (10.20.153.40) 1.16ms[I 07:40:34.947 NotebookApp] Writing notebook-signing key to /root/.local/share/jupyter/notebook_secret[W 07:40:34.952 NotebookApp] Notebook tensorflow-tutorials/basic_classification.ipynb is not trusted[I 07:40:36.081 NotebookApp] Kernel started: b4f634bf-1da6-48e8-81cd-f11f45df4072[I 07:40:37.784 NotebookApp] Adapting to protocol v5.1 for kernel b4f634bf-1da6-48e8-81cd-f11f45df4072 执行完后，可以在浏览器中输入 http://ip:8888 来访问 Jupyter Notebook ， token 为上面输出的那串数字！ Jupyter Notebook 教程Jupyter Notebook 是网页化的 Python 编辑器，快速方便交互。 快捷键Jupyter 和 vim 一样分为命令模式和编辑模式，使用 ESC 进入命令模式；如下是部分快捷键： 命令模式 L 显示当前单元格行号 shift + L 显示所有单元格行号 编辑模式 tab 自动补全 shift + tab 查看当前函数说明 shift + enter 运行当前单元，并选中下一单元 ctrl + enter 只运行当前单元 使用 Alt 键可以多列选择。 特殊功能在 Jupyter notebook 中支持命令安装，图形显示等等。 安装 python 包Jupyter 的每个 cell 可以执行 unix command ，具体方法是在 command 前加一个 ! 号。比如使用 pip install 安装 matplotlib 包时，键入 !pip install matplotlib 。其他示例：查看 python 版本 !python --version ；运行 python 文件 !python myfile.py 。 % 运算符 使用 matplotlib 显示图形时，输入命令 %matplotlib inline 将本地的 .py 文件加载到当前单元 %load test.py 运行本地 .py 文件 %run file.py 扩展安装扩展： pip install jupyter_contrib_nbextensions; jupyter contrib nbextension install AutoPEP8代码格式化工具： pip install autopep8 ，安装完毕后，在扩展中勾选 autopep8 。 基础知识Tensor 张量Tensor 张量，表示一个数据结构，有三个最基本的属性：名称 name ，形状 shape ，数据类型 dtype 。张量用来存放数据（通常是多维数组，维度即为形状），比如： 12345c = tf.constant([[1,2,3],[4,5,6]])print(c)with tf.Session() as sess: print(sess.run(c)) 输出结果为： 123Tensor(&quot;Const_10:0&quot;, shape=(2, 3), dtype=int32)[[1 2 3] [4 5 6]] 示例中张量 c 名称为 Const_10 ，形状为可以存放 2*3 的数据，数据类型为 int32 。 我们用阶表示张量的维度： 0 阶张量即为标量，表示一个单独数： S=123 。 1 阶张量表示一个一维数组： `S=[1, 2, 3] 。 2 阶张量表示一个二维数组，它可以有 i 行 j 列个元素，每个元素可以通过下标来索引到： S=[[1, 2, 3], [4, 5, 6]] 。 判断张量是几阶的，可以通过等号后面中括号的个数来看出来，比如 m=[[[...] 表示为 3 阶的。 会话会话 Session ，执行计算过程； Tensor 只描述了数据，所有 Tensor 的操作也只描述了计算过程，而运算都是通过会话来实现的。计算过程使用下面结构： 12with tf.Session() as sess: sess.run(***) run 来执行运算过程。 神经网络 官方经典示例： mnist 手写识别 常用函数 神经网络参数指神经元线上的权重，参数初始值通常使用随机数，这些参数也是最终我们需要求出的值。通过张量来描述: w = tf.Variable(tf.truncated_normal(shape, stddev=0.1)) 。 前向传播搭建模型的计算过程，让模型具有推理能力，可以针对一组输入给出响应的输出。比如某个神经元的前向传播描述为：输入乘以权重后，加上偏置，再通过激活函数；表示为 y1 = tf.nn.relu(tf.matmul(x, w1) + b1) 。 反向传播训练模型参数，使神经网络模型在训练数据上的损失函数最小，比如在所有参数上用梯度下降。损失函数 loss 即计算得到的预测值和已知结果的差距。如果预测值 y 与已知答案 y_ ，常见损失函数有： 均方差 mse ： mse=tf.reduce_mean(tf.square(y-y_)) 交叉熵 ce ： ce=tf.reduce_mean(y_*tf.log(tf.clip_by_value(y, 1e-12, 1.0))) 常见分类器 Sigmoid 分类器，也就是 Sigmoid 激活函数，用于二分类 Softmax 分类器，用于多分类； n 分类应用中：softmax 函数在 n 分类应用中，模型会有 n 个输出 y1, y2,..., yn ，其中 yi 表示第 i 种情况出现的概率；这 n 个输出经过 softmax 函数后，可以得到符合概率分布的分类结果。一般让模型的输出经过 softmax 函数，以获得输出分类的概率分布，再与标准答案对比，求出交叉熵，得到损失函数： 123ce = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, 1))cem = tf.reduce_mean(ce) 学习率学习率 learning rate ：决定每次参数更新的幅度。当学习率选择过大时会出现震荡不收敛；选择过小时会出现收敛速度慢的情况。在训练过程中，参数的更新向着损失函数梯度下降的方向。指数衰减学习率：学习率随着训练轮数变化而动态更新，计算公式如下： 1234Learning_rate=LEARNING_RATE_BASE*LEARNING_RATE_DECAY *(global_step/LEARNING_RATE_BATCH_SIZE)decayed_learning_rate = learning_rate * decay_rate ^ (global_step / decay_steps) 对应函数为： 1234567global_step = tf.Variable(0, trainable=False)decayed_learning_rate = tf.train.exponential_decay( learning_rate, // 学习率的初始值 global_step, // 当前训练轮数 decay_steps, // 多少轮更新一次学习率 decay_rate, // 学习率的衰减率 staircase=True/False) // Ture 表示除号取整，阶梯型衰减；False 表示平滑下降 示例代码，初始值为 0.1 ，每 100000 轮更新一次学习率，衰减率为 0.96 ： 1234global_step = tf.Variable(0, trainable=False)starter_learning_rate = 0.1learning_rate = tf.train.exponential_decay(starter_learning_rate, global_step, 100000, 0.96, staircase=True) 滑动平均滑动平均：记录了一段时间内模型中所有参数 w 和 b 各自的平均值，利用滑动平均值可以增强模型的泛化能力。滑动平均影子计算公式： shadow_variable = decay * shadow_variable + (1 - decay) * variable衰减率 decay=min(decay, (1 + num_updates) / (10 + num_updates)) ，初始值通常为接近 1 的数，比如： 0.99 ， 0.999 等等。 12345678910# Create an ExponentialMovingAverage objectema = tf.train.ExponentialMovingAverage( decay, // 衰减率，初值通常为 0.99, 0.999 等 num_updates=None) // 多少轮更新一次衰减率 # 求参数列表的滑动平均值ema_op = ema.apply(tf.trainable_varialbes())# 查看参数的滑动平均值sess.run([w1, ema.average(w1)]) 正则化在损失函数中给每个参数 W 加上权重，引入模型复杂度指标，从而抑制模型噪声，减小过拟合。正则化有 L1, L2 的区分，计算公式如下： 12loss_l1 = tf.contrib.layers.l1_regularizer(REGULARIZER)(w)loss_l2 = tf.contrib.layers.l2_regularizer(REGULARIZER)(w) 其中 w 为希望被正则化的参数， REGULARIZER 为标量乘法器的值（即正则化后再乘以这个比例），通常初始为 0.001 。正则化参数后，优化损失函数： 1234tf.add_to_collection('losses', tf.contrib.layers.l2_regularizer(regularizer)(w))loss_mse = tf.reduce_mean(tf.square(y-y_))loss_total = loss_mse + tf.add_n(tf.get_collection('losses')) 神经网络搭建八股神经网络搭建，参考： 北大mooc tensorflow 笔记 助教整理 pdf 网友整理的代码实现： Adnios kaixindelele tianxiaomo 搭建大体遵循如下流程： 准备数据集，提取特征，作为输入喂给神经网络 搭建 NN 结构，从输入到输出；即搭建计算图NN 前向传播算法，计算输出结果 大量特征数据喂给 NN ，迭代优化 NN 参数NN 反向传播算法，优化参数训练模型 使用训练好的模型预测和分类 基于神经网络的机器学习主要分为两个过程：训练过程和使用过程。训练过程指前三步是反复循环迭代的过程，参数优化完成后保存固化；使用过程指使用训练过程固化的参数，实现特定应用。实际应用中，通常使用现有成熟的网络结构，喂入新的数据，训练相应模型，判断是否能对喂入的新数据作出正确响应，再适当更改网络结构，反复迭代，直到找到最优结构和参数。 整理成 python 的常用格式为： 导入模块，生成模拟数据集 123import常量定义生成数据集 前向传播：定义输入、参数和输出 123x= y_= // 已知的输入和输出集w1= w2= // 要求解的参数，通常先赋值随机参数a= y= // 根据输入 x 和参数 w ，计算得到隐藏层及输出结果 反向传播：定义损失函数，反向传播方法 12loss= // 根据已知输出 y_ 和计算得到的输出 y ，计算损失值train_step= // 反向传播训练方法 生成会话，训练指定轮数 神经网络断点续训神经网络保存以及重新加载，这样有利于断点保护，当训练时间很长时，可以在某个时刻暂停保存，后续需要继续训练时，可以从此处开始。 保存MODEL_SAVE_PATH 是神经网络参数保存的路径， MODEL_NAME 保存文件名的前缀；通常是在训练过程中，比如每 1000 轮保存一次参数。 12345678saver = tf.train.Saver()with tf.Session() as sess: for i in range(STEPS): ... if i % 1000 == 0: saver.save(sess, os.path.join(MODEL_SAVE_PATH, MODEL_NAME), global_step=global_step) 保存的文件通常是三个： .meta 文件，保存当前图的结构 .index 文件，保存当前参数名 .data 文件，保存当前参数 恢复MODEL_SAVE_PATH 是神经网络参数保存的路径（不需要指定文件名）。 123456saver = tf.train.Saver()with tf.Session() as sess: ckpt = tf.train.get_checkpoint_state(MODEL_SAVE_PATH) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, ckpt.model_checkpoint_path) 恢复参数的滑动平均值如果保存模型时，模型中采用了滑动平均，则参数的滑动平均值需要单独恢复加载：在实例化 Saver 时，滑动平均参数直接传递到构造函数中： 123ema = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY)ema_restore = ema.variables_to_restore()saver = tf.train.Saver(ema_restore) CNN 卷积神经网络卷积conv2d 卷积是将给定的 4 维的输入和卷积核张量，转换为输出 2 维张量，函数原型如下： 1234#/usr/local/lib/python3.5/dist-packages/tensorflow/python/ops/gen_nn_ops.pydef conv2d(input, filter, strides, padding, use_cudnn_on_gpu=True, data_format="NHWC", dilations=[1, 1, 1, 1], name=None): input输入张量，形状为 input=[batch, in_height, in_width, in_channels] ，即每次处理 batch 张图片，每张图片有 in_channels 个通道数。 filter也称为卷积核 kernel ，形状为 filter=[filter_height, filter_width, in_channels, out_channels] ，通道数和输入保持一致； out_channels 输出通道数，也表示卷积核的个数，即从输入提取多少个特征；也就是一张图片，可以提取出 out_channels 张特征图。 strides滑动步长，表示卷积核横向和纵向上每次移动的步长。 padding在输入图像外圈填充一圈像素，也就是扩大输入图像的大小；有两个可能值： valid表示不需要填充像素。 same表示输出和输入的大小相同，padding 补全的大小为 p=(f-1)/2 ，使用全零填充。 卷积后输出张量的形状为 output=[batch, out_height, out_width, out_channels] ，其中 out_height, out_width 计算方式如下：如果输入数据大小为 n*n ，卷积核为 f*f ，滑动步长为 s ， padding 填充为 p ，则输出大小为 (n+2p-f)/s + 1 。 123456789101112131415161718import tensorflow as tfinput = tf.Variable(tf.random_normal([1,5,5,3]))filter = tf.Variable(tf.random_normal([3,3,3,1])) # 核个数为 1stride_1 = [1, 1, 1, 1]stride_2 = [1, 2, 2, 1]same_2d_1 = tf.nn.conv2d(input=input, filter=filter, strides=stride_1, padding=&apos;SAME&apos;)valid_2d_1 = tf.nn.conv2d(input=input, filter=filter, strides=stride_1, padding=&apos;VALID&apos;)same_2d_2 = tf.nn.conv2d(input, filter, stride_2, &apos;SAME&apos;)print(input)print(filter)print(same_2d_1)print(valid_2d_1)print(same_2d_2) 输出结果形状如下： 12345&lt;tf.Variable &apos;Variable_16:0&apos; shape=(1, 5, 5, 3) dtype=float32_ref&gt;&lt;tf.Variable &apos;Variable_17:0&apos; shape=(3, 3, 3, 1) dtype=float32_ref&gt;Tensor(&quot;Conv2D_17:0&quot;, shape=(1, 5, 5, 1), dtype=float32)Tensor(&quot;Conv2D_18:0&quot;, shape=(1, 3, 3, 1), dtype=float32)Tensor(&quot;Conv2D_19:0&quot;, shape=(1, 3, 3, 1), dtype=float32) 池化最大池化和平均池化函数原型： 1234def max_pool(input, ksize, strides, padding, data_format=&quot;NHWC&quot;, name=None):def avg_pool(value, ksize, strides, padding, data_format=&quot;NHWC&quot;, name=None): input/value输入张量，形状为 [batch, height, width, channels] ksize池化核的大小，形状为 [batch, height, width, channels] ，通常我们不会在 batch, channels 上做池化，所以一般设置为 [1, height, width, 1] ，仅仅给出池化核的大小。 strides, padding 和卷积中的意义一样。 123456input = tf.Variable(tf.random_normal([1, 4, 4, 2]))pooling = tf.nn.max_pool(input, ksize=[1, 2, 2, 1], strides=[1, 1, 1, 1], padding='VALID')print(input)print(pooling) 输出结果形状如下： 12&lt;tf.Variable &apos;Variable_36:0&apos; shape=(1, 4, 4, 2) dtype=float32_ref&gt;Tensor(&quot;MaxPool_7:0&quot;, shape=(1, 3, 3, 2), dtype=float32) TensorBoardTensorFlow 虚拟可视化技术，能记录和查看整个网络的相关信息，通过网页来查看相关信息；支持如下几个操作： tf.summary.scalar 标量，也就是常量参数 tf.summary.image 图片显示，常见图片分类中会显示训练图片 tf.summary.audio 声音相关 tf.summary.text 文本相关 tf.summary.histogram 柱状图 除了这些操作外， TensorBoard 还会默认显示整个神经网络的结构图 Graph 以及 Distributions （它是 histogram 的另外一种展示方式）。 官网网站 TensorBoard：可视化学习 github 文档 计算图计算图 Graph ，描述了神经网络的计算过程，是承载一个或多个计算节点的一张图，只搭建网络不运算。它是对神经网络的一个描述，描述了神经网络的组建方式，输入，参数，层数，输出等等。 基本用法 所有的 name_scope 都会生成 Graph 中一个节点，双击这个节点可以展开节点看到更详细信息 1234# Input placeholderswith tf.name_scope('input'): x = tf.placeholder(tf.float32, [None, 784], name='x-input') y_ = tf.placeholder(tf.int64, [None], name='y-input') 标量和柱状图 1234567891011def variable_summaries(var): """Attach a lot of summaries to a Tensor (for TensorBoard visualization).""" with tf.name_scope('summaries'): mean = tf.reduce_mean(var) tf.summary.scalar('mean', mean) with tf.name_scope('stddev'): stddev = tf.sqrt(tf.reduce_mean(tf.square(var - mean))) tf.summary.scalar('stddev', stddev) tf.summary.scalar('max', tf.reduce_max(var)) tf.summary.scalar('min', tf.reduce_min(var)) tf.summary.histogram('histogram', var) tf.summary.merge_all 合并操作，生成所有汇总数据：一个序列化的 Summary protobuf 对象 1234merged = tf.summary.merge_all()// 所有操作只能在 run 中生成数据，所以 merge 的结果为 run 返回值summary, acc = sess.run( [merged, accuracy], feed_dict=feed_dict(False)) tf.summary.FileWriter 将汇总的 protobuf 以文件的方式保存下来 1234// 指定 log 保存路径train_writer = tf.summary.FileWriter(log_dir, sess.graph) train_writer.add_summary(summary, i)train_writer.close() 注意：每个 log 目录下只能保存一个 events.out.tfevents.** 事件日志，如果有多个日志只能显示最后一个。多个日志可以新建不同的目录单独保存，在 tensorboard 运行时，指定日志目录为其父目录就能查看所有的日志了。 运行 tensorboard在 tf.summary.FileWriter 中会指定 log 保存路径，运行 tensorboard 时需要指定到这个路径： tensorboard --logdir=logs ，运行成功后，默认以 6006 端口来访问它，比如： http://ip:6006 。 12root@136b043c9daa:/tf/# tensorboard --logdir mnist_with_summaries/TensorBoard 1.13.1 at http://136b043c9daa:6006 (Press CTRL+C to quit) 注意：如果在服务器上通过 docker 运行 TensorFlow 环境，需要在 docker 启动镜像时，指定 6006 转发端口： -p 0.0.0.0:6006:6006 ，否则在客户端提示无法访问，参考 stackoverflow: How to use TensorBoard in a Docker container (on Windows)。 1234docker run --name py3-jupyter -it -d --rm -v /home/share:/tf/py3-jupyter \ -p 0.0.0.0:6006:6006 \ -p 8888:8888 \ mytensorflow:py3-jupyter 其中： 6006 为 tensorboard 转发端口； 8888 为 jupyter notebook 转发端口。 已有模型 pb 的可视化对于已经存在的 pb 文件，可以通过 netron 在线查看，也可以使用代码保存 log 后通过 tensorboard 来查看图结构： 123456789import tensorflow as tfmodel = '/tf/py3-jupyter/04-Face/Mtcnn/model_check_point/mtcnn.pb'log_dir = '/tf/py3-jupyter/01-Tensor-Flow-base/tensorboard/mtcnn'graph = tf.get_default_graph()graph_def = graph.as_graph_def()graph_def.ParseFromString(tf.gfile.FastGFile(model, 'rb').read())tf.import_graph_def(graph_def, name='mtcnn_graph')summaryWriter = tf.summary.FileWriter(log_dir, graph) 运行 tensorboard ，在 graph 页面双击生成的 mtcnn_graph 展开查看详细图结构信息。 TensorFlow 分布式TensorFlow LiteTensorFlow Lite 是 TensorFlow 的简化版本，用于手机或者 IOT 设备等，它的模型文件是 tflite 后缀；而 TensorFlow Mobile 被弃用，全面使用 Lite 。官方资料： 官网信息 github 仓库 github 文档 github 量化训练及准确率 github tensor lite示例 github Android 参考示例 一个第三方在线查看 TensorFlow 模型 pb, tflite 文件的结构的网站：netron ；也可以通过 tensorboard 查看图结构。转换为 tflite 可能经常出现不支持的操作，对照着图结构可以清楚的看出该操作具体的位置，想办法规避或替换不支持的操作。 模型转换通常使用 TensorFlow 训练出模型后，再将模型转换为 tflite 文件，参考官方模型转换指导 ，推荐使用 python api 的方式来实现，但是 TensorFlow python 接口个版本间差异较大，使用时参考官方最新提供的接口文档：python api 。 卷积神经网络 CNN卷积神经网络的输入可以是任意形状 None ，但是转换为 tflite 必须要指定具体形状，可以在转换时先随便指定一个固定值，在实际调用时动态改变输入的形状 set_tensor ，参考stackoverflow: Input images with dynamic dimensions in Tensorflow-lite 。 量化模型浮点型转换为整型，相对于浮点型整个模型可以压缩到 1/4 ，但准确率只有几个点的下降；量化模型在手持设备上，速度有 2 倍以上的提升。 pb 文件转换为 tflite 12345678910import tensorflow as tfgraph_def_file = "/path//mobilenet_v1_1.0_224/frozen_graph.pb"input_arrays = ["input"]output_arrays = ["MobilenetV1/Predictions/Softmax"]converter = tf.lite.TFLiteConverter.from_frozen_graph( graph_def_file, input_arrays, output_arrays)tflite_model = converter.convert() // 转换open("converted_model.tflite", "wb").write(tflite_model) // 保存文件 转换为量化模型 123456789101112131415161718192021222324252627282930import tensorflow as tfgraph_def_file = "/tf/py3-jupyter/04-Face/Mtcnn/model_check_point/mtcnn.pb"tflite_quant_file = "/tf/py3-jupyter/04-Face/Mtcnn/model_check_point/mtcnn_quant.tflite"output_arrays = ['pnet/prob1', # PNet face classification 'pnet/conv4-2/BiasAdd', # PNet BoundingBox Regression 'rnet/prob1', # RNet face classification 'rnet/conv5-2/conv5-2', # RNet BoundingBox Regression 'onet/prob1', # ONet face classification 'onet/conv6-2/conv6-2', # ONet BoundingBox Regression 'onet/conv6-3/conv6-3' # ONet Facial Landmark ]input_arrays = ['pnet/input', 'rnet/input', 'onet/input']// 卷积神经网络，必须给定具体形状input_shapes = &#123;'pnet/input': [1, 224, 224, 3], 'rnet/input': [1, 24, 24, 3], 'onet/input': [1, 48, 48, 3]&#125;converter = tf.lite.TFLiteConverter.from_frozen_graph( graph_def_file, input_arrays, output_arrays, input_shapes)converter.inference_type = tf.lite.constants.QUANTIZED_UINT8converter.quantized_input_stats = &#123;input_arrays[0]: (127.5, 128.), input_arrays[1]: ( 127.5, 128.), input_arrays[2]: (127.5, 128.)&#125; # mean, std_devconverter.default_ranges_stats = (-1.0, 1.0)tflite_quant_model = converter.convert()open(tflite_quant_file, "wb").write(tflite_quant_model)print("end...") 转换为量化模型时，需要指定 inference_type 为 QUANTIZED_UINT8 ，以及设置均值、标准差、最大值、最小值等等。转换为量化模型的接口随着 TensorFlow 版本升级，可能不一样，请参考最新接口。有时候模型可以正确转换为 tflite 浮点型，但是量化时却失败，因为量化支持的操作比较少，根据错误信息，修改原始模型（使用支持量化的操作），再重新生成量化模型文件。 移植到 Android 手机 Java 方案Android Studio 新建项目后，在 Gradle 文件中增加如下配置： 12345678910111213android &#123; ... aaptOptions &#123; noCompress &quot;tflite&quot; // 不要压缩 tflite 文件，否则调用异常 &#125;&#125;dependencies &#123; // 导入 tensorflow lite aar 文件 implementation &apos;org.tensorflow:tensorflow-lite:0.0.0-nightly&apos; implementation &apos;org.tensorflow:tensorflow-lite-gpu:0.0.0-nightly&apos;&#125; 其中 aar 文件的源码可以在aar 源码中查看 。 Java 代码中加载 tflite 模型，并获取输入输出张量相关信息： 123456789101112131415161718192021222324252627private void loadTfLiteModel() &#123; try &#123; MappedByteBuffer tfliteModel; Interpreter tflite; AssetFileDescriptor fileDescriptor = assetManager.openFd("mtcnn.tflite"); FileInputStream inputStream = new FileInputStream( fileDescriptor.getFileDescriptor()); FileChannel fileChannel = inputStream.getChannel(); long startOffset = fileDescriptor.getStartOffset(); long declaredLength = fileDescriptor.getDeclaredLength(); // 加载模型 tfliteModel = fileChannel.map(FileChannel.MapMode.READ_ONLY, startOffset, declaredLength); // 新建解释器对象 tflite = new Interpreter(tfliteModel, null); Log.d(TAG, "loadTfLiteModel: success."); // 获取输入张量索引及信息 pInputIndex = tflite.getInputIndex(P_NET_INPUT_NAME); Tensor pInput = tflite.getInputTensor(pInputIndex); // 获取输出张量索引及信息 pOutputProbIndex = tflite.getOutputIndex(P_NET_OUTPUT_PROB_NAME); Tensor pOutProb = tflite.getOutputTensor(pOutputProbIndex); &#125; catch (IOException ioe) &#123; Log.d(TAG, "loadTfLiteModel: " + ioe); &#125;&#125; 加载的模型使用类型为 MappedByteBuffer ，并初始化生成解释器 Interpreter ，通过它调用神经网络模型，得到输出结果： 1234567891011121314151617181920// 输入为 ByteBuffer 类型ByteBuffer imgData = ByteBuffer.allocateDirect( 1 * h * w * 3 * getNumBytesPerChannel());imgData.order(ByteOrder.nativeOrder());// 逐个读入输入数据，可能会对数据做归一化loadImageData(bitmap, imgData);// 输出为数组，维度为神经网络输出张量的形状 shapefloat[][][][] pNetOutProb = new float[1][outW][outH][2];float[][][][] pNetOutBias = new float[1][outW][outH][4];Map&lt;Integer, Object&gt; outputs = new HashMap();outputs.put(0, pNetOutProb);outputs.put(1, pNetOutBias);int index = tflite.getInputIndex(&quot;pnet/input&quot;);int[] resizeShape = &#123;1, w, h, 3&#125;;// 动态改变输入的形状tflite.resizeInput(pInputIndex, resizeShape);// 调用神经网络 tflite.runForMultipleInputsOutputs(new Object[]&#123;imgData&#125;, outputs); 输入为 ByteBuffer 类型，并将输入数据逐个存入 输出为数组，维度为神经网络模型输出张量的阶 使用 tflite.run***() 调用神经网络模型，得到输出结果 如果为卷积神经网络 CNN ，即输入可以是任意形状，但是 tflite 只支持固定形状，需要动态调整 官方经典示例 tflite 花识别示例 人体姿势，眼，鼻，手，腿等关键点定位 TF-mobile 参考示例 其他 tflite 移植到 arm c++ 实现 常见操作遍历 pb 文件所有的节点信息1234567import tensorflow as tfgraph_def_file = "/tf/py3-jupyter/pb/mtcnn_1.12.pb"gf = tf.GraphDef()gf.ParseFromString(open(graph_def_file,'rb').read())for i,n in enumerate(gf.node): print(str(i) +', '+n.name+' ===&gt; '+n.op) 遍历 tflite 文件所有节点信息12345678910111213141516171819# 遍历 tflite 文件所有 tensor import tensorflow as tf#tflite_file = "/tf/pb/tflite/mobilenet_v1_1.0_224_quant.tflite"tflite_file = "/tf/pb/tflite/mobilenet_v1_1.0_224.tflite"if __name__=="__main__": interpreter = tf.lite.Interpreter(model_path=tflite_file) interpreter.allocate_tensors() tensors = interpreter.get_tensor_details() // 获取模型所有的节点 print(len(tensors)) // 长度 for i in range(len(tensors)): print(tensors[i]) // 遍历每个节点 print(interpreter.get_input_details()) // 获取所有输入节点 print(interpreter.get_output_details()) // 获取所有输出节点 print("end...") pb 转 tflite转换时， output 必须和保存 pb 时一致，否则会出各种莫名其妙的问题，这些问题并不会提示你是因为 output 不一致。 1234567891011121314151617181920def freeze(sess,): output_name=['pnet/prob1', #PNet face classification 'pnet/conv4-2/BiasAdd', #PNet BoundingBox Regression 'rnet/prob1', #RNet face classification 'rnet/conv5-2/conv5-2', #RNet BoundingBox Regression 'onet/prob1', #ONet face classification 'onet/conv6-2/conv6-2', #ONet BoundingBox Regression 'onet/conv6-3/conv6-3' #ONet Facial Landmark ] graphDef = convert_variables_to_constants(sess, sess.graph_def, output_node_names=output_name) with tf.gfile.GFile("mtcnn_freezed_model.pb", 'wb') as f: f.write(graphDef.SerializeToString()) input_name = ["pnet/input"] input_shapes = &#123;"pnet/input":[1,224,224,3]&#125; tf_file = "mtcnn.tflite" converter = tf.lite.TFLiteConverter.from_frozen_graph("mtcnn_freezed_model.pb", input_name, output_name, input_shapes=input_shapes) tflite_model = converter.convert() open(tf_file, "wb").write(tflite_model) 常见问题断点恢复1234567891011121314151617181920NotFoundError: Key Variable/ExponentialMovingAverage_8 not found in checkpoint [[node save_8/RestoreV2 (defined at &lt;ipython-input-31-954ff7be1933&gt;:138) ]]...&lt;ipython-input-31-954ff7be1933&gt; in train(self, mnist) 145 ckpt = tf.train.get_checkpoint_state(MODEL_SAVE_PATH) 146 if ckpt and ckpt.model_checkpoint_path:--&gt; 147 saver.restore(sess, ckpt.model_checkpoint_path) 148 149 for i in range(self.STEPS):/usr/local/lib/python3.5/dist-packages/tensorflow/python/training/saver.py in restore(self, sess, save_path) 1290 # a helpful message (b/110263146) 1291 raise _wrap_restore_error_with_msg(-&gt; 1292 err, &quot;a Variable name or other graph key that is missing&quot;) 1293 1294 # This is an object-based checkpoint. We&apos;ll print a warning and then doNotFoundError: Restoring from checkpoint failed. This is most likely due to a Variable name or other graph key that is missing from the checkpoint. Please ensure that you have not altered the graph expected based on the checkpoint. Original error: 出现问题是因为运行完储存指令就调用，然而计算机已经有了训练好的神经网络，再调用神经网络会出问题。所以储存完后，需要在 jupyter notebook 上重启核，再运行程序即可。或者使用 with tf.Graph().as_default() as tg: 恢复神经网络，再 restore 参数。 读取 tflite 的张量 tensor12interpreter = tf.lite.Interpreter(model_path=tflite_file)interpreter.allocate_tensors() 运行时报错： 1RuntimeError: tensorflow/lite/kernels/conv.cc:224 input-&gt;dims-&gt;size != 4 (0 != 4)Node number 29 (CONV_2D) failed to prepare. 解决思路，我们将第 29 个节点打印出来，看看它的 shape 1234interpreter = tf.lite.Interpreter(model_path=tflite_file)#interpreter.allocate_tensors()tensors = interpreter.get_tensor_details()print(tensors[29]) 打印结果为： 1&#123;&apos;quantization&apos;: (0.0, 0), &apos;name&apos;: &apos;onet/input&apos;, &apos;shape&apos;: array([], dtype=int32), &apos;index&apos;: 29, &apos;dtype&apos;: &lt;class &apos;numpy.float32&apos;&gt;&#125; 可以看到第 29 个节点的 &#39;shape&#39;: array([], dtype=int32) ，是空的，正常情况下 array 应该是一个 4 维数据，比如 [1, 224, 224, 3] ，因此我们从原始的 pb 文件中查看对应 onet/input 的形状： 12345gf = tf.GraphDef()gf.ParseFromString(open(graph_def_file,'rb').read())for i,n in enumerate(gf.node): if n.name == 'onet/input': print(n) 打印结果为： 123456789101112131415161718192021222324252627name: &quot;onet/input&quot;op: &quot;Placeholder&quot;attr &#123; key: &quot;dtype&quot; value &#123; type: DT_FLOAT &#125;&#125;attr &#123; key: &quot;shape&quot; value &#123; shape &#123; dim &#123; size: -1 &#125; dim &#123; size: 48 &#125; dim &#123; size: 48 &#125; dim &#123; size: 3 &#125; &#125; &#125;&#125; pb 文件中 onet/input 形状为 [-1, 48, 48, 3] ，也就是说，我们将 pb 转换为 tflite 时，没有包含这个信息。所以重新转换： 12345678910input_name = ['pnet/input', 'rnet/input', 'onet/input'] // 指定 onet/input ，发生错误前并没有添加这项input_shapes = &#123;'pnet/input':[1,224,224,3], 'rnet/input':[1,24,24,3], 'onet/input':[1,48,48,3]&#125; // 指定它的形状为 [1, 48, 48, 3]converter = tf.lite.TFLiteConverter.from_frozen_graph(pb_file, input_name, output_name, input_shapes=input_shapes)tflite_model = converter.convert()open(tflite_file, "wb").write(tflite_model) numpy 处理后的数据类型默认 float64 ，而 tensorflow 中默认使用 float32 需要转换12345// 发生错误： ValueError: Cannot set tensor: Got tensor of type 0 but expected type 1 for input 111 // 而第 111 个节点信息为 &#123;&apos;quantization&apos;: (0.0, 0), &apos;name&apos;: &apos;pnet/input&apos;, &apos;index&apos;: 111, &apos;dtype&apos;: &lt;class &apos;numpy.float32&apos;&gt;, &apos;shape&apos;: array([ 1, 224, 224, 3], dtype=int32)&#125; 查看该节点类型为 numpy.float32 的，而 numpy 默认操作数组时类型是 float64 ，需要转换： 123print(img.shape, img.dtype)img = img.astype(&apos;float32&apos;) // 转换为 float32 print(img.shape, img.dtype) pb 的 shape 为 None 时，即可以是任意形状，但是转换为 tflite 时，必须指定为具体数字12345// 设置输入数据时interpreter.set_tensor(input_details[0][&apos;index&apos;], img)// 发生错误：ValueError: Cannot set tensor: Dimension mismatch 解决方案，参考stackoverflow: Input images with dynamic dimensions in Tensorflow-lite 第一步，转换时先设置固定值： 1234567tflite_convert \ --graph_def_file=&apos;model.pb&apos; \ --output_file=&apos;model.tflite&apos; \ --input_shapes=1,128,80,1 \ # &lt;-- here, you set an # arbitrary valid shape --input_arrays=&apos;input&apos; \ --output_arrays=&apos;Softmax&apos; 第二步，调用时先调整大小再调用： 1234567891011121314from tensorflow.contrib.lite.python import interpreter# Load the *.tflite model and get input detailsmodel = Interpreter(model_path=&apos;model.tflite&apos;)input_details = model.get_input_details()# Your network currently has an input shape (1, 128, 80 , 1),# but suppose you need the input size to be (2, 128, 200, 1).model.resize_tensor_input( input_details[0][&apos;index&apos;], (2, 128, 200, 1))model.allocate_tensors()# 先调整完大小后再设置数据model.set_tensor(input_details[0][&apos;index&apos;], img) 量化不支持的操作Unimplemented: this graph contains an operator of type Neg for which the quantized form is not yet implemented. 123456789@layerdef prelu(self, inp, name): with tf.variable_scope(name): i = int(inp.get_shape()[-1]) alpha = self.make_var('alpha', shape=(i,)) #output = tf.nn.relu(inp) + tf.multiply(alpha, -tf.nn.relu(-inp)) output = tf.math.maximum(0.0, inp) + tf.math.multiply(alpha, tf.math.minimum(0.0, inp)) return output TensorFlow 默认不支持 prelu 激活函数，需要自己实现；上面两种方式都能实现 prelu ，但是量化时不支持负号操作，所以改写成取最大值最小值来实现。 参考文档 TensorFlow 官网 github TensorFlow 官方示例 w3cschool TensorFlow 教程-API描述 最详尽使用指南：超快上手Jupyter Notebook Jupyter Notebook快速入门教程 Tensorflow基础知识 北大 mooc tensorflow 笔记 北大 mooc 助教整理 pdf Logistic 分类器与 softmax分类器 Softmax函数 在线查看 TensorFlow 模型 pb, tflite 文件的结构 TF-lite 模型结构解析 Tensorflow 模型量化:Quantizing deep convolutional networks for efficient inference: A whitepaper 译文]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
        <tag>TensorFlow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CNN - 卷积神经网络]]></title>
    <url>%2F2019%2F05%2F22%2F0115-dl-cnn%2F</url>
    <content type="text"><![CDATA[卷积神经网络基础，以及经典模型的介绍： LeNet-5, AlexNet, VGGNet, GoogLeNet, ResNet, MobileNet 。 卷积神经网络CNN: Convolutional Neural Networks 卷积神经网络也是由输入层、输出层和多个隐藏层组成，但是隐藏层可分为卷积层 Convolution ，池化层 Pooling 、全连接层 FCN:fully connected neural network 。在图像分类任务中，卷积和池化后的结果是每个输入图像的特征空间，然后将它喂给全连接层实现分类，即从输入图像到标签集的映射。目前主流的卷积神经网络，比如 VGG, ResNet 等都是由简单的 CNN 调整组合而来。下图为常见的卷积和池化的示例： 上图示例输入为 277*277 的 RGB 图像，采用 96 个 11*11*3 的卷积核 kernels 同时扫描，得到输出的特征图是 96 个 267*267 的二维 feature map ； 267*267 是单个特征图的宽高， 96 是卷积核的个数，原本 3 通道元素在卷积的时候会被作为一个元素加起来。这些 feature map 可视化之后，可以看到： 4 和 35 表示边缘特征 23 是模糊化的输入 10 和 16 在强调灰度变化 39 强调眼睛 45 强调红色通道 基本概念 特征图 Feature map输入图像和卷积核做卷积后的输出图即为特征图！它表示该卷积核从输入图中提取的一个特征。 感受野 Receptive field特征图上每个像素点在输入图片上映射的区域，即该像素点为输入图中哪块像素和卷积核做卷积计算的。输入图中这块像素区域大小即为感受野，也就是感受野的大小和卷积核的大小相同。 Convolutional Layer 卷积层卷积是一种有效提取图片特征的方法：使用一个正方形的卷积核，遍历图片上的每个像素点；图片与卷积核重合区域内相对应的每一个像素值乘以卷积核内对应点的权重，然后求和得到输出图片中的一个像素值。输入图像感受野区域和卷积核中对应位置相乘后求和，卷积核中的值表示权重；输出值为卷积核矩阵和感受野区域矩阵进行点积。根据线性代数理论，点积表示向量在某个特征（向量）上的投影再乘以这个特征（向量），直接意义表示向量在某个特征（向量）上的强度；也就是说，做一次点积相当于提取了一次特征。卷积层的意义：卷积核在输入图像上从左到右，从上到下滑动，提取整幅图像在卷积核上的特征。计算过程如下图所示： 图中显示了两个卷积示例，绿色部分和红色部分；绿色部分见图中计算结果，红色部分计算如下： (-1)*2+(-1)*9+(-1)*2+1*4+1*4=-5 。 假设输入图像大小为 n*n ，卷积核大小为 f*f ，滑动步长为 s ，输入图像 padding 位数为 p ，则输出图像大小为 (n+2p-f)/s + 1 。输入图像和卷积核做卷积后，输出特征图大小和个数就是由这些参数决定： padding 填充在输入图像外圈填充一圈像素，也就是扩大输入图像的大小；通常 padding 的目的是为了使得输出特征图和输入图像大小保持一致，深度学习中通常使用全零来填充外圈像素。 stride 步长表示卷积核横向和纵向上每次移动的步长。 channels 通道数通道数（有时也叫深度），卷积过程中输入和卷积核的通道数必须相同，表示输入和输出的个数。输入图像如果为灰度图，则通道数为 1 ；如果为彩色图，则通道数为 3 ，分别表示输入图像红绿蓝三色；卷积核的输入通道数与输入相同，它的输出通道数表示卷积后特征图的个数。 卷积过程是一个提取对应特征图的过程，而特征提取由卷积核性质来决定；不同卷积核（即滤波器）对应的主观效果： 卷积核通常为正方形，大小为奇数，通常为 1*1, 3*3, 5*5, 7*7 。 pooling 池化层池化 pooling 是一种降采样操作 subsampling ，主要目标是降低特征图的特征空间，或者可以认为是降低特征图的分辨率。因为特征图参数太多，而图像细节不利于高层特征的抽取。池化分为最大池化和平均池化两类： 最大池化采样时取池化核大小中的最大值；其中池化核的大小为 2*2 ，步长也为 2*2 ： 平均池化采样时取池化核大小中的平均值；其中池化核的大小为 2*2 ，步长也为 2*2 ： 假设输入大小为 n*n ，池化核大小为 f*f ，滑动步长为 s ，则输出大小为 (n-f)/s + 1 ；和卷积核计算公式一样，只不过池化时不涉及 padding ，池化也不会改变输入和输出的通道数。 全连接层全连接 Fully Connected Network 层，就是普通的神经网络层；特点是每个神经元与前后相邻层的每一个神经元都有连接关系，即全连接。一张分辨率仅仅是 28*28 的黑白图像，就有接近 40 万个待优化参数；而现实中都为高分辨率的彩色图像，像素点非常多，且为红黄蓝三通道信息；而待优化参数过多，容易导致模型的过拟合。在图像分类中，先把输入图像通过卷积和池化后提取特征，降低参数数量，在接入全连接层输出预测的结果；全连接层就是把卷积层和池化层的输出展开成一维的输出结果。 CNN 特点CNN 与传统的神经网络相比，主要有三大特色：局部感知、权重共享和多卷积核。 局部感知局部感知也就是感受野，卷积核和输入图像卷积时，每次卷积核所覆盖的像素只是图像的一小部分，是局部特征，即局部感知，局部感受野。人类对外界的认知一般是从局部到全局，先对局部有感知的认识，再逐步对全体有认知，这是人类的认识模式。在图像中的空间联系也是类似，局部范围内的像素之间联系较为紧密，而距离较远的像素则相关性较弱。因而每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。这种模式就是卷积神经网络中的局部感受野，它能大大降低参数。 权重共享传统的神经网络的参数量是非常巨大的，比如 1000X1000 像素的图片，映射到和自己相同的大小，需要 1000X1000 的平方，也就是 10 的 12 次方，参数量太大了，而 CNN 除全连接层外，卷积层的参数完全取决于卷积核（滤波器）的大小，比如 10x10 的滤波器，只有 100 个参数，当然滤波器的个数不止一个，也就是下面要说的多卷积核。但与传统的神经网络相比，参数量小，计算量小，整个图片共享同一组滤波器的参数，即卷积核参数表示的权重。 多卷积核一种卷积核代表提取输入图片的一种特征，为获得更多不同的特征集合，卷积层会有多个卷积核，生成不同的特征图。 小结大型深层的卷积神经网络 CNNs （请注意这里是复数）通常由多个基础 CNN 组成，而基础 CNN 结构前后连接、层内调整组成，根据功能不同，我们称这些前后连接的结构处于不同阶段 Stage 。不同 Stage 里 CNN 会有不同的单元和结构，比如卷积核 kernel 大小、个数， padding, stride 等可能不同，激活函数 activition function 可能不同， pooling 操作可能不存在等等。 LeNet5LeNet 诞生于 1994 年，由 Yann LeCun 提出并实现，是最早的卷积神经网络之一。LeNet-5 模型相关资源： LeNet-5 卷积神经网络，官网 LeNet-5 论文：Gradient-Based Learning Applied to Document Recognition 网络模型LeNet-5 神经网络结构为： LeNet-5 主要分为输入层，卷积层特征提取，全连接层分类识别。 特点 输入层32*32*1 大小的灰度图，即单通道输入。 第一层卷积层，卷积核大小为 5*5*1 ，核个数为 6 ，步长为 1 ；则输出为 (32-5)/1+1=28 ，即输出为 28*28*6 ，相当于提取了 6 个 28*28 的特征图 Feature Map 。同一个卷积核对应的神经元使用相同的 w 权重和 b 偏置；一个卷积核有 5*5=25 个 w 和 1 个 b ，一共 6 个卷积核，因此卷积后每个神经元的参数个数为 (5*5*1+1)*6=156 ，即卷积层总参数为 156 个。第一层使用的是全连接，一共 28*28 个神经元，因此连接数为 28*28*156=122304 个连接数。 第二层池化层，池化核大小为 2*2 ，步长为 1 ；池化后输出为 14*14*6 ，特征图大小减半；这一层的计算方法是：将池化核中每个元素相加，再乘以权重 w ，最后加上偏置 b ，然后通过 sigmoid 激活函数。每个池化核中 4 个元素使用相同的 w 和 b ，一共 6 个池化核，因此参数个数为 (1+1)*6=12 个；池化也是全连接，一共 14*14 个神经元，因此连接数为 (2*2+1)*6*14*14=5880 个。 LeNet-5 中卷积和池化示意图： 第三层卷积层，卷积核大小为 5*5 ，核个数为 16 ，步长为 1 ；则输出大小为 (14-5)/1+1=10 ，即输出为 10*10*16 ；这一层并没有使用全连接，参考 LeNet-5 论文，该层连接如下图所示；比如第一列表示第三层的第 0 个特征图只和第二层的第 0,1,2 这三个特征图连接；有 3 个连接的特征图个数为 6 个、有 4 个连接的特征图个数为 9 个、有 6 个连接的特征图个数为 1 个；所以参数数目为 (5*5*3+1)*6 + (5*5*4+1)*9 + (5*5*6+1)*1=1516 个；一共有 10*10 个神经元，因此总连接数为 10*10*1516=151600 个。 第四层池化层，池化核大小为 2*2 ，步长为 1 ；池化层输入为上一层的 10*10*16 ，池化核效果是大小减半，所以池化层输出为 5*5*16 。参数计算方法和第二层池化层一样，池化核的每个元素共用权重和偏置，因此参数个数为 (1+1)*16=32 ；池化是全连接，一共 5*5 个神经元，因此连接数为 (2*2+1)*16*5*5=2000 。 第五层卷积层，卷积核大小为 5*5 ，卷积核有 120 个，步长为 1 ；输出大小为 (5-5)/1+1=1 ，即输出为 1*1*120 ；因为输入大小和卷积核大小一样，所以卷积后称为单个像素的特征图，卷积过程刚好使得卷积层和全连接层表现一样；如果输入分辨率加大，则改层就不是全连接层了。参数个数为 (5*5*16+1)*120=48120 ，输出刚好只有 1*1 个神经元，全连接数为 1*1*48120=48120 。 第六层全连接层，输出为 84 个单元，每个单元表示一个像素，对应于一个 7*12 的比特图。如果 -1 表示白色， 1 表示黑色，这个 84 个单元刚好组成 7*12 的黑白图，对应下图中的一个编码。参数个数为 (120+1)*84=10164 ，全连接数也是 10164 ；全连接层点积结果加上偏置后，通过 sigmoid 激活函数。 第七层输出层，输出为 10 个节点，分别表示数字 0-9 。该层采用径向基函数 RBF 的连接方式计算输出结果。参数个数为 84*10=840 ，连接个数也为 840 。 AlexNetAlexNet 是 Alex Krizhevsky, Ilya Sutskever 在多伦多大学 Geoff Hinton 的实验室设计出的一个深层卷积神经网络；该模型是 2012 年年提出并夺得了当年 ImageNet LSVRC 的冠军，且准确率远超第二名（ top5 错误率为 15.3% ，第二名为 26.2% ）。 AlexNet 可以说是具有历史意义的一个网络结构，在此之前深度学习已经沉寂了很长时间，从它诞生之后， ImageNet 以后举行的比赛，冠军都是用卷积神经网络 CNN 来做的，并且层次越来越深，使得 CNN 成为在图像识别分类的核心算法模型，带来了深度学习的大爆发。而仔细分析 AlexNet ，可以看出它实际上是参考了 LeNet-5 ，只是 LeNet 当年受到了计算机硬件性能的限制。 AlexNet 模型的相关资源： 论文：ImageNet Classification with Deep Convolutional Neural Networks stanford 课件 模型结构及特点 AlexNet 一共有 5 个卷积层和 3 个全连接层，该模型的特点： 使用 ReLU 作为激励函数传统的神经网络普遍使用 Sigmoid, tanh 等非线性函数作为激励函数，然而它们容易出现梯度弥散或梯度饱和的情况。以 Sigmoid 函数为例，当输入的值非常大或者非常小的时候，这些神经元的梯度接近于 0 ；如果输入的初始值很大的话，梯度在反向传播时因为需要乘上一个 Sigmoid 导数，会造成梯度越来越小，导致网络变的很难学习。在 AlexNet 中使用了 ReLU: Rectified Linear Units 激励函数；由于它是线性的，且导数始终为 1 ，计算量大大减少，收敛速度会比 Sigmoid, tanh 快很多。 全连接层使用了随机 Dropout为了防止神经网络过拟合，引入了 Dropout 的概念；对于某一层神经元，随机的将概率置为 0 ，即这个神经元不参加前向和后向传播（如同被删除一样）； Dropout 可以看作是模型组合，每次生成的网络结构都不一样，通过组合多个模型来减少过拟合。 Dropout 是 AlexNet 中的一项非常大的创新，以至于神经网络之父 Hinton 在很多演讲中都拿出来讲解。 数据扩充神经网络为了避免过拟合，加大加深网络结构，需要海量数据来进行训练，能有效提高算法的准确率。但实际上数据往往是有限的，可以通过一些变换将现有数据生成新的数据来扩充数据集。图像数据中可以通过：水平翻转，随机裁剪、平移变换，颜色、光照变换等来快速扩充。 重叠池化 Overlapping Pooling池化核移动步长小于核大小，也就是移动时会出现重叠元素；重叠池化能避免过拟合问题。 局部归一化 LRN: Local Response Normalization模仿真实神经元的侧抑制机制，实现局部抑制，尤其当使用 ReLU 作为激励函数时非常有效； LRN 能提高网络的泛化能力，使 top 1/5 错误率下降了 1.4/1.2% 。 多 GPU 训练神经网络规模太大，单个 GPU 无法满足计算需求，该网络模型使用 2 个 GPU 分别训练一半的模型；多用一个 GPU 对训练时间影响并不明显，但使 top 1/5 错误率下降了 1.7/1.2% 。 其中 ReLU 激励函数和正则化使用 Dropout 成为后续 CNN 的标配。 模型解析所有激活函数都使用 ReLU ；所有的池化层都为 3*3 步长为 2 的最大池化。 第一段总体为：卷积 -&gt; 激励 -&gt; 池化 -&gt; LRN ；其中输入大小为 227x227x3 的红黄蓝三基色图；卷积核大小为 11*11 ，通道数为 96 个，步长为 4 ，则第一层的输出大小根据计算公式 (n+2p-f)/s + 1 为 (227+0-11)/4+1=55 ，即输出层为 55*55*96 ；输出通过 ReLU 激活函数；通过池化层后，输出为 (55-3)/2+1=27 ，即池化层输出为 27*27*96 ；通过 LRN 进行归一化处理，归一化后分为两组 27*27*48 分别送给两个 GPU 训练。 第二段总体为：卷积 -&gt; 激励 -&gt; 池化 -&gt; LRN ；其中输入为第一层归一化后的输出 27*27*96 （分为两组分别给两个 GPU 训练）；为了方便计算输入做了 2 个像素的 0 填充，卷积核大小为 5*5 ，通道数为 256 ，移动步长为 1 ，则卷积后的输出大小为 (27+2*2-5)/1+1=27 ，即卷积后的输出为 2 组 27*27*128 ；通过 ReLU 激活函数；池化后为 2 组 13*13*128 ；再将这两组数据归一化后，分别送给两个 GPU 训练。 第三段总体为：卷积 -&gt; 激励 ；这一层没有池化和 LRN ；输入为第二层的输出： 2 组 13*13*128 ；先做 1 像素的 0 填充，卷积核大小为 3*3 ，通道数为 192 ，步长为 1 ，卷积后的大小为 (13+2-3)/1+1=13 ，即卷积后的输出为 2 组 13*13*192 ；输出经过 ReLU 激活函数后，直接进入下一层。注意该层模型中两个 GPU 之间存在虚线，即每个 GPU 都需要计算第二层的所有数据。 第四段总体为：卷积 -&gt; 激励 ；这一层也没有池化和 LRN ；输入为第三层输出的 2 组 13*13*196 ；第四层和第三层唯一的区别是，第四层两个 GPU 间没有虚线连接，即第四层每个 GPU 只需计算第三层一半的输出。 第五段总体为：卷积 -&gt; 激励 -&gt; 池化 ；这一层没有 LRN ；输入为第四层输出的 2 组 13*13*196 ；先做 1 像素的 0 填充，卷积核大小为 3*3 ，通道数为 256 ，步长为 1 ，卷积后的大小为 (13+2-3)/1+1=13 ，即卷积后的输出为 2 组 13*13*128 ；输出经过 ReLU 激活函数；再经过池化层，输出为 2 组 6*6*128 。 第六段总体为：卷积（全连接） -&gt; 激励 -&gt; Dropout ；这一层属于全连接层，但是使用卷积来实现的；输入为第五层输出的 2 组 6*6*128 ，卷积核的尺寸刚好和输入一样大，卷积核中每个系数都和输入对应像素相乘，一一对应，因此该层也为全连接层，卷积核通道数为 4096 ，则卷积后的输出为 2 组 1*1*2048 ，即有 4096 个神经元；通过 ReLU 激活函数后；再通过随机的 Dropout ，概率选择为 50% ，即丢掉一半的网络特征。 第七段总体为：全连接 -&gt; 激励 -&gt; Dropout 。 第八段第八段为全连接层，输出为 1000 个分类结果的评分。 如下为 AlexNet 模型的简图： VGGVGGNet 是 Visual Geometry Group 牛津大学计算机视觉组和 Google DeepMind 公司的研究员一起研发的深度卷积神经网络，该模型是 2014 年提出并取得了 ImageNet-ILSVRC 竞赛的第二名（第一名是 GoogLeNet ）和定位项目的第一名。VGGNet 首次将网络深度提升到了 19 层，并且使用较小的卷积核，证明了增加网络的深度能够在一定程度上影响网络最终的性能，使错误率大幅下降；该网络拓展性很强，迁移到其它图片数据上的泛化性也非常好， VGG 常被用来提取图像特征。VGG 模型相关资源： 牛津大学官网 对应论文为 Very Deep Convolutional Networks for Large-Scale Image Recognition VGG 会议 pdf 模型结构VGGNet 可以看成是加深版本的 AlexNet ，都是由卷积层、全连接层两大部分构成： VGG16, VGG19 是常用模型，它们通常是从图像中提取 CNN 特征的首选算法；主要缺点在于参数量非常大，有 140M 左右需要更大的存储空间。 模型特点VGGNet 的特点可以通过下图体现： VGGNet 结构简洁清晰，由 5 段卷积层（每段可能会有 3 到 5 个卷积层），3 个全连接层， Softmax 输出层构成，所有隐藏层的激活函数都采用 ReLU 函数，池化层采用最大池化 max-pooling 。 输入层固定为 224*224 大小，红黄蓝三基色图像。在训练期间，唯一的预处理是输入图像中每个像素中减去在训练集上计算的 RGB 均值，这个预处理可以加快学习。 卷积核卷积核固定为 3*3 大小，所有的卷积操作都遵循 SAME 原则； 3*3 会比大卷积核需要更少的参数；两个 3*3 卷积核串联（所需参数个数 2*3*3=18 ）获取的感受野大小相当于一个 5*5 卷积核（所需参数个数 1*5*5=25 ）；而三个 3*3 卷积核串联（所需参数个数 3*3*3=27 ）获取的感受野相当于一个 7*7 的卷积核（所需参数个数 1*7*7=49 ）。使用 3*3 卷积核有三个优点：多个卷积核能获取更大的感受野；增加非线性映射；需要更少的参数。 通道数第一段卷积层统一使用 64 个通道，之后逐段翻倍，直到第五段卷积层统一使用 512 个通道。通道数越大，提取的特征信息越多。 激活函数隐藏层配置的激活函数都是非线性 ReLU 函数。 池化核池化核固定为 2*2 大小，全部采用相同的最大池化方式，步长为 2 。池化主要目标是缩小宽和高，控制了计算量的规模。 全连接层三个全连接层的配置是相同的，前两个都有 4096 个通道，第三个需要执行 1000 维的分类，因此只包含 1000 个通道（每个通道对应一个类别）。VGGNet 模型中，在测试阶段，会将全连接层全部转换为卷积层；第一层 7*7*512 和 4096 个神经元做全连接，测试时转换为和 1*1*4096 的卷积核做卷积。测试阶段将全连接转换成卷积后，则可以对任意分辨率的图做卷积，而不需要缩放到 224*224 的输入大小。 Softmax 层全连接最后一层通过 Softmax 转换为预测结果的概率。 小结VGGNet 模型探讨并证明了以下观点： 用多层的卷积层组合配以小尺寸的滤波器，能实现大尺寸滤波器的感受野，同时还能使参数数量更少 层深度的增加，能有效提升网络的性能 模型融合的性能优于单模型的性能 训练期间分阶段降低学习率有助模型收敛 VGG 模型中除了输入的图像是 224×224 的 RGB 图像，其他参数基本和 AlexNet 一致； VGG 中 BCDE 版本网络的参数初始化均来自于版本 A 网络（即参数预初始化），由于网络 A 较小，因此收敛较快，先训练一个网络 A ，然后将其训练好的参数作为后面网络的初始值（前面四个卷积层和最后的三个全连接层）。其它的参数进行随机初始化，从 (0,0.01) 的高斯分布中进行初始化。 GoogLeNetGoogLeNet 是 Google 公司设计的网络模型（其中 L 大写表示致敬 LeNet ），该模型在 2014 年取得 ImageNet-ILSVRC 分类挑战赛第一名（第二名是 VGGNet ）。GoogLeNet 相关资源： Inception v1-Going Deeper with Convolutions Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift Inception v2,v3-Rethinking the Inception Architecture for Computer Vision Inception-v4-Inception-ResNet and the Impact of Residual Connections on Learning 解决的问题通常提升网络性能主要是增加网络深度和宽度：深度指网络层次数，宽度指神经元数量。但是这会导致： 参数过多时，如果训练数据有限，很容易产生过拟合 参数过多时，计算复杂度太大 网络越深，越容易出现梯度弥散（越往后梯度越容易消失） 解决思路是在增加网络深度和宽度的同时，减少参数；为了减少参数，将全连接变成稀疏连接，但大部分硬件都是针对密集矩阵做的优化，所以稀疏矩阵中计算数虽然变少，但是计算量并没有质的提升。GoogLeNet 提出了 Inception 网络结构，用来构造一种神经元，搭建稀疏高计算性能的网络结构。 1*1 卷积核Network in Network 中最早提出 1*1 卷积核的概念； 1*1 卷积核可以起到降维（升维）的作用，并减少参数。比如当前层为 x*x*m 即图像大小为 x*x ，特征层数为 m ，然后如果将其通过 1*1 的卷积核，特征层数为 n ，那么只要 n&lt;m 这样就能起到降维的目的。如果使用 1*1 的卷积核，这个操作实现的就是多个 feature map 的线性组合，实现通道个数上的变化。如果卷积后添加非线性记录，能提升网络的表达能力。 Inception 网络结构Inception Module 查看大图 Inception 结构：将前一层的数据，同时通过 1*1, 3*3, 5*5 的卷积，以及 3*3 的池化，最终再汇总到一起形成该结构的输出；既增加了网络的宽度，又增加了网络尺度的适应性；该结构使用不同尺寸卷积核来提取特征，每个卷积后都会通过 ReLU 增加网络的非线性特征。为了避免 3*3, 5*5 卷积计算量太大，以及最终的特征图厚度太大，分别在卷积前和池化后加上了 1*1 卷积核，有效降低特征图数量。可以理解为 Inception 结构有多个分支，每个分支提取不同的特征图，每个分支输出的特征图尺寸大小是相同的，但是厚度不一样，最终汇总成一个统一的输出；该结构设计了一个稀疏网络结构，但是能够产生稠密的数据，既增加神经网络表现，又保证计算资源的使用效率。 GoogLeNet 模型GoogLeNet 结构，查看大图 模型特点： 采用了模块化的 Inception 结构，方便添加和修改 在分类器之前采用了平均池化接入 模型解析模型细节，查看大图 GoogLeNet 模型细节中：#3x3 reduce, #5x5 reduce 表示在 3x3, 5x5 卷积之前使用的 1*1 卷积；这样起名易于理解 1*1 卷积核的作用。 输入层输入图像为 224x224x3 ，且都进行了零均值化的预处理操作（图像每个像素减去均值）。 第一段卷积层，使用 7x7 的卷积核，滑动步长 2 ， padding 为 3 ， 64 通道，输出为 112x112x64 ，卷积后通过 ReLU 激活；再经过 3x3 的 max pooling ，步长为 2 ，输出大小为 (112-3)/2+1=56 ，即 56x56x64 ，再通过 ReLU 激活。 第二段卷积层，使用 3x3 的卷积核，滑动步长 1 ， padding 为 1 ， 192 通道，输出为 56x56x192 ，卷积后通过 ReLU 激活；再经过 3x3 的 max pooling ，步长为 2 ，输出大小为 (56-3)/2+1=28 ，即 28x28x192 ，再通过 ReLU 激活。 第三段 Inception a有四个分支，采用不同尺寸的卷积核提取特征图： 分支一： 64 个 1x1 的卷积后通过 RuLU ，输出为 28x28x64 分支二： 96 个 1x1 的卷积后，作为 3x3 卷积核之前的降维，变成 28x28x96 ，然后通过 ReLU ；再进行 128 个 3x3 的卷积， padding 为 1 ，输出 28x28x128 分支三： 16 个 1x1 的卷积后，作为 5x5 卷积核之前的降维，变成 28x28x16 ，然后通过 ReLU ；再进行 32 个 5x5 的卷积， padding 为 2 ，输出 28x28x32 分支四：使用 3x3 的池化核 padding 为 1 ，进行最大池化，输出 28x28x192 ，然后进行 32 个 1x1 的卷积，输出 28x28x32最终将所有分支的结果进行连接，即将特征图厚度叠加：64+128+32+32=256 ，这一层最终输出为 28*28*256 。 第三段 Inception b有四个分支，采用不同尺寸的卷积核提取特征图： 分支一： 128 个 1x1 的卷积后通过 RuLU ，输出为 28x28x128 分支二： 128 个 1x1 的卷积后，作为 3x3 卷积核之前的降维，变成 28x28x128 ，然后通过 ReLU ；再进行 192 个 3x3 的卷积， padding 为 1 ，输出 28x28x192 分支三： 32 个 1x1 的卷积后，作为 5x5 卷积核之前的降维，变成 28x28x32 ，然后通过 ReLU ；再进行 96 个 5x5 的卷积， padding 为 2 ，输出 28x28x96 分支四：使用 3x3 的池化核 padding 为 1 ，进行最大池化，输出 28x28x256 ，然后进行 64 个 1x1 的卷积，输出 28x28x64最终将所有分支的结果进行连接，即将特征图厚度叠加：128+192+96+64=480 ，这一层最终输出为 28*28*480 。 根据模型细节的详细参数，依次类推剩下各层。 Inception V2Inception V2 版本最大的改变是将大尺寸卷积核分解成小尺寸卷积核，保持非对称结构，并将卷积和池化并行计算。 大尺寸卷积核分解使用 2 个 3*3 卷积核替代 5*5 卷积核； n*n 卷积都可以使用 1*n 和 n*1 非对称替换。 减少特征图大小减小特征图大小通常使用池化和卷积叠加，但是谁先谁后会产生不同的影响：先池化再 Inception 卷积，会导致特征缺失；先 Inception 卷积再池化，计算量会很大。为了保持特征并减低计算量，修改了 V1 的网络结构，将卷积和池化并行进行： Inception V2 版本的网络结构细节图： 其中的 Figure 5,6,7 分别表示： 第三段的： 5*5 卷积核使用 2 个 3*3 的卷积 第四段的： n*n 卷积核都是用 1*n 和 n*1 叠加 第五段的： 靠近输出的 3*3 卷积核使用 1*3 和 3*1 并行计算 Inception V3Inception V3 版本在 V2 版本上做了比较小的改进，添加了如下功能： 7*7 的卷积核分解 全连接层使用了辅助分类器，并通过 BN 处理 使用标签平滑 Inception V3 网络结构添加部分： Inception V4Inception V4 是在 V3 版本上做了比较小的改进，使得网络结构变得更复杂： 每个 Inception 结构和 Reducing 结构细节如下： Inception V4 的测试结果显示，即使不适用残差结构，也能得到较深的层次和很好的准确率。 Inception-ResNet微软的残差网络流行后， GoogLeNet 在 Inception 中也引入了残差结构，并提出了 Inception-ResNet-V1, Inception-ResNet-V2 模型，其中 V1, V2 主要区别在于残差结构中卷积层数不一样： 每个 Inception 残差结构和 Reducing 结构细节如下： 小结GoogLeNet 的几篇论文中详细描述了各个版本的网络模型， Inception 结构的细节，以及各结构对应的分类结果。 ResNetDRN: Deep Residual Networks 深度残差网络，即 ResNet: Residual Networks ，是微软研究院的 Kaiming He 等四人提出的，通过使用 ResNet Unit 成功训练出了 152 层的神经网络，在 2015 年 ImageNet 竞赛上的 classification, localization, detection 以及 Microsoft COCO 竞赛中 detection, segmentation ，全部获得第一名，而且对应论文 Deep Residual Learning for Image Recognition 也获得了 CVPR2016 的最佳论文。ResNet 相关资源： Deep Residual Learning for Image Recognition Identity Mappings in Deep Residual Networks 解决的问题从 AlexNet 到 VGGNet ，可以看出深度学习网络层数越多，学习能力越好；但是对于常规网络 plain network ，直接堆叠深度，从实验效果来看：随着网络层级的不断增加，模型精度不断得到提升，而当网络层级增加到一定的数目以后，训练精度和测试精度迅速下降。这说明当网络变得很深以后，深度网络就变得更加难以训练了！ 从神经网络的反向传播链式法则中可以知道，神经网络在反向传播过程中要不断地传播梯度，来调整参数矩阵；而当网络层数加深时，梯度在传播过程中会逐渐消失，导致无法对前面网络层的权重进行有效的调整；所以普通网络中层数超过一定深度后，反而错误率会出现上升！ ResNet 残差网络提出了一个网络结构，它借鉴了 Training Very Deep Networks 论文中的 Highway Networks 即跨层链接思想，使用了恒等映射 identity mapping 。 这个残差模块中，通过捷径连接 shortcut connections 的方式，直接把输入 x 传到输出，使得输出结果变为 H(x)=F(x)+x ；当 F(x)=0 时，那么 H(x)=x ，即恒等映射。因此 ResNet 残差网络改变了学习目标，即将残差 F(x)=H(x)-x 结果训练逼近于 0 ，这样即使网络加深，准确率也不会下降。 残差网络结构打破了神经网络层数的约束，可以使层数达到成百上千层。 残差网络残差网络在 VGG-19 上的对比效果： 左边展示 VGG19 ，中间为基于 VGG19 直接扩充到 34 层，右边为使用残差结构扩充到 34 层。残差结构中实线和虚线的区别： 实线连接：表示通道数相同，比如输入 x 和输出 F(x) 都是 3*3*64 ，所以输出结果可以直接相加 H(x)=F(x)+x 虚线连接：表示通道数不同，比如输入 x 为 3*3*64 ，而输出 F(x) 为 3*3*128 ，需要调整计算公式 H(x)=F(x)+Wx ，其中 W 是卷积操作，用来调整 x 的维度 实验结果如下：直接扩充错误率反而会上升，而 ResNet 扩充后错误率下降。 深度残差 作者在提出 ResNet 50/100/150 深度残差网络时，为了减少计算量，提出了深度残差模型，也就是使用小卷积 1*1 来减少特征图。残差网络 ResNet 不仅解决了反向传播中退化问题，而且减少了参数的计算量。 ResNet-V2对于残差结构， BN 归一化和 ReLU 激活层的位置，对准确率有较大影响，测试结果如下： weight 表示卷积层；其中图 a 是 ResNet-V1 使用的残差结构，策略是先卷积后激活；而图 e 则被称为 ResNet-V2 ，策略是先激活后卷积。其中 BN 对数据起到了正则化的效果，所以训练后测试结果更理想。 MobileNetMobileNet 是 Google 在 2017 年为移动设备设计的通用计算机视觉神经网络，支持图像分类、目标检测、分隔等。MobileNet 相关资源： MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications MobileNetV2: Inverted Residuals and Linear Bottlenecks MobileNet 源码 深度可分离卷积MobileNet 的核心是深度可分离卷积 Depthwise Separable Convolution ，该模型将标准卷积分解为深度卷积 dw:Depthwise 以及一个 1*1 的卷积 pw:Pointwise。 上图展示的是卷积核卷积的过程：输入 F 的尺寸为 (Df, Df, M) ，卷积后输出 G 的尺寸为 Dg, Dg, N ： 标准卷积标准卷积核 K 尺寸为 Dk, Dk, M ，通道数为 N ；计算量为 Dk * Dk * M * N * Df * Df 。 深度可分离卷积将标准卷积核拆分为深度卷积 dw 和 1*1 逐点卷积 pw ；计算量为 Dk * Dk * M * Df * Df + M * N * Df * Df 。 深度卷积核 dw ，负责滤波作用，尺寸 Dk, Dk, 1 ，通道数为 M ；卷积后该层输出为 Dg, Dg, M 1*1 卷积核 pw ，用于转换通道数，尺寸为 1, 1, M ，通道数为 N ；卷积后输出为 Dg, Dg, N 深度可分离卷积，在不改变卷积结果的情况下，大大降低了计算量，缩减量为 1/N + 1/(Dk*Dk) 。同时，每次分解都会增加 BN 和 ReLU 激活： MobileNetV1 网络结构MobileNetV1 网络结构模型如下， dw 表示深度可分离卷积： 最后的 FC 层没有非线性激活函数，其他层都有 BN, ReLU 非线性函数。网络结构除了使用深度可分离卷积外，还有一个特点是：直接使用步长为 2 的 s2 卷积运算来代替池化。 宽度乘法器 Width Multiplier宽度乘法器用于控制模型的输入和输出通道数，使得模型变得更薄；假设宽度因子 Width multiplier 为 α ，即输入通道数从 M 变为 αM ，输出通道数从 N 变为 αN ；深度可分离卷积计算量降低为 Dk * Dk * αM * Df * Df + αM * αN * Df * Df ，宽度因子使得计算量和参数降低约 α*α 倍，可以很方便的控制模型大小。 宽度因子取值范围为 α∈(0,1] ，通常设置为 1, 0.75, 0.5, 0.25 。 分辨率乘法器 Resolution Multiplier分辨率乘法器用于控制输入的分辨率，假设分辨率因子 Resolution Multiplier 为 ρ ，即输入图片尺寸从 Df 变为 ρDf ；深度可分离卷积计算量为 Dk * Dk * αM * ρDf * ρDf + αM * αN * ρDf * ρDf ，分辨率因子使得计算量和参数降低约为 ρ*ρ 倍；分比率因子取值范围为 ρ∈(0,1] ，通常设置输入分辨率为 224,192,160,128 。 Width Multiplier, Resolution Multiplier 对参数及计算量的影响： Linear Bottlenecks在深度神经网络中，当前层的维度为 hi*wi*di ，其中 d 表示通道数，也称为宽度；当通道数过低时， ReLu 激活函数会有很大的信息损耗；如下图所示，低维度情况下，张量的的恢复较差，几乎变形；高维度时则恢复较好： 所谓 Bottleneck ，指的是输入和输出的维度差异较大，就像一个瓶颈一样。 Inverted residual block深度残差网络 ResNet 结构可以很好的增大网络深度，基于残差模块引入了 Inverted residual block 即倒置残差模块，示意图如下： 实现思路是：先通过 1*1 卷积核增加通道数，再进行深度可分离卷积，最后通过 1*1 卷积核减少通道数。 MobileNetV2 版本网络结构基于 Linear Bottlenecks 和 Inverted residual block 提出了 MobileNet V2 版本，其模块结构如下： 深度可分离卷积引入了残差 使用 1*1 卷积核降低深度时，使用线性激活替代了 ReLU 激活函数 输入经过 V2 结构后对应的输出为： MobileNetV2 完整结构如下： 其中 t 代表单元的扩张系数， c 代表 channel 数， n 为单元重复个数， s 为 stride 步长数。 V2 和 V1 的比较 在 dw 卷积前引入了一个 pw 卷积，用于提高输入通道数 在最后 pw 卷积之后，去掉了 ReLU 激活函数，在低维度情况下， ReLU 会破坏特征不如线性效果好 V2 和 ResNet 的比较 两者网络结构基本一样，区别在于： ResNet 使用标准卷积，而 MobileNetV2 使用 dw 卷积 ResNet 第一个 1*1 卷积是降维，最后一个 1*1 卷积是升维，网络特征图模型为沙漏型； MobileNetV2 第一个 1*1 卷积是升维，最后一个 1*1 卷积是降维，网络特征图模型为纺锤型 BN: Batch NormalizationBN: Batch Normalization 也就是“批量归一化”，在深度神经网络训练过程中， BN 可以对神经网络每一层的输入做归一化处理。论文地址： Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift Internal Covariate Shift在深层网络训练的过程中，由于网络中参数变化而引起内部结点数据分布发生变化的这一过程被称作 ICS:Internal Covariate Shift ，也就是隐藏层的输入分布总是变化。 Internal Covariate Shift 带来的问题： 上层网络需要不停调整来适应输入数据分布的变化，导致网络学习速度的降低 网络的训练过程容易陷入梯度饱和区，减缓网络收敛速度 可以通过固定输入值的分布为了解决这些问题，而常见的方法就是白化 Whitening 。白化是机器学习里面常用的一种规范化数据分布的方法，主要是 PCA 白化与 ZCA 白化。白化是对输入数据分布进行变换，进而达到以下两个目的： 使得输入特征分布具有相同的均值与方差。其中 PCA 白化保证了所有特征分布均值为 0 ，方差为 1 ；而 ZCA 白化则保证了所有特征分布均值为 0 ，方差相同 去除特征之间的相关性 通过白化操作，我们可以减缓 ICS 的问题，进而固定了每一层网络输入分布，加速网络训练过程的收敛。但是对每一层进行白化过程，计算成本太高；并且由于白化改变了网络每一层的分布，从而改变了网络层中本身数据的表达能力。 BN 算法BN 的基本思想是：在将输入送给神经元之前，先归一化将输入的分布规范化成在固定区间范围的标准分布（均值为 0 ，方差为 1 ），然后再对其做平移和伸缩变换；计算公式如下： BN 引入了两个可学习的参数：缩放系数 γ 和平移系数 β ，这两个参数的引入是为了恢复数据本身的表达能力，对规范化后的数据进行线性变换。另外，由于 γ 和 β 是可训练的，那么意味着神经网络会随着训练过程自己挑选一个最适合的分布。 DNN 的归一化就是白化操作，在神经网络训练过程中对整体训练数据做归一化带来的计算量太大，这也是白化遇到的问题；而 BN 简化了白化操作： 直接对输入信号的每个维度做归一化 normalize each scalar feature independently 在小批量训练数据中做归一化，即 mini-batch 中计算均值和方差（而不是整体所有数据） 缩放系数 γ 和平移系数 β 保证了模型的表达能力不会归一化后而下降 BN 的优点 使得模型对网络中减轻了对参数初始化的依赖，简化调参过程，使得网络学习更加稳定 使得网络中每层输入数据的分布相对稳定，加速模型学习速度 允许网络使用饱和性激活函数（例如 sigmoid, tanh 等），缓解梯度消失问题 一定程度上增加了泛化能力，具有一定正则化效果（Dropout 等技术可以去掉） 通常在非线性映射前增加 BN ，也就是数据在送入激活函数前先通过 BN 将输入归一化。 Google 发表 BN 论文是在 VGGNet 上做的实验。 后续 搞清楚分类、定位、目标检测、分隔的用途，以及对应常见模型 2017 CVPR 最佳论文 DenseNet 2018 CVPR 最佳论文 Taskonomy: Disentangling Task Transfer Learning SSD, YOLO 模型介绍 对抗模型 ShuffleNetV2 等小规模模型 参考文档 卷积神经网络-知乎百科 大话卷积神经网络 CNN 大话 CNN 经典模型：LeNet 大话 CNN 经典模型：AlexNet 大话CNN经典模型：VGGNet 大话CNN经典模型：GoogLeNet(从Inception v1到v4的演进) 大话深度残差网络（DRN）ResNet网络原理 详解深度学习之经典网络架构 ResNet 两代 轻量级网络–MobileNet 论文解读 MobileNetV1 &amp; MobileNetV2 简介 论文笔记 MobileNet V2 详解深度学习中的Normalization，不只是BN Batch Normalization原理与实战 深入理解 BN Batch Normalization Batch-Normalization详细解析 深度学习中 Batch Normalization为什么效果好 MobileNetV1 &amp; MobileNetV2 简介 翻译：深度学习之MobileNetV1 cs231n 整理的 ImageNet 中经典模型： 1*1 卷积核的作用 斯坦福：卷积可视化 卷积神经网络是什么]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习、深度学习、神经网络]]></title>
    <url>%2F2019%2F05%2F17%2F0114-dl-machine-learning%2F</url>
    <content type="text"><![CDATA[介绍机器学习，深度学习，神经网络基础。 基础概念AI: Artificial Intelligence 人工智能，它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。ML: Machine Learning 机器学习，它是人工智能的子集；机器学习从有限的观测数据中学习或猜测出具有一般性的规律，并将这些规律应用到未观测样本上的方法。DL: Deep Learning 深度学习，它是机器学习的子集；深度学习通过建立具有阶层结构的人工神经网络 ANNs:Artifitial Neural Networks ，在计算系统中实现人工智能。 监督学习/无监督学习 监督学习 supervised learning每个输入数据都有对应标签 Label ，则为监督学习。监督学习中经典算法为分类、回归、统计，常见的为 KNN, SVN 等。常见应用场景有：垃圾邮件识别、图像识别、房价预测等等。 无监督学习 unsupervised learning只有输入数据，没有任何标签，则为无监督学习。无监督学习有聚类 Clustering ，主成分分析 PCA 等。常见应用场景有：新闻聚合、内容挖掘等。 半监督学习 semi-supervised learning对于半监督学习，其训练数据的一部分是有标签的，另一部分没有标签，而没标签数据的数量常常极大于有标签数据数量（这也是符合现实情况的）。常见应用场景：医疗影像、金融风控。 强化学习 reinforcement learning强化学习是指没有任何的标签，但有一系列的奖励和惩罚规则，计算机通过不断尝试，从错误中学习，最后找到规律。常见应用场景有： AlphaGo ，在线广告系统，工业机器人等。 分类和回归分类和回归的本质是一样的，都是对输入做出预测，其区别在于输出的类型： 分类问题输出是离散型变量，如 +1、-1 ，是一种定性输出。例如预测明天天气是阴、晴还是雨。 回归问题输出是连续型变量，是一种定量输出。例如预测明天的温度是多少度。 神经网络人工神经网络 ANNs:Artificial Neural Networks 简称为神经网络 NN ，是神经科学家模仿人脑神经系统设计的数学模型；在机器学习领域，神经网络由很多人工神经元构成的网络结构模型，这些神经元之间的连接是可学习的参数。 一个典型的神经元数学结构示例： 其中：输入为 x1, x2, ... ，权重为 w1, w2, ... ，偏置为 b ，激活函数为 f 。 前馈神经网络前馈神经网络 Feedforward Neural Network 简称前馈网络，是人工神经网络的一种。在此种神经网络中，各神经元从输入层开始，接收前一级输入，并输出到下一级，直至输出层。整个网络中无反馈，可用一个有向无环图表示。前馈神经网络采用一种单向多层结构。其中每一层包含若干个神经元，同一层的神经元之间没有互相连接，层间信息的传送只沿一个方向进行。其中第一层称为输入层。最后一层为输出层．中间为隐含层，简称隐层。隐层可以是一层，也可以是多层。 神经网络的层数：一般不计入输入层，层数为 n 个隐藏层加上 1 个输出层。前馈神经网络使用数学表达式来表示为： 根据通用近似定理 Universal Approximation Theorem ，对于具有线性输出层和至少一个使用“挤压”性质的激活函数的隐藏层组成的前馈神经网络，只要其隐藏层神经元的数量足够，它可以以任意的精度来近似任何从一个定义在实数空间 Rd 中的有界闭集函数。也就是说，神经网络在某种程度上可以作为一个“万能”函数来使用，可以用来进行复杂的特征转换，或逼近一个复杂的条件分布。 常见激活函数激活函数 Activation Function 在神经元模型中非常重要，增强了网络的表示能力和学习能力，激活函数具备的几点性质： 连续并可导（允许少数点上不可导）的非线性函数。可导的激活函数可以直接利用数值优化的方法来学习网络参数 激活函数及其导函数要尽可能的简单，有利于提高网络计算效率 激活函数的导函数的值域要在一个合适的区间内，不能太大也不能太小，否则会影响训练的效率和稳定性 常见激活函数有： sigmoid, tanh, relu 等等。 Sigmoid 函数Sigmoid 型函数是指一类 S 型曲线函数，为两端饱和函数。常用的 Sigmoid 型函数有 Logistic 函数和 Tanh 函数；通常在实际使用中， Sigmoid 会特指为 Logistic 函数。对于函数 f(x)：若 x → −∞ 时，其导数 f′(x) → 0 ，则称其为左饱和；若 x → +∞ 时，其导数 f′(x) → 0 ，则称其为右饱和。当同时满足左、右饱和时，就称为两端饱和。 Tanh 函数Tanh 函数也是 Sigmoid 型的一种，其曲线和数学表达式如下： ReLU 函数ReLU: Rectified Linear Unit 修正线性单元，是目前深层神经网络中最常用的激活函数。 ReLU 激活函数的优缺点： 优点ReLU 的神经元只需要进行加、乘和比较的操作，计算上更加高效。 Sigmoid 型激活函数会导致一个非稀疏的神经网络，而 ReLU 却具有很好的稀疏性，大约 50% 的神经元会处于激活状态。在优化方面，相比于 Sigmoid 型函数的两端饱和， ReLU 函数为左饱和函数，且在 x&gt;0 时导数为 1 ，在一定程度上缓解了神经网络的梯度消失问题，加速梯度下降的收敛速度。 缺点ReLU 函数的输出是非零中心化的，给后一层的神经网络引入偏置偏移，会影响梯度下降的效率。此外在训练时，当输入小于 0 时，输出全部为 0 ，使得梯度为 0 ，这种现象称为死亡 ReLU 问题 Dying ReLU Problem 。 反向传播反向传播 BP: BackPropagation 算法在 1970 年代提出，大概 1986 年由 Hinton 等人在神经网络上发扬光大。给定一个样本 (x, y) ，通过神经网络模型后得到的输出为 ˆy ，假设损失函数为 L(y, ˆy) ，计算损失函数关于每个参数的导数。对第 l 层中的参数 W(l) 和 b(l) 计算偏导数， ∂L(y,ˆy)/∂W(l) 的计算涉及到矩阵的微分十分繁琐，因为满足 z(l) = W(l)a(l−1) + b(l) ，根据导数的链式法则： 计算出每一层的误差项之后，我们就可以得到每一层参数的梯度；因此反向传播算法训练过程为： 前馈计算每一层的净输入 z(l) 和激活值 a(l) ，直到最后一层 反向传播计算每一层的误差项 δ(l) 计算每一层参数的偏导数，并更新参数 使结果误差反向传播从而得出权重 w 调整的梯度。通过不断迭代，对参数矩阵进行不断调整后，使得输出结果的误差值更小，使输出结果与事实更加接近。 常见损失函数损失函数 loss function ，有时也称为残差函数 error function 或者代价函数 cost function ，就是用来表现预测与实际数据的差距。反向传播算法的目标是将损失函数降到最低。损失函数的计算有很多方法，常见的有：均方误差 MSE ，平均绝对误差 MAE ，交叉熵 CE 等等。 均方误差 MSE: Mean Square Error也称为 L2 损失函数，计算方法：目标值和预测值之差的平方再求平均： 平均绝对误差 MAE: Mean Absolute Error也称为 L1 损失函数，计算方法：目标值与预测值之差绝对值的和，表示了预测值的平均误差幅度，而不需要考虑误差的方向： 交叉熵 CE: Cross Entropy交叉熵损失函数是一个平滑函数，用于度量两个概率分布间的差异性信息，交叉熵越低，策略越好。如下图所示中：C 是类别数（比如猫、狗、其他动物等）， n 是总样本， yc,i 是第 i 个样本真实类别 c， pc,i 是第 i 个样本预测为类别 c 的概率。 在分类应用中：交叉熵损失函数通常和 Softmax 多分类器或者 Sigmoid 二分类器一起使用。 梯度消失/爆炸在深度神经网络中的梯度是不稳定的，在靠近输入层的隐藏层中可能会出现梯度消失 Vanishing Gradient Problem 或梯度爆炸 Exploding Gradient Problem。梯度不稳定的原因是，在反向传播过程中，前面层上的梯度是来自后面层上梯度的乘积。当神经网络层数越多时，梯度就会越不稳定。 梯度消失前面的网络层比后面的网络层梯度变化更小，故权值变化缓慢，从而引起了梯度消失问题，也称为梯度弥散。 梯度爆炸前面的网络层比后面的网络层梯度变化更快，引起了梯度爆炸的问题。 根据导数链式法则，梯度的变化由激活函数决定， Sigmoid 激活函数很容易出现梯度消失现象，所以通常使用 ReLU 激活函数。 优化器反向传播中，优化器提供了计算损失函数梯度更新的方法，常见优化器有：梯度下降 gradient descent ， momentum 优化器， adam 优化器，等等，参考论文： An overview of gradient descent optimization algorithms 下图是常见优化器的比较： 神经网络优化过拟合过拟合 overfit ：神经网络模型在训练数据集上的准确率较高，但在新的数据进行预测或分类时准确率较低，说明模型的泛华能力差。 正则化正则化 Regularization ：用于增加训练误差为代价来减少测试集上的误差的策略或技术；常见的技术有： 数据集增强 Data Agumentation 提前终止 Early Stopping 参数范数惩罚 Parameter Norm Penalties Dropout 参数范数惩罚：在损失函数中添加一个惩罚项，约束模型的学习能力；即给每个参数权重 w 进行惩罚，引入模型复杂度指标，从而抑制模型噪声，减小过拟合。常见的有 L1, L2 正则化，其中 L1 正则化惩罚的是权重 w 的绝对值，在损失函数求导数时，意味着如果 w 为正数时， w 减小趋于 0 ；如果 w 为负数时， w 增加趋于 0 ； L1 的思路就是把权重往 0 靠，从而降低网络复杂度。通常在需要压缩模型时使用 L1 ，其他情况使用 L2 。其中 λ 是正则化超参数，通常设为 0.001 。 Dropout 通过改变神经网络的结构来增强网络的泛化能力。在用前向传播算法和反向传播算法训练模型时，随机的从全连接 DNN 网络中去掉一部分隐含层的神经元； Dropout 可以看作是模型组合，每次生成的网络结构都不一样，通过组合多个模型来减少过拟合。 学习率学习率 Learning rate ：是一个超参数。在训练过程中，参数的更新向着损失函数梯度下降的方向，学习率决定了参数每次更新的幅度。当学习率选择过大时会出现震荡不收敛；选择过小时会出现收敛速度慢的情况。 因此选择一个合适的学习率非常重要，但是实际训练中往往并不清楚该超参数设置成什么值，通常动态来设置学习率，即学习率退火 learning rate annealing ：先从比较高的学习率开始，然后在训练中慢慢降低学习率。常有两种实现方法： 线性衰减每经过 n 轮训练后，将学习率减少一半。 指数衰减每经过 n 轮训练后，学习率指数改变。这里有一个 tensorflow 中提供的计算公式：decayed_learning_rate = learning_rate*decay_rate^(global_step/decay_steps) ，其中 learning_rate, decay_rate 是两个超参数，分别表示初始学习率和底数； global_step 表示当前训练的轮数， decay_steps 表示多少轮更新一次学习率。初始学习率和底数通常设置为 learning_rate=0.001, decay_rate=0.99 。 滑动平均滑动平均 ema:exponential moving average 或者叫做指数加权平均 exponentially weighted moving average ，可以用来估计变量的局部均值，使得变量的更新与一段时间内的历史取值有关。滑动平均记录了一段时间内模型中所有参数 w 和 b 各自的平均值，利用滑动平均值可以增强模型的泛化能力。滑动平均对每一个变量会维护一个影子变量 shadow variable ，这个影子变量的初始值就是相应变量的初始值，而每次运行变量更新时，影子变量的值会被更新；滑动平均影子计算公式：shadow_variable = decay * shadow_variable + (1 - decay) * variable ，其中 decay 是超参数，表示衰减率，决定了影子变量的更新速度； decay 越大影子变量越趋于稳定。在实际运用中，decay 一般会设成非常接近 1 的数，比如 0.99 ， 0.999 等等。 在 tensorflow 中为了使得影子变量在训练前期可以更新更快，滑动平均还提供了 num_updates 参数动态设置 decay 的大小。衰减率计算公式：decay=min(decay, (1 + num_updates) / (10 + num_updates)) ， num_updates 表示多少轮更新一次。 偏差和方差偏差 Bias ：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力。方差 Variance ：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。欠拟合 underfit ：模型不能适配训练样本，有一个很大的偏差。过拟合 overfit ：模型很好适配训练样本，但在测试集上表现很糟，有一个很大的方差。 下图很好的说明的偏差和方差和模型选择的关系： 模型越复杂，拥有更好的数据拟合能力，获得更低的偏差，但是会导致过拟合而出现方差过大。在模型评估中，根据偏差和方差结果绘制出的图形可以看出，针对偏差和方差过大解决方法如下： 偏差过大，即欠拟合 寻找更好的特征（具有代表性） 用更多的特征（增大输入向量的维度，增加模型复杂度） 方差过大，即过拟合 增大数据集合，使用更多的数据，噪声点比减少（减少数据扰动所造成的影响） 减少数据特征，减少数据维度，高维空间密度小（减少模型复杂度） 正则化方法 交叉验证法 偏差和方差用来描述模型的好坏，以及模型需要优化的方向。 参考文档 复旦教授-神经网络与深度学习 人工智能、机器学习和深度学习之间的区别与联系 神经网络浅讲：从神经元到深度学习 从机器学习谈起 深度学习中常用的激励函数 五种损失函数 学习率 神经网络梯度消失和梯度爆炸及解决办法 梯度弥散与梯度爆炸 无监督、有监督、半监督、强化学习 模型的偏差和方差 机器学习中的Bias(偏差)，Error(误差)，和Variance(方差)有什么区别和联系]]></content>
      <categories>
        <category>DeepLearning</category>
      </categories>
      <tags>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 图形显示简述]]></title>
    <url>%2F2019%2F04%2F17%2F0113-android-graphics-display%2F</url>
    <content type="text"><![CDATA[Android 图形 Graphic 和显示 Display 是两个独立的部分，这里放在一起简述；介绍了图像和显示相关的基本概念，比如 BufferQueue 生产者消费者模型， Surface/SurfaceFlinger 图形合成等等。 概念应用开发者可通过两种方式将图像绘制到屏幕上：使用 Canvas 或 OpenGL ： android.graphics.Canvas 是一个 2D 图形 API ， Canvas API 通过一个名为 OpenGLRenderer 的绘制库实现硬件加速，该绘制库将 Canvas 运算转换为 OpenGL 运算，以便它们可以在 GPU 上执行。从 Android 4.0 开始，硬件加速的 Canvas 默认情况下处于启用状态 除了 Canvas，开发者渲染图形的另一个主要方式是使用 OpenGL ES 直接渲染到 Surface 。 Android 在 Android.opengl 软件包中提供了 OpenGL ES 接口 EGL先熟悉 Android 平台图形处理 API 的标准： OpenGL是由 SGI 公司开发的一套 3D 图形软件接口标准，由于具有体系结构简单合理、使用方便、与操作平台无关等优点， OpenGL 迅速成为 3D 图形接口的工业标准，并陆续在各种平台上得以实现。 OpenGL ES是由 khronos 组织根据手持及移动平台的特点，对 OpenGL 3D 图形 API 标准进行裁剪定制而形成的。 Vulkan是由 khronos 组织在 2016 年正式发布的，是 OpenGL ES 的继任者。 API 是轻量级、更贴近底层硬件 close-to-the-metal 的接口，可使 GPU 驱动软件运用多核与多线程 CPU 性能。 OpenGL ES 定义了一个渲染图形的 API ，但没有定义窗口系统。为了让它能够适合各种平台，它将与知道如何通过操作系统创建和访问窗口的库结合使用。而在 Android 中，这个库被称为 EGL ；也就是说 EGL 主要是适配系统和关联窗口属性。如果要绘制纹理多边形，应使用 OpenGL ES 调用；如果要在屏幕上进行渲染，应使用 EGL 调用。OpenGL ES 是 Android 绘图 API ，但 OpenGL ES 是平台通用的，在特定设备上使用需要一个中间层做适配， Android 中这个中间层就是 EGL 。 Surface 和 SurfaceFlinger无论开发者使用什么渲染 API，一切内容都会渲染到 Surface 。 Surface 表示缓冲队列中的生产者，而缓冲队列通常会被 SurfaceFlinger 消耗。在 Android 平台上创建的每个窗口都由 Surface 提供支持。所有被渲染的可见 Surface 都被 SurfaceFlinger 合成到显示部分。它们遵循生产者/消费者模型： 图像流生产者图像流生产者可以是生成图形缓冲区以供消耗的任何内容。例如 OpenGL ES, Canvas 2D, mediaserver 视频解码器。 图像流消费者图像流的最常见消费者是 SurfaceFlinger ，该系统服务会消耗当前可见的 Surface ，并使用窗口管理器中提供的信息将它们合成到显示部分。 SurfaceFlinger 是可以修改所显示部分内容的唯一服务。 SurfaceFlinger 使用 OpenGL 和 Hardware Composer 来合成一组 Surface 。其他 OpenGL ES 应用也可以消耗图像流，例如相机应用会消耗相机预览图像流。非 GL 应用也可以是消费者，例如 ImageReader 类。 WMS: WindowManagerServices窗口管理器，控制窗口的 Android 系统服务，它是视图容器。窗口总是由 Surface 提供支持。该服务会监督生命周期、输入和聚焦事件、屏幕方向、转换、动画、位置、变形、 Z-Order 以及窗口的其他许多方面。窗口管理器会将所有窗口元数据发送到 SurfaceFlinger ，以便 SurfaceFlinger 可以使用该数据在显示部分合成 Surface 。 FrameBufferFrameBuffer 帧缓冲驱动，它是 Linux 的一种驱动程序接口。 Linux 是工作在保护模式下，所以用户态进程是无法象 DOS 那样使用显卡 BIOS 里提供的中断调用来实现直接写屏， Linux 抽象出 FrameBuffer 这个设备来供用户态进程实现直接写屏。 FrameBuffer 机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过 FrameBuffer 的读写直接对显存进行操作。用户可以将 FrameBuffer 看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的统一的。用户不必关心物理显存的位置、换页机制等等具体细节，这些都是由 FrameBuffer 设备驱动来完成的。但 FrameBuffer 本身不具备任何运算数据的能力，就只好比是一个暂时存放水的水池。 CPU 将运算后的结果放到这个水池,水池再将结果流到显示器，中间不会对数据做处理。应用程序也可以直接读写这个水池的内容在这种机制下，尽管 FrameBuffer 需要真正的显卡驱动的支持，但所有显示任务都有 CPU 完成，因此 CPU 负担很重。 在开发者看来， FrameBuffer 本质上是一块显示缓存，往显示缓存中写入特定格式的数据就意味着向屏幕输出内容。所以说 FrameBuffer 就是一块白板。例如对于初始化为 16 位色的 FrameBuffer 来说， FrameBuffer 中的两个字节代表屏幕上一个点，从上到下，从左至右，屏幕位置与内存地址是顺序的线性关系。帧缓存可以在系统存储器(内存)的任意位置，视频控制器通过访问帧缓存来刷新屏幕。帧缓存也叫刷新缓存 FrameBuffer 或 RefreshBuffer ，这里的帧 Frame 是指整个屏幕范围。帧缓存有个地址，是在内存里。我们通过不停的向 FrameBuffer 中写入数据，显示控制器就自动的从 FrameBuffer 中取数据并显示出来。全部的图形都共享内存中同一个帧缓存。 FrameBuffer 帧缓冲实际上包括两个不同的方面： Frame ：帧，就是指一幅图像，在屏幕上看到的那幅图像就是一帧 Buffer ：缓冲，就是一段存储区域，可这个区域存储的是帧 FrameBuffer 就是一个存储图形/图像帧数据的缓冲。Linux 内核提供了统一的 Framebuffer 显示驱动，设备节点 /dev/graphics/fb* 或者 /dev/fb* ，以 fb0 表示第一个 Monitor ，当前实现中只用到了一个显示屏。这个虚拟设备将不同硬件厂商实现的真实设备统一在一个框架下，这样应用层就可以通过标准的接口进行图形/图像的输入和输出了： 从上图中可以看出，应用层通过标准的 ioctl, mmap 等系统调用，就可以操作显示设备，用起来非常方便。这里 mmap 把设备中的显存映射到用户空间的，在这块缓冲上写数据，就相当于在屏幕上绘画。 GrallocGralloc 的含义为是 Graphics Alloc 图形分配 。 Android 系统在硬件抽象层中提供了一个 Gralloc 模块，封装了对 Framebuffer 的所有访问操作。Gralloc 模块符合 Android 标准的 HAL 架构设计；它分为 fb 和 gralloc 两个设备：前者负责打开内核中的 Framebuffer 、初始化配置，以及提供 post, setSwapInterval 等操作；后者则管理帧缓冲区的分配和释放。上层只能通过 Gralloc 访问帧缓冲区，这样一来就实现了有序的封装保护。 Gralloc 图形内存分配器，分配图像生产者请求的内存。它不仅仅是在原生堆上分配内存的另一种方法；在某些情况下，分配的内存可能并非缓存一致，或者可能完全无法从用户空间访问。分配的性质由用法标记确定，这些标记包括以下属性： 从软件 CPU 访问内存的频率 从硬件 GPU 访问内存的频率 是否将内存用作 OpenGL ES: GLES 纹理 视频编码器是否会使用内存 例如如果格式指定为 RGBA 8888 像素，并且指明将从软件访问缓冲区（这意味着应用将直接触摸像素），则分配器必须按照 R-G-B-A 的顺序为每个像素创建 4 个字节的缓冲区。相反如果指明仅从硬件访问缓冲区且缓冲区作为 GLES 纹理，则分配器可以执行 GLES 驱动程序所需的任何操作 - BGRA 排序、非线性搅和布局、替代颜色格式等。允许硬件使用其首选格式可以提高性能。某些值在特定平台上无法组合，例如视频编码器标记可能需要 YUV 像素，因此将无法添加软件访问权并指定 RGBA 8888 。 Gralloc 分配器返回的句柄可以通过 Binder 在进程之间传递。 HWCHWC: Hardware Composer 硬件混合渲染器，显示子系统的硬件抽象实现。 SurfaceFlinger 可以将某些合成工作委托给 Hardware Composer，以分担 OpenGL 和 GPU 上的工作量。 SurfaceFlinger 只是充当另一个 OpenGL ES 客户端。因此在 SurfaceFlinger 将一个或两个缓冲区合成到第三个缓冲区中的过程中，它会使用 OpenGL ES 。这样使合成的功耗比通过 GPU 执行所有计算更低。Hardware Composer HAL 则进行另一半的工作，并且是所有 Android 图形渲染的核心。 Hardware Composer 必须支持事件，其中之一是 VSYNC（另一个是支持即插即用 HDMI 的热插拔 hotplug ） 。 VSYNC 垂直刷新先介绍几个概念： 帧视频，动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。 帧率Frame Rate ，也指帧速率，单位 fps:frames per second ，描述视频、电子绘图或游戏每秒播放多少帧；FPS 是测量用于保存、显示动态视频的信息数量；我们本篇讲的帧率/帧速率指的是系统显卡处理的速率，即每秒能处理多少帧。每秒钟帧数愈多，所显示的动作就会愈流畅。通常要避免动作不流畅的最低是 30 ，所以常见的有 30fps, 60fps 等。 wiki 百科中提到几个帧率数字： 12 fps：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约 10-12 帧的时候，就会认为是连贯的，是动画的 24 fps：有声电影的拍摄及播放帧率均为每秒 24 帧，对一般人而言已算可接受 30 fps：早期的高动态电子游戏，帧率少于每秒 30 帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低 60 fps：在实际体验中，60 帧相对于 30 帧有着更好的体验 85 fps：一般而言，大脑处理视频的极限 屏幕刷新频率Refresh Rate 或者是 Scanning Frequency，单位赫兹 Hz （即周期/秒），是指设备刷新屏幕的频率，通常为 60hz 。屏幕的刷新过程是每一行从左到右（行刷新，水平刷新，Horizontal Scanning ），从上到下（屏幕刷新，垂直刷新， Vertical Scanning ）。 Tearing 撕裂显示出来的图像出现上半部分和下半部分不属于同一帧，我们称之为 tearing 。假设系统显卡处理能力为 FPS 100 ，显示器的刷新频率是 75Hz ，显卡将比显示器快 1/3 ；这意味着，在一个刷新周期之内，显卡将写入 4/3 的帧数据，也就是说下一帧的 1/3 覆盖在前一帧之上；当然随着系统运行， 1/3 这个比例会发生变化，1/3，2/3，1，1/3，循环；这种帧与帧之间的不完全覆盖重合现象就是 Tearing 撕裂现象。 显卡处理图像的帧速率和屏幕刷新频率是相互独立的，当两者不一致时会出现 tearing 问题，为了解决不一致的问题，引入了 Vsync 信号：当整个屏幕刷新完毕，即一个垂直刷新周期完成，会有短暂的空白期，等待定期同步信号 VSync 信号，收到后才开始下一次屏幕刷新；所以 VSync 中的 V 指的是垂直刷新中的垂直 Vertical 。Vsync 技术意味着，显卡显示性能极限被限制在屏幕刷新率以内了：在系统显卡处理的 FPS 高于屏幕刷新率时，显卡会将一部分时间浪费在等待上；因为没有可用的内存用于绘制，显卡需要等待 Vsync 信号才能绘制下一帧。 单缓存缓存模型理想的情况是帧率和刷新频率相等，每绘制一帧，屏幕显示一帧，如下图所示；但是如果不一致，就会出现 tearing 。 双重缓存 Double Buffer两个缓存区分别为 Back Buffer 和 Frame Buffer 。 GPU 向 Back Buffer 中写数据，屏幕从 Frame Buffer 中读数据。当屏幕刷新完成后产生 VSync 信号，此时将数据从 Back Buffer 复制到 Frame Buffer，可认为该复制操作在瞬间完成；复制完后显示设备开始显示这帧数据，同时通知 CPU/GPU 绘制下一帧图像。但是当 GPU/CPU 绘制一帧的时间超过了 Vsync 时，屏幕刷新从 Frame Buffer 取到的数据仍然是上一帧数据，即两个 Vsync 周期显示同一帧数据，我们称为发生了掉帧 Dropped Frame, Skipped Frame, Jank 现象。 三重缓存 Triple Buffer在双重缓存模型中，当 Jank 现象出现时， GPU/CPU 此时都处于闲置状态，所以引入了三重缓存的概念：在 Jank 时， GPU/CPU 在第三个 Buffer 中绘制数据：需要注意的是，第三个缓存并不是总是存在的，只要当需要的时候才会创建；而且也无法完全解决 Jank 现象，但是能缓解。 60Hz 和 16 ms从上面解释帧速率时提到，虽然人眼感知生理的极限 85fps ，但达到 60fps 时动画就已经有很好的体验，不会出现卡顿和迟滞现象；而最为关键的是 60Hz 是美国交流电的频率，如果屏幕刷新频率能够匹配交流电的频率就可以有效的预防屏幕中出现滚动条；所以： 60Hz 的屏幕刷新率或者 60fps 的帧率，是人眼能够感知到比较流畅的数值 1000ms/60=16ms ， 16ms 是指 GPU/CPU 在绘制图形时，必须在这个刷新频率内绘制完成，否则会出现丢帧现象 BufferQueue实现了整个生产者消费者模型。 BufferQueues 是 Android 图形组件之间的粘合剂。它们是一对队列，可以调解缓冲区从生产者到消费者的固定周期。一旦生产者移交其缓冲区， SurfaceFlinger 便会负责将所有内容合成到显示部分。BufferQueue 永远不会复制缓冲区内容（移动如此多的数据是非常低效的操作）；相反缓冲区始终通过句柄进行传递。 BufferQueue 包含将图像流生产者与图像流消费者结合在一起的逻辑。图像生产者的一些示例包括由相机 HAL 或 OpenGL ES 游戏生成的相机预览。图像消费者的一些示例包括 SurfaceFlinger 或显示 OpenGL ES 流的另一个应用，如显示相机取景器的相机应用。BufferQueue 是将缓冲区池与队列相结合的数据结构，它使用 Binder IPC 在进程之间传递缓冲区。生产者接口，或者您传递给想要生成图形缓冲区的某个人的内容，即是 IGraphicBufferProducer （ SurfaceTexture 的一部分）。 BufferQueue 通常用于渲染到 Surface ，并且与 GL 消费者及其他任务一起消耗内容。 BufferQueue 可以在三种不同的模式下运行： 类同步模式默认情况下， BufferQueue 在类同步模式下运行，在该模式下，从生产者进入的每个缓冲区都在消费者那退出。在此模式下不会舍弃任何缓冲区。如果生产者速度太快，创建缓冲区的速度比消耗缓冲区的速度更快，它将阻塞并等待可用的缓冲区。 非阻塞模式BufferQueue 还可以在非阻塞模式下运行，在此类情况下，它会生成错误，而不是等待缓冲区。在此模式下也不会舍弃缓冲区。这有助于避免可能不了解图形框架的复杂依赖项的应用软件出现潜在死锁现象。 舍弃模式BufferQueue 可以配置为丢弃旧缓冲区，而不是生成错误或进行等待。例如，如果对纹理视图执行 GL 渲染并尽快绘制，则必须丢弃缓冲区。 为了执行这项工作的大部分环节， SurfaceFlinger 就像另一个 OpenGL ES 客户端一样工作。例如当 SurfaceFlinger 正在积极地将一个缓冲区或两个缓冲区合成到第三个缓冲区中时，它使用的是 OpenGL ES 。 数据流Android 图形管道数据流如下图所示： 左侧的对象是生成图形缓冲区的渲染器，如主屏幕、状态栏和系统界面。 SurfaceFlinger 是合成器，而硬件混合渲染器是制作器。 组件小结 低级别组件 BufferQueue 和 gralloc 。 BufferQueue 将可生成图形数据缓冲区的组件（生产者）连接到接受数据以便进行显示或进一步处理的组件（消费者）。通过供应商专用 HAL 接口实现的 gralloc 内存分配器将用于执行缓冲区分配任务。 SurfaceFlinger, Hardware Composer 和虚拟显示屏。 SurfaceFlinger 接受来自多个源的数据缓冲区，然后将它们进行合成并发送到显示屏。 Hardware Composer HAL (HWC) 确定使用可用硬件合成缓冲区的最有效的方法，虚拟显示屏使合成输出可在系统内使用（录制屏幕或通过网络发送屏幕）。 Surface, Canvas, SurfaceHolder 。 Surface 可生成一个通常由 SurfaceFlinger 使用的缓冲区队列。当渲染到 Surface 上时，结果最终将出现在传送给消费者的缓冲区中。 Canvas API 提供一种软件实现方法（支持硬件加速），用于直接在 Surface 上绘图（ OpenGL ES 的低级别替代方案）。与视图有关的任何内容均涉及到 SurfaceHolder ，其 API 可用于获取和设置 Surface 参数（如大小和格式）。 EGLSurface, OpenGL ES 。 OpenGL ES (GLES) 定义了用于与 EGL 结合使用的图形渲染 API 。 EGI 是一个规定如何通过操作系统创建和访问窗口的库（要绘制纹理多边形，请使用 GLES 调用；要将渲染放到屏幕上，请使用 EGL 调用）。 ANativeWindow ，它是 Java Surface 类的 C/C++ 等价类，用于通过原生代码创建 EGL 窗口 Surface 。 Vulkan 。 Vulkan 是一种用于高性能 3D 图形的低开销、跨平台 API 。与 OpenGL ES 一样， Vulkan 提供用于在应用中创建高质量实时图形的工具。 Vulkan 的优势包括降低 CPU 开销以及支持 SPIR-V 二进制中间语言。 高级别组件 SurfaceView 和 GLSurfaceView 。 SurfaceView 结合了 Surface 和 View 。 SurfaceView 的 View 组件由 SurfaceFlinger （而不是应用）合成，从而可以通过单独的线程/进程渲染，并与应用界面渲染隔离。 GLSurfaceView 提供帮助程序类来管理 EGL 上下文、线程间通信以及与 Activity 生命周期的交互（但使用 GLES 时并不需要 GLSurfaceView ）。 SurfaceTexture 。 SurfaceTexture 将 Surface 和 GLES 纹理相结合来创建 BufferQueue ，而应用是 BufferQueue 的消费者。当生产者将新的缓冲区排入队列时，它会通知应用。应用会依次释放先前占有的缓冲区，从队列中获取新缓冲区并执行 EGL 调用，从而使 GLES 可将此缓冲区作为外部纹理使用。 Android 7.0 增加了对安全纹理视频播放的支持，以便用户能够对受保护的视频内容进行 GPU 后处理。 TextureView 。 TextureView 结合了 View 和 SurfaceTexture 。 TextureView 对 SurfaceTexture 进行包装，并负责响应回调以及获取新的缓冲区。在绘图时， TextureView 使用最近收到的缓冲区的内容作为其数据源，根据 View 状态指示，在它应该渲染的任何位置和以它应该采用的任何渲染方式进行渲染。 View 合成始终通过 GLES 来执行，这意味着内容更新可能会导致其他 View 元素重绘。 高级别组件可以直接在 APP 中使用。 Buffer/Window 体系代码速查表1234567system/core/libcutils/include/cutils/native_handle.hhardware/qcom/display/libgralloc/gralloc_priv.hframeworks/native/libs/nativebase/include/nativebase/nativebase.hframeworks/native/libs/nativewindow/include/system/window.hframeworks/native/libs/ui/include/ui/ANativeObjectBase.hframeworks/native/libs/ui/include/ui/GraphicBuffer.hframeworks/native/libs/gui/include/gui/Surface.h native_handle/buffer_handle_t先看 native_handle 这个结构体的定义： 1234567891011121314151617// native_handle.htypedef struct native_handle&#123; int version; /* sizeof(native_handle_t) */ int numFds; /* number of file-descriptors at &amp;data[0] */ int numInts; /* number of ints at &amp;data[numFds] */#if defined(__clang__)#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wzero-length-array"#endif int data[0]; /* numFds + numInts ints */#if defined(__clang__)#pragma clang diagnostic pop#endif&#125; native_handle_t;typedef const native_handle_t* buffer_handle_t; native_handle 这个结构体，描述了一个数据结构，其中最关键的是 data[0] ，它是一个长度为 0 的数组，即 native_handle 是一个柔性数组。在标准的 C/C++ 中,长度为 0 的数组是不被允许的，编译时会产生错误！长度为 0 的数组是 C/C++ 的扩展，需要当前编译器支持这个扩展。从头文件注释中也可以看出，当使用的是 clang 编译器时，才会定义 data[0] 并且忽略数组为 0 的警告。 从 C/C++ 中柔性数组的用途来看， native_handle 表示的是一个不定长数据结构，实际意义指向连续分配的内存空间（除了 native_handle 之外）代表的数据结构（通常是 private_handle_t ）。这里这么做，是因为显示系统和每家实现平台相关度很高， native_handle 定义一个通用的数据结构，至于显示系统如何显示，每家自己去实现对应的 private_handle_t 。 native_handle 结构体中的注释写的很清楚， numFds 表示被指向数据结构包含几个文件描述符； numInts 表示被指向数据结构长度是多少个整型；有了这两个信息后，内存分配就很容易了，参考 native_handle_create 的源码实现： 1234567891011121314151617181920// native_handle.cnative_handle_t* native_handle_create(int numFds, int numInts) &#123; if (numFds &lt; 0 || numInts &lt; 0 || numFds &gt; kMaxNativeFds || numInts &gt; kMaxNativeInts) &#123; errno = EINVAL; return NULL; &#125; // 给 native_handle 分配连续的内存空间 // 除了 native_handle 自身所占空间，还包含被指向数据结构的长度 size_t mallocSize = sizeof(native_handle_t) + (sizeof(int) * (numFds + numInts)); native_handle_t* h = malloc(mallocSize); if (h) &#123; h-&gt;version = sizeof(native_handle_t); h-&gt;numFds = numFds; h-&gt;numInts = numInts; &#125; return h;&#125; 小结： native_handle, native_handle_t 表示一个不定长数据结构，而 buffer_handle_t 表示指向 native_handle 的指针。 private_handle_tprivate_handle_t 描述的是一块缓存，因为和实现平台高度相关，我这里选取高通平台，先看头文件定义： 1234567891011121314151617181920212223242526272829303132333435363738394041// gralloc_priv.h#ifdef __cplusplusstruct private_handle_t : public native_handle &#123;#else struct private_handle_t &#123; native_handle_t nativeHandle;#endif enum &#123; PRIV_FLAGS_FRAMEBUFFER = 0x00000001, ... &#125;; // file-descriptors int fd; int fd_metadata; // fd for the meta-data // ints int magic; int flags; unsigned int size; unsigned int offset; int bufferType; uint64_t base __attribute__((aligned(8))); unsigned int offset_metadata; // The gpu address mapped into the mmu. uint64_t gpuaddr __attribute__((aligned(8))); int format; int width; // holds aligned width of the actual buffer allocated int height; // holds aligned height of the actual buffer allocated uint64_t base_metadata __attribute__((aligned(8))); int unaligned_width; // holds width client asked to allocate int unaligned_height; // holds height client asked to allocate#ifdef __cplusplus static const int sNumFds = 2; static inline int sNumInts() &#123; return ((sizeof(private_handle_t) - sizeof(native_handle_t)) / sizeof(int)) - sNumFds; &#125; static const int sMagic = 'gmsm'; ...&#125; private_handle_t 描述了缓存区使用的文件描述符 fd, fd_metadata 、大小、偏移量、基地址、长宽、格式、没有对齐的长宽等等，而 sNumFds 对应 nativeHandle.numFds ； sNumInts 对应 nativeHandle.numInts ，即除了文件描述符之外，该数据结构的长度。小结： private_handle_t 在各个模块之间传递的时候很不方便，而如果用 native_handle 的来传递，就可以消除平台的差异性。一个简单示意图描述两者的关系： 至此，我们可以简单的理解为 native_handle, native_handle_t, private_handle_t, buffer_handle_t 表示的是同一块内存。 ANativeWindowBuffer先了解 android_native_base_t 数据结构的定义： 1234567891011121314typedef struct android_native_base_t&#123; /* a magic value defined by the actual EGL native type */ int magic; /* the sizeof() of the actual EGL native type */ int version; void* reserved[4]; /* reference-counting interface */ void (*incRef)(struct android_native_base_t* base); void (*decRef)(struct android_native_base_t* base);&#125; android_native_base_t; android_native_base_t 中 incRef/decRef 主要功能是：为了把派生类和 Android 所有 class 的老祖宗 RefBase 联系起来所预留的函数指针。 再看 ANativeWindowBuffer 数据结构的定义： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// nativebase.htypedef struct ANativeWindowBuffer&#123;#ifdef __cplusplus ANativeWindowBuffer() &#123; common.magic = ANDROID_NATIVE_BUFFER_MAGIC; common.version = sizeof(ANativeWindowBuffer); memset(common.reserved, 0, sizeof(common.reserved)); &#125; // Implement the methods that sp&lt;ANativeWindowBuffer&gt; expects so that it // can be used to automatically refcount ANativeWindowBuffer's. void incStrong(const void* /*id*/) const &#123; common.incRef(const_cast&lt;android_native_base_t*&gt;(&amp;common)); &#125; void decStrong(const void* /*id*/) const &#123; common.decRef(const_cast&lt;android_native_base_t*&gt;(&amp;common)); &#125;#endif struct android_native_base_t common; int width; int height; int stride; int format; int usage_deprecated; uintptr_t layerCount; void* reserved[1]; const native_handle_t* handle; uint64_t usage; // we needed extra space for storing the 64-bits usage flags // the number of slots to use from reserved_proc depends on the // architecture. void* reserved_proc[8 - (sizeof(uint64_t) / sizeof(void*))];&#125; ANativeWindowBuffer_t;typedef struct ANativeWindowBuffer ANativeWindowBuffer;// Old typedef for backwards compatibility.typedef ANativeWindowBuffer_t android_native_buffer_t; ANativeWindowBuffer 中使用了 native_handle_t 指针，同时该结构体中也有长宽、格式、步进等基本描述信息；也就是 ANativeWindowBuffer 描述的是一块 Window 相关的缓存区。 ANativeWindowANativeWindow 数据结构的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// window.hstruct ANativeWindow&#123;#ifdef __cplusplus ANativeWindow() : flags(0), minSwapInterval(0), maxSwapInterval(0), xdpi(0), ydpi(0) &#123; common.magic = ANDROID_NATIVE_WINDOW_MAGIC; common.version = sizeof(ANativeWindow); memset(common.reserved, 0, sizeof(common.reserved)); &#125; /* Implement the methods that sp&lt;ANativeWindow&gt; expects so that it can be used to automatically refcount ANativeWindow's. */ void incStrong(const void* /*id*/) const &#123; common.incRef(const_cast&lt;android_native_base_t*&gt;(&amp;common)); &#125; void decStrong(const void* /*id*/) const &#123; common.decRef(const_cast&lt;android_native_base_t*&gt;(&amp;common)); &#125;#endif struct android_native_base_t common; /* flags describing some attributes of this surface or its updater */ const uint32_t flags; /* min swap interval supported by this updated */ const int minSwapInterval; /* max swap interval supported by this updated */ const int maxSwapInterval; /* horizontal and vertical resolution in DPI */ const float xdpi; const float ydpi; /* Some storage reserved for the OEM's driver. */ intptr_t oem[4]; int (*setSwapInterval)(struct ANativeWindow* window, int interval); int (*dequeueBuffer_DEPRECATED)(struct ANativeWindow* window, struct ANativeWindowBuffer** buffer); int (*lockBuffer_DEPRECATED)(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer); int (*queueBuffer_DEPRECATED)(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer); int (*query)(const struct ANativeWindow* window, int what, int* value); int (*perform)(struct ANativeWindow* window, int operation, ... ); int (*cancelBuffer_DEPRECATED)(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer); int (*dequeueBuffer)(struct ANativeWindow* window, struct ANativeWindowBuffer** buffer, int* fenceFd); int (*queueBuffer)(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer, int fenceFd); int (*cancelBuffer)(struct ANativeWindow* window, struct ANativeWindowBuffer* buffer, int fenceFd);&#125;; /* Backwards compatibility: use ANativeWindow (struct ANativeWindow in C). * android_native_window_t is deprecated. */typedef struct ANativeWindow android_native_window_t __deprecated; 从数据结构定义中可以看出， ANativeWindow 和窗口属性相关，它表示的是一个底层实现的窗口，定义的各种函数指针都是对 ANativeWindowBuffer 内存的操作；而 fenceFd 可以看成这个 buffer 的锁。 小结：不管是 ANativeWindow, ANativeWindowBuffer 它们都包含 android_native_base_t 结构体，但是都没有对 incRef, decRef 赋值；可以认为 ANativeWindow, ANativeWindowBuffer 为抽象数据结构。 ANativeObjectBase 模板ANativeObjectBase 是一个模板类，定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// ANativeObjectBase.htemplate &lt;typename NATIVE_TYPE, typename TYPE, typename REF, typename NATIVE_BASE = android_native_base_t&gt;class ANativeObjectBase : public NATIVE_TYPE, public REF&#123;public: // Disambiguate between the incStrong in REF and NATIVE_TYPE void incStrong(const void* id) const &#123; REF::incStrong(id); &#125; void decStrong(const void* id) const &#123; REF::decStrong(id); &#125;protected: typedef ANativeObjectBase&lt;NATIVE_TYPE, TYPE, REF, NATIVE_BASE&gt; BASE; ANativeObjectBase() : NATIVE_TYPE(), REF() &#123; NATIVE_TYPE::common.incRef = incRef; NATIVE_TYPE::common.decRef = decRef; &#125; static inline TYPE* getSelf(NATIVE_TYPE* self) &#123; return static_cast&lt;TYPE*&gt;(self); &#125; static inline TYPE const* getSelf(NATIVE_TYPE const* self) &#123; return static_cast&lt;TYPE const *&gt;(self); &#125; static inline TYPE* getSelf(NATIVE_BASE* base) &#123; return getSelf(reinterpret_cast&lt;NATIVE_TYPE*&gt;(base)); &#125; static inline TYPE const * getSelf(NATIVE_BASE const* base) &#123; return getSelf(reinterpret_cast&lt;NATIVE_TYPE const*&gt;(base)); &#125; static void incRef(NATIVE_BASE* base) &#123; ANativeObjectBase* self = getSelf(base); self-&gt;incStrong(self); &#125; static void decRef(NATIVE_BASE* base) &#123; ANativeObjectBase* self = getSelf(base); self-&gt;decStrong(self); &#125;&#125;;&#125; // namespace android#endif // __cplusplus ANativeObjectBase 模板类的主要作用就是实现 incRef, decRef 引用计数，以及父类子类的类型转换。 GraphicBuffer先看 GraphicBuffer 的头文件定义： 12345// GraphicBuffer.hclass GraphicBuffer : public ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer, RefBase&gt;, public Flattenable&lt;GraphicBuffer&gt;&#123;...&#125; GraphicBuffer 使用 ANativeObjectBase 模板，即 GraphicBuffer 就是 ANativeWindowBuffer 的一种具体实现；而 ANativeWindowBuffer.common 成员的两个函数指针 incRef, decRef 指向了 GraphicBuffer 的另一个基类 RefBase 的 incStrong, decStrong ；而 ANativeWindowBuffer 可以看做是把 buffer_handle_t 包了一层，所以 GraphicBuffer 也是指向的一块缓存区。 SurfaceSurface 的头文件定义： 1234567891011121314// Surface.hclass Surface : public ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;&#123; ...protected: ... struct BufferSlot &#123; sp&lt;GraphicBuffer&gt; buffer; Region dirtyRegion; &#125;; BufferSlot mSlots[NUM_BUFFER_SLOTS]; ...&#125; Surface 也使用了 ANativeObjectBase 模板，即 Surface 就是 ANativeWindow 的一种具体实现，同样也继承了 RefBase 实现引用计数。另外成员数据结构 BufferSlot 是对 GraphicBuffer 的包装，而 mSlots 数组表示每个 Surface 中包含 NUM_BUFFER_SLOTS 个 GraphicBuffer 缓存。而 Surface 的构造函数中，也将 ANativeWindow 的函数指针进行了赋值： 123456789101112131415161718192021222324// Surface.cppSurface::Surface(const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp) : mGraphicBufferProducer(bufferProducer), mCrop(Rect::EMPTY_RECT), mBufferAge(0), mGenerationNumber(0), mSharedBufferMode(false), mAutoRefresh(false), mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT), mSharedBufferHasBeenQueued(false), mQueriedSupportedTimestamps(false), mFrameTimestampsSupportsPresent(false), mEnableFrameTimestamps(false), mFrameEventHistory(std::make_unique&lt;ProducerFrameEventHistory&gt;())&#123; // Initialize the ANativeWindow function pointers. ANativeWindow::setSwapInterval = hook_setSwapInterval; ANativeWindow::dequeueBuffer = hook_dequeueBuffer; ANativeWindow::cancelBuffer = hook_cancelBuffer; ANativeWindow::queueBuffer = hook_queueBuffer; ANativeWindow::query = hook_query; ANativeWindow::perform = hook_perform; ...&#125; 小结 native_handle/native_handle_t 是 private_handle_t 的抽象表示方法，消除平台相关性；方便 private_handle_t 所表示的缓存区可以在 Android 各个层次之间传递；而 buffer_handle_t 是指向他们的指针 ANativeWindowBuffer 将 buffer_handle_t 进行了包装；ANativeWindow, ANativeWindowBuffer 都继承于 android_native_base_t ，它定义了引用计数两个函数指针；可以认为 ANativeWindow, ANativeWindowBuffer 为抽象数据结构，表示窗口和其对应缓存 GraphicBuffer, Surface 都使用了模版类 ANativeObjectBase ，都继承了 RefBase 实现 incRef, decRef 引用计数；它们是具体的实现类，即实现具体的窗口缓存和窗口 Surface 的成员 BufferSlot mSlots[NUM_BUFFER_SLOTS]; 可以看作是 sp&lt;GraphicBuffer&gt; 类型的数组；也就是说每个 Surface 中都包含有 NUM_BUFFER_SLOTS 个 GraphicBuffer Surface, GraphicBuffer 是图形显示系统的高层类，后续主要围绕这两个类来介绍；一个代表窗口，一个代表窗口对应的缓存 Buffer/Window 体系缓存，查看大图 BufferQueue 中的 Buffer 对象，我们用的都是 GraphicBuffer 。 Surface 是 Andorid 窗口的描述，是 ANativeWindow 的实现；同样 GraphicBuffer 是 Android 中图形 Buffer 的描述，是 ANativeWindowBuffer 的实现。而一个窗口可以有多个 Buffer 。 libui 库libui.so 库主要是 GraphicBuffer 缓存相关的代码，包含缓存分配，映射当当前进程等等，而 IAllocator, IMapper 具体是在 HAL 中实现的。 代码目录结构frameworks/native/libs/ui 目录结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ui├── Android.bp├── ColorSpace.cpp├── DebugUtils.cpp├── Fence.cpp├── FenceTime.cpp├── FrameStats.cpp├── Gralloc2.cpp├── GraphicBufferAllocator.cpp├── GraphicBuffer.cpp├── GraphicBufferMapper.cpp├── HdrCapabilities.cpp├── include│ └── ui│ ├── ANativeObjectBase.h│ ├── BufferQueueDefs.h│ ├── ColorSpace.h│ ├── DebugUtils.h│ ├── DisplayInfo.h│ ├── DisplayStatInfo.h│ ├── Fence.h│ ├── FenceTime.h│ ├── FloatRect.h│ ├── FrameStats.h│ ├── Gralloc2.h│ ├── GraphicBufferAllocator.h│ ├── GraphicBuffer.h│ ├── GraphicBufferMapper.h│ ├── HdrCapabilities.h│ ├── PixelFormat.h│ ├── Point.h│ ├── Rect.h│ ├── Region.h│ └── UiConfig.h├── MODULE_LICENSE_APACHE2├── NOTICE├── PixelFormat.cpp├── Rect.cpp├── Region.cpp├── tests│ ├── Android.bp│ ├── colorspace_test.cpp│ └── Region_test.cpp├── tools│ ├── Android.bp│ └── lutgen.cpp└── UiConfig.cpp4 directories, 42 files GraphicBufferAllocator/GraphicBufferMapper它们两个都是包装类，包装了 IAllocator, IMapper ，而这两个类都是在 HAL Gralloc2 中实现的。 GraphicBufferAllocator缓存分配，包装了 IAllocator 类。 GraphicBufferMapper缓存映射到当前进程，包装了 IMapper 类。 GraphicBufferGraphicBuffer 继承 ANativeWindowBuffer ，并持有 GraphicBufferMapper 映射对应的缓存区。 12345678910111213class GraphicBuffer : public ANativeObjectBase&lt;ANativeWindowBuffer, GraphicBuffer,RefBase&gt;, public Flattenable&lt;GraphicBuffer&gt;&#123;public: static sp&lt;GraphicBuffer&gt; from(ANativeWindowBuffer *); ...private: GraphicBufferMapper&amp; mBufferMapper; ssize_t mInitCheck; uint64_t mId; uint32_t mGenerationNumber;&#125;; Fence 机制Fence 是一种同步机制，主要用于 GraphicBuffer 的同步。它主要被用来处理跨硬件的情况，尤其是 CPU, GPU, HWC 之间的同步，另外它还可以用于多个时间点之间的同步。 GPU 编程和纯 CPU 编程一个很大的不同是它是异步的，也就是说当我们调用 GL command 返回时这条命令并不一定完成了，只是把这个命令放在本地的 command buffer 里，而 Fence 机制就是解决这些同步问题的。Fence 顾名思义就是把先到的拦住，等后来的，两者步调一致了再往前走。抽象地说，Fence 包含了同一或不同时间轴上的多个时间点，只有当这些点同时到达时 Fence 才会被触发。 Fence 可以由硬件实现 Graphic driver，也可以由软件实现 Android kernel 中的 sw_sync 。 Fence 的主要实现代码路径： 1234frameworks/native/libs/ui/Fence.cppsystem/core/libsync/sync.ckernel/drivers/base/sync.cframeworks/native/libs/gui/SyncFeatures.cpp 总得来说， kernel driver 部分是同步的主要实现，libsync 是对 driver 接口的封装， Fence 是对 libsync 的进一步的 C++ 封装。 Fence 会被作为 GraphicBuffer 的附属随着 GraphicBuffer 在生产者和消费间传输； SyncFeatures 用以查询系统支持的同步机制。 DisplayInfo 显示信息123456789101112131415161718192021222324// DisplayInfo.hstruct DisplayInfo &#123; uint32_t w&#123;0&#125;; // 屏幕的宽 uint32_t h&#123;0&#125;; // 屏幕的高 float xdpi&#123;0&#125;; // 屏幕 x 方向每英寸的像素点 float ydpi&#123;0&#125;; // 屏幕 y 方向每英寸的像素点 float fps&#123;0&#125;; // FPS 屏幕的刷新率 float density&#123;0&#125;; // 屏幕的密度 uint8_t orientation&#123;0&#125;; // 屏幕的旋转方式 bool secure&#123;false&#125;; // 屏幕是否是安全的 nsecs_t appVsyncOffset&#123;0&#125;; // App 的 Vsync 的偏移 nsecs_t presentationDeadline&#123;0&#125;; // 显示的最后时间&#125;;/* Display orientations as defined in Surface.java and ISurfaceComposer.h. */enum &#123; DISPLAY_ORIENTATION_0 = 0, DISPLAY_ORIENTATION_90 = 1, DISPLAY_ORIENTATION_180 = 2, DISPLAY_ORIENTATION_270 = 3&#125;;&#125;; // namespace android DisplayInfo 结构体包含了显示屏幕的基本信息： 屏幕分辨率 Resolution屏幕的宽高是用分辨率 Resolution 来描述的，也就是有多少个像素点。屏幕宽度，即屏幕横向可以显示多少个像素点；屏幕高度，即屏幕纵向可以显示多少给像素点。平常所说的 720P: 1080x720 屏幕，即横向可以显示 1080 个像素点，纵向可以显示 720 个像素点。如下为常见屏幕分辨率： 屏幕 DPIDPI: Dots Per Inch 每英寸点数，是一个度量单位，表示屏幕每英寸上有多少个物理点。常见屏幕物理大小，是用英寸来描述屏幕对角线的长度，比如 IPhone X 的大小 5.8 寸，即屏幕对角线长度为 5.8 英寸。*标准 DPI 为 160dpi *，人类视网膜级通常为 300dpi 。PPI: Pixel Per Inch 每英寸像素，也是度量单位，表示每英寸显示多少个像素。通常情况下 DPI, PPI 设为相同，表示每个物理点显示一个像素；但是好一点的显示器，可能 DPI 比 PPI 大，即一个像素由多个物理点来显示。 密度 DensityDIP: Density Independent Pixels 设备无关像素，通常简写为 DP=DIP，请注意 DPI 做好区分。 DP 表示这个像素的数值是和设备无关的，那实际转换时怎么转换呢？Density 密度，实际是一个缩放因子，它表示当前设备实际 DPI 和标准 DPI 的比例值；比如设备实际 DPI 为 320dpi ，那么 density=320/160=2 ，即 density 为 2 。有了 density 之后， dp, px 可以使用公式来转换 px=density*dp 。所以我们在 APP 布局设计中，所有显示设置的距离，通常使用 dp 来计算，来规避不同屏幕特性。 屏幕刷新率 FPS这里屏幕刷新率使用 FPS 来表示，不是 Hz ，表示屏幕每秒能显示多少帧数据；通常为 60 fps ，即 16 ms 刷新一次。 屏幕旋转方向 orientations手机默认竖屏，0 表示竖屏， 180 表示横屏。 屏幕安全性 secure这主要是用于 DRM 数字版权保护时，确保显示的设备是安全的，以防止 DRM 的内容被在显示的过程中被截取，只有安全的设备才能显示 DRM 的内容。 Android 默认所有的非虚拟显示都是安全的。 appVsyncOffset, presentationDeadline这两个都和 Vsync 有关； appVsyncOffset 是一个偏移量，在系统或硬件 Vsync 的基础上做一些偏移； presentationDeadline 表示，一帧数据必现在这个时间内显示出来。 libgui 库代码目录结构frameworks/native/libs/gui 目录结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081gui/├── Android.bp├── BitTube.cpp├── BufferItemConsumer.cpp├── BufferItem.cpp├── bufferqueue│ └── 1.0│ ├── B2HProducerListener.cpp│ └── H2BGraphicBufferProducer.cpp├── BufferQueueConsumer.cpp├── BufferQueueCore.cpp├── BufferQueue.cpp├── BufferQueueProducer.cpp├── BufferSlot.cpp├── CleanSpec.mk├── ConsumerBase.cpp├── CpuConsumer.cpp├── DisplayEventReceiver.cpp├── FrameTimestamps.cpp├── GLConsumer.cpp├── GuiConfig.cpp├── IConsumerListener.cpp├── IDisplayEventConnection.cpp├── IGraphicBufferConsumer.cpp├── IGraphicBufferProducer.cpp├── include│ ├── gui│ │ ├── BufferItemConsumer.h│ │ ├── BufferItem.h│ │ ├── bufferqueue│ │ │ └── 1.0│ │ │ ├── B2HProducerListener.h│ │ │ └── H2BGraphicBufferProducer.h│ │ ├── BufferQueueConsumer.h│ │ ├── BufferQueueCore.h│ │ ├── BufferQueueDefs.h│ │ ├── BufferQueue.h│ │ ├── BufferQueueProducer.h│ │ ├── BufferSlot.h│ │ ├── ConsumerBase.h│ │ ├── CpuConsumer.h│ │ ├── DisplayEventReceiver.h│ │ ├── FrameTimestamps.h│ │ ├── GLConsumer.h│ │ ├── GuiConfig.h│ │ ├── IConsumerListener.h│ │ ├── IDisplayEventConnection.h│ │ ├── IGraphicBufferConsumer.h│ │ ├── IGraphicBufferProducer.h│ │ ├── IProducerListener.h│ │ ├── ISurfaceComposerClient.h│ │ ├── ISurfaceComposer.h│ │ ├── OccupancyTracker.h│ │ ├── StreamSplitter.h│ │ ├── SurfaceComposerClient.h│ │ ├── SurfaceControl.h│ │ ├── Surface.h│ │ └── view│ │ └── Surface.h│ └── private│ └── gui│ ├── BitTube.h│ ├── ComposerService.h│ ├── LayerState.h│ └── SyncFeatures.h├── IProducerListener.cpp├── ISurfaceComposerClient.cpp├── ISurfaceComposer.cpp├── LayerState.cpp├── OccupancyTracker.cpp├── StreamSplitter.cpp├── SurfaceComposerClient.cpp├── SurfaceControl.cpp├── Surface.cpp├── SyncFeatures.cpp├── tests│ ├── ...└── view └── Surface.cpp11 directories, 96 files 其中 H2B, B2H 表示 Framework Buffer 和 HAL 层数据结构的相互转换；实际上代表的是同一样东西，方便各层内部使用。 IGraphicBufferProducer/IProducerListener 生产者IGraphicBufferProducer 是生产者接口，实现了 IInterface 可以用于跨进程通信。 123456789101112131415161718192021222324252627282930313233343536373839404142// IGraphicBufferProducer.hclass IGraphicBufferProducer : public IInterface&#123;public: DECLARE_HYBRID_META_INTERFACE(GraphicBufferProducer, HGraphicBufferProducer) ... // 根据指定参数申请一块 Buffer ，索引值为 slot ，同步为 fence // 从 BufferQueue 中出队一块缓存 GraphicBuffer virtual status_t dequeueBuffer(int* slot, sp&lt;Fence&gt;* fence, uint32_t w, uint32_t h, PixelFormat format, uint64_t usage, uint64_t* outBufferAge, FrameEventHistoryDelta* outTimestamps) = 0; // 获取 slot 位置的 GraphicBuffer virtual status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) = 0; // 客户端已经向 slot 位置的 Buffer 填充完数据 // IGraphicBufferProducer 得到 Buffer 的输入信息， // slot 这块缓存 GraphicBuffer 进入队列 BufferQueue virtual status_t queueBuffer(int slot, const QueueBufferInput&amp; input, QueueBufferOutput* output) = 0; // 释放 slot 位置的 GraphicBuffer virtual status_t detachBuffer(int slot) = 0; virtual status_t detachNextBuffer(sp&lt;GraphicBuffer&gt;* outBuffer, sp&lt;Fence&gt;* outFence) = 0; // 根据指定的 buffer 获取 slot virtual status_t attachBuffer(int* outSlot, const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0; // 释放 slot 位置的 buffer virtual status_t cancelBuffer(int slot, const sp&lt;Fence&gt;&amp; fence) = 0; ... // 客户端根据 api 类型，连接 IGraphicBufferProducer ， // 客户端得到缓存的相关信息 QueueBufferOutput virtual status_t connect(const sp&lt;IProducerListener&gt;&amp; listener, int api, bool producerControlledByApp, QueueBufferOutput* output) = 0; // 断开连接 virtual status_t disconnect(int api, DisconnectMode mode = DisconnectMode::Api) = 0; // 获取消费者名称 virtual String8 getConsumerName() const = 0; ...&#125;; IProducerListener 是 IGraphicBufferProducer 对应的回调接口。 1234567891011121314151617181920212223242526272829303132// IProducerListener.hclass ProducerListener : public virtual RefBase&#123;public: ProducerListener() &#123;&#125; virtual ~ProducerListener(); virtual void onBufferReleased() = 0; // Asynchronous virtual bool needsReleaseNotify() = 0;&#125;;class IProducerListener : public ProducerListener, public IInterface&#123;public: DECLARE_META_INTERFACE(ProducerListener)&#125;;class BnProducerListener : public BnInterface&lt;IProducerListener&gt;&#123;public: virtual status_t onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0); virtual bool needsReleaseNotify();&#125;;class DummyProducerListener : public BnProducerListener&#123;public: virtual ~DummyProducerListener(); virtual void onBufferReleased() &#123;&#125; virtual bool needsReleaseNotify() &#123; return false; &#125;&#125;; IGraphicBufferConsumer/IConsumerListener 消费者IGraphicBufferConsumer 是消费者接口，实现了 IInterface 可以用于跨进程通信。 12345678910111213141516171819202122232425// IGraphicBufferConsumer.hclass IGraphicBufferConsumer : public IInterface &#123;public: DECLARE_META_INTERFACE(GraphicBufferConsumer) ... // 从 BufferQueue 中获取一块准备好了的缓存 GraphicBuffer virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen, uint64_t maxFrameNumber = 0) = 0; // 释放 slot 位置的缓存 virtual status_t detachBuffer(int slot) = 0; // 根据指定的 GraphicBuffer 获取 slot virtual status_t attachBuffer(int* outSlot, const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0; // 移除指定 slot 位置的缓存 virtual status_t releaseBuffer(int buf, uint64_t frameNumber, EGLDisplay display, EGLSyncKHR fence, const sp&lt;Fence&gt;&amp; releaseFence) = 0; ... // 连接一个消费者进入 BufferQueue virtual status_t consumerConnect(const sp&lt;IConsumerListener&gt;&amp; consumer, bool controlledByApp) = 0; // 从 BufferQueue 断开连接 virtual status_t consumerDisconnect() = 0; ...&#125;; IConsumerListener 是 IGraphicBufferConsumer 对应的回调接口： 123456789101112131415161718192021// IConsumerListener.hclass ConsumerListener : public virtual RefBase &#123;public: ConsumerListener() &#123;&#125; virtual ~ConsumerListener(); virtual void onDisconnect() &#123;&#125; /* Asynchronous */ virtual void onFrameAvailable(const BufferItem&amp; item) = 0; /* Asynchronous */ virtual void onFrameReplaced(const BufferItem&amp; /* item */) &#123;&#125; /* Asynchronous */ virtual void onBuffersReleased() = 0; /* Asynchronous */ virtual void onSidebandStreamChanged() = 0; /* Asynchronous */ virtual void addAndGetFrameTimestamps(const NewFrameEventsEntry* /*newTimestamps*/, FrameEventHistoryDelta* /*outDelta*/) &#123;&#125;&#125;;class IConsumerListener : public ConsumerListener, public IInterface &#123;public: DECLARE_META_INTERFACE(ConsumerListener)&#125;; BufferItemBufferItem 描述了一块缓存 GraphicBuffer ，以及位置 mSlot ，同步 mFence 等等信息。 123456789101112// BufferItem.hclass BufferItem : public Flattenable&lt;BufferItem&gt; &#123; ... sp&lt;GraphicBuffer&gt; mGraphicBuffer; sp&lt;Fence&gt; mFence; Rect mCrop; ... android_dataspace mDataSpace; uint64_t mFrameNumber; int mSlot; ...&#125; BufferSlotBufferSlot 记录了当前 slot 位置的缓存 GraphicBuffer ，以及对应状态， EGL 相关信息。 12345678910111213141516171819202122232425// BufferSlot.hstruct BufferSlot &#123; BufferSlot() : mGraphicBuffer(nullptr), mEglDisplay(EGL_NO_DISPLAY), mBufferState(), mRequestBufferCalled(false), mFrameNumber(0), mEglFence(EGL_NO_SYNC_KHR), mFence(Fence::NO_FENCE), mAcquireCalled(false), mNeedsReallocation(false) &#123; &#125; sp&lt;GraphicBuffer&gt; mGraphicBuffer; EGLDisplay mEglDisplay; BufferState mBufferState; bool mRequestBufferCalled; uint64_t mFrameNumber; EGLSyncKHR mEglFence; sp&lt;Fence&gt; mFence; bool mAcquireCalled; bool mNeedsReallocation;&#125;; BufferQueueDefs 中定义了一个 BufferSlot 的数组结构类型 SlotsType 。 12345678// BufferQueueDefs.hnamespace android &#123; class BufferQueueCore; namespace BufferQueueDefs &#123; typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS]; &#125; // namespace BufferQueueDefs&#125; // namespace android BufferQueueCoreBufferQueueCore 是生产者消费模型的核心，如下是几个重要的成员变量： 123456789101112131415// BufferQueueCore.hclass BufferQueueCore : public virtual RefBase &#123;public: ... typedef Vector&lt;BufferItem&gt; Fifo;private: ... String8 mConsumerName; sp&lt;IConsumerListener&gt; mConsumerListener; sp&lt;IProducerListener&gt; mConnectedProducerListener; BufferQueueDefs::SlotsType mSlots; Fifo mQueue; ...&#125; mQueue是一个新建先出队列，存储了一队 BufferItem 数据，即一组缓存区。 mSlots一个数组，保存了 BufferSlot 数据，每个 slot 位置对应一个缓存。 mConsumerListener当前生产消费模型中的，消费者回调接口。 mConnectedProducerListener当前生产消费模型中的，生产者回调接口。 BufferQueueProducer/BufferQueueConsumer 生产者/消费者实现类BufferQueueProducer 是 IGraphicBufferConsumer 的实现类，实现了生产者对应的功能。 123456789101112131415// BufferQueueProducer.hclass BufferQueueProducer : public BnGraphicBufferProducer, private IBinder::DeathRecipient &#123; ...private: ... sp&lt;BufferQueueCore&gt; mCore; // This references mCore-&gt;mSlots. BufferQueueDefs::SlotsType&amp; mSlots; String8 mConsumerName; ... sp&lt;Fence&gt; mLastQueueBufferFence; Rect mLastQueuedCrop; uint32_t mLastQueuedTransform;&#125; BufferQueueProducer 中持有 BufferQueueCore 对象； mSlots 指向 mCore-&gt;mSlots ；同时保持了生产消费模型中，对应消费者的名称。 BufferQueueConsumer 是 IGraphicBufferConsumer 的实现类，实现了消费者对应的功能。 123456789// BufferQueueConsumer.hclass BufferQueueConsumer : public BnGraphicBufferConsumer &#123; ...private: sp&lt;BufferQueueCore&gt; mCore; // This references mCore-&gt;mSlots. BufferQueueDefs::SlotsType&amp; mSlots; String8 mConsumerName;&#125; BufferQueueConsumer 中持有 BufferQueueCore 对象； mSlots 指向 mCore-&gt;mSlots 。 BufferQueue 模型BufferQueue 类是 Android 中所有图形处理操作的核心。它的作用很简单：将生成图形数据缓冲区的一方（生产者）连接到接受数据以进行显示或进一步处理的一方（消费者）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue 。基本用法很简单：生产者请求一个可用的缓冲区 dequeueBuffer ，并指定一组特性，包括宽度、高度、像素格式和用法标记；生产者填充缓冲区并将其返回到队列 queueBuffer 。随后消费者获取该缓冲区 acquireBuffer ，并使用该缓冲区的内容。当消费者操作完毕后，将该缓冲区返回到队列 releaseBuffer 。最新的 Android 设备支持“同步框架”，这使得系统能够在与可以异步处理图形数据的硬件组件结合使用时提高工作效率。例如，生产者可以提交一系列 OpenGL ES 绘制命令，然后在渲染完成之前将输出缓冲区加入队列。该缓冲区伴有一个栅栏，当内容准备就绪时，栅栏会发出信号。当该缓冲区返回到空闲列表时，会伴有第二个栅栏，因此消费者可以在内容仍在使用期间释放该缓冲区。该方法缩短了缓冲区通过系统时的延迟时间，并提高了吞吐量。队列的一些特性（例如可以容纳的最大缓冲区数）由生产者和消费者联合决定。但是 BufferQueue 负责根据需要分配缓冲区。除非特性发生变化，否则将会保留缓冲区；例如，如果生产者请求具有不同大小的缓冲区，则系统会释放旧的缓冲区，并根据需要分配新的缓冲区。生产者和消费者可以存在于不同的进程中； BufferQueue 永远不会复制缓冲区内容（移动如此多的数据是非常低效的操作），缓冲区始终通过句柄进行传递。 1234567891011121314151617181920212223242526272829303132333435// BufferQueue.hclass BufferQueue &#123;public: ... typedef ::android::ConsumerListener ConsumerListener; // ProxyConsumerListener 是 ConsumerListener 弱引用实现 class ProxyConsumerListener : public BnConsumerListener &#123; public: explicit ProxyConsumerListener(const wp&lt;ConsumerListener&gt;&amp; consumerListener); ~ProxyConsumerListener() override; void onDisconnect() override; void onFrameAvailable(const BufferItem&amp; item) override; void onFrameReplaced(const BufferItem&amp; item) override; void onBuffersReleased() override; void onSidebandStreamChanged() override; void addAndGetFrameTimestamps( const NewFrameEventsEntry* newTimestamps, FrameEventHistoryDelta* outDelta) override; private: // 弱引用 wp&lt;ConsumerListener&gt; mConsumerListener; &#125;; // BufferQueue manages a pool of gralloc memory slots to be used by // producers and consumers. allocator is used to allocate all the // needed gralloc buffers. static void createBufferQueue( sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, bool consumerIsSurfaceFlinger = false); BufferQueue() = delete; // Create through createBufferQueue&#125;; BufferQueue 的头文件定义很简单： 定义了一个 ConsumerListener 的弱引用 整个类只有一个函数 createBufferQueue ，它将参数中的 IGraphicBufferProducer, IGraphicBufferConsumer 消费者关联起来 没有构造函数，只能通过 createBufferQueue 来创建对象 BufferQueue 中并不包含队列数据结构来存储缓存，仅仅连接了生产者、消费者两者的关系 来看 createBufferQueue 的具体实现： 123456789101112131415// BufferQueue.cpvoid BufferQueue::createBufferQueue( sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, bool consumerIsSurfaceFlinger) &#123; ... sp&lt;BufferQueueCore&gt; core(new BufferQueueCore()); sp&lt;IGraphicBufferProducer&gt; producer( new BufferQueueProducer(core, consumerIsSurfaceFlinger)); ... sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core)); ... *outProducer = producer; *outConsumer = consumer;&#125; 上面代码删掉了 LOG 打印及空判断，整个代码流程非常简单： 新建 BufferQueueCore core 由 core 新建生产者 IGraphicBufferProducer 由 core 新建消费者 IGraphicBufferConsumer 也就是说 BufferQueueCore 是最终的纽带，保存了生产者消费者对应的缓存区，连接了两者的关系。 SurfaceSurface 代表着窗口，它包含一个生产者 IGraphicBufferProducer 用来填充缓存，也就是窗口中用来显示在屏幕上的内容，mSlot 数组表示可以有多个缓存区。 12345678910111213141516171819202122232425262728// Surface.hclass Surface : public ANativeObjectBase&lt;ANativeWindow, Surface, RefBase&gt;&#123;public: ... sp&lt;IGraphicBufferProducer&gt; getIGraphicBufferProducer() const; String8 getConsumerName() const; ...protected: ... struct BufferSlot &#123; sp&lt;GraphicBuffer&gt; buffer; Region dirtyRegion; &#125;; sp&lt;IGraphicBufferProducer&gt; mGraphicBufferProducer; BufferSlot mSlots[NUM_BUFFER_SLOTS]; uint32_t mReqWidth; uint32_t mReqHeight; PixelFormat mReqFormat; ... // must be used from the lock/unlock thread sp&lt;GraphicBuffer&gt; mLockedBuffer; sp&lt;GraphicBuffer&gt; mPostedBuffer; ...private: ...&#125; ISurfaceComposer/ISurfaceComposerClientISurfaceComposerClient/ISurfaceComposer 都继承了 IInterface ，它们俩分别代表 Surface 合成的客户端和服务端，具体在 SurfaceFlinger 服务进程中实现， libgui 中只对合成能力（函数）做了定义。 1234567891011121314151617181920212223242526272829303132333435363738// ISurfaceComposerClient.hclass ISurfaceComposerClient : public IInterface &#123;public: DECLARE_META_INTERFACE(SurfaceComposerClient) ... virtual status_t createSurface(const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, const sp&lt;IBinder&gt;&amp; parent, uint32_t windowType, uint32_t ownerUid, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) = 0; virtual status_t destroySurface(const sp&lt;IBinder&gt;&amp; handle) = 0; virtual status_t clearLayerFrameStats(const sp&lt;IBinder&gt;&amp; handle) const = 0; virtual status_t getLayerFrameStats(const sp&lt;IBinder&gt;&amp; handle, FrameStats* outStats) const = 0;&#125;;// ISurfaceComposer.hclass ISurfaceComposer: public IInterface &#123;public: DECLARE_META_INTERFACE(SurfaceComposer) ... virtual sp&lt;ISurfaceComposerClient&gt; createConnection() = 0; virtual sp&lt;ISurfaceComposerClient&gt; createScopedConnection( const sp&lt;IGraphicBufferProducer&gt;&amp; parent) = 0; virtual sp&lt;IDisplayEventConnection&gt; createDisplayEventConnection( VsyncSource vsyncSource = eVsyncSourceApp) = 0; virtual sp&lt;IBinder&gt; createDisplay(const String8&amp; displayName, bool secure) = 0; virtual void destroyDisplay(const sp&lt;IBinder&gt;&amp; display) = 0; ... virtual status_t captureScreen(const sp&lt;IBinder&gt;&amp; display, const sp&lt;IGraphicBufferProducer&gt;&amp; producer, Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight, int32_t minLayerZ, int32_t maxLayerZ, bool useIdentityTransform, Rotation rotation = eRotateNone) = 0;&#125; 如下是 ISurfaceComposerClient 相关的类图结构： 先看 ComposerService ，它代表着 SurfaceFlinger 服务端，头文件定义如下： 1234567891011121314151617// ComposerService.hclass ComposerService : public Singleton&lt;ComposerService&gt;&#123; sp&lt;ISurfaceComposer&gt; mComposerService; sp&lt;IBinder::DeathRecipient&gt; mDeathObserver; Mutex mLock; ComposerService(); void connectLocked(); void composerServiceDied(); friend class Singleton&lt;ComposerService&gt;;public: // Get a connection to the Composer Service. This will block until // a connection is established. static sp&lt;ISurfaceComposer&gt; getComposerService();&#125;; 查看 connectLocked, getComposerService 两个函数的实现： 1234567891011121314151617181920// SurfaceComposerClient.cppvoid ComposerService::connectLocked() &#123; const String16 name("SurfaceFlinger"); while (getService(name, &amp;mComposerService) != NO_ERROR) &#123; usleep(250000); &#125; assert(mComposerService != NULL); ...&#125;/*static*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123; ComposerService&amp; instance = ComposerService::getInstance(); Mutex::Autolock _l(instance.mLock); if (instance.mComposerService == NULL) &#123; ComposerService::getInstance().connectLocked(); assert(instance.mComposerService != NULL); ALOGD("ComposerService reconnected"); &#125; return instance.mComposerService;&#125; connectLocked 连接过程就是等待 SurfaceFlinger 服务启动后并获取它； getComposerService 直接返回已经连接成功的实例 mComposerService 。 再看 SurfaceComposerClient ，可以将它理解为应用端，是 SurfaceFlinger 服务的客户端，它将建立和 SurfaceFlinger 服务的通信，头文件定义如下： 1234567891011121314151617181920212223242526272829303132333435// SurfaceComposerClient.hclass SurfaceComposerClient : public RefBase&#123;public: // Return the connection of this client sp&lt;IBinder&gt; connection() const; ... //! Create a surface sp&lt;SurfaceControl&gt; createSurface( const String8&amp; name,// name of the surface uint32_t w, // width in pixel uint32_t h, // height in pixel PixelFormat format, // pixel-format desired uint32_t flags = 0, // usage flags SurfaceControl* parent = nullptr, // parent uint32_t windowType = 0, uint32_t ownerUid = 0 // UID of the task ); status_t destroySurface(const sp&lt;IBinder&gt;&amp; id); //! Create a virtual display static sp&lt;IBinder&gt; createDisplay(const String8&amp; displayName, bool secure); //! Destroy a virtual display static void destroyDisplay(const sp&lt;IBinder&gt;&amp; display); ...private: virtual void onFirstRef(); Composer&amp; getComposer(); ... sp&lt;ISurfaceComposerClient&gt; mClient; Composer&amp; mComposer; wp&lt;IGraphicBufferProducer&gt; mParent;&#125;; mClient 实际对应的是 SurfaceFlinger 进程中的 Client.cpp ，查看 SurfaceComposerClient::onFirstRef 源码： 123456789101112131415161718192021222324252627282930// SurfaceComposerClient.cppvoid SurfaceComposerClient::onFirstRef() &#123; sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService()); if (sm != 0) &#123; auto rootProducer = mParent.promote(); sp&lt;ISurfaceComposerClient&gt; conn; conn = (rootProducer != nullptr) ? sm-&gt;createScopedConnection(rootProducer) : sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125; &#125;&#125;// SurfaceFlinger.cppsp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createScopedConnection( const sp&lt;IGraphicBufferProducer&gt;&amp; gbp) &#123; if (authenticateSurfaceTexture(gbp) == false) &#123; return nullptr; &#125; const auto&amp; layer = (static_cast&lt;MonitoredProducer*&gt;( gbp.get()))-&gt;getLayer(); if (layer == nullptr) &#123; return nullptr; &#125; return initClient(new Client(this, layer));&#125; SurfaceComposerClient 中有一个重要功能就是创建 Surface ，对应源码： 123456789101112131415161718192021222324252627282930// SurfaceComposerClient.cppsp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, SurfaceControl* parent, uint32_t windowType, uint32_t ownerUid)&#123; sp&lt;SurfaceControl&gt; sur; if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IBinder&gt; parentHandle; sp&lt;IGraphicBufferProducer&gt; gbp; if (parent != nullptr) &#123; parentHandle = parent-&gt;getHandle(); &#125; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, windowType, ownerUid, &amp;handle, &amp;gbp); ALOGE_IF(err, "SurfaceComposerClient::createSurface error.."); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp); &#125; &#125; return sur;&#125; 最终会调用 SurfaceFlinger 中的 mClient 来创建 Layer, IGraphicBufferProducer ；而具体的 Surface 则由 SurfaceControl 来创建。 SurfaceControlSurfaceControl 持有创建的 Surface 的强引用，头文件定义： 123456789101112// SurfaceControl.hclass SurfaceControl : public RefBase&#123; ...private: ... sp&lt;SurfaceComposerClient&gt; mClient; sp&lt;IBinder&gt; mHandle; sp&lt;IGraphicBufferProducer&gt; mGraphicBufferProducer; mutable sp&lt;Surface&gt; mSurfaceData;&#125;;&#125; mHandle 指向 SurfaceFlinger 创建的 Layer 。而 SurfaceControl::createSurface 直接 new 了一个 Surface 对象。 123456789101112131415// SurfaceControl.cppsp&lt;Surface&gt; SurfaceControl::generateSurfaceLocked() const&#123; // This surface is always consumed by SurfaceFlinger, so the // producerControlledByApp value doesn't matter; using false. mSurfaceData = new Surface(mGraphicBufferProducer, false); return mSurfaceData;&#125;sp&lt;Surface&gt; SurfaceControl::createSurface() const&#123; Mutex::Autolock _l(mLock); return generateSurfaceLocked();&#125; IDisplayEventConnection 显示连接IDisplayEventConnection 继承了 IInterface ，客户端 APP 通过它向服务端 SurfaceFlinger 发送刷新请求。 123456789101112131415161718192021222324252627class IDisplayEventConnection : public IInterface &#123;public: DECLARE_META_INTERFACE(DisplayEventConnection) /* * stealReceiveChannel() returns a BitTube to receive events from. *Only the receive file descriptor of outChannel will be initialized, * and this effectively "steals" the receive channel from the remote * end (such that the remote end can only use its send channel). */ virtual status_t stealReceiveChannel(gui::BitTube* outChannel) = 0; /* * setVsyncRate() sets the vsync event delivery rate. * A value of 1 returns every vsync event. * A value of 2 returns every other event, etc. * A value of 0 returns no event unless * requestNextVsync() has been called. */ virtual status_t setVsyncRate(uint32_t count) = 0; /* * requestNextVsync() schedules the next vsync event. * It has no effect if the vsync rate is &gt; 0. */ virtual void requestNextVsync() = 0; // Asynchronous&#125;; IDisplayEventConnection 的类图结构 IDisplayEventConnection 的具体实现是在 SurfaceFlinger 进程中的 EventThread::Connection ；DisplayEventReceiver 持有该实例。 小结 libgui 中一共提供了 4 组 IInterface 接口： IGraphicBufferProducer/IProducerListener, IGraphicBufferConsumer/IConsumerListener, ISurfaceComposerClient/ISurfaceComposer, IDisplayEventConnection IGraphicBufferProducer/IProducerListener 生产者模型 IGraphicBufferConsumer/IConsumerListener 消费者模型 ISurfaceComposerClient/ISurfaceComposer 提供创建 Surface 的功能，及相关管理 IDisplayEventConnection 提供了 APP 客户端请求服务端 SurfaceFlinger 刷新的接口 SurfaceFlinger代码速查表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101surfaceflinger/├── Android.bp├── Android.mk├── Barrier.h├── Client.cpp├── Client.h├── clz.h├── Colorizer.h├── DdmConnection.cpp├── DdmConnection.h├── DisplayDevice.cpp├── DisplayDevice.h├── DisplayHardware│ ├── ComposerHal.cpp│ ├── ComposerHal.h│ ├── DisplaySurface.h│ ├── FramebufferSurface.cpp│ ├── FramebufferSurface.h│ ├── HWC2.cpp│ ├── HWC2.h│ ├── HWComposerBufferCache.cpp│ ├── HWComposerBufferCache.h│ ├── HWComposer.cpp│ ├── HWComposer.h│ ├── HWComposer_hwc1.cpp│ ├── HWComposer_hwc1.h│ ├── PowerHAL.cpp│ ├── PowerHAL.h│ ├── VirtualDisplaySurface.cpp│ └── VirtualDisplaySurface.h├── DisplayUtils.cpp├── DisplayUtils.h├── DispSync.cpp├── DispSync.h├── Effects│ ├── Daltonizer.cpp│ └── Daltonizer.h├── EventControlThread.cpp├── EventControlThread.h├── EventLog│ ├── EventLog.cpp│ ├── EventLog.h│ └── EventLogTags.logtags├── EventThread.cpp├── EventThread.h├── ExSurfaceFlinger│ ├── ExLayer.cpp│ ├── ExLayer.h│ ├── ExSurfaceFlinger.cpp│ ├── ExSurfaceFlinger.h│ ├── ExVirtualDisplaySurface.cpp│ └── ExVirtualDisplaySurface.h├── FrameTracker.cpp├── FrameTracker.h├── GpuService.cpp├── GpuService.h├── Layer.cpp├── LayerDim.cpp├── LayerDim.h├── Layer.h├── LayerRejecter.cpp├── LayerRejecter.h├── LayerVector.cpp├── LayerVector.h├── main_surfaceflinger.cpp├── MessageQueue.cpp├── MessageQueue.h├── MODULE_LICENSE_APACHE2├── MonitoredProducer.cpp├── MonitoredProducer.h├── RenderEngine│ ├── Description.cpp│ ├── Description.h│ ├── GLES20RenderEngine.cpp│ ├── GLES20RenderEngine.h│ ├── GLExtensions.cpp│ ├── GLExtensions.h│ ├── Mesh.cpp│ ├── Mesh.h│ ├── ProgramCache.cpp│ ├── ProgramCache.h│ ├── Program.cpp│ ├── Program.h│ ├── RenderEngine.cpp│ ├── RenderEngine.h│ ├── Texture.cpp│ └── Texture.h├── StartPropertySetThread.cpp├── StartPropertySetThread.h├── SurfaceFlingerConsumer.cpp├── SurfaceFlingerConsumer.h├── SurfaceFlinger.cpp├── SurfaceFlinger.h├── SurfaceFlinger_hwc1.cpp├── surfaceflinger.rc├── SurfaceInterceptor.cpp├── SurfaceInterceptor.h├── Transform.cpp└── Transform.h9 directories, 117 files surfaceflinger 进程SurfaceFlinger 是以独立进程运行的，进程名为 surfaceflinger ，对应的 rc 文件如下： 12345678910// surfaceflinger.rcservice surfaceflinger /system/bin/surfaceflinger class core animation user system group graphics drmrpc readproc onrestart restart zygote writepid /dev/stune/foreground/tasks socket pdx/system/vr/display/client stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0 socket pdx/system/vr/display/manager stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0 socket pdx/system/vr/display/vsync stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0 surfaceflinger 服务属于核心类 core，当 surfaceflinger 重启时会触发 zygote 的重启。接下来看进程 main 方法对应文件为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// main_surfaceflinger.cppint main(int, char**) &#123; // 启动 IAllocator, DisplayService 两个服务 startHidlServices(); signal(SIGPIPE, SIG_IGN); ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4); sp&lt;ProcessState&gt; ps(ProcessState::self()); ps-&gt;startThreadPool(); // 1. new SurfaceFlinger 实例 sp&lt;SurfaceFlinger&gt; flinger = DisplayUtils::getInstance()-&gt;getSFInstance(); setpriority(PRIO_PROCESS, 0, PRIORITY_URGENT_DISPLAY); set_sched_policy(0, SP_FOREGROUND); if (cpusets_enabled()) set_cpuset_policy(0, SP_SYSTEM); // 2. SurfaceFlinger 初始化 flinger-&gt;init(); // 3. 发布 SurfaceFlinger, GpuService 两个服务 // publish surface flinger sp&lt;IServiceManager&gt; sm(defaultServiceManager()); sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, false); // publish GpuService sp&lt;GpuService&gt; gpuservice = new GpuService(); sm-&gt;addService(String16(GpuService::SERVICE_NAME),gpuservice,false); struct sched_param param = &#123;0&#125;; param.sched_priority = 2; if (sched_setscheduler(0, SCHED_FIFO, &amp;param) != 0) &#123; ALOGE(&quot;Couldn&apos;t set SCHED_FIFO&quot;); &#125; // run surface flinger in this thread // 4. SurfaceFlinger 无限循环等待事件 flinger-&gt;run(); return 0;&#125; surfaceflinger 进程的 main 函数中主要做了 4 件事： 通过 DisplayUtils 创建 SurfaceFlinger 对象 SurfaceFlinger 对象调用 init 方法，实现初始化 SurfaceFlinger 向系统注册 Binder 服务 SurfaceFlinger 对象调用 run 方法，该方法是一个 do-while 无限循环 初始化流程SurfaceFlinger 初始化流程，查看大图 DisplayDevice 显示设备1234567891011121314// DisplayDevice.hclass DisplayDevice : public LightRefBase&lt;DisplayDevice&gt;&#123;public: ... enum DisplayType &#123; DISPLAY_ID_INVALID = -1, DISPLAY_PRIMARY = HWC_DISPLAY_PRIMARY, // 主显 DISPLAY_EXTERNAL = HWC_DISPLAY_EXTERNAL, // 外显 DISPLAY_VIRTUAL = HWC_DISPLAY_VIRTUAL, // 虚显 NUM_BUILTIN_DISPLAY_TYPES = HWC_NUM_PHYSICAL_DISPLAY_TYPES, &#125;; ...&#125; 显示设备有三种类型：主显、外显、虚显；每添加一个显示屏，都会创建一个 DisplayDevice 。 Layer 层Layer 是 SurfaceFlinger 进行合成的基本操作单元。Layer 在应用请求创建 Surface 的时候在 SurfaceFlinger 内部创建，因此一个 Surface 对应一个 Layer 。每个 Layer 包含常见属性： Z order Alpha value from 0 to 255 visibleRegion crop region transformation: rotate 0, 90, 180, 270: flip H, V: scale 当多个 Layer 进行合成的时候，并不是整个 Layer 的空间都会被完全显示，根据这个 Layer 最终的显示效果，一个 Layer 可以被划分成很多的 Region ， 在 SurfaceFlinger 中定义了以下几种类型： TransparantRegion ：完全透明的区域，在它之下的区域将被显示出来 OpaqueRegion ：完全不透明的区域，是否显示取决于它上面是否有遮挡或是否透明 VisibleRegion ：可见区域，包括完全不透明无遮挡区域或半透明区域；即 visibleRegion = Region - above OpaqueRegion. CoveredRegion ：被遮挡区域，在它之上，有不透明或半透明区域 DirtyRegion ：可见部分改变区域，包括新的被遮挡区域，和新的露出区域 头文件定义： 123456789101112131415161718192021222324252627282930313233343536373839404142// Layer.hclass Layer : public SurfaceFlingerConsumer::ContentsChangedListener &#123;public: ... // regions below are in window-manager space Region visibleRegion; Region coveredRegion; Region visibleNonTransparentRegion; Region surfaceDamageRegion; // Layer serial number. This gives layers an explicit ordering, so we // have a stable sort order when their layer stack and Z-order are // the same. int32_t sequence; ...private: ... // constants sp&lt;SurfaceFlingerConsumer&gt; mSurfaceFlingerConsumer; sp&lt;IGraphicBufferProducer&gt; mProducer; uint32_t mTextureName; // from GLES bool mPremultipliedAlpha; String8 mName; String8 mTransactionName; // A cached version of "TX - " + mName for systraces PixelFormat mFormat; ... FenceTimeline mAcquireTimeline; FenceTimeline mReleaseTimeline; ... // The mesh used to draw the layer in GLES composition mode mutable Mesh mMesh; // The texture used to draw the layer in GLES composition mode mutable Texture mTexture; Vector&lt;BufferItem&gt; mQueueItems; // Child list about to be committed/used for editing. LayerVector mCurrentChildren; // Child list used for rendering. LayerVector mDrawingChildren; wp&lt;Layer&gt; mCurrentParent; wp&lt;Layer&gt; mDrawingParent;&#125; SurfaceFlinger 接收所有 Surface 作为输入，根据 Z-Order， 透明度，大小，位置等参数，计算出每个 Surface 在最终合成图像中的位置，然后交由 HWComposer, OpenGL 生成最终的显示 Buffer , 然后显示到特定的显示设备上。Layer 的合成分为两种，离线合成和在线合成： 离线合成先将所有图层画到一个最终层 FrameBuffer 上，再将 FrameBuffer 送到 LCD 显示。由于合成 FrameBuffer 与送 LCD 显示一般是异步的（线下生成 FrameBuffer ，需要时线上的 LCD 去取），因此叫离线合成。 在线合成不使用 FrameBuffer ，在 LCD 需要显示某一行的像素时，用显示控制器将所有图层与该行相关的数据取出，合成一行像素送过去。只有一个图层时，又叫 Overlay 技术。由于省去合成 FrameBuffer 时读图层，写 FrameBuffer 的步骤，大幅降低了内存传输量，减少了功耗，但这个需要硬件支持。 Surface 创建流程图由客户端 SurfaceComposerClient 发起创建流程，然后由服务端 SurfaceFlinger 创建对应的 Layer ，而 Layer 在被引用时会创建生产者消费者模型的 BufferQueue ，然后再由客户端将拿到的结果传入 SurfaceControl ，最后直接实例化一个 Surface 。 创建生产者消费者模型 BufferQueue 的关键代码： 1234567891011121314151617181920// Layer.cppvoid Layer::onFirstRef() &#123; // Creates a custom BufferQueue for SurfaceFlingerConsumer to use sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferConsumer&gt; consumer; BufferQueue::createBufferQueue(&amp;producer, &amp;consumer, true); mProducer = new MonitoredProducer(producer, mFlinger, this); mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this); mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0)); mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this); mSurfaceFlingerConsumer-&gt;setName(mName); if (mFlinger-&gt;isLayerTripleBufferingDisabled()) &#123; mProducer-&gt;setMaxDequeuedBufferCount(2); &#125; const sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice()); updateTransformHint(hw);&#125; 创建 Surface 流程，查看大图 VSYNC 垂直刷新Android 中有 2 种 VSync 信号：屏幕产生的硬件 VSync 和由 SurfaceFlinger 将其转成的软件 Vsync 信号；软件 Vsync 后者经由 Binder 传递给 Choreographer 。Vsync 信号可将某些事件同步到显示设备的刷新周期。应用总是在 VSYNC 边界上开始绘制，而 SurfaceFlinger 总是在 VSYNC 边界上进行合成。这样可以消除卡顿，并提升图形的视觉表现。 HWComposer 对象创建过程，会注册一些回调方法；当硬件产生 VSYNC 信号时，则会回调 HWC2::ComposerCallbackBridge::onVsync 方法，然后逐级回调，下图是整个回调流程图： 硬件 Vsync 信号发送过来，一路执行到 DispSyncThread.updateModel 方法中调用 mCond.signal ，唤醒 DispSyncThread 线程 DispSyncThread 线程中执行 EventThread::onVSyncEvent 中调用 mCondition.broadcast 唤醒 EventThread 线程 EventThread 线程中执行 DisplayEventReceiver::sendEvents 方法，会调用 BitTube::sendObjects ；在 MessageQueue::setEventThread 中，我们设置了 BitTube 事件的回调，当收到数据会触发 MQ.cb_eventReceiver ；根据 Handler 消息机制，进入 SurfaceFlinger 主线程 SurfaceFlinger 主线程进入到 MesageQueue的handleMessage ，最终调用 SurfaceFlinger::handleMessageRefresh 客户端通知 SurfaceFlinger 刷新BufferQueueProducer::queueBuffer 函数中会调用 listener-&gt;onFrameAvailable ，而这最终会触发服务端的 Layer::onFrameAvailable ，从而通知 SurfaceFlinger 合成图像。我们先看 onFrameAvailable 接口的继承关系： 从 Surface 创建流程中贴出的 Layer::onFirstRef 代码中可以看到，在 Layer 中设置了 mSurfaceFlingerConsumer-&gt;setContentsChangedListener 监听事件，所以 BufferQueueProducer::queueBuffer 会触发 Layer::onFrameAvailable 事件，下面是完整的请求流程。客户端在 BufferQueue 中生产完图像数据后，通知 SurfaceFlinger 刷新界面的流程图： 客户端通知 SurfaceFlinger 刷新，查看大图 后续 WMS Layer 合成流程 结合 Camera 熟悉图形显示中 Buffer 相关流程 Choreographer 及掉帧分析 Choreographer 简析 详述 SurfaceTexture, SurfaceView, GLSurfaceView 等区别 工具 dumpsys SurfaceFlinger 输出的 LOG 分析 screencap 命令及源码分析 Systrace 性能工具分析 Systrace 官网 参考文档 Android 图形显示-官网 Android中native_handle private_handle_t 的关系 夕阳风-图形显示系列文章 SurfaceFlinger 系列 理解 VSYNC dp, dpi, px, density 的关系 gityuan: SurfaceFlinger 相关 阿拉神农：深入理解Surface系统 图解 Surface, SurfaceFlinger 关系 Google Grafika 图形引擎的核心 - BufferQueue surfaceflinger框架-流程图大全 BufferQueue介绍 GraphicBuffer同步机制-Fence]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android JNI]]></title>
    <url>%2F2019%2F04%2F10%2F0112-android-jni%2F</url>
    <content type="text"><![CDATA[本文是在针对 Android 平台中使用 JNI 的分析。 基础JNI:Java Native Interface 是 Java 本地开发接口，JNI 是一个协议，这个协议用来沟通 Java 代码和外部的本地代码 C/C++ ，确保 Java 和 C/C++ 代码之间能相互调用。 类型与数据结构基本数据类型Java 基本数据类型在 JNI 中的对应关系： Java 类型 Native 类型 描述 boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar unsigned 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void not applicable jni.h 中基本类型对应源码： 12345678910111213141516// jni.h/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* "cardinal indices and sizes" */typedef jint jsize;#define JNI_FALSE 0#define JNI_TRUE 1 引用类型Java 中的引用类型 Object 对应 JNI 中的 jobject ，代表一切引用类型。在 C++ 中通过类继承的方式体现层级，在 C 中都是无类型指针 void* ；先看对应关系： Java 类型 Native 类型 描述 Object jobject 所有的 Java 对象 Class jclass Class 对象 Throwable jthrowable 可抛出类型对象 String jstring 字符串 Object[] jarray 数组 boolean[] jbooleanArray 布尔数组 byte[] jbyteArray 字节数组 char[] jcharArray 字符数组 short[] jshortArray 短整型数组 int[] jintArray 整形数组 long[] jlongArray 长整型数组 float[] jfloatArray 浮点数组 double[] jdoubleArray 双浮点数组 jni.h 中引用类型对应的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#ifdef __cplusplus/* * Reference types, in C++ */class _jobject &#123;&#125;;class _jclass : public _jobject &#123;&#125;;class _jstring : public _jobject &#123;&#125;;class _jarray : public _jobject &#123;&#125;;class _jobjectArray : public _jarray &#123;&#125;;class _jbooleanArray : public _jarray &#123;&#125;;class _jbyteArray : public _jarray &#123;&#125;;class _jcharArray : public _jarray &#123;&#125;;class _jshortArray : public _jarray &#123;&#125;;class _jintArray : public _jarray &#123;&#125;;class _jlongArray : public _jarray &#123;&#125;;class _jfloatArray : public _jarray &#123;&#125;;class _jdoubleArray : public _jarray &#123;&#125;;class _jthrowable : public _jobject &#123;&#125;;typedef _jobject* jobject;typedef _jclass* jclass;typedef _jstring* jstring;typedef _jarray* jarray;typedef _jobjectArray* jobjectArray;typedef _jbooleanArray* jbooleanArray;typedef _jbyteArray* jbyteArray;typedef _jcharArray* jcharArray;typedef _jshortArray* jshortArray;typedef _jintArray* jintArray;typedef _jlongArray* jlongArray;typedef _jfloatArray* jfloatArray;typedef _jdoubleArray* jdoubleArray;typedef _jthrowable* jthrowable;typedef _jobject* jweak;#else /* not __cplusplus *//* * Reference types, in C. */typedef void* jobject;typedef jobject jclass;typedef jobject jstring;typedef jobject jarray;typedef jarray jobjectArray;typedef jarray jbooleanArray;typedef jarray jbyteArray;typedef jarray jcharArray;typedef jarray jshortArray;typedef jarray jintArray;typedef jarray jlongArray;typedef jarray jfloatArray;typedef jarray jdoubleArray;typedef jobject jthrowable;typedef jobject jweak;#endif /* not __cplusplus */ 属性和方法Java 中的属性和方法，在反射时会用到，在 JNI 中由对应类型： 12345struct _jfieldID; /* opaque structure */typedef struct _jfieldID* jfieldID; /* field IDs */struct _jmethodID; /* opaque structure */typedef struct _jmethodID* jmethodID; /* method IDs */ 这里并没有给出 _jfieldID, _jmethodID 两个结构体的详细定义，但是可以用 jfieldID, jmethodID 两个结构体指针来表示 Java 类的属性和方法。 可变参数列表Java 方法中的可变参数列表比如 void set(String... params) ，不定长度的参数可以看做一个数组；在 JNI 中使用 jvalue 来表示，它是一个联合体，通常在 C/C++ 调用 Java 时会用到： 1234567891011typedef union jvalue &#123; jboolean z; jbyte b; jchar c; jshort s; jint i; jlong j; jfloat f; jdouble d; jobject l;&#125; jvalue; 类型签名 Type SignaturesJNI 中使用 Java VM 虚拟机的类型签名格式来表示： 类型签名 Java 类型 Z boolean B byte C char S short I int J long F float D double L fully-qualified-class ; fully-qualified-class [ type type[] ( arg-types ) ret-type method type 这个表格包含如下几个部分： 基本类型基本类型都使用单个字符来表示签名，如 int a ，签名为 I 。 类全限定名类都使用全限定名，并以 L 开头，; 分号结尾，比如 String 的全限定名为： Ljava/lang/String; 。 数组数组必须以 [ 开头，比如 int[] 表示为：[I 。 方法描述符先写参数再写返回值，比如方法 long f (int n, String s, int[] arr); 表示为 (ILjava/lang/String;[I)J 。 字符串编码Unicode 编码字符串常见的编码有 ASCII 和 Unicode ；其中 ASCII 只能表示 128 种符号，对于英文完全够用了，但是对于中文、俄文、阿拉伯文等远远不够，于是新定义了通用型 Unicode 方案，它使用 21 位来编码，表示范围为 U+0000 ~ U+10FFFF 接近几百万个字符，其中 U+D800 ~ U+DFFF 之间为保留码位。ASCII 只需要 8 位就能全部表示完，但是 Unicode 编码方案，并没有规定如何存储，因此实现 Unicode 的存储出现了不同的 UTF: Unicode Transformation Format 编码方案：UTF-8, UTF-16, UTF-32 。其中 UTF-8, UTF-16 是变长编码，而 UTF-32 是 32 bit 定长编码。 UTF-8UTF-8: 8-bit Unicode Transformation Format 变长编码，每个 Unicode 字符被编码为 1-4 个字节，对应关系如下： Unicode 编码 UTF-8 编码 U+0000 ~ U+007F 0xxxxxxx U+0080 ~ U+07FF 110xxxxx 10xxxxxx U+0800 ~ U+FFFF 1110xxxx 10xxxxxx 10xxxxxx U+10000 ~ U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 也就是最高字节有几个 1 即表示当前 Unicode 字符占几个字节；所以英文字符只需要 1 个字节，绝大部分中文需要 3 个字节，少数可能会使用 4 个字节。 Unicode 码 对应字符 UTF-8 编码 U+0041 A 0x41 U+7834 破 0xE7 0xA0 0xB4 U+6653 晓 0xE6 0x99 0x93 U+2A6A5 𪚥(四个龍) 0xF0 0xAA 0x9A 0xA5 从实际的结果上看，UTF-8 编码只有在单字节内的 Unicode 码和对应的 UTF-8 编码相同；多字节的 UTF-8 编码已经看不出对应的 Unicode 码了。 UTF-16UTF-16: 16-bit Unicode Transformation Format 变长编码，每个 Unicode 字符被编码为 2 个或者 4 个字节；即码位范围 U+0000 ~ U+FFFF 使用 2 字节，而 U+10000 ~U+10FFFF 使用 4 字节。 码位范围 U+0000 ~ U+FFFF ，以中文为例，相当于能表示 65536 个常用汉字，因为使用的是 2 字节，所以这个范围内的 UTF-16 编码和 Unicode 码完全一样： Unicode 字符 UTF-16 码元 UTF-16 LE 小端 UTF-16 BE 大端 U+0041 A 0x0041 0x41 0x00 0x00 0x41 U+7834 破 0x7834 0x34 0x78 0x78 0x34 U+6653 晓 0x6653 0x53 0x66 0x66 0x53 码位范围 U+10000 ~U+10FFFF ，并不是直接使用 4 字节存储的，而是使用的代理码，即先将码表减去 0x10000 再针对高低 10 位分别与前导码做或运算后再存储的，这里不做详细分析。 修改后的 UTF-8 编码JVM 中字符串使用的是修改后的 UTF-8 编码方案，即 Modified UTF-8 ，它实际是 UTF-8 和 UTF-16 的一个混合体： Unicode 编码 Modified UTF-8 编码 U+0000 ~ U+007F 0xxxxxxx U+0080 ~ U+07FF 110xxxxx 10xxxxxx U+0800 ~ U+FFFF 1110xxxx 10xxxxxx 10xxxxxx U+10000 ~ U+10FFFF 11101101 1010vvvv 10wwwwww 11101101 1011yyyy 10zzzzzz 修改后的 UTF-8 只使用 1 字节、 2 字节、 3 字节和 6 字节四种方式来存储，其中码位范围 U+10000 ~U+10FFFF 的第 1 和 4 字节都是固定的 11101101 ，另外 4 个字节使用的是 UTF-16 的代理码，高 10 位放入第 2 和第 3 字节，低 10 位放入第 5 和第 6 字节。JNI 中的字符串也采用的是这种修改后的 UTF-8 编码。 JNI 接口指针基本概念JNI 的设计架构如下图所示： JNI 接口指针指向函数表，包含当前线程的所有信息，而这个接口指针在 JNI 中，使用 JNIEnv 来表示；每个线程对应一个 JNIEnv 结构，它们保存在线程本地存储 TLS 中；因此不同的线程的 JNIEnv 是不同，也不能相互共享使用。JavaVM 是虚拟机在 JNI 层的代表，一个进程只有一个 JavaVM，所有的线程共用一个 JavaVM ，所以一个 JavaVM 中可以有多个 JNIEnv 。 12345678910111213// jni.hstruct JNIInvokeInterface;struct _JNIEnv;struct _JavaVM;typedef const struct JNINativeInterface* C_JNIEnv;#if defined(__cplusplus)typedef _JNIEnv JNIEnv;typedef _JavaVM JavaVM;#elsetypedef const struct JNINativeInterface* JNIEnv;typedef const struct JNIInvokeInterface* JavaVM;#endif JavaVM 源码JavaVM 代表的是虚拟机相关信息，源码中 JavaVM 实际就是 JNIInvokeInterface 指针，在 C++ 中，_JavaVM 是 JNIInvokeInterface 的包装类。 1234567891011121314151617181920212223242526272829303132333435// jni.h/* * JNI invocation interface. */struct JNIInvokeInterface &#123; void* reserved0; void* reserved1; void* reserved2; jint (*DestroyJavaVM)(JavaVM*); jint (*AttachCurrentThread)(JavaVM*, JNIEnv**, void*); jint (*DetachCurrentThread)(JavaVM*); jint (*GetEnv)(JavaVM*, void**, jint); jint (*AttachCurrentThreadAsDaemon)(JavaVM*, JNIEnv**, void*);&#125;;/* * C++ version. */struct _JavaVM &#123; const struct JNIInvokeInterface* functions;#if defined(__cplusplus) jint DestroyJavaVM() &#123; return functions-&gt;DestroyJavaVM(this); &#125; jint AttachCurrentThread(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThread(this, p_env, thr_args); &#125; jint DetachCurrentThread() &#123; return functions-&gt;DetachCurrentThread(this); &#125; jint GetEnv(void** env, jint version) &#123; return functions-&gt;GetEnv(this, env, version); &#125; jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args) &#123; return functions-&gt;AttachCurrentThreadAsDaemon(this, p_env, thr_args); &#125;#endif /*__cplusplus*/&#125;; JNIEnv 源码JNIEnv 代表了当前线程的函数表，几乎包含了所有的 JNI 函数，它是线程隔离 TLS 的，所以不能在线程间共享。JNIEnv 主要用于操作 Java 对象的类、方法、属性等，可以理解为反射的 C/C++ 实现。JNIEnv 实际是 JNINativeInterface 结构指针，在 C++ 中，_JNIEnv 是 JNINativeInterface 的包装类。所以它们的调用有两种风格： C 风格：(*env)-&gt;NewStringUTF(env, “Hellow World!”); C++ 风格： env-&gt;NewStringUTF(“Hellow World!”); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356struct JNINativeInterface &#123; void* reserved0; void* reserved1; void* reserved2; void* reserved3; jint (*GetVersion)(JNIEnv *); // 类反射 jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, jsize); jclass (*FindClass)(JNIEnv*, const char*); jmethodID (*FromReflectedMethod)(JNIEnv*, jobject); jfieldID (*FromReflectedField)(JNIEnv*, jobject); /* spec doesn't show jboolean parameter */ jobject (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean); jclass (*GetSuperclass)(JNIEnv*, jclass); jboolean (*IsAssignableFrom)(JNIEnv*, jclass, jclass); /* spec doesn't show jboolean parameter */ jobject (*ToReflectedField)(JNIEnv*, jclass, jfieldID, jboolean); jint (*Throw)(JNIEnv*, jthrowable); jint (*ThrowNew)(JNIEnv *, jclass, const char *); jthrowable (*ExceptionOccurred)(JNIEnv*); void (*ExceptionDescribe)(JNIEnv*); void (*ExceptionClear)(JNIEnv*); void (*FatalError)(JNIEnv*, const char*); jint (*PushLocalFrame)(JNIEnv*, jint); jobject (*PopLocalFrame)(JNIEnv*, jobject); jobject (*NewGlobalRef)(JNIEnv*, jobject); void (*DeleteGlobalRef)(JNIEnv*, jobject); void (*DeleteLocalRef)(JNIEnv*, jobject); jboolean (*IsSameObject)(JNIEnv*, jobject, jobject); jobject (*NewLocalRef)(JNIEnv*, jobject); jint (*EnsureLocalCapacity)(JNIEnv*, jint); jobject (*AllocObject)(JNIEnv*, jclass); jobject (*NewObject)(JNIEnv*, jclass, jmethodID, ...); jobject (*NewObjectV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*NewObjectA)(JNIEnv*, jclass, jmethodID, const jvalue*); jclass (*GetObjectClass)(JNIEnv*, jobject); jboolean (*IsInstanceOf)(JNIEnv*, jobject, jclass); // 获取方法的 ID jmethodID (*GetMethodID)(JNIEnv*, jclass, const char*, const char*); jobject (*CallObjectMethod)(JNIEnv*, jobject, jmethodID, ...); jobject (*CallObjectMethodV)(JNIEnv*, jobject, jmethodID, va_list); jobject (*CallObjectMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jboolean (*CallBooleanMethod)(JNIEnv*, jobject, jmethodID, ...); jboolean (*CallBooleanMethodV)(JNIEnv*, jobject, jmethodID, va_list); jboolean (*CallBooleanMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jbyte (*CallByteMethod)(JNIEnv*, jobject, jmethodID, ...); jbyte (*CallByteMethodV)(JNIEnv*, jobject, jmethodID, va_list); jbyte (*CallByteMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jchar (*CallCharMethod)(JNIEnv*, jobject, jmethodID, ...); jchar (*CallCharMethodV)(JNIEnv*, jobject, jmethodID, va_list); jchar (*CallCharMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jshort (*CallShortMethod)(JNIEnv*, jobject, jmethodID, ...); jshort (*CallShortMethodV)(JNIEnv*, jobject, jmethodID, va_list); jshort (*CallShortMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jint (*CallIntMethod)(JNIEnv*, jobject, jmethodID, ...); jint (*CallIntMethodV)(JNIEnv*, jobject, jmethodID, va_list); jint (*CallIntMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jlong (*CallLongMethod)(JNIEnv*, jobject, jmethodID, ...); jlong (*CallLongMethodV)(JNIEnv*, jobject, jmethodID, va_list); jlong (*CallLongMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jfloat (*CallFloatMethod)(JNIEnv*, jobject, jmethodID, ...); jfloat (*CallFloatMethodV)(JNIEnv*, jobject, jmethodID, va_list); jfloat (*CallFloatMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jdouble (*CallDoubleMethod)(JNIEnv*, jobject, jmethodID, ...); jdouble (*CallDoubleMethodV)(JNIEnv*, jobject, jmethodID, va_list); jdouble (*CallDoubleMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); void (*CallVoidMethod)(JNIEnv*, jobject, jmethodID, ...); void (*CallVoidMethodV)(JNIEnv*, jobject, jmethodID, va_list); void (*CallVoidMethodA)(JNIEnv*, jobject, jmethodID, const jvalue*); jobject (*CallNonvirtualObjectMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jobject (*CallNonvirtualObjectMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jobject (*CallNonvirtualObjectMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jboolean (*CallNonvirtualBooleanMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jbyte (*CallNonvirtualByteMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jbyte (*CallNonvirtualByteMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jbyte (*CallNonvirtualByteMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jchar (*CallNonvirtualCharMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jchar (*CallNonvirtualCharMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jchar (*CallNonvirtualCharMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jshort (*CallNonvirtualShortMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jshort (*CallNonvirtualShortMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jshort (*CallNonvirtualShortMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jint (*CallNonvirtualIntMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jint (*CallNonvirtualIntMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jint (*CallNonvirtualIntMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jlong (*CallNonvirtualLongMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jlong (*CallNonvirtualLongMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jlong (*CallNonvirtualLongMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jfloat (*CallNonvirtualFloatMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jfloat (*CallNonvirtualFloatMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jfloat (*CallNonvirtualFloatMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); jdouble (*CallNonvirtualDoubleMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); void (*CallNonvirtualVoidMethod)(JNIEnv*, jobject, jclass, jmethodID, ...); void (*CallNonvirtualVoidMethodV)(JNIEnv*, jobject, jclass, jmethodID, va_list); void (*CallNonvirtualVoidMethodA)(JNIEnv*, jobject, jclass, jmethodID, const jvalue*); // 获取属性字段的 ID jfieldID (*GetFieldID)(JNIEnv*, jclass, const char*, const char*); jobject (*GetObjectField)(JNIEnv*, jobject, jfieldID); jboolean (*GetBooleanField)(JNIEnv*, jobject, jfieldID); jbyte (*GetByteField)(JNIEnv*, jobject, jfieldID); jchar (*GetCharField)(JNIEnv*, jobject, jfieldID); jshort (*GetShortField)(JNIEnv*, jobject, jfieldID); jint (*GetIntField)(JNIEnv*, jobject, jfieldID); jlong (*GetLongField)(JNIEnv*, jobject, jfieldID); jfloat (*GetFloatField)(JNIEnv*, jobject, jfieldID); jdouble (*GetDoubleField)(JNIEnv*, jobject, jfieldID); void (*SetObjectField)(JNIEnv*, jobject, jfieldID, jobject); void (*SetBooleanField)(JNIEnv*, jobject, jfieldID, jboolean); void (*SetByteField)(JNIEnv*, jobject, jfieldID, jbyte); void (*SetCharField)(JNIEnv*, jobject, jfieldID, jchar); void (*SetShortField)(JNIEnv*, jobject, jfieldID, jshort); void (*SetIntField)(JNIEnv*, jobject, jfieldID, jint); void (*SetLongField)(JNIEnv*, jobject, jfieldID, jlong); void (*SetFloatField)(JNIEnv*, jobject, jfieldID, jfloat); void (*SetDoubleField)(JNIEnv*, jobject, jfieldID, jdouble); jmethodID (*GetStaticMethodID)(JNIEnv*, jclass, const char*, const char*); jobject (*CallStaticObjectMethod)(JNIEnv*, jclass, jmethodID, ...); jobject (*CallStaticObjectMethodV)(JNIEnv*, jclass, jmethodID, va_list); jobject (*CallStaticObjectMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jboolean (*CallStaticBooleanMethod)(JNIEnv*, jclass, jmethodID, ...); jboolean (*CallStaticBooleanMethodV)(JNIEnv*, jclass, jmethodID, va_list); jboolean (*CallStaticBooleanMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jbyte (*CallStaticByteMethod)(JNIEnv*, jclass, jmethodID, ...); jbyte (*CallStaticByteMethodV)(JNIEnv*, jclass, jmethodID, va_list); jbyte (*CallStaticByteMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jchar (*CallStaticCharMethod)(JNIEnv*, jclass, jmethodID, ...); jchar (*CallStaticCharMethodV)(JNIEnv*, jclass, jmethodID, va_list); jchar (*CallStaticCharMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jshort (*CallStaticShortMethod)(JNIEnv*, jclass, jmethodID, ...); jshort (*CallStaticShortMethodV)(JNIEnv*, jclass, jmethodID, va_list); jshort (*CallStaticShortMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jint (*CallStaticIntMethod)(JNIEnv*, jclass, jmethodID, ...); jint (*CallStaticIntMethodV)(JNIEnv*, jclass, jmethodID, va_list); jint (*CallStaticIntMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jlong (*CallStaticLongMethod)(JNIEnv*, jclass, jmethodID, ...); jlong (*CallStaticLongMethodV)(JNIEnv*, jclass, jmethodID, va_list); jlong (*CallStaticLongMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jfloat (*CallStaticFloatMethod)(JNIEnv*, jclass, jmethodID, ...); jfloat (*CallStaticFloatMethodV)(JNIEnv*, jclass, jmethodID, va_list); jfloat (*CallStaticFloatMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jdouble (*CallStaticDoubleMethod)(JNIEnv*, jclass, jmethodID, ...); jdouble (*CallStaticDoubleMethodV)(JNIEnv*, jclass, jmethodID, va_list); jdouble (*CallStaticDoubleMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); void (*CallStaticVoidMethod)(JNIEnv*, jclass, jmethodID, ...); void (*CallStaticVoidMethodV)(JNIEnv*, jclass, jmethodID, va_list); void (*CallStaticVoidMethodA)(JNIEnv*, jclass, jmethodID, const jvalue*); jfieldID (*GetStaticFieldID)(JNIEnv*, jclass, const char*, const char*); jobject (*GetStaticObjectField)(JNIEnv*, jclass, jfieldID); jboolean (*GetStaticBooleanField)(JNIEnv*, jclass, jfieldID); jbyte (*GetStaticByteField)(JNIEnv*, jclass, jfieldID); jchar (*GetStaticCharField)(JNIEnv*, jclass, jfieldID); jshort (*GetStaticShortField)(JNIEnv*, jclass, jfieldID); jint (*GetStaticIntField)(JNIEnv*, jclass, jfieldID); jlong (*GetStaticLongField)(JNIEnv*, jclass, jfieldID); jfloat (*GetStaticFloatField)(JNIEnv*, jclass, jfieldID); jdouble (*GetStaticDoubleField)(JNIEnv*, jclass, jfieldID); void (*SetStaticObjectField)(JNIEnv*, jclass, jfieldID, jobject); void (*SetStaticBooleanField)(JNIEnv*, jclass, jfieldID, jboolean); void (*SetStaticByteField)(JNIEnv*, jclass, jfieldID, jbyte); void (*SetStaticCharField)(JNIEnv*, jclass, jfieldID, jchar); void (*SetStaticShortField)(JNIEnv*, jclass, jfieldID, jshort); void (*SetStaticIntField)(JNIEnv*, jclass, jfieldID, jint); void (*SetStaticLongField)(JNIEnv*, jclass, jfieldID, jlong); void (*SetStaticFloatField)(JNIEnv*, jclass, jfieldID, jfloat); void (*SetStaticDoubleField)(JNIEnv*, jclass, jfieldID, jdouble); jstring (*NewString)(JNIEnv*, const jchar*, jsize); jsize (*GetStringLength)(JNIEnv*, jstring); const jchar* (*GetStringChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*); jstring (*NewStringUTF)(JNIEnv*, const char*); jsize (*GetStringUTFLength)(JNIEnv*, jstring); /* JNI spec says this returns const jbyte*, but that's inconsistent */ const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*); jsize (*GetArrayLength)(JNIEnv*, jarray); jobjectArray (*NewObjectArray)(JNIEnv*, jsize, jclass, jobject); jobject (*GetObjectArrayElement)(JNIEnv*, jobjectArray, jsize); void (*SetObjectArrayElement)(JNIEnv*, jobjectArray, jsize, jobject); // 新建基本类型数组 jbooleanArray (*NewBooleanArray)(JNIEnv*, jsize); jbyteArray (*NewByteArray)(JNIEnv*, jsize); jcharArray (*NewCharArray)(JNIEnv*, jsize); jshortArray (*NewShortArray)(JNIEnv*, jsize); jintArray (*NewIntArray)(JNIEnv*, jsize); jlongArray (*NewLongArray)(JNIEnv*, jsize); jfloatArray (*NewFloatArray)(JNIEnv*, jsize); jdoubleArray (*NewDoubleArray)(JNIEnv*, jsize); // 获取基本类型数组中的元素，返回对应指针类型（表示一个数组） jboolean* (*GetBooleanArrayElements)(JNIEnv*, jbooleanArray, jboolean*); jbyte* (*GetByteArrayElements)(JNIEnv*, jbyteArray, jboolean*); jchar* (*GetCharArrayElements)(JNIEnv*, jcharArray, jboolean*); jshort* (*GetShortArrayElements)(JNIEnv*, jshortArray, jboolean*); jint* (*GetIntArrayElements)(JNIEnv*, jintArray, jboolean*); jlong* (*GetLongArrayElements)(JNIEnv*, jlongArray, jboolean*); jfloat* (*GetFloatArrayElements)(JNIEnv*, jfloatArray, jboolean*); jdouble* (*GetDoubleArrayElements)(JNIEnv*, jdoubleArray, jboolean*); void (*ReleaseBooleanArrayElements)(JNIEnv*, jbooleanArray, jboolean*, jint); void (*ReleaseByteArrayElements)(JNIEnv*, jbyteArray, jbyte*, jint); void (*ReleaseCharArrayElements)(JNIEnv*, jcharArray, jchar*, jint); void (*ReleaseShortArrayElements)(JNIEnv*, jshortArray, jshort*, jint); void (*ReleaseIntArrayElements)(JNIEnv*, jintArray, jint*, jint); void (*ReleaseLongArrayElements)(JNIEnv*, jlongArray, jlong*, jint); void (*ReleaseFloatArrayElements)(JNIEnv*, jfloatArray, jfloat*, jint); void (*ReleaseDoubleArrayElements)(JNIEnv*, jdoubleArray, jdouble*, jint); void (*GetBooleanArrayRegion)(JNIEnv*, jbooleanArray, jsize, jsize, jboolean*); void (*GetByteArrayRegion)(JNIEnv*, jbyteArray, jsize, jsize, jbyte*); void (*GetCharArrayRegion)(JNIEnv*, jcharArray, jsize, jsize, jchar*); void (*GetShortArrayRegion)(JNIEnv*, jshortArray, jsize, jsize, jshort*); void (*GetIntArrayRegion)(JNIEnv*, jintArray, jsize, jsize, jint*); void (*GetLongArrayRegion)(JNIEnv*, jlongArray, jsize, jsize, jlong*); void (*GetFloatArrayRegion)(JNIEnv*, jfloatArray, jsize, jsize, jfloat*); void (*GetDoubleArrayRegion)(JNIEnv*, jdoubleArray, jsize, jsize, jdouble*); /* spec shows these without const; some jni.h do, some don't */ void (*SetBooleanArrayRegion)(JNIEnv*, jbooleanArray, jsize, jsize, const jboolean*); void (*SetByteArrayRegion)(JNIEnv*, jbyteArray, jsize, jsize, const jbyte*); void (*SetCharArrayRegion)(JNIEnv*, jcharArray, jsize, jsize, const jchar*); void (*SetShortArrayRegion)(JNIEnv*, jshortArray, jsize, jsize, const jshort*); void (*SetIntArrayRegion)(JNIEnv*, jintArray, jsize, jsize, const jint*); void (*SetLongArrayRegion)(JNIEnv*, jlongArray, jsize, jsize, const jlong*); void (*SetFloatArrayRegion)(JNIEnv*, jfloatArray, jsize, jsize, const jfloat*); void (*SetDoubleArrayRegion)(JNIEnv*, jdoubleArray, jsize, jsize, const jdouble*); jint (*RegisterNatives)(JNIEnv*, jclass, const JNINativeMethod*, jint); jint (*UnregisterNatives)(JNIEnv*, jclass); jint (*MonitorEnter)(JNIEnv*, jobject); jint (*MonitorExit)(JNIEnv*, jobject); jint (*GetJavaVM)(JNIEnv*, JavaVM**); void (*GetStringRegion)(JNIEnv*, jstring, jsize, jsize, jchar*); void (*GetStringUTFRegion)(JNIEnv*, jstring, jsize, jsize, char*); void* (*GetPrimitiveArrayCritical)(JNIEnv*, jarray, jboolean*); void (*ReleasePrimitiveArrayCritical)(JNIEnv*, jarray, void*, jint); const jchar* (*GetStringCritical)(JNIEnv*, jstring, jboolean*); void (*ReleaseStringCritical)(JNIEnv*, jstring, const jchar*); jweak (*NewWeakGlobalRef)(JNIEnv*, jobject); void (*DeleteWeakGlobalRef)(JNIEnv*, jweak); jboolean (*ExceptionCheck)(JNIEnv*); jobject (*NewDirectByteBuffer)(JNIEnv*, void*, jlong); void* (*GetDirectBufferAddress)(JNIEnv*, jobject); jlong (*GetDirectBufferCapacity)(JNIEnv*, jobject); /* added in JNI 1.6 */ jobjectRefType (*GetObjectRefType)(JNIEnv*, jobject);&#125;;/* * C++ object wrapper. * * This is usually overlaid on a C struct whose first element is a * JNINativeInterface*. We rely somewhat on compiler behavior. */struct _JNIEnv &#123; /* do not rename this; it does not seem to be entirely opaque */ const struct JNINativeInterface* functions;#if defined(__cplusplus) jint GetVersion() &#123; return functions-&gt;GetVersion(this); &#125; ...#endif /*__cplusplus*/&#125;; JNI 引用JNI 支持将类实例和数组类型（如 jobject, jclass, jstring, jarray ）作为不透明的引用，通过使用 JNI 方法来得到指向该数据结构的指针的引用，也就是说 JNI 操作的内容都是引用。JNI 规范中定义了三种引用： Local Reference 局部引用 Global Reference 全局引用 Weak Global Reference 弱全局引用 这三种引用的作用域和生命周期都不一样： 局部引用在方法返回时会被自动释放，当局部引用在使用过程中，GC 不会回收该对象 全局引用和弱全局引用，一直保存直到手动释放 全局引用在释放前不会被 GC 回收；弱全局引用 GC 时会被回收 局部引用 通过 NewLocalRef ；或者大部分创建接口 FindClass, NewObject, GetObjectClass, NewCharArray 等都会生成局部引用 虽然局部引用在方法返回时会自动释放，但是通常如果后续并不使用该引用了，应该主动释放 DeleteLocalRef 局部引用是线程相关的，不在跨函数使用，不能跨线前使用 全局引用 全局引用必须主动创建 NewGlobalRef ；通过 DeleteGlobalRef 主动释放 全局引用可以跨方法使用，可以在多线程中使用 全局引用在使用中，引用的对象不会被 GC 回收，需要特别注意 弱全局引用 弱全局引用必须主动创建 NewWeakGlobalRef ；通过 DeleteGlobalWeakRef 主动释放 弱全局引用可以跨方法使用，可以在多线程中使用 弱全局引用在使用中，引用的对象可能会被 GC 回收，使用时需要做空判断 引用比较使用 IsSameObject 比较两个引用是否指向同一个对象：jboolean (IsSameObject)(JNIEnv, jobject, jobject); ；返回 JNI_TRUE 表示指向的是同一个。 API 基本功能JNIEnv 主要是操作 Java 中的代码，类似反射，所以主要根据 Java 特性来介绍例子。先说明 JNI 中几个重要的类型： jclass ：表示 Java 中的类 jfieldID ：表示 Java 中的属性字段 ID jmethodID ：表示 Java 中的方法 ID jobject ：表示 Java 中的一切对象 动态注册方法Java 中 native 的方法可以通过静态注册和动态注册的方式和 C/C++ 中的代码绑定： 静态注册必须满足命名格式：Java_packageName_className_nativeMethodName ，都是以下划线 _ 拼接的。如果满足这个格式，Java 和 C/C++ 会自动关联。 动态注册不需要满足命名格式，在 so 文件加载时，通过代码动态注册来关联。 动态注册的入口函数为 JNI_OnLoad ，并通过 JNINativeMethod 结构体提供映射表，示例代码 Java 中的 dynamicRegistration 动态注册匹配 nativeDynamicRegistration 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void nativeDynamicRegistration()&#123; LOGE("nativeDynamicRegistration");&#125;static const JNINativeMethod gRegisterMethods[] = &#123; /* name, signature, funcPtr */ &#123;"dynamicRegistration","()V",(void*)nativeDynamicRegistration&#125;,&#125;;jint registerNativeMethods(JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods)&#123; LOGE("registerNativeMethods."); jclass clz = env-&gt;FindClass(className); if (clz == NULL)&#123; LOGE("can't find class = %s", className); return JNI_ERR; &#125; // 动态注册 if (env-&gt;RegisterNatives(clz, gMethods, numMethods) &lt; 0)&#123; LOGE("register natives error!"); return JNI_ERR; &#125; env-&gt;DeleteLocalRef(clz); return JNI_OK;&#125;jint JNI_OnLoad(JavaVM* vm, void* reserved)&#123; LOGE("JNI_OnLoad..."); JNIEnv* env = NULL; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6) != JNI_OK)&#123; LOGE("vm get env error."); return JNI_ERR; &#125; registerNativeMethods(env, "com/***/jni/JniClient", gRegisterMethods, sizeof(gRegisterMethods)/sizeof(JNINativeMethod)); return JNI_VERSION_1_6;&#125; 这段代码中： JNI_OnLoad 是入口函数，在 so 文件加载时调用，可以在该函数中使用全局变量保存 vm 变量的值 JNINativeMethod 定义映射数组时，每个映射方法必须按照：名称、方法签名、函数指针；格式来匹配 env-&gt;RegisterNatives 注册方法映射数组 字符串操作从字符串编码那一节我们可以看到，Java, JNI, C/C++ 对字符串编码都不一样，所以 JNI 中的字符串操作需要先进行转码；可以简单的理解为： jstring ：Java 和 JNI 中可以相互传递和使用 char * ：C/C++ 和 JNI 中可以相互传递和使用 jchar* ：JNI 中特有的（本文暂时没找到怎么用） 因此我们重点需要关注的就是 jstring, char* 之间的转换了；相关 API ： 123456789101112// jchar* 和 jstring 相互转换jstring (*NewString)(JNIEnv*, const jchar*, jsize);jsize (*GetStringLength)(JNIEnv*, jstring);const jchar* (*GetStringChars)(JNIEnv*, jstring, jboolean*);void (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*);// jstring 和 char* 相互转换 jstring (*NewStringUTF)(JNIEnv*, const char*);jsize (*GetStringUTFLength)(JNIEnv*, jstring);/* JNI spec says this returns const jbyte*, but that's inconsistent */const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*);void (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*); 示例代码，Java 传入的字符包含中英文，从 JNI 中返回的字符串也包含中英文： 123String input = "abc你好";String resultStr = sampleString(input);Log.d(TAG, "showJNI: resultStr = " + resultStr); JNI 对字符串的处理： 1234567891011JNIEXPORT jstring JNICALLJava_com_***_jni_JniClient_sampleString (JNIEnv *env, jobject instance, jstring input)&#123; const char *inputStr = env-&gt;GetStringUTFChars(input, NULL); LOGE("sampleString, inputStr = %s", inputStr); env-&gt;ReleaseStringUTFChars(input, inputStr); const char *resultStr = "从JNI中返回的结果！"; jstring result = env-&gt;NewStringUTF(resultStr); return result;&#125; 输出结果： 1211:07:52.786 E/JniClient-jni: sampleString, inputStr = abc你好11:07:52.787 D/JniSampleActivity:: showJNI: resultStr = 从JNI中返回的结果！ 数组JNI 中数组操作重要 API ： GetIntArrayElements... 获取数组的元素，返回一个指针类型，表示指向一个数组 GetArrayLength 获取数组长度 使用完毕后，需要使用 ReleaseIntArrayElements 释放内存 NewCharArray 创建数组 SetCharArrayRegion 拷贝内容到数组 先看 Java 端调用的代码： 12345678public native char[] samplesArray(int[] array);// 调用 native 方法，传入 int 数组int[] array = &#123;1, 2, 3, 4, 5&#125;;char[] results = samplesArray(array);for (int i = 0; i &lt; results.length; ++i)&#123; Log.d(TAG, "showJNI: c[" + i + "] = " + results[i]);&#125; JNI 中的实现，先获取数组指针，再获取数组长度，遍历打印数组，最后释放内存： 123456789101112131415JNIEXPORT jcharArray JNICALLJava_com_***_jni_JniClient_samplesArray( JNIEnv *env, jobject instance, jintArray intArray) &#123; jint *array = env-&gt;GetIntArrayElements(intArray, NULL); int length = env-&gt;GetArrayLength(intArray); for (int i = 0; i &lt; length; ++i) &#123; LOGE("samplesArray[%d]=%d", i, array[i]); &#125; env-&gt;ReleaseIntArrayElements(intArray,array, NULL); jchar result[] = &#123;'a', 'b', 'c', 'd', 'e'&#125;; jcharArray charArray = env-&gt;NewCharArray(length); env-&gt;SetCharArrayRegion(charArray, 0, length, result); return charArray;&#125; 创建 Java 对象JNI 中创建 Java 对象步骤： 根据 package/Classname 类名来查找对应类 查找构造方法 ID ，构造方法默认名称为 &lt;init&gt; 根据构造方法 ID 和类来创建对象 对象使用完毕后，需要删除释放 查找类时，传递的参数不是类的全限定名，只需要包名和类名即可！ 12345678// Constructorjclass clz = env-&gt;FindClass("com/***/jni/JniObject");jmethodID defaultConstructorID=env-&gt;GetMethodID(clz, "&lt;init&gt;", "()V");jobject jniObjectInstance = env-&gt;NewObject(clz, defaultConstructorID);// releaseenv-&gt;DeleteLocalRef(jniObjectInstance);env-&gt;DeleteLocalRef(clz); 获取 Java 对象的属性和方法和反射一样，public, private 等访问控制符并不生效，JNI 中可以获取 Java 对象所有的属性和方法，包含 private 修饰的。重要 API ： GetFieldID ：获取属性 ID ；参数需要使用类型签名 GetMethodID ：获取方法 ID ；参数需要使用方法的类型签名 GetObjectField/GetIntField... ：获取属性对应的值，有多个基本类型变种 CallVoidMethod/CallBooleanMethod... ：调用某个方法，根据返回值有多个基本类型变种 1234567891011121314151617181920212223242526272829303132333435363738// 获取和调用 public 的属性和方法// public field and methodjfieldID publicIntID = env-&gt;GetFieldID(clz, "publicInt", "I");jint publicIntValue = env-&gt;GetIntField(jniObjectInstance, publicIntID);LOGE("default publicIntValue = %d", publicIntValue);// change valuepublicIntValue = 100;env-&gt;SetIntField(jniObjectInstance, publicIntID, publicIntValue);// check valuejint publicIntValue1 = env-&gt;GetIntField(jniObjectInstance, publicIntID);LOGE("modify publicIntValue1 = %d", publicIntValue1);// call public method: setPublicIntjmethodID setPublicIntMethodId = env-&gt;GetMethodID(clz, "setPublicInt", "(I)V");publicIntValue = 200;env-&gt;CallVoidMethod(jniObjectInstance, setPublicIntMethodId, publicIntValue);// check valuejint publicIntValue2 = env-&gt;GetIntField(jniObjectInstance, publicIntID);LOGE("modify by Method, publicIntValue = %d", publicIntValue2);// 获取和调用 private 的属性和方法// private field and methodjfieldID privateBooleanID = env-&gt;GetFieldID(clz, "privateBoolean", "Z");jboolean privateBooleanValue = env-&gt;GetBooleanField(jniObjectInstance, privateBooleanID);LOGE("default privateBooleanValue = %d", privateBooleanValue);// call private method: setPrivateBooleanjmethodID setPrivateBooleanId = env-&gt;GetMethodID(clz, "setPrivateBoolean", "(Z)V");privateBooleanValue = 1;env-&gt;CallVoidMethod(jniObjectInstance, setPrivateBooleanId, privateBooleanValue);// check valuejboolean privateBooleanValue2 = env-&gt;GetBooleanField(jniObjectInstance, privateBooleanID);LOGE("modify by private Method, privateBooleanValue = %d", privateBooleanValue2); 获取 Java 中 static 静态属性和方法static 修饰的属性和方法是属于类的，所以在调用时，并不需要指定对象 jobject ；重要 API ： GetStaticFieldID ：获取静态 static 属性 ID ；参数需要使用类型签名 GetStaticMethodID ：获取静态 static 方法 ID ；参数需要使用方法的类型签名 GetStaticObjectField/GetStaticIntField... ：获取静态属性的值，有多个基本类型的变种 CallStaticVoidMethod/CallStaticIntMethod... ：调用静态方法，根据返回值有多个基本类型的变种 12345678910111213141516171819202122// static field and methodjfieldID publicStaticStrID = env-&gt;GetStaticFieldID(clz, "publicStaticStr", "Ljava/lang/String;");jstring publicStaticStrValue = (jstring)env-&gt;GetStaticObjectField(clz, publicStaticStrID);const char *strValue = env-&gt;GetStringUTFChars(publicStaticStrValue,NULL);LOGE("default publicStaticStrValue = %s", strValue);env-&gt;ReleaseStringUTFChars(publicStaticStrValue, strValue);// call static method: changeValuejmethodID changeValueId = env-&gt;GetStaticMethodID(clz, "changeValue", "(Ljava/lang/String;)V");std::string newStr = "Hello from C++, changeValue";jstring publicStaticStrValue2 = env-&gt;NewStringUTF(newStr.c_str());env-&gt;CallStaticVoidMethod(clz, changeValueId, publicStaticStrValue2);// check valuejstring publicStaticStrValue3 = (jstring)env-&gt;GetStaticObjectField(clz, publicStaticStrID);const char *newStrValue = env-&gt;GetStringUTFChars(publicStaticStrValue3, NULL);LOGE("modify by static Method, publicStaticStrValue = %s", newStrValue);env-&gt;ReleaseStringUTFChars(publicStaticStrValue3, newStrValue); 注意事项： 这里在获取字符串时，jobject 可以直接强制转换为 jstring jstring 打印时，需要转换为 char* 指针 JNI 中对 Java 多态的处理Java 多态中的重载，可以通过方法签名（参数不一样）来区分；重写，通常情况下并不需要通过子类调用父类的重写方法，但是 JNI 中提供了该功能；重要 API ： CallNonvirtualVoidMethod/CallNonvirtualIntMethod... ：在重写时，直接调用父类的方法 Java 示例代码，father.show 因为重写，输出结果为 Son, show: ： 123456789101112131415161718public class JniPolymorphic &#123; private static final String TAG = "JniPolymorphic"; private Father father = new Son(); public class Father&#123; public void show()&#123; Log.d(TAG, "Father, show: "); &#125; &#125; public class Son extends Father&#123; @Override public void show() &#123; Log.d(TAG, "Son, show: "); &#125; &#125;&#125; JNI 中，可以通过 CallNonvirtualVoidMethod 来直接调用，输出 Father, show: ： 12345678910111213141516171819202122232425262728// 构造 JniPolymorphic 对象jclass clz = env-&gt;FindClass("com/***/jni/JniPolymorphic");jmethodID defaultConstructorID = env-&gt;GetMethodID(clz, "&lt;init&gt;", "()V");jobject jniObjectInstance = env-&gt;NewObject(clz, defaultConstructorID);// 获取 father 对象jfieldID fatherID = env-&gt;GetFieldID(clz, "father", "Lcom/***/jni/JniPolymorphic$Father;");jobject fatherObject = env-&gt;GetObjectField(jniObjectInstance, fatherID);// 获取 show 方法的 idjclass fatherClass = env-&gt;FindClass("com/***/jni/JniPolymorphic$Father");jmethodID fatherShowMethodID = env-&gt;GetMethodID(fatherClass, "show", "()V");// 调用 father 对象的 show 方法，因为重写，输出的结果为 Son, showenv-&gt;CallVoidMethod(fatherObject, fatherShowMethodID);// 调用 father 对象的 show 方法，这里调用的是 Father 父类的 show 方法 // 所以输出结果为 Father, showenv-&gt;CallNonvirtualVoidMethod(fatherObject, fatherClass, fatherShowMethodID);// releaseenv-&gt;DeleteLocalRef(jniObjectInstance);env-&gt;DeleteLocalRef(clz);env-&gt;DeleteLocalRef(fatherObject);env-&gt;DeleteLocalRef(fatherClass); 注意事项： 内部类的类名拼接时，需要使用美元符 $ Android NDK概念 Android NDK 是一套允许使用 C/C++ 等语言，以原生代码实现部分应用的工具集，Google NDK 官网 CMake 一款外部构建工具，可与 Gradle 搭配使用来构建原生库；Android Studio 中已经使用 Cmake 替换原来的 ndk-build LLDB 一种调试程序，Android Studio 使用它来调试原生代码 CPU 架构及 ABI不同的 CPU 架构：ARMv5, ARMv7, x86, MIPS, ARMv8, MIPS64, x86_64 都关联着一个对应的 ABI 。ABI（Application Binary Interface） 决定了二进制文件如何与系统进行交互。CPU 对应的 ABI 有 armeabi, armeabi­v7a, arm64­v8a, x86, x86_64, mips, mips64 。Android NDK 支持的 ABI，查看官网 armeabi将创建以基于 ARM v5 的设备为目标的库。使用软件浮点运算，可以在所有 ARM 设备上运行；NDK 中已经弃用。 armeabi-v7a创建支持基于 ARM v7 的设备的库，并将使用硬件 FPU 指令，支持硬件浮点运算及高级扩展功能。与 ARMv5、v6 设备不兼容。 mips是世界上很流行的一种 RISC 处理器，其机制是尽量利用软件办法避免流水线中的数据相关问题；NDK 已弃用。 x86支持基于硬件的浮点运算的 IA-32 指令集。x86 是可以兼容 armeabi 平台运行的，无论是 armeabi-v7a 还是 armeabi，同时带来的也是性能上的损耗。 当前现状，几个大厂的 APK (微信，美团等) 都只使用了 armeabi-v7a，可能是 Android 手机碎片化严重，为了能支持更多的设备。Gradle 中如果不指定，默认会生成所有架构对应的 so ，导致 apk 很大。这里可以参考大厂，只指定 armeabi-v7a ！在 defaultConfig 中增加如下代码： 123ndk&#123; abiFilter &apos;armeabi-v7a&apos;&#125; Android Studio 设置快速生成 h 文件这个方法是使用命令对 Java 中的 native 方法，手动生成对应头文件，非常方便。 AndroidStudio 中快速生成 h 文件，查看大图 对应填写的参数如下： 123$JDKPath$\bin\javah.exe-classpath . -jni -encoding $FileEncoding$ -d $ModuleFileDir$\src\main\jni $FileClass$$ModuleFileDir$\src\main\java 搭建 JNI 编译环境在 Android Studio 中搭建好 JNI 编译环境后，所有的 native 代码会自动生成对应的 JNI 代码。 新建 jni 目录 Folder -&gt; JNI Folder ，并创建 JNI 对应的 cpp 文件 新建 CMakeLists.txt 文件，可以拷贝一份模板并将 cpp 文件和生成库的名称替换下 build.gradle 中添加 CMakeLists.txt 路径，并重新 sync 工程确保能正确编译 Java 文件中添加 native 方法，测试是否能自动生成对应的 JNI如果是新建 Native 工程，则会自动添加；但是手动新建的，native 方法总是生成对应的 .c 文件，需要拷贝到 .cpp 中；如果使用了动态注册，则 Android Studio 中对 native 方法不再出现小红灯提示，这个时候只能手动生成头文件了。 C/C++ 中的 LOG 打印 Cmake中 增加 log 模块 12target_link_libraries(hello-jni log) C/C++ 包含头文件#include &lt;android/log.h&gt; 自定义 LOG 输出 12#define LOGI(...) \ ((void)__android_log_print(ANDROID_LOG_INFO, "MyTag::", __VA_ARGS__)) C/C++ 代码中使用 LOG 打印LOGI(&quot;sum %d&quot;, sum); 调试JNI 代码出错后，会导致 crash ，根据 logcat 中 backtrace 输出的出错地址，来找到原始代码出错行。工具主要是 ndk 提供的 addr2line 和 ndk-stack 。 示例出错的源码： 12345Java_com_***_jni_JniClient_sampleReflectJNI( JNIEnv *env, jobject instance) &#123; jclass clz = env-&gt;FindClass("Lcom/***/jni/JniObject;"); ...&#125; 出错原因是 env-&gt;FindClass 时，找不到指定类 Lcom/***/jni/JniObject; （FindClass 方法参数中类名不需要添加 L 和 ; ，直接使用 package/Classname ），在 logcat 中输出了如下错误信息： 1234567891011121314151617181920212223242526272829 --------- beginning of crash2019-04-15 10:11:59.805 10175-10175/com.*** A/libc: Fatal signal 6 (SIGABRT), code -6 in tid 10175 (dbasicknowledge), pid 10175 (dbasicknowledge)2019-04-15 10:11:59.805 10175-10175/com.*** A/zygote: runtime.cc:531] 2019-04-15 10:11:59.918 10224-10224/? I/crash_dump32: obtaining output fd from tombstoned, type: kDebuggerdTombstone2019-04-15 10:11:59.919 796-796/? I//system/bin/tombstoned: received crash request for pid 101752019-04-15 10:11:59.920 10224-10224/? I/crash_dump32: performing dump of process 10175 (target tid = 10175)2019-04-15 10:11:59.920 10224-10224/? A/DEBUG: *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***2019-04-15 10:11:59.921 10224-10224/? A/DEBUG: Build fingerprint: &apos;Panasonic/ELUGA_Ray_710/ELUGA_Ray_710:8.1.0/OPM1.171019.011/013015:user/release-keys&apos;2019-04-15 10:11:59.921 10224-10224/? A/DEBUG: Revision: &apos;0&apos;2019-04-15 10:11:59.921 10224-10224/? A/DEBUG: ABI: &apos;arm&apos;2019-04-15 10:11:59.921 10224-10224/? A/DEBUG: pid: 10175, tid: 10175, name: dbasicknowledge &gt;&gt;&gt; com.*** &lt;&lt;&lt;2019-04-15 10:11:59.921 10224-10224/? A/DEBUG: signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------2019-04-15 10:11:59.927 10224-10224/? A/DEBUG: Abort message: &apos;java_vm_ext.cc:534] JNI DETECTED ERROR IN APPLICATION: illegal class name &apos;Lcom/***/jni/JniObject;&apos;&apos;2019-04-15 10:11:59.928 10224-10224/? A/DEBUG: r0 00000000 r1 000027bf r2 00000006 r3 000000082019-04-15 10:11:59.928 10224-10224/? A/DEBUG: r4 000027bf r5 000027bf r6 ffc85f8c r7 0000010c2019-04-15 10:11:59.928 10224-10224/? A/DEBUG: r8 00000000 r9 e940c1a0 sl 0000000a fp ffc85fd82019-04-15 10:11:59.928 10224-10224/? A/DEBUG: ip cdf4ac20 sp ffc85f78 lr ea4f7c6d pc ea4f170e cpsr 200f00302019-04-15 10:11:59.936 10224-10224/? A/DEBUG: backtrace:2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #00 pc 0001a70e /system/lib/libc.so (abort+63)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #01 pc 0035ad89 /system/lib/libart.so (art::Runtime::Abort(char const*)+392)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #02 pc 0041a62d /system/lib/libart.so (android::base::LogMessage::~LogMessage()+452)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #03 pc 0024d2f9 /system/lib/libart.so (art::JavaVMExt::JniAbort(char const*, char const*)+1212)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #04 pc 0024d47b /system/lib/libart.so (art::JavaVMExt::JniAbortV(char const*, char const*, std::__va_list)+58)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #05 pc 000d5bd3 /system/lib/libart.so (art::ScopedCheck::AbortF(char const*, ...)+42)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #06 pc 000c126d /system/lib/libart.so (art::CheckJNI::FindClass(_JNIEnv*, char const*)+496)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #07 pc 000081c5 /data/app/com.***-cnsQVEa2GWUFUs2IvyISdw==/lib/arm/libjni-sample.so (_JNIEnv::FindClass(char const*)+36)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #08 pc 0000812d /data/app/com.***-cnsQVEa2GWUFUs2IvyISdw==/lib/arm/libjni-sample.so (Java_com_***_jni_JniClient_sampleReflectJNI+24)2019-04-15 10:11:59.936 10224-10224/? A/DEBUG: #09 pc 0000a0fb /data/app/com.***-cnsQVEa2GWUFUs2IvyISdw==/oat/arm/base.odex (offset 0xa000)2019-04-15 10:12:01.314 796-796/? E//system/bin/tombstoned: Tombstone written to: /data/tombstones/tombstone_05 也可以将 tombstone 取出来获取更详细的信息。 addr2line 工具addr2line 工具在 ndk 的交叉编译工具链中，根据当前调试手机平台选择具体的交叉编译工具，示例代码使用的是 armeabi：ndk-bundle\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\bin ，找到 arm-linux-androideabi-addr2line.exe 文件，它就是 addr2line 工具。命令格式： addr2line -e so文件 出错地址 ；上面示例中，so 文件为 libjni-sample.so ，这个库文件在 Android Studio 的 app\build\intermediates\cmake\debug\obj\armeabi-v7a\ 目录下；错误地址是 0000812d ，完整命令如下： 12C:\**\ndk-bundle\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\bin&gt;arm-linux-androideabi-addr2line.exe -e E:\***\app\build\intermediates\cmake\debug\obj\armeabi-v7a\libjni-sample.so 0x0000812dE:\***\app\src\main\jni/JniClient.cpp:26 得到的解析结果为源码 JniClient.cpp 的第 26 行错误。 ndk-stack 工具ndk-stack 工具在 ndk 的当前目录 $NDK_HOME 下，是一个脚本文件 ndk-stack.cmd ，不需要指定交叉编译版本，取出 tombstone 文件后，使用 ndk-stack 自动解析出错误行。命令格式： ndk-stack -sym so所在文件目录 -dump tobstone &gt; 1.txt ；上面示例中，不需要指定 so 文件名，只需要支持所在目录就行；完整命令如下： 1C:\***\ndk-bundle\ndk-stack.cmd -sym E:\***\app\build\intermediates\cmake\debug\obj\armeabi-v7a\ -dump tombstone_05 &gt; 1.txt 我们打开 1.txt 文件，可以查看到解析的结果： 123456789101112131415161718********** Crash dump: **********Build fingerprint: &apos;Panasonic/ELUGA_Ray_710/ELUGA_Ray_710:8.1.0/OPM1.171019.011/013015:user/release-keys&apos;Abort message: &apos;java_vm_ext.cc:534] JNI DETECTED ERROR IN APPLICATION: illegal class name &apos;L/com/***/jni/JniObject;&apos;&apos;#00 0x0001a70e /system/lib/libc.so (abort+63)#01 0x0035ad89 /system/lib/libart.so (art::Runtime::Abort(char const*)+392)#02 0x0041a62d /system/lib/libart.so (android::base::LogMessage::~LogMessage()+452)#03 0x0024d2f9 /system/lib/libart.so (art::JavaVMExt::JniAbort(char const*, char const*)+1212)#04 0x0024d47b /system/lib/libart.so (art::JavaVMExt::JniAbortV(char const*, char const*, std::__va_list)+58)#05 0x000d5bd3 /system/lib/libart.so (art::ScopedCheck::AbortF(char const*, ...)+42)#06 0x000c126d /system/lib/libart.so (art::CheckJNI::FindClass(_JNIEnv*, char const*)+496)#07 0x000081c5 /data/app/com.***-cnsQVEa2GWUFUs2IvyISdw==/lib/arm/libjni-sample.so (_JNIEnv::FindClass(char const*)+36) _JNIEnv::FindClass(char const*) C:/***/ndk-bundle/toolchains/llvm/prebuilt/windows-x86_64/sysroot/usr/include\jni.h:504:14#08 0x0000812d /data/app/com.***-cnsQVEa2GWUFUs2IvyISdw==/lib/arm/libjni-sample.so (Java_com_***_jni_JniClient_sampleReflectJNI+24) Java_com_***_jni_JniClient_sampleReflectJNI E:\***\app\src\main\jni\JniClient.cpp:26:23#09 0x0000a0fb /data/app/com.***-cnsQVEa2GWUFUs2IvyISdw==/oat/arm/base.odex (offset 0xa000)Crash dump is completed 得到了同样的解析结果： JniClient.cpp 的第 26 行错误。 其他 JNI 默认对应的是 C 代码，所以在 C++ 代码中需要做如下声明：extern &quot;C&quot; Android 中 jni.h 定义的函数，都是在 art/runtime/jni_internal.cc 中实现的 参考文档 Oracle: Java 8 JNI 官网 Goolge: Android JNI 官网 Google: NDK 官网 隔壁老李头：Android JNI Unicode 与 utf8 utf16 utf32的关系 字符、编码和Java中的编码 C–中文汉字占用字节长度 JVM Utf8 JNI中引用类型 在JNI中使用引用 JavaVM和 JNIEnv 动态注册本地方法 NewString 与 NewStringUtf 解析 NI数据类型与方法属性访问 Android Studio 中添加 C/C++ 代码 Android Studio NDK快速生成.h头文件 小楠总: Android NDK开发之旅]]></content>
      <categories>
        <category>Android</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seAndroid 安全机制]]></title>
    <url>%2F2019%2F04%2F02%2F0111-android-seandroid%2F</url>
    <content type="text"><![CDATA[seAndroid 安全机制简介。 基本概念主体/客体在一个操作系统中，每一个实体组件都必须是主体或者客体，或者既是主体又是客体。 主体主体是一个主动的实体，包括用户、用户组、进程等；通常指用户或由用户发起运行的进程或用户正在使用的设备。主体主动发起对资源的访问，它是系统中信息流的启动者。 客体客体是一个被动的实体，包括文件、目录、端口、设备、进程等资源；通常是指信息的载体或从其他主体或客体接收信息的实体。主体有时也会成为访问或受控的对象，如一个主体可以向另一个主体授权，一个进程可能控制几个子进程等等，这时受控的主体或子进程也通常被认为是一种客体。 访问控制模式 DAC: Discretionary Access Control 自主访问控制DAC 主要的内容是：权限 rwx 、所有权 ugo ；在这个模型中，主体是用户的身份，客体是资源或者说是文件（ Linux 中一切皆文件）。由客体的属主对自己的客体进行管理，由主体自己决定是否将自己的客体访问权限或部分访问权限授予其他主体，这种控制方式是自主的。也就是说，在自主访问控制下，用户可以按自己的意愿，有选择地与其他用户共享他的文件。DAC 是一种相对比较宽松但是却很有效的保护资源不被非法访问和使用的手段，权限是访问的关键；但 Linux 中，root 用户不受任何管制，系统上任何资源都可以无限制地访问。 MAC: Mandatory Access Control 强制访问控制MAC 是利用策略将访问控制规则“强加”给访问主体的，即系统强制主体服从访问控制策略。MAC 主要作用的对象是所有主体及其所操作的客体（如：进程、文件等）。MAC 为这些主体及其所操作的客体提供安全标记，这些标记是实施强制访问控制的依据。系统通过比较主体和客体的安全标记来判断一个主体是否能够访问其要操作的客体。用户发起的进程无法改变其自身及其它客体的安全标记，利用这样的机制，系统可以比较有效地防止特洛伊木马攻击以及 root 身份冒用或盗用等安全威胁。MAC 又细分为了两种方式：类别安全 MCS 模式；多级安全 MLS 模式。 MAC 一般与 DAC 共同使用，两种访问控制机制的过滤结果将累积，以此来达到更佳的访问控制效果。也就是说，一个主体只有通过了 DAC 限制检查与 MAC 限制检查的双重过滤装置之后，才能真正访问某个客体。 SELinux 的工作模式SELinux: Secure Enhanced Linux 是美国国家安全局 NSA: The National Security Agency 和 SCC:Secure Computing Corporation 在 Linux 社区的帮助下开发了 MAC 强制访问控制的安全模块，Linux 从 2.6 版本后将它集成到了内核中。主体在访问客体时，SELinux 策略决策过程如下图，Kernel 中的策略执行服务器将检查 AVC: Access Vector Cache ，访问矢量缓存中存储的是访问控制策略： SELinux 有三种工作模式： enforcing强制模式，违反 SELinux 规则的行为将被阻止（权限拒绝）并记录到日志中。 permissive宽容模式，违反 SELinux 规则的行为（权限不会被拒绝）只会记录到日志中，一般为调试用。 disabled关闭 SELinux 。 SEAndroid 是在 Android 系统中基于 SELinux 推出的强制访问控制模型，是 SELinux 的一个子集；可以通过 adb 命令来查看/设置模式： 123adb shell getenforce // 查看当前模式adb shell setenforce 1 // 设置为 enforcing 模式adb shell setenforce 0 // 设置为 permissive 模式 在 CTS 兼容性测试时，Android 有以下要求官方要求： 必须实现 SELinux 必须将 SELinux 设置为全局强制模式 enforcing 必须将所有域配置为强制模式。不允许使用宽容模式域，包括特定于设备/供应商的域 访问控制策略 policy访问控制策略 policy 都是在 .te: Type Enforcement 文件中定义的，用来控制主体是否能访问客体，以及能放问客体哪些东西；下面先介绍几个用来描述主客体的几个概念。更多规则和关键字等基本概念，参考The SELinux Notebook, 4th Edition（SELinux 手册第 4 版） 。 classes定义客体的安全类别，可以在 system/sepolicy/private/security_classes 查看： 1234567891011121314151617181920212223242526# Classes marked as userspace are classes# for userspace object managersclass securityclass processclass systemclass capability# file-related classesclass filesystemclass file // 文件class dir // 目录class fd // 文件描述符class lnk_fileclass chr_fileclass blk_fileclass sock_fileclass fifo_file# network-related classesclass socketclass tcp_socketclass udp_socket...class binder # Android 平台特有的 binder... permissiones定义每个客体类别支持哪些操作权限，可以在 system/sepolicy/private/access_vectors 中查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# Define common prefixes for access vectors# common common_name &#123; permission_name ... &#125;# Define a common prefix for file access vectors.common file // 定义 file 通用的操作权限&#123; ioctl read write create getattr ...&#125;# Define a common prefix for socket access vectors.common socket // 定义 socket 通用的操作权限&#123;# inherited from file ioctl read write ...# socket-specific bind connect listen accept ...&#125;...class file // 客体类别 file 支持的操作权限inherits file&#123; execute_no_trans entrypoint execmod open audit_access&#125;class dirinherits file&#123; add_name remove_name ...&#125;class socketinherits socketclass tcp_socket // 客体类别 tcp_socket 支持的操作权限inherits socket&#123; node_bind name_connect&#125;... attribute 属性attribute 实际是组的概念，表示一组 group ；有了组的概念后，可以每次对一个组设置策略。attribute 可以是主体，也可以是客体；在 system/sepolicy/public/attributes 文件查看： 12345678910111213141516171819# All types used for processes.attribute domain;# All types used for filesystems.# On change, update CHECK_FC_ASSERT_ATTRS# definition in tools/checkfc.c.attribute fs_type;# All types used for context= mounts.attribute contextmount_type;# All types used for files that can exist on a labeled fs.# Do not use for pseudo file types.# On change, update CHECK_FC_ASSERT_ATTRS# definition in tools/checkfc.c.attribute file_type;# All types used for domain entry points.attribute exec_type; 从注释中也可以看出，是 All types 所有的类型，接下来看 type 。 type表示类型，可以理解为主体或客体的名称，表示这一类主体或这一类客体；所有的 type 都是在 .te 文件中定义的，同时会设置对应的策略。 type 直接定义命名格式：type type_id [alias alias_id,] [attribute_id] ；[] 是可选项，alias 表示假名，attribute_id 可以是多个，表示属于哪一组。示例：type shell, domain; ；定义了一个名为 shell 的 type ，它和名为 domain 的属性 attribute 关联；换句话说 shell 属于 domain 组。type 和 attribute 位于同一个命名空间，所以不能用 type 命令和 attribute 命令定义相同名字的东西。 typeattribute 添加对应属性typeattribute 是针对已经被定义了的 type ，添加属性（即属于哪一组），格式：typeattribute type_id attribute_id 。示例 typeattribute mediaserver halclientdomain; ，表示 mediaserver 拥有 halclientdomain 属性，即属于这一组。 policy策略规则 policy 也是在 .te 文件中声明的，其语法格式为：RULE_VARIANT SOURCE_TYPES TARGET_TYPES:CLASSES PERMISSIONS ，其中： RULE_VARIANT常见的访问规则如下，这里仅仅 allow 是授予权限允许操作，其他都是辅助型的（都不会授予权限）。 allow 授予权限，允许操作（默认情况下只记录权限检查失败的信息） neverallow 不允许操作（通常用来做检查，检查是否有违反规则） auditallow 记录所有的（成功和失败）权限检查事件 dontaudit 不记录权限检查失败的信息 SOURCE_TYPES主体类型，由 type 定义。 TARGET_TYPES客体类型，由 type 定义。 CLASSES客体的安全类别，即 system/sepolicy/private/security_classes 文件中，关键字 class 定义的类别。 PERMISSIONS客体安全类别的操作权限，即 system/sepolicy/private/access_vectors 文件中，该安全类别对应的操作权限。 policy 描述的含义实际就是：主体对客体的某种类别拥有的权限；示例： allow appdomain app_data_file:file rw_file_perms;主体 appdomain 对客体 app_data_file 的 file 类别，拥有读取和写入权限。其中 rw_file_perms 是宏定义的一组权限。 allow domain null_device:chr_file { open read};主体 domain 对客体 null_device 的 chr_file 类别，拥有打开和读的权限。 self 关键字self 表示客体类型使用的主体类型自身，即客体类型等于主体类型；注意：不能使用 self 代表主体类型。示例： 12345678910# 这两条策略是相等的 allow user_t user_t : process signal; allow user_t self : process signal;# 这两条策略 allow user_t user_t : process signal;allow staff_t staff_t : process signal; # 等于下面这一条策略 allow &#123;user_t staff_t&#125; self : process signal; 特殊操作符 - 非操作符表示从 attribute 一组类型中，移除特定类型；如： allow vndservicemanager { domain -coredomain -init }:binder transfer; ，表示 vndservicemanager 除了 coredomain, init 以外，所有 domain 的 binder 类别，都拥有 transfer 操作权限。 ~ 求补操作符表示除了列出的操作权限外，其他的都包含；如 allow init unlabeled:filesystem ~relabelto; 。 * 通配符表示任意的；neverallow * logpersist:process dyntransitionneverallow mediacodec domain:{ tcp_socket udp_socket rawip_socket } *; 示例以下是一个完整的 DHCP 策略示例： 12345678910111213141516171819202122232425262728type dhcp, domain;permissive dhcp; // 声明为宽容域type dhcp_exec, exec_type, file_type;type dhcp_data_file, file_type, data_file_type;init_daemon_domain(dhcp)net_domain(dhcp)allow dhcp self:capability &#123; setgid setuid net_admin net_raw net_bind_service&#125;;allow dhcp self:packet_socket create_socket_perms;allow dhcp self:netlink_route_socket &#123; create_socket_perms nlmsg_write &#125;;allow dhcp shell_exec:file rx_file_perms;allow dhcp system_file:file rx_file_perms;# For /proc/sys/net/ipv4/conf/*/promote_secondariesallow dhcp proc_net:file write;allow dhcp system_prop:property_service set ;unix_socket_connect(dhcp, property, init)type_transition dhcp system_data_file:&#123; dir file &#125; dhcp_data_file;allow dhcp dhcp_data_file:dir create_dir_perms;allow dhcp dhcp_data_file:file create_file_perms;allow dhcp netd:fd use;allow dhcp netd:fifo_file rw_file_perms;allow dhcp netd:&#123;dgram_socket_class_set unix_stream_socket&#125; &#123;read write&#125;;allow dhcp netd:&#123; netlink_kobject_uevent_socket netlink_route_socketnetlink_nflog_socket &#125; &#123; read write &#125;; type dhcp, domain;定义一个 dhcp 域，它属于 domain 组。 permissive dhcp;声明新建的 dhcp 域为宽容域（调试完毕后，必须要移除）。 type dhcp_exec, exec_type, file_type;定义 dhcp_exec ，同时属于 exec_type, file_type 组。 init_daemon_domain(dhcp)声明 dhcp 是从 init 衍生而来的，并且可以与其通信。init_daemon_domain 等域操作，详细可以参考 system/sepolicy/public/te_macros 中的定义。 allow dhcp self:packet_socket create_socket_perms;允许 dhcp 创建 socket ，权限类 create_socket_perms 等参考 system/sepolicy/public/global_macros 中的定义。 目录速查表selinux 代码目录位于 Android 源码目录的 external/selinux 目录下，external/selinux/prebuilts/bin 有些工具类文件，方便快速分析权限问题。 policy 文件目录在 Android 8.0 及更高版本中，policy 文件位于 AOSP 中的以下位置： system/sepolicy/public其中包括所导出的用于供应商特定策略的策略；公共策略会保留在不同版本上，可以在自定义策略的 /public 中添加任何内容。正因如此，可存放在 /public 中的策略类型的限制性更强。将此目录视为相应平台的已导出策略 API：处理 /system 与 /vendor 之间的接口的所有内容都位于这里。 system/sepolicy/private包括系统映像正常运行所必需（但供应商映像策略应该不知道）的策略。 system/sepolicy/vendor包括位于 /vendor 但存在于核心平台树（非设备特定目录）中的组件的相关策略。这是编译系统区分设备和全局组件的软件工件；从概念上讲，这是下述设备专用策略的一部分。 device/manufacturer/sepolicy/device-name包含设备专用策略，以及对策略进行的设备自定义（在 Android 8.0 及更高版本中，该策略对应于供应商映像组件的相关策略）。 通常情况下，不能直接修改 system/sepolicy 文件，而是添加或修改自己的设备专用策略文件（位于 /device/manufacturer/device-name/sepolicy 目录中）。 宏定义系统的策略文件中，定义很多宏，方便共享和快速定义策略文件，路径如下： 123456system/sepolicy/public/ioctl_macros // ioctlsystem/sepolicy/public/global_macros // 权限system/sepolicy/public/te_macros // 域操作system/sepolicy/public/neverallow_macrossystem/sepolicy/reqd_mask/mls_macrossystem/sepolicy/private/mls_macros 标签定义标签，也被称为安全上下文 security context ，组成元素为：user:role:type:mls_level ，每个元素的意义： user指登录系统的用户类型，比如 root, user_u, system_u ；但是在 SEAndroid 中 user 只有一个，都是 u 。 role定义文件、进程和用户的用途。在 SEAndroid 中的 role 只有两个：object_r 表示文件；r 表示进程。 type指定主体和客体的类型。 mls_level指安全级别，格式为 sensitivity[:category list][- sensitivity[:category list]]，冒号后面的内容是 category ，“-”号左右分别标识了安全级别的最低和最高；例如 s0 - s15:c0.c1023 ，其中 s0 之后的内容可以不需要。在 SEAndroid 中只有一个级别即 s0，category 共有 1024 个，因此最低安全级别就是 s0，最高安全级别就是 s0:c0.c1023 ，通常我们就只会看到 s0 。 在 SEAndroid 中，标签的角色仅仅只有两个：进程和文件。进程标签的 type 又称为域；所以 policy 也可以理解为 - 进程访问文件权限的规则：allow domains types:classes permissions; 。在 AVC 消息中，主体上下文（标签）为 scontext ；客体上下文（标签） tcontext ，客体类别 tclass 。 在 Linux 中一切都是文件，所以我们在打标签时，不可能存在 r 角色；所有的进程在系统中都是一个可执行文件，所以对于进程的标签通常是：先在 te 文件中通过 type 定义一个类型；然后在 file_contexts 中为进程对应的可执行文件打上该 type 标签。 查看标签我们通过 ls -Z 和 ps -AZ 分别查看文件和进程（两个角色）的标签，示例如下： 123456789101112131415161718// 查看文件角色的标签ELUGA_Ray_710:/ # ls -Zu:object_r:cgroup:s0 acctu:object_r:rootfs:s0 bt_firmwareu:object_r:rootfs:s0 bugreportsu:object_r:cache_file:s0 cacheu:object_r:rootfs:s0 chargeru:object_r:configfs:s0 configu:object_r:rootfs:s0 du:object_r:system_data_file:s0 datau:object_r:rootfs:s0 default.prop// 查看进程角色的标签 ELUGA_Ray_710:/ # ps -ZLABEL USER PID PPID VSZ RSS ADDR S NAMEu:r:shell:s0 root 6897 592 9228 1928 772c07a568 S shu:r:shell:s0 root 7930 6897 10804 2032 792b23ef10 R ps type 是整个 SEAndroid 中最重要的参量，所有的 policy 都围绕这一参量展开，所以为系统中每个文件标记上合适的 type 就显得极为重要了。通过 *_contexts 上下文描述文件，来给具体的文件或进程打标签。 file_contexts用于为文件（分为：进程对应的可执行文件（主体）和常规文件（客体））分配标签，并且可供多种用户空间组件使用。在创建新策略时，请创建或更新该文件，以便为文件分配新标签。要应用新的 file_contexts，请重新构建文件系统映像，或对要重新添加标签的文件运行 restorecon。在升级时，对 file_contexts 所做的更改会在升级过程中自动应用于系统和用户数据分区。此外还可以通过以下方式使这些更改在升级过程中自动应用于其他分区：在以允许读写的方式装载相应分区后，将 restorecon_recursive 调用添加到 init.board.rc 文件中。 file_contexts 所在目录为： 12345system/sepolicy/private/file_contextssystem/sepolicy/vendor/file_contextsdevice/manufacturer/device-name/sepolicy/file_contextsdevice/manufacturer/sepolicy/device-name/file_contextsdevice/manufacturer/sepolicy/private/file_contexts 查询 private/file_contexts 文件中的示例： 1234567891011121314151617181920212223242526// system/sepolicy/private/file_contexts# Root/ u:object_r:rootfs:s0# Data files/adb_keys u:object_r:adb_keys_file:s0/build\.prop u:object_r:rootfs:s0.../verity_key u:object_r:rootfs:s0# Executables/charger u:object_r:rootfs:s0/init u:object_r:init_exec:s0/sbin(/.*)? u:object_r:rootfs:s0# For kernel modules/lib(/.*)? u:object_r:rootfs:s0# Empty directories/lost\+found u:object_r:rootfs:s0/mnt u:object_r:tmpfs:s0...# Symlinks/bugreports u:object_r:rootfs:s0... file_contexts 中的 type 类型，基本都是在如下 .te 文件中定义的： 12345678910111213// file.tesystem/sepolicy/private/file.tesystem/sepolicy/vendor/file.tesystem/sepolicy/public/file.tedevice/manufacturer/sepolicy/device-name/file.tedevice/manufacturer/sepolicy/private/file.tedevice/manufacturer/sepolicy/public/file.te// device.tesystem/sepolicy/public/device.tedevice/manufacturer/sepolicy/private/device.tedevice/manufacturer/sepolicy/public/device.tedevice/manufacturer/sepolicy/device-name/device.te 查询 system/sepolicy/public/file.te 文件中的示例： 1234567891011121314151617# Filesystem typestype labeledfs, fs_type;type pipefs, fs_type;type sockfs, fs_type;type rootfs, fs_type;type proc, fs_type;# Security-sensitive proc nodes that should not be writable to most.type proc_security, fs_type;type proc_drop_caches, fs_type;type proc_overcommit_memory, fs_type;# proc, sysfs, or other nodes that permit # configuration of kernel usermodehelpers.type usermodehelper, fs_type;type sysfs_usermodehelper, fs_type, sysfs_type;type qtaguid_proc, fs_type, mlstrustedobject;type proc_bluetooth_writable, fs_type;... service_contexts用于为 Android Binder 服务分配标签，以便控制哪些进程可以为相应服务添加（注册）和查找（查询） Binder 引用，在启动期间 servicemanager 进程会读取此配置。service_contexts 所在目录： 1234system/sepolicy/private/service_contextsdevice/manufacturer/sepolicy/device-name/service_contextsdevice/manufacturer/sepolicy/private/service_contextsdevice/manufacturer/sepolicy/common/service_contexts 查看 system/sepolicy/private/service_contexts 中的示例： 12345678910111213...launcherapps u:object_r:launcherapps_service:s0location u:object_r:location_service:s0lock_settings u:object_r:lock_settings_service:s0...media.camera u:object_r:cameraserver_service:s0media.camera.proxy u:object_r:cameraproxy_service:s0media.log u:object_r:audioserver_service:s0...netd u:object_r:netd_service:s0netpolicy u:object_r:netpolicy_service:s0netstats u:object_r:netstats_service:s0... service_contexts 中的 type 类型，基本都是在 service.te 文件中定义的： 1234system/sepolicy/public/service.tedevice/manufacturer/sepolicy/device-name/service.tedevice/manufacturer/sepolicy/private/service.tedevice/manufacturer/sepolicy/common/service.te 查看 system/sepolicy/public/service.te 中的示例： 12345678type audioserver_service, service_manager_type;...type cameraserver_service, service_manager_type;type default_android_service, service_manager_type;type drmserver_service, service_manager_type;type dumpstate_service, service_manager_type;type fingerprintd_service, service_manager_type;... 其他上下文标签 genfs_contexts用于为不支持扩展属性的文件系统（例如 proc, vfat ）分配标签。此配置会作为内核策略的一部分进行加载，但更改可能对内核 inode 无效。要全面应用更改，需要重新启动设备，或卸载并重新装载文件系统。此外通过使用 context=mount 选项，可以为装载的特定系统文件（例如 vfat ）分配特定标签。 property_contexts用于为 Android 系统属性分配标签，以便控制哪些进程可以设置这些属性。在启动期间 init 进程会读取此配置。 seapp_contexts用于为应用进程和 /data/data 目录分配标签。在每次应用启动时，zygote 进程都会读取此配置；在启动期间 installd 会读取此配置。 mac_permissions.xml用于根据应用签名和应用软件包名称（后者可选）为应用分配 seinfo 标记。随后分配的 seinfo 标记可在 seapp_contexts 文件中用作密钥，以便为带有该 seinfo 标记的所有应用分配特定标签。在启动期间 system_server 会读取此配置。 添加/修改策略 policy原则 采用最小权限原则，仅针对添加的内容调整 SELinux 策略 将各个软件组件拆分成多个负责执行单项任务的模块，创建将这些任务与无关功能隔离开来的 SELinux 策略 将这些策略放在 /device/manufacturer/sepolicy/device-name 目录中的 *.te 文件，然后使用 BOARD_SEPOLICY 变量将它们纳入到版本中 先将新域设为宽容域：在该域的 .te 文件中使用宽容声明 permissive *** ；分析结果并优化域定义，当版本中不再出现拒绝事件时，移除宽容声明 编译策略修改和添加，尽量都放在 /device/manufacturer/sepolicy/device-name 目录中实现，方便后续追溯。同时需要在 /device/manufacturer/device-name/BoardConfig.mk 中指定 sepolicy 子目录和每个新的策略文件。详细请参阅 system/sepolicy/README 文件。 1234567BOARD_SEPOLICY_DIRS += \ &lt;root&gt;/device/manufacturer/device-name/sepolicyBOARD_SEPOLICY_UNION += \ genfs_contexts \ file_contexts \ sepolicy.te 重新进行编译后，新策略设置会自动内置到最终的内核策略文件中。 示例以下为 Android 官网上提供的示例：为新服务添加标签并解决拒绝事件，通过 init 启动的服务需要在各自的 SELinux 域中运行。以下示例会将服务 foo 放入它自己的 SELinux 域中并为其授予权限。 该服务是在设备的 init.device.rc 文件中启动的，如下所示： 123// 服务进程对应的可执行文件service foo /system/bin/foo class core 创建一个新域 foo创建包含以下内容的文件 device/manufacturer/sepolicy/device-name/foo.te ：123456# 为进程定义一个类型# foo servicetype foo, domain;type foo_exec, exec_type, file_type;init_daemon_domain(foo) 这是 foo SELinux 域的初始模板，可以根据该可执行文件执行的具体操作为该模板添加规则。 为 /system/bin/foo 添加标签将以下内容添加到 device/manufacturer/sepolicy/device-name/file_contexts ： 123# 为进程对应可执行文件打标签，类型对应的是给进程分配的类型# file_contexts/system/bin/foo u:object_r:foo_exec:s0 这可确保为该可执行文件添加适当的标签，以便 SELinux 在适当的域中运行相应服务。 编译并刷写启动映像和系统映像 优化相应域的 SELinux 规则根据拒绝事件确定所需的权限。audit2allow 工具提供了一些实用的指南，但该工具仅适用于提供编写政策时所需的信息。切勿只是复制输出内容。 audit 日志分析SELinux 有大量的工具记录日志信息，或审核、访问尝试被策略允许或拒绝的信息。审核消息通常叫做 AVC 消息，它提供了详细了关于访问尝试的信息，包括是允许还是拒绝，源和目标的安全上下文，以及其它一些访问尝试涉及到资源信息。avc dennied 的示例 log : 123// a.txtavc: denied &#123; open &#125; for pid=1003 comm=”mediaserver” path=&quot;/dev/kgsl-3d0” dev=&quot;tmpfs&quot; scontext=u:r:mediaserver:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=1avc: denied &#123; read write &#125; for pid=1003 name=&quot;kgsl-3d0&quot; dev=&quot;tmpfs&quot; scontext=u:r:mediaserver:s0 tcontext=u:object_r:device:s0 tclass=chr_file permissive=1 可以通过 external/selinux/prebuilts/bin/audit2allow 提供的工具来分析： 1234xmt@server139:~/external/selinux/prebuilts/bin$ audit2allow -i a.txt#============= mediaserver ==============allow mediaserver device:chr_file &#123; read write &#125;; 工具自动生成，通常给的权限范围会过大，需要手动细化，满足最小权限原则。 后续 域转换 角色转换 实例分析 参考文档 Android selinux 官网 Android 官方文档 SELinux_Treble The SELinux Notebook, 4th Edition（SELinux 手册第 4 版） SELinux策略语言–类型强制(编写TE规则) SELinux 小结 阿拉神农-深入理解SELinux SEAndroid avc dennied权限问题解决方法 SEAndroid策略分析 SELinux_Treble 官网文档的翻译 SELinux策略实例–type_transition]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android HIDL]]></title>
    <url>%2F2018%2F12%2F27%2F0110-android-hidl%2F</url>
    <content type="text"><![CDATA[Android HIDL 基础知识，源码分析。 概念在 Android O 8.0 后引入的 Treble 项目，目的是将 Framework 和 HAL 层分开；Google 重点关注 Framework 及以上部分，HAL 及以下交给各厂商实现, HAL 层及厂商实现都会放到新的 /vendor 分区中；这样 Google 在后续 OTA 系统升级时，可以单独升级系统部分，而不需要修改厂商实现部分。因此重新定义了 Framework 和 HAL 层的接口，即 HIDL ；以及新增了接口层的测试 VTS: Vendor Test Suite ，确保厂商实现部分接口设计符合规范并能向前兼容。简而言之，Google 这么做主要目的是：不管厂商如何实现，修改了哪些东西，需要确保 Android 原生系统都能在这台设备上升级并使用。当然这种结构也方便手机厂商做 system 升级，如果当前版本已经是 Android O ，各个分区已经分配好，可以做到仅仅更新 AOSP 部分到 P ，而其他 vendor 可以保持不变，提供了一种可能性和便利性，实际上厂商是否愿意这么做呢？ HIDL: HAL Interface Definition Language ， HIDL 发音为 hide-l ，指定了 HAL 层和 Framework 层通信的接口，目的是 Framework和 HAL 层能相互通信；这样用户能够替换 Android 框架，而无需重新编译 HAL 。 HAL 类型HAL 有两种类型： Binder HAL绑定式 HAL ，通过 Binder 机制实现跨进程通信。 Passthrough HAL直通式 HAL ，通过 dlopen 方式加载库，也就是在同一进程直接调用。这里需要注意，默认情况下通常会使用 *Binder 化直通式 HAL *，也就是说最后仍然是跨进程 Binder 通信。 Binder HALAndroid O 开始，Framework 和 HAL 跨进程也是使用 Binder 互相通信，这种通信方式极大地增加了老版本中的 Binder 流量，因此新增了 Binder 域，官网推荐三个域的使用范围： /dev/binder用于 Framework 和 APP 之间的 IPC ，使用 AIDL 接口。 /dev/hwbinder用于 Framework 和 Vendor 进程之间的 IPC ，使用 HIDL 接口。用于供应商进程之间的 IPC ，使用 HIDL 接口。 /dev/vndbinder供应商/供应商进程之间的 IPC ，使用 AIDL 接口。 Binder 化直通式 HAL它实际是直通模式的 HAL ，通过 Binder 化来实现。比如 HAL 接口 a.b.c.d@M.N::IFoo，系统会创建两个软件包： a.b.c.d@M.N::IFoo-impl包含 HAL 的实现，并暴露函数 IFoo* HIDL_FETCH_IFoo(const char* name)。在旧版设备上，此软件包经过 dlopen 处理，且实现使用 HIDL_FETCH_IFoo 进行了实例化。也可以使用 hidl-gen 和 -Lc++-impl 以及 -Landroidbp-impl 来生成基础代码。 a.b.c.d@M.N::IFoo-service打开直通式 HAL，并将其自身注册为 Binder 化服务，从而使同一 HAL 实现能够同时以直通模式和 Binder 化模式使用。如果有一个 IFoo ，可以调用 sp&lt;IFoo&gt; IFoo::getService(string name, bool getStub) ，以获取对 IFoo 实例的访问权限。如果 getStub 为 True，则 getService 会尝试仅在直通模式下打开 HAL。如果 getStub 为 False，则 getService 会尝试找到 Binder 化服务；如果未找到，则它会尝试找到直通式服务。除了在 defaultPassthroughServiceImplementation 中，其余情况一律不得使用 getStub 参数。（搭载 Android O 的设备是完全 Binder 化的设备，因此不得在直通模式下打开服务。） 网络配置工具Android 中包含标准的 Linux 网络实用程序: ifconfig, ip, ip6tables 等，但是这些程序都在 system/bin 目录下， 在 Android O 之后，避免系统更新导致这些程序使用时不匹配，这些程序都被集成到 netutils-wrapper-1.0 工具中： 1234567ELUGA_Ray_710:/system/bin # ls *wrapper-* -llrwxr-xr-x 1 root shell 20 20*:56 ip-wrapper-1.0 -&gt; netutils-wrapper-1.0lrwxr-xr-x 1 root shell 20 20*:56 ip6tables-wrapper-1.0 -&gt; netutils-wrapper-1.0lrwxr-xr-x 1 root shell 20 20*:56 iptables-wrapper-1.0 -&gt; netutils-wrapper-1.0lrwxr-xr-x 1 root shell 20 20*:56 ndc-wrapper-1.0 -&gt; netutils-wrapper-1.0lrwxr-xr-x 1 root shell 20 20*:56 tc-wrapper-1.0 -&gt; netutils-wrapper-1.0-rwxr-xr-x 1 root shell 65248 20*:56 netutils-wrapper-1.0 Android O 之后，vendor 中不能直接调用 /system/bin/netutils-wrapper-1.0 ，否则会出错；也不能直接调用 /system/bin/ip &lt;FOO&gt; &lt;BAR&gt; ，而只能使用封装程序 /system/bin/ip-wrapper-1.0 &lt;FOO&gt; &lt;BAR&gt; ；如果 vendor 进程调用这些命令，需要在 SELinux policy 中添加： 1domain_auto_trans(VENDOR-DOMAIN-NAME, netutils_wrapper_exec, netutils_wrapper) 转换工具Android 源码中提供了工具将老旧版本的 hal 模块转换为 HIDL HAL 格式，工具： c2hal: system/tools/hidl/c2hal ，使用示例： 1c2hal -r android.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport -p android.hardware.nfc@1.0 hardware/libhardware/include/hardware/nfc.h 转换完成后，可以进一步手动修正部分小错误。 术语 Binder 化表示 HIDL 用于进程之间的远程过程调用，并通过类似 Binder 的机制来实现。 异步回调由 HAL 用户提供、传递给 HAL（通过 HIDL 方法）并由 HAL 调用以随时返回数据的接口。 同步回调将数据从服务器的 HIDL 方法实现返回到客户端；不用于返回无效值或单个原始值的方法。 客户端调用特定接口的方法的进程。 HAL 进程或框架进程可以是一个接口的客户端和另一个接口的服务器。 扩展也可以理解为继承；表示向另一接口添加方法和/或类型的接口，一个接口只能扩展另一个接口。可用于具有相同软件包名称的 Minor 版本递增，也可用于在旧软件包的基础上构建的新软件包。 生成表示将值返回给客户端的接口方法。要返回一个非原始值或多个值，则会生成同步回调函数。 接口方法和类型的集合。会转换为 C++ 或 Java 中的类。接口中的所有方法均按同一方向调用：客户端进程会调用由服务器进程实现的方法。 单向应用到 HIDL 方法时，表示该方法既不返回任何值也不会造成阻塞。 直通式HIDL 的一种模式，使用这种模式时，服务器是共享库，由客户端进行 dlopen 处理。在直通模式下，客户端和服务器是相同的进程，但代码库不同。此模式仅用于将旧版代码库并入 HIDL 模型。 服务器实现接口的方法的进程。 传输在服务器和客户端之间移动数据的 HIDL 基础架构。 版本软件包的版本。由两个整数组成： Major 版本和 Minor 版本。 Minor 版本递增可以添加（但不会更改）类型和方法。 应用二进制接口 `ABI应用编程接口 + 所需的任何二进制链接。 完全限定名称 fqName用于区分 hidl 类型的名称。例如： android.hardware.foo@1.0::IFoo 。 软件包共用一个版本的接口和数据类型的集合。包含 HIDL 接口和类型的软件包。例如： android.hardware.foo@1.0 。 软件包根目录包含 HIDL 接口的根目录软件包。例如： HIDL 接口 android.hardware 在软件包根目录 android.hardware.foo@1.0 中。 软件包根目录路径软件包根目录映射到的 Android 源代码树中的位置。 基础语法规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879ROOT = PACKAGE IMPORTS PREAMBLE &#123; ITEM ITEM ... &#125; // not for types.hal PREAMBLE = interface identifier EXTENDS | PACKAGE IMPORTS ITEM ITEM... // only for types.hal; no method definitionsITEM = ANNOTATIONS? oneway? identifier(FIELD, FIELD ...) GENERATES?; | struct identifier &#123; SFIELD; SFIELD; ...&#125;; // Note - no forward declarations | union identifier &#123; UFIELD; UFIELD; ...&#125;; | enum identifier: TYPE &#123; ENUM_ENTRY, ENUM_ENTRY ... &#125;; // TYPE = enum or scalar | typedef TYPE identifier;VERSION = integer.integer;PACKAGE = package android.hardware.identifier[.identifier[...]]@VERSION;PREAMBLE = interface identifier EXTENDSEXTENDS = &lt;empty&gt; | extends import_name // must be interface, not packageGENERATES = generates (FIELD, FIELD ...)// allows the Binder interface to be used as a type// (similar to typedef&apos;ing the final identifier)IMPORTS = [empty] | IMPORTS import import_name;TYPE = uint8_t | int8_t | uint16_t | int16_t | uint32_t | int32_t | uint64_t | int64_t | float | double | bool | string| identifier // must be defined as a typedef, struct, union, enum or import // including those defined later in the file| memory| pointer| vec&lt;TYPE&gt;| bitfield&lt;TYPE&gt; // TYPE is user-defined enum| fmq_sync&lt;TYPE&gt;| fmq_unsync&lt;TYPE&gt;| TYPE[SIZE]FIELD = TYPE identifierUFIELD = TYPE identifier | struct identifier &#123; FIELD; FIELD; ...&#125; identifier; | union identifier &#123; FIELD; FIELD; ...&#125; identifier;SFIELD = TYPE identifier | struct identifier &#123; FIELD; FIELD; ...&#125;; | union identifier &#123; FIELD; FIELD; ...&#125;; | struct identifier &#123; FIELD; FIELD; ...&#125; identifier; | union identifier &#123; FIELD; FIELD; ...&#125; identifier;SIZE = // Must be greater than zero constexprANNOTATIONS = [empty] | ANNOTATIONS ANNOTATIONANNOTATION = | @identifier | @identifier(VALUE) | @identifier(ANNO_ENTRY, ANNO_ENTRY ...)ANNO_ENTRY = identifier=VALUEVALUE = &quot;any text including \&quot; and other escapes&quot; | constexpr | &#123;VALUE, VALUE ...&#125; // only in annotationsENUM_ENTRY = identifier | identifier = constexpr 可以使用 /** */, /* */, // 来注释 [empty] 表示该字词可能为空 ? 跟在文本或字词后，表示它是可选的 ... 表示包含零个或多个项、用指定的分隔符号分隔的序列。HIDL 中不含可变参数 逗号 , 用于分隔序列元素 分号 ; 用于终止各个元素，包括最后的元素 大写字母是非终止符 italics 是一个令牌系列，例如 integer 或 identifier（标准 C 解析规则） constexpr 是 C 样式的常量表达式（如 1 + 1 和 1L &lt;&lt; 3） import_name 是软件包或接口名称，按 HIDL 版本编号中所述的方式加以限定 小写 words 是文本令牌 软件包软件包名称可以具有子级，例如 package.subpackage 。软件包前缀和对应的位置如下： 软件包前缀 位置 android.hardware.* hardware/interfaces/* android.frameworks.* frameworks/hardware/interfaces/* android.system.* system/hardware/interfaces/* android.hidl.* system/libhidl/transport/* 例如 package android.hardware.example.extension.light@2.0 软件包：可以在 hardware/interfaces/example/extension/light/2.0 下找到。软件包目录中包含扩展名为 .hal 的文件，每个文件均必须包含一个指定文件所属的软件包和版本的 package 语句；文件 types.hal（如果存在）并不定义接口，而是定义软件包中每个接口可以访问的数据类型。 版本编号软件包分版本，用两个整数表示： major.minor ： Major 版本不向后兼容递增 Major 版本号将会使 Minor 版本号重置为 0 。 Minor 版本向后兼容如果递增 Minor 版本号，则意味着较新版本完全向后兼容之前的版本。可以添加新的数据结构和方法，但不能更改现有的数据结构或方法签名。 可同时在一台设备上提供 HAL 的多个 Major 或 Minor 版本。不过 Minor 版本应优先于 Major 版本，因为与之前的 Minor 版本接口一起使用的客户端代码也适用于同一接口的后续 Minor 版本。 支持的注解主要用于 VTS 测试 @callflownext= @entry @exit hal 定义12345678interface IBar extends IFoo &#123; // IFoo is another interface // embedded types struct MyStruct &#123;/*...*/&#125;; // interface methods create(int32_t id) generates (MyStruct s); close();&#125;; 不含显式 extends 声明的接口会从 android.hidl.base@1.0::IBase （类似于 Java 中的 java.lang.Object ）隐式扩展。隐式导入的 IBase 接口声明了多种不应也不能在用户定义的接口中重新声明或以其他方式使用的预留方法，也就是说 hal 中不存在重载和重写！ 接口只能扩展一个其他接口（不支持多重继承），具有非零 Minor 版本号的软件包中的每个接口必须扩展一个以前版本的软件包中的接口： 存在 1.2 版本的软件包 original 中的接口 IFoo 小版本 Minor 升级到 1.3 版本，软件包 original 中的接口 IFoo 必须继承 1.2 版本的 IFoo 假设大版本 Major 升级到 4.0 版本，而软件包 derivative 中的接口 IBar 是继承于 1.2 版本的软件包 original 中的接口 IFoo 小版本 Minor 升级到 4.1 版本， IBar 必须扩展 4.0 版本的 IBar ；而不能继承 1.3 版本的 IFoo ，因为它是与 1.2 版本的 IFoo 绑定的 大版本 Major 再次升级到 5.0 版本，此时 IBar 可以直接 1.3 版本的 `IFoo 接口扩展并不意味着生成的代码中存在代码库依赖关系或跨 HAL 包含关系，接口扩展只是在 HIDL 级别导入数据结构和方法定义。HAL 中的每个方法必须在相应 HAL 中重新实现。 import 导入import 语句是用于访问其他软件包中的软件包接口和类型的 HIDL 机制，存在两种导入情况： import 语句位于 types.hal 文件中时，导入的内容对整个软件包可见，属于软件包级导入 improt 语句位于 custom.hal 接口文件中时，导入的内容只对当前接口文件可见，属于接口级导入 import 语句后，根据导入值分三种情况： 完整软件包导入导入值是一个软件包名称和版本，则系统会将整个软件包导入，即可访问整个软件包的接口或类型。 接口导入导入值是一个接口文件，则导入该接口以及 types.hal 两个文件。 类型导入导入值是 types.hal 中定义的某个类型，则仅将该类型导入，而 types.hal 中的其他类型不导入。 123import android.hardware.nfc@1.0; // 导入整个软件包import android.hardware.example@1.0::IQuux; // 导入接口文件和 types.halimport android.hardware.example@1.0::types; // 仅仅导入 types.hal 中定义的 types 类型 接口哈希 Hash 和版本控制文件 current.txtHIDL 接口哈希，是一种旨在防止意外更改接口并确保接口更改经过全面审查的机制。因为 HIDL 接口带有版本编号，也就是说接口一经发布便不得再更改。 软件包根目录必须有版本控制文件 current.txt ；如果创建一个软件包路径，如 -r vendor.awesome:vendor/awesome/interfaces ），则还应创建文件 $ANDROID_BUILD_TOP/vendor/awesome/interfaces/current.txt 。current.txt 必须包含接口哈希及接口全限定名称，比如 system/libhidl/transport/current.txt 文件内容为： 1234567891011121314151617# Do not change this file except to add new interfaces. Changing# pre-existing interfaces will fail VTS and break framework-only OTAs# HALs released in Android Ofc6c***da68 android.hidl.allocator@1.0::IAllocatorbdda***0fd9 android.hidl.base@1.0::IBase500e***7567 android.hidl.base@1.0::types4d04***0d3f android.hidl.manager@1.0::IServiceManager5055***50fb android.hidl.manager@1.0::IServiceNotification2b88***27c8 android.hidl.memory@1.0::IMapper4632***a16b android.hidl.memory@1.0::IMemory7c9f***4b7c android.hidl.token@1.0::ITokenManager# HALs released in Android O-MR10b94***4ef6 android.hidl.manager@1.1::IServiceManager current.txt 中的内容按照 Android 大版本来分隔，比如上半部分为 Android O ，下半部分为 Android O-MR1 ，厂商自定义的接口文件也应该遵循这个格式。 可以手动将哈希添加到 current.txt 文件中，也可以使用 hidl-gen 加上参数 -Lhash 选项添加。如下为针对类型文件、接口、整个软件包生成哈希： 12345678$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0::types9626fd18...f9d298a6 vendor.awesome.nfc@1.0::types$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0::INfc07ac2dc9...11e3cf57 vendor.awesome.nfc@1.0::INfc$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.09626fd18...f9d298a6 vendor.awesome.nfc@1.0::types07ac2dc9...11e3cf57 vendor.awesome.nfc@1.0::INfcf2fe5442...72655de6 vendor.awesome.nfc@1.0::INfcClientCallback 如果是新添加的 hal 软件包，则将生成哈希及对应接口文件，一并写入 current.txt 文件中： 1$ hidl-gen -L hash -r vendor.awesome:vendor/awesome/hardware/interfaces -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport vendor.awesome.nfc@1.0 &gt;&gt; vendor/awesome/hardware/interfaces/current.txt 接口文件的哈希，可以通过调用 IBase::getHashChain 来查看。 hidl-gen 编译接口时，会检查 HAL 软件包根目录中的 current.txt 文件，以查看 HAL 是否已被更改： 如果没有找到对应的哈希值，则继续编译，并认为接口没有发布 如果找到了对应哈希值，则做相应检查： 如果接口与哈希值匹配，则继续编译 如果接口与哈希值不匹配，则意味着接口被更改了，停止编译 所以，如果接口文件处于调试阶段，需要等调试完成后再发布到 current.txt 中；而接口文件一旦发布，将无法更改；如果想更改接口，必须升级版本号，也就是重新定义接口。比如 camera 相关接口的修改，必须升级版本号： 12345678// hardware/interfaces/current.txtc170***2d62f android.hardware.camera.device@1.0::ICameraDevice78e9***44076 android.hardware.camera.device@1.0::ICameraDeviceCallback28f0***44566 android.hardware.camera.device@1.0::ICameraDevicePreviewCallback4db4***352a3 android.hardware.camera.device@1.0::typesb32f***55918 android.hardware.camera.device@3.2::ICameraDevice63bf***b3b21 android.hardware.camera.device@3.2::ICameraDeviceCallback0fa3***7208e android.hardware.camera.device@3.2::ICameraDeviceSession 数据传递数据在传递过程中： .hal 文件接口中定义的方法默认为阻塞模式，如果需要采用非阻塞式则在方法前面使用关键字 oneway 方法调用和回调只能接受 in 参数，并且不支持 out, inout 参数 方法在数据传递时超过 4KB 以上的数据便被认为是过度调用；同时跨进程调用是基于 Binder 机制，所以总的数据传输不能超过 1MB 对于跨进程通信， HIDL 只使用参数回调函数，避免了内存所有权的棘手问题，特别是不能有效通过方法返回的值可以直接通过回调函数返回。这样既不将数据传递到 HIDL ，也不从 HIDL 接收数据，改变数据的所有权。数据只需要在被调用函数的持续时间内存在，并且可以在被调用函数返回后立即销毁。 HIDL 如果不使用 Binder RPC ，可以通过两种方法来转移数据： 共享内存分配的内存通过映射来共享。 快速消息队列 FMQHIDL 提供了一种可实现无等待消息传递的模板化消息队列类型。 快速消息队列 FMQHIDL 的远程过程调用 RPC 基础架构使用 Binder 机制，这意味着调用涉及开销、需要内核操作，并且可以触发调度程序操作。不过对于必须在开销较小且无内核参与的进程之间传输数据的情况， HIDL 提供了快速消息队列 FMQ 系统。FMQ 会创建具有所需属性的消息队列， MQDescriptorSync, MQDescriptorUnsync 对象可通过 HIDL RPC 调用发送，并可供接收进程用于访问消息队列。 它在直通式或绑定式模式下不使用内核或调度程序，从而创建可以借助内置 HIDL 类型 MQDescriptorSync 或 MQDescriptorUnsync 的参数通过 RPC 传递的对象。 MessageQueue 支持的队列类型 flavor 有两种： 未同步队列 flavor: kSynchronizedReadWrite可以溢出，并且可以有多个读取器；每个读取器都必须及时读取数据，否则数据将会丢失。未同步队列只有一个写入器，但可以有任意多个读取器。此类队列有一个写入位置；不过，每个读取器都会跟踪各自的独立读取位置。执行写入操作一定会成功（不会检查是否出现溢出情况），但前提是写入的内容不超出配置的队列容量（如果写入的内容超出队列容量，则操作会立即失败）。由于各个读取器的读取位置可能不同，因此每当新的写入操作需要空间时，系统都允许数据离开队列，而无需等待每个读取器读取每条数据。 已同步队列 flavor: kUnsynchronizedWrite不能溢出，并且只能有一个读取器。已同步队列有一个写入器和一个读取器，其中写入器有一个写入位置，读取器有一个读取位置。写入的数据量不可能超出队列可提供的空间；读取的数据量不可能超出队列当前存在的数据量。 这两种队列都不能下溢（从空队列进行读取将会失败），并且只能有一个写入器。 FMQ 相关源码路径如下，其中 MessageQueue 主要是模板，所以定义和代码实现都在该 .h 文件中： 12system/libfmq/include/fmq/MessageQueue.hsystem/libhidl/base/include/hidl/MQDescriptor.h 队列类型是在 MQDescriptor.h 中定义的： 123456789101112131415// MQDescriptor.henum MQFlavor : uint32_t &#123; /* * represents the wait-free synchronized flavor of the * FMQ. It is intended to be have a single reader and single writer. * Attempts to overflow/underflow returns a failure. */ kSynchronizedReadWrite = 0x01, /* * represents the flavor of FMQ where writes always succeed. * This flavor allows one writer and many readers. A read operation * can detect an overwrite and reset the read counter. */ kUnsynchronizedWrite = 0x02&#125;; 创建快速队列示例： 1234567891011121314151617#include &lt;fmq/MessageQueue.h&gt;using android::hardware::kSynchronizedReadWrite;using android::hardware::kUnsynchronizedWrite;using android::hardware::MQDescriptorSync;using android::hardware::MQDescriptorUnsync;using android::hardware::MessageQueue;....// For a synchronized non-blocking FMQmFmqSynchronized = new (std::nothrow) MessageQueue&lt;uint16_t, kSynchronizedReadWrite&gt; (kNumElementsInQueue);// For an unsynchronized FMQ that supports blockingmFmqUnsynchronizedBlocking = new (std::nothrow) MessageQueue&lt;uint16_t, kUnsynchronizedWrite&gt; (kNumElementsInQueue, true /* enable blocking operations */); MessageQueue&lt;T, flavor&gt;(numElements) 初始化程序负责创建并初始化支持消息队列功能的对象 MessageQueue&lt;T, flavor&gt;(numElements, configureEventFlagWord) 初始化程序负责创建并初始化支持消息队列功能和阻塞的对象 flavor 可以是 kSynchronizedReadWrite 同步队列或 kUnsynchronizedWrite 未同步队列 uint16_t 可以是任意不涉及嵌套式缓冲区（无 string 或 vec 类型）、句柄或接口的 HIDL 定义的类型 kNumElementsInQueue 表示队列的大小（以条目数表示）；它用于确定将为队列分配的共享内存缓冲区的大小 内存共享HIDL 共享内存 MemoryBlock 是构建在 hidl_memory ， HIDL @1.0::IAllocator 和 HIDL @1.0::IMapper 之上的抽象层，专为有多个内存块共用单个内存堆的 HIDL 服务而设计。也就是说， HIDL 共享内存块只是提供了一种使用思路，而不是像 FMQ 提供了具体实现；使用 MemoryBlock 可显著减少 mmap/munmap 数量和用户空间细分错误，从而提升性能。架构图如下，核心思想是多个内存块共用单个内存堆 hidl_memory ： 基本数据类型HIDL 基本数据类型及对应处理，都是在 system/libhidl/base 目录中实现的，基本数据类型的定义文件为 HidlSupport.h ，目录结构为： 123456789101112131415├── Android.bp├── HidlInternal.cpp├── HidlSupport.cpp├── include│ └── hidl│ ├── HidlInternal.h│ ├── HidlSupport.h│ ├── MQDescriptor.h│ ├── Status.h│ ├── SynchronizedQueue.h│ └── TaskRunner.h├── Status.cpp└── TaskRunner.cpp2 directories, 11 files hidl_death_recipient服务死亡通知，如果客户端注册该通知，当服务端断开时，会发出通知。 1234struct hidl_death_recipient : public virtual RefBase &#123; virtual void serviceDied(uint64_t cookie, const ::android::wp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; who) = 0;&#125;; hidl_handle句柄基本类型，是对 native_handle_t 句柄的封装： 123456789struct hidl_handle &#123; ... // explicit conversion const native_handle_t *getNativeHandle() const;private: ... details::hidl_pointer&lt;const native_handle_t&gt; mHandle __attribute__ ((aligned(8)));&#125;; 调用传递 hidl_handle 对象（复合类型的顶级或一部分）的 HIDL 接口方法时，其中包含的文件描述符的所有权如下所述： 将 hidl_handle 对象作为参数传递的调用程序会保留对其封装的 native_handle_t 中包含的文件描述符的所有权；该调用程序在完成对这些文件描述符的操作后，必须将这些文件描述符关闭 通过将 hidl_handle 对象传递到 _cb 函数来返回该对象的进程会保留对该对象封装的 native_handle_t 中包含的文件描述符的所有权；该进程在完成对这些文件描述符的操作后，必须将这些文件描述符关闭 接收 hidl_handle 的传输拥有对相应对象封装的 native_handle_t 中的文件描述符的所有权；接收器可在事务回调期间按原样使用这些文件描述符，但如果想在回调完成后继续使用这些文件描述符，则必须克隆原生句柄。事务完成时， transport 将自动对文件描述符执行 close 操作 HIDL 不支持在 Java 中使用句柄。 hidl_stringHIDL 字符串；通过 HIDL 接口将字符串传递到 Java 或从 Java 传递字符串将会导致字符集转换，而此项转换可能无法精确保留原始编码。 1234567891011struct hidl_string &#123; ... const char *c_str() const; size_t size() const; bool empty() const; ...private: details::hidl_pointer&lt;const char&gt; mBuffer; uint32_t mSize; // NOT including the terminating '\0'. ...&#125;; hidl_memorymemory 类型用于表示 HIDL 中未映射的共享内存。 1234567struct hidl_memory &#123; ...private: hidl_handle mHandle __attribute__ ((aligned(8))); uint64_t mSize __attribute__ ((aligned(8))); hidl_string mName __attribute__ ((aligned(8)));&#125;; hidl_vecvec&lt;T&gt; 模板用于表示包含 T 实例且大小可变的缓冲区。 T 可以是任何由 HIDL 提供的或由用户定义的类型，句柄除外。（ vec&lt;T&gt; 的 vec&lt;&gt; 将指向 vec&lt;T&gt; 结构体数组，而不是指向内部 T 缓冲区数组。） T 可以是以下项之一： 基本类型（例如 uint32_t ） 字符串 用户定义的枚举 用户定义的结构体 接口，或 interface 关键字（ vec&lt;IFoo&gt;，vec&lt;interface&gt; 仅在作为顶级参数时受支持） 句柄 bitfield&lt;U&gt; vec&lt;U&gt; ，其中 U 可以是此列表中的任何一项，接口除外（例如， vec&lt;vec&lt;IFoo&gt;&gt; 不受支持） U[]（有大小的 U 数组），其中 U 可以是此列表中的任何一项，接口除外 hidl_array表示多维数组。 1234567891011121314template&lt;typename T, size_t SIZE1, size_t... SIZES&gt;struct hidl_array &#123; ...private: T mBuffer[elementCount()];&#125;;// An array of T's. Assumes that T::operator=(const T &amp;) is defined.template&lt;typename T, size_t SIZE1&gt;struct hidl_array&lt;T, SIZE1&gt; &#123; ...private: T mBuffer[SIZE1];&#125;; hidl_versionHIDL 版本号。 1234567891011121314struct hidl_version &#123; ... constexpr uint16_t get_major() const &#123; return mMajor; &#125; constexpr uint16_t get_minor() const &#123; return mMinor; &#125;private: uint16_t mMajor; uint16_t mMinor;&#125;;inline android::hardware::hidl_version make_hidl_version( uint16_t major, uint16_t minor) &#123; return hidl_version(major,minor);&#125; .hal 文件自动生成代码基本步骤比如 .hal 文件准备添加到 hardware/interface 目录下： 新建包名对应的文件夹，比如 myintere 在包文件夹下新建主次版本对应的文件夹，比如 1.0 在版本目录下定义并编写 .hal 文件 执行 .hal 文件所在位置的 update-makefiles.sh 脚本（实际还是调用的 hidl-gen ），自动生成 Android.bp/mk 文件因为是在 hardware/interface 目录下添加的，则执行： ./hardware/interfaces/update-makefiles.sh ，自动生成对应 Android.bp 。 123456// 1. 新建目录xmt@server139:~/**/hardware/interfaces/tests/$ mkdir -p myintere/1.0// 2. 新建 .hal 文件xmt@server139:~/**/hardware/interfaces/tests/myintere/1.0$ touch IMyCallback.hal IMyIntere.hal// 3. 根目录下执行 update-makefiles.sh 脚本xmt@server139:~/**/$ ./hardware/interfaces/update-makefiles.sh hidl-gen 规则hidl-gen 转换规则以及生成哪些文件都是在自动生成的 Android.bp 文件中定义的； hidl, aidl 文件自动生成 java, cpp, h 文件工具源码都是在 system/tools/ 目录下： 123system/tools/├── aidl└── hidl 绑定式模式使用 hidl-gen 编译器并以 IFoo.hal 接口文件作为输入，它具有以下自动生成的文件： 由编译器生成的文件： IFoo.h描述 C++ 类中的纯 IFoo 接口；它包含 IFoo.hal 文件中的 IFoo 接口中所定义的方法和类型，必要时会转换为 C++ 类型。不包含与用于实现此接口的 RPC 机制（例如 HwBinder）相关的详细信息。类的命名空间包含软件包名称和版本号，例如 ::android::hardware::samples::IFoo::V1_0 。客户端和服务器都包含此标头：客户端用它来调用方法，服务器用它来实现这些方法。 IHwFoo.h头文件，其中包含用于对接口中使用的数据类型进行序列化的函数的声明。开发者不得直接包含其标头（它不包含任何类）。 BpFoo.h从 IFoo 继承的类，可描述接口的 HwBinder 代理（客户端）实现。开发者不得直接引用此类。 BnFoo.h保存对 IFoo 实现的引用的类，可描述接口的 HwBinder 存根 Stub （服务器端）实现。开发者不得直接引用此类。 FooAll.cpp包含 HwBinder 代理和 HwBinder 存根 Stub 的实现的类。当客户端调用接口方法时，代理会自动从客户端封送参数，并将事务发送到绑定内核驱动程序，该内核驱动程序会将事务传送到另一端的存根 Stub（该存根随后会调用实际的服务器实现）。 生成的这些文件结构类似于由 aidl-cpp 生成的文件。独立于 HIDL 使用的 RPC 机制的自动生成的文件是 IFoo.h ，其他所有文件都与 HIDL 使用的 HwBinder RPC 机制相关联。因此客户端和服务器实现不得直接引用除 IFoo 之外的任何内容。为了满足这项要求，只包含 IFoo.h 并链接到生成的共享库。 在直通式模式中，在编译 IFoo.hal 文件时，标头文件除了用于 Binder 通信的标头之外， hidl-gen 还会生成一个额外的直通标头文件 BsFoo.h ；此标头定义了会被执行 dlopen 操作的函数。由于直通式 HAL 在它们被调用的同一进程中运行，因此在大多数情况下，直通方法由直接函数调用（同一线程）来调用。 oneway 方法在各自的线程中运行，因为它们不需要等待 HAL 来处理它们（这意味着，在直通模式下使用 oneway 方法的所有 HAL 对于线程必须是安全的）。 BsFoo.h 文件类似于 BpFoo.h ，不过所需函数是直接调用的，并未使用 Binder 传递调用 IPC 。未来 HAL 的实现可能提供多种实现结果，例如 FooFast HAL 和 FooAccurate HAL 。在这种情况下，系统会针对每个额外的实现结果创建一个文件（例如 PTFooFast.cpp 和 PTFooAccurate.cpp ）。 hidl-gen 语法12345678910111213141516171819202122usage: hidl-gen [-p &lt;root path&gt;] -o &lt;output path&gt; -L &lt;language&gt; (-r &lt;interface root&gt;)+ [-t] fqname+ -h: Prints this menu. -L &lt;language&gt;: The following options are available: check : Parses the interface to see if valid but doesn&apos;t write any files. c++ : (internal) (deprecated) Generates C++ interface files for talking to HIDL interfaces. c++-headers : (internal) Generates C++ headers for interface files for talking to HIDL interfaces. c++-sources : (internal) Generates C++ sources for interface files for talking to HIDL interfaces. export-header : Generates a header file from @export enumerations to help maintain legacy code. c++-impl : Generates boilerplate implementation of a hidl interface in C++ (for convenience). c++-impl-headers: c++-impl but headers only c++-impl-sources: c++-impl but sources only java : (internal) Generates Java library for talking to HIDL interfaces in Java. java-constants : (internal) Like export-header but for Java (always created by -Lmakefile if @export exists). vts : (internal) Generates vts proto files for use in vtsd. makefile : (internal) Generates makefiles for -Ljava and -Ljava-constants. androidbp : (internal) Generates Soong bp files for -Lc++-headers and -Lc++-sources. androidbp-impl : Generates boilerplate bp files for implementation created with -Lc++-impl. hash : Prints hashes of interface in `current.txt` format to standard out. -o &lt;output path&gt;: Location to output files. -p &lt;root path&gt;: Android build root, defaults to $ANDROID_BUILD_TOP or pwd. -r &lt;package:path root&gt;: E.g., android.hardware:hardware/interfaces. -t: generate build scripts (Android.bp) for tests. fqName ： 完全限定名 -L ：指定生成的语言包 -r ： hal 文件路径 文件路径映射每个 hal 文件都可以通过软件包根目录映射及其完全限定名称找到，软件包根目录以参数 -r android.hardware:hardware/interfaces 的形式指定给 hidl-gen 。例如： 1hidl-gen -r vendor.awesome:some/device/independent/path/interfaces vendor.awesome.foo@1.0::IFoo 根目录参数为 vendor.awesome:some/device/independent/path/interfaces表示 vendor.awesome 对应的目录路径为：$ANDROID_BUILD_TOP/some/device/independent/path/interfaces 。 软件包为 vendor.awesome.foo@1.0::IFoo表示接口文件应该位于 vendor.awesome 目录路径下的 foo 接口的 1.0 版本下的 IFoo.hal 文件，即：$ANDROID_BUILD_TOP/some/device/independent/path/interfaces/foo/1.0/IFoo.hal 。 软件包路径映射不得重复，比如如果同时存在 -rsome.package:$PATH_A 和 -rsome.package:$PATH_B ，则 $PATH_A 必须等于 $PATH_B 才能实现一致的接口目录（这也能让接口版本控制起来更简单）。 代码文件生成 定义 hal 文件组 1234567filegroup &#123; name: &quot;android.hardware.camera.provider@2.4_hal&quot;, srcs: [ &quot;ICameraProvider.hal&quot;, &quot;ICameraProviderCallback.hal&quot;, ],&#125; 生成头文件 123456789101112131415161718192021// hardware/interfaces/camera/provider/2.4/Android.bpgenrule &#123; name: &quot;android.hardware.camera.provider@2.4_genc++_headers&quot;, tools: [&quot;hidl-gen&quot;], cmd: &quot;$(location hidl-gen) -o $(genDir) -Lc++-headers -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.camera.provider@2.4&quot;, srcs: [ &quot;:android.hardware.camera.provider@2.4_hal&quot;, // hal 文件组 ], out: [ &quot;android/hardware/camera/provider/2.4/ICameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/IHwCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/BnHwCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/BpHwCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/BsCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/ICameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/IHwCameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/BnHwCameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/BpHwCameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/BsCameraProviderCallback.h&quot;, ],&#125; 生成 CPP 文件 12345678910111213// hardware/interfaces/camera/provider/2.4/Android.bpgenrule &#123; name: &quot;android.hardware.camera.provider@2.4_genc++&quot;, tools: [&quot;hidl-gen&quot;], cmd: &quot;$(location hidl-gen) -o $(genDir) -Lc++-sources -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.camera.provider@2.4&quot;, srcs: [ &quot;:android.hardware.camera.provider@2.4_hal&quot;, // hal 文件组 ], out: [ &quot;android/hardware/camera/provider/2.4/CameraProviderAll.cpp&quot;, &quot;android/hardware/camera/provider/2.4/CameraProviderCallbackAll.cpp&quot;, ],&#125; HIDL 服务新增函数HIDL 服务在代码自动生成，每个服务对应的头文件中，比如 IFoo.h 都会自动添加如下几个函数： 123456789// 获取服务static ::android::sp&lt;IFoo&gt; getService( const std::string &amp;serviceName="default", bool getStub=false);// 注册服务::android::status_t registerAsService( const std::string &amp;serviceName="default");// 服务注册成功后的通知static bool registerForNotifications( const std::string &amp;serviceName, const ::android::sp&lt;IServiceNotification&gt; &amp;notification); getService ：获取服务 registerAsService ：注册服务 registerForNotifications ：注册通知监听事件，服务注册成功后会发出通知 服务注册与获取服务端注册 Binder 服务HIDL 接口使用 IInterface::registerAsService 来注册 Binder 服务，注册的名称不需要与接口或软件包名称相关。如果没有指定名称，则默认为 default ； HIDL 接口调用 android::hardware::IInterface::getInterfaceVersion 可以查看当前接口的版本。 12345sp&lt;IFoo&gt; myFoo = new Foo();status_t status = myFoo-&gt;registerAsService(); // 默认值为 "default"sp&lt;IFoo&gt; anotherFoo = new Foo();status_t anotherStatus = anotherFoo-&gt;registerAsService("another_foo_service"); // 显示指定服务名称 Binder 化直通式首先要理解 Binder 化直通式 HAL ，指的是 HAL 服务端注册的方式：以直通的方式加载服务端，并向 hwservicemanager 注册该服务；通过函数 defaultPassthroughServiceImplementation&lt;IFoo&gt; 来注册： 12defaultPassthroughServiceImplementation&lt;ICameraProvider&gt;( "legacy/0", /*maxThreads*/ 6); 下面是源码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// LegacySupport.hnamespace android &#123;namespace hardware &#123;/** * Registers passthrough service implementation. */template&lt;class Interface&gt;__attribute__((warn_unused_result))status_t registerPassthroughServiceImplementation( std::string name = "default") &#123; // 直通式加载服务端 sp&lt;Interface&gt; service = Interface::getService(name, true /* getStub */); if (service == nullptr) &#123; ALOGE(...); return EXIT_FAILURE; &#125; LOG_FATAL_IF(...); // 向 hwservicemanager 注册服务 status_t status = service-&gt;registerAsService(name); if (status == OK) &#123; ALOGI(...); &#125; else &#123; ALOGE(...); &#125; return status;&#125;template&lt;class Interface&gt;__attribute__((warn_unused_result))status_t defaultPassthroughServiceImplementation(std::string name, size_t maxThreads = 1) &#123; configureRpcThreadpool(maxThreads, true); status_t result = registerPassthroughServiceImplementation&lt;Interface&gt;(name); if (result != OK) &#123; return result; &#125; joinRpcThreadpool(); return 0;&#125;template&lt;class Interface&gt;__attribute__((warn_unused_result))status_t defaultPassthroughServiceImplementation(size_t maxThreads = 1) &#123; return defaultPassthroughServiceImplementation&lt;Interface&gt;( "default", maxThreads);&#125; registerPassthroughServiceImplementation 函数中，在 getService 时，参数 getStub 为 ture ，即通过直通式加载服务端；拿到直通式服务端 Interface 后，又通过 registerAsService 向 hwservicemanager 注册该服务。即加载服务端的当前进程，作为服务进程；客户端从 hwservicemanager 可以查到服务端，并通过 Binder 和服务进程通信。 客户端获取服务HIDL 接口因为有版本区分，所以每个接口文件都可以被认为是单独的、唯一的。因此 IFooService 版本 1.1 和 IFooService 版本 2.2 都可以注册为 foo_service ，并且两个接口上的 getService(&quot;foo_service&quot;) 都可获取该接口的已注册服务。因此在大多数情况下，注册或发现服务均无需提供名称参数（也就是说名称为 default ）。 12345678// C++sp&lt;V1_1::IFooService&gt; service = V1_1::IFooService::getService();sp&lt;V1_1::IFooService&gt; alternateService = V1_1::IFooService::getService(&quot;another_foo_service&quot;);// JavaV1_1.IFooService service = V1_1.IFooService.getService(true /* retry */);V1_1.IFooService alternateService = V1_1.IFooService.getService(&quot;another&quot;, true /* retry */); 客户端通过 getService 来获取服务端，而 getService 是每个 .hal 文件在自动生成源码时，都会自动添加的函数，函数原型为（这里以 IServiceManager.hal 为例）：static ::android::sp&lt;IServiceManager&gt; getService(const std::string &amp;serviceName=&quot;default&quot;, bool getStub=false);除了 &lt;&gt; 里的接口文件类型不一样，所有的 .hal 文件都会生成同样的代码；而它的实现则是在对应的 .cpp 文件中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ServiceManagerAll.cpp::android::sp&lt;IServiceManager&gt; IServiceManager::getService( const std::string &amp;serviceName, const bool getStub) &#123; using ::android::hardware::defaultServiceManager; using ::android::hardware::getPassthroughServiceManager; ... sp&lt;IServiceManager&gt; iface = nullptr; // 获取绑定式 IServiceManager const sp&lt;IServiceManager&gt; sm = defaultServiceManager(); if (sm == nullptr) &#123; ALOGE("getService: defaultServiceManager() is null"); return nullptr; &#125; ... for (int tries = 0; !getStub &amp;&amp; (vintfHwbinder || (vintfLegacy &amp;&amp; tries == 0)); tries++) &#123; ... // 通过绑定式 IServiceManager 获取服务端 Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = sm-&gt;get(IServiceManager::descriptor, serviceName); ... sp&lt;::android::hidl::base::V1_0::IBase&gt; base = ret; ... // 强制转换为服务端对应类型，这里以 IServiceManager 为例 Return&lt;sp&lt;IServiceManager&gt;&gt; castRet = IServiceManager::castFrom(base, true /* emitError */); ... iface = castRet; ... return iface; &#125; if (getStub || vintfPassthru || vintfLegacy) &#123; // 获取直通式 IServiceManager const sp&lt;IServiceManager&gt; pm = getPassthroughServiceManager(); if (pm != nullptr) &#123; // 通过直通式 IServiceManager 获取服务端 Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = pm-&gt;get(IServiceManager::descriptor, serviceName); if (ret.isOk()) &#123; sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret; if (baseInterface != nullptr) &#123; // 强制转换为服务端对应类型，这里以 IServiceManager 为例 iface = IServiceManager::castFrom(baseInterface); // 直通模式中如果 getStub 为 false，返回的是 BsServiceManager if (!getStub || trebleTestingOverride) &#123; iface = new BsServiceManager(iface); &#125; &#125; &#125; &#125; &#125; return iface;&#125; getService 主要是根据参数 getStub 的值来决定采用哪种方式获取服务端： 为 false 时通过 defaultServiceManager 获取服务端，即绑定式。 为 true 时通过 getPassthroughServiceManager 获取服务端，即直通式。 这两个函数下面会详细介绍。 服务死亡通知客户端需要注册服务终止通知接收器，当服务终止时，客户端收到通知；接收器需要继承 hidl_death_recipient 子类，并实现对应的方法。 123456789class IMyDeathReceiver : hidl_death_recipient &#123; virtual void serviceDied(uint64_t cookie, wp&lt;IBase&gt;&amp; service) override &#123; log(&quot;RIP service %d!&quot;, cookie); // Cookie should be 42 &#125;&#125;;....IMyDeathReceiver deathReceiver = new IMyDeathReceiver();m_importantService-&gt;linkToDeath(deathReceiver, 42); 源码结构源码目录速查表实现源码路径为： 123system/libhidlsystem/libhwbindersystem/hwservicemanager libhidl主要包含三个动态库： libhidlbase, libhidltransport, libhidlmemory ；其中 libhidlbase 主要是 hidl 的基本类型相关； libhidlmemory 是封装了 memory 通过 IMapper 来映射；libhidltransport 包含直通式 IServiceManager.hal 的实现。 123456789101112131415161718192021222324252627libhidl/├── base│ ├── Android.bp│ ├── HidlInternal.cpp│ ├── HidlSupport.cpp│ ├── include│ ├── Status.cpp│ └── TaskRunner.cpp├── libhidlmemory│ ├── Android.bp│ ├── include│ └── mapping.cpp├── transport│ ├── allocator│ ├── Android.bp│ ├── base│ ├── current.txt│ ├── HidlBinderSupport.cpp│ ├── HidlTransportSupport.cpp│ ├── HidlTransportUtils.cpp│ ├── include│ ├── manager│ ├── memory│ ├── ServiceManagement.cpp│ ├── Static.cpp│ └── token└── ... libhwbinder对应生成 libhwbinder 库，是 .hal 文件 Binder 通信相关库。 123456789101112131415161718192021libhwbinder/├── Android.bp├── Binder.cpp├── BpHwBinder.cpp├── BufferedTextOutput.cpp├── Debug.cpp├── IInterface.cpp├── include│ └── hwbinder├── IPCThreadState.cpp├── MODULE_LICENSE_APACHE2├── NOTICE├── OWNERS├── Parcel.cpp├── PREUPLOAD.cfg├── ProcessState.cpp├── Static.cpp├── TextOutput.cpp└── vts ├── OWNERS └── performance hwservicemanager生成可执行文件 hwservicemanager ，是 HIDL 绑定式服务的大管家。 123456789101112131415161718hwservicemanager/├── AccessControl.cpp├── AccessControl.h├── Android.bp├── HidlService.cpp├── HidlService.h├── hwservicemanager.rc├── hwservicemanagerTest.cpp├── MODULE_LICENSE_APACHE2├── NOTICE├── OWNERS├── service.cpp├── ServiceManager.cpp├── ServiceManager.h├── TokenManager.cpp├── TokenManager.h├── Vintf.cpp└── Vintf.h libhidl 目录libhidlbase 库libhidlbase 库对应的源码列表如下： 1234567891011121314base/├── Android.bp├── HidlInternal.cpp├── HidlSupport.cpp├── include│ └── hidl│ ├── HidlInternal.h│ ├── HidlSupport.h│ ├── MQDescriptor.h│ ├── Status.h│ ├── SynchronizedQueue.h│ └── TaskRunner.h├── Status.cpp└── TaskRunner.cpp HidlInternalhidl 内部使用的一些类、字符串定义等等。 hal 客户端/服务端都不会使用。 HidlSupporthidl 支持的基本数据类型（不包含 C++, Java 类型）。 MQDescripto快速消息队列 fmq 中相关类型。 Status表示 hidl 通信的状态和返回值，比如成功、失败、异常等等。 SynchronizedQueue同步队列。 TaskRunner后台无限循环的任务，使用 SynchronizedQueue 队列保存任务。 libhidlmemory 库libhidlmemory 库对应的源码列表如下： 123456libhidlmemory/├── Android.bp├── include│ └── hidlmemory│ └── mapping.h└── mapping.cpp 就一个有效文件 mapping ，对应头文件： 12345678910111213// mapping.hnamespace android &#123;namespace hardware &#123;/** * Returns the IMemory instance corresponding to a hidl_memory object. * If the shared memory cannot be fetched, this returns nullptr. */sp&lt;android::hidl::memory::V1_0::IMemory&gt; mapMemory( const hidl_memory &amp;memory);&#125; // namespace hardware&#125; // namespace android 只包含一个功能函数：将 hidl_memory 内存映射后，返回对应的 IMemory 。 libhidlmemory 库是对 system/libhidl/transport/memory 的封装，而 transport/memory 则是具体的实现。 android.hidl.* 软件包system/libhidl/transport/* 目录下包含 5 个软件包，这些软件包以 android.hidl.* 开头，它们是 hidl 的基础软件包： base定义了 IBase.hal ，它的功能类似 Java Object ，也就是说 Ibase.hal 是所有 hal 文件的父类。每个 hal 文件在自动生成源码时，都会自动添加 IBase 中的函数及其默认实现。 allocator定义了内存分配接口 IAllocator.hal ，内存分配的具体实现为 AshmemAllocator 。 memory定义了内存映射接口 IMapper.hal 以及内存接口 IMemory.hal ；而内存映射的具体实现为 AshmemMapper ，内存块 IMemory 的具体实现为 AshmemMemory 。 manager定义了 IServiceManager.hal 相关功能接口；它有两个实现：直通式是在 system/libhidl/ServiceManagement.cpp 中实现的，对应 libhidltransport 库；绑定式是在 system/hwservicemanager/ServiceManager.cpp 中实现的，对应 hwservicemanager 可执行文件。 token定义了接口 ITokenManager.hal ，它可以将 hidl 接口转换为 token 方便跨进程传输；该接口是在 hwservicemanager 中实现的。 hidl 相关的内存分配和映射，都是使用的匿名共享内存机制 Ashmem ； IServiceManager 服务管理分为直通式和绑定式，是在不同文件中实现的。 IBase 文件路径为 system/libhidl/transport/base/1.0/IBase.hal ，是所有 hal 的基础接口，类似 Java 中的 Object 类；因为 hidl 中不存在重写和重载，所以自定义的 hal 文件中函数名不能和下面的重复： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package android.hidl.base@1.0;interface IBase &#123; // 测试服务是否正在运行 ping(); /* * Provides run-time type information for this object. * For example, for the following interface definition: * package android.hardware.foo@1.0; * interface IParent &#123;&#125;; * interface IChild extends IParent &#123;&#125;; * return:interfaceChain on an IChild object must yield the following * [&quot;android.hardware.foo@1.0::IChild&quot;, * &quot;android.hardware.foo@1.0::IParent&quot; * &quot;android.hidl.base@1.0::IBase&quot;] */ interfaceChain() generates (vec&lt;string&gt; descriptors); /* * Provides run-time type information for this object. * For example, for the following interface definition: * package android.hardware.foo@1.0; * interface IParent &#123;&#125;; * interface IChild extends IParent &#123;&#125;; * Calling interfaceDescriptor on an IChild object must yield * &quot;android.hardware.foo@1.0::IChild&quot; * * @return descriptor a descriptor of the run-time type of the * object (the first element of the vector returned by * interfaceChain()) */ interfaceDescriptor() generates (string descriptor); oneway notifySyspropsChanged(); linkToDeath(death_recipient recipient, uint64_t cookie) generates (bool success); unlinkToDeath(death_recipient recipient) generates (bool success); oneway setHALInstrumentation(); getDebugInfo() generates (DebugInfo info); debug(handle fd, vec&lt;string&gt; options); /* * For example, for the following interface definition: * package android.hardware.foo@1.0; * interface IParent &#123;&#125;; * interface IChild extends IParent &#123;&#125;; * return:interfaceChain on an IChild object must yield the following * [(hash of IChild.hal), * (hash of IParent.hal) * (hash of IBase.hal)]. * * SHA-256 is used as the hashing algorithm. Each hash has 32 bytes * according to SHA-256 standard. * * @return hashchain a vector of SHA-1 digests */ getHashChain() generates (vec&lt;uint8_t[32]&gt; hashchain);&#125;; libhidltransport 库libhidltransport 库中的头文件 #include &lt;hidl/ServiceManagement.h&gt; ，包含了几组重要函数，用来区分当前是客户端采用绑定式还是直通式来获取服务端： 1234567// ServiceManagement.h// These functions are for internal use by hidl. If you want to get ahold// of an interface, the best way to do this is by calling IFoo::getService()sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; defaultServiceManager();sp&lt;::android::hidl::manager::V1_1::IServiceManager&gt; defaultServiceManager1_1();sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; getPassthroughServiceManager();sp&lt;::android::hidl::manager::V1_1::IServiceManager&gt; getPassthroughServiceManager1_1(); defaultServiceManager ：绑定式服务管理 IServiceManager getPassthroughServiceManager ：直通式服务管理 IServiceManager 它们都是在 ServiceManagement.cpp 中实现的，先看绑定式源码： 123456789101112131415161718192021222324252627282930313233// ServiceManagement.cppsp&lt;IServiceManager1_0&gt; defaultServiceManager() &#123; return defaultServiceManager1_1();&#125;sp&lt;IServiceManager1_1&gt; defaultServiceManager1_1() &#123; &#123; AutoMutex _l(details::gDefaultServiceManagerLock); if (details::gDefaultServiceManager != NULL) &#123; return details::gDefaultServiceManager; &#125; if (access("/dev/hwbinder", F_OK|R_OK|W_OK) != 0) &#123; // HwBinder not available on this device or not accessible to // this process. return nullptr; &#125; waitForHwServiceManager(); while (details::gDefaultServiceManager == NULL) &#123; details::gDefaultServiceManager = fromBinder&lt;IServiceManager1_1, BpHwServiceManager, BnHwServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); if (details::gDefaultServiceManager == NULL) &#123; LOG(ERROR) &lt;&lt; "..."; sleep(1); &#125; &#125; &#125; return details::gDefaultServiceManager;&#125; 它的核心代码是 fromBinder 这个模板函数，这里需要注意 ProcessState::self()-&gt;getContextObject(NULL) 这句代码的含义是：获取 handle 为 0 的 IBinder ，而 handle 为 0 表示是 hwservicemanager 守护进程，后续在 hwservicemanager 进程中做详细介绍。这里 ProcessState, IPCThreadState 等，虽然都是在 libhwbinder 库中，实际上和 Framework Binder 中代码很多都是相同，实现的功能也大致相同。fromBinder 是在 HidlBinderSupport.h 头文件中定义的： 1234567891011121314151617181920// HidlBinderSupport.htemplate &lt;typename IType, typename ProxyType, typename StubType&gt;sp&lt;IType&gt; fromBinder(const sp&lt;IBinder&gt;&amp; binderIface) &#123; using ::android::hidl::base::V1_0::IBase; using ::android::hidl::base::V1_0::BnHwBase; if (binderIface.get() == nullptr) &#123; return nullptr; &#125; if (binderIface-&gt;localBinder() == nullptr) &#123; return new ProxyType(binderIface); &#125; sp&lt;IBase&gt; base = static_cast&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl(); if (details::canCastInterface(base.get(), IType::descriptor)) &#123; StubType* stub = static_cast&lt;StubType*&gt;(binderIface.get()); return stub-&gt;getImpl(); &#125; else &#123; return nullptr; &#125;&#125; 模板代码表示，如果是远程访问，则新建代理对象即 BpHwServiceManager ，即客户端持有服务端的代理；如果是本地调用，则直接转换为 BnHwServiceManager ，换句话说这里客户端就是服务端自己。当是远程访问时，实际的 IServiceManager 是由 hwservicemanager 进程中 ServiceManager 实现的。 再看直通式源码： 123456789// ServiceManagement.cppsp&lt;IServiceManager1_0&gt; getPassthroughServiceManager() &#123; return getPassthroughServiceManager1_1();&#125;sp&lt;IServiceManager1_1&gt; getPassthroughServiceManager1_1() &#123; static sp&lt;PassthroughServiceManager&gt; manager( new PassthroughServiceManager()); return manager;&#125; 直通模式获取服务端时，直接返回的 PassthroughServiceManager 对象，通过它获取服务端 get 方法源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879struct PassthroughServiceManager : IServiceManager1_1 &#123; static void openLibs( const std::string&amp; fqName, std::function&lt;bool /* continue */ (void* /* handle */, const std::string&amp; /* lib */, const std::string&amp; /* sym */)&gt; eachLib) &#123; //fqName looks like android.hardware.foo@1.0::IFoo size_t idx = fqName.find(&quot;::&quot;); ... std::string packageAndVersion = fqName.substr(0, idx); std::string ifaceName = fqName.substr(idx + strlen(&quot;::&quot;)); const std::string prefix = packageAndVersion + &quot;-impl&quot;; // hardcode 服务端必须包含一个 HIDL_FETCH_ 开头的函数 const std::string sym = &quot;HIDL_FETCH_&quot; + ifaceName; const int dlMode = RTLD_LAZY; void *handle = nullptr; ... std::vector&lt;std::string&gt; paths = &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, HAL_LIBRARY_PATH_VNDK_SP, HAL_LIBRARY_PATH_SYSTEM&#125;; ... for (const std::string&amp; path : paths) &#123; std::vector&lt;std::string&gt; libs = search(path, prefix, &quot;.so&quot;); for (const std::string &amp;lib : libs) &#123; const std::string fullPath = path + lib; // 找到库文件，打开后返回句柄 if (path != HAL_LIBRARY_PATH_SYSTEM) &#123; handle = android_load_sphal_library( fullPath.c_str(), dlMode); &#125; else &#123; handle = dlopen(fullPath.c_str(), dlMode); &#125; // 没有找到则继续循环查找 if (handle == nullptr) &#123; const char* error = dlerror(); LOG(ERROR)...; continue; &#125; // 回调传入的函数 if (!eachLib(handle, lib, sym)) &#123; return; &#125; &#125; &#125; &#125; Return&lt;sp&lt;IBase&gt;&gt; get(const hidl_string&amp; fqName, const hidl_string&amp; name) override &#123; sp&lt;IBase&gt; ret = nullptr; openLibs(fqName, [&amp;](void* handle, const std::string &amp;lib, const std::string &amp;sym) &#123; IBase* (*generator)(const char* name); *(void **)(&amp;generator) = dlsym(handle, sym.c_str()); if(!generator) &#123; const char* error = dlerror(); LOG(ERROR)...; dlclose(handle); return true; &#125; ret = (*generator)(name.c_str()); if (ret == nullptr) &#123; dlclose(handle); return true; &#125; registerReference(fqName, name); return false; &#125;); return ret; &#125; ...&#125; openLibs 首先根据全限定名解析出版本号，以及 .hal 接口名称，再查找其实现库即 IFoo-impl.so 库，查找路径为 HAL_LIBRARY_PATH_SYSTEM 等等，它们的定义如下： 123456789101112131415161718192021// HidlInternal.h#define HAL_LIBRARY_PATH_SYSTEM_64BIT "/system/lib64/hw/"#define HAL_LIBRARY_PATH_VNDK_SP_64BIT "/system/lib64/vndk-sp/hw/"#define HAL_LIBRARY_PATH_VENDOR_64BIT "/vendor/lib64/hw/"#define HAL_LIBRARY_PATH_ODM_64BIT "/odm/lib64/hw/"#define HAL_LIBRARY_PATH_SYSTEM_32BIT "/system/lib/hw/"#define HAL_LIBRARY_PATH_VNDK_SP_32BIT "/system/lib/vndk-sp/hw/"#define HAL_LIBRARY_PATH_VENDOR_32BIT "/vendor/lib/hw/"#define HAL_LIBRARY_PATH_ODM_32BIT "/odm/lib/hw/"#if defined(__LP64__)#define HAL_LIBRARY_PATH_SYSTEM HAL_LIBRARY_PATH_SYSTEM_64BIT#define HAL_LIBRARY_PATH_VNDK_SP HAL_LIBRARY_PATH_VNDK_SP_64BIT#define HAL_LIBRARY_PATH_VENDOR HAL_LIBRARY_PATH_VENDOR_64BIT#define HAL_LIBRARY_PATH_ODM HAL_LIBRARY_PATH_ODM_64BIT#else#define HAL_LIBRARY_PATH_SYSTEM HAL_LIBRARY_PATH_SYSTEM_32BIT#define HAL_LIBRARY_PATH_VNDK_SP HAL_LIBRARY_PATH_VNDK_SP_32BIT#define HAL_LIBRARY_PATH_VENDOR HAL_LIBRARY_PATH_VENDOR_32BIT#define HAL_LIBRARY_PATH_ODM HAL_LIBRARY_PATH_ODM_32BIT#endif 也就是说在这些路径中搜索 IFoo-impl.so 库文件，直到找到为止。 IFoo.hal 的实现文件 Foo.cpp 中，必须包含 HIDL_FETCH_IFoo 的函数，这个是在 openLibs 中代码写死的。通常在 HIDL_FETCH_IFoo 中， new Foo() 来新建 Foo 对象。 直通式中获取服务端的流程：先通过 openLibs 加载实现库 IFoo-impl.so ，再调用 HIDL_FETCH_IFoo 方法，得到 Foo 对象（即服务端）。也就是说，直通式 Passthrough HAL 中客户端直接将服务端的代码库加载到当前进程中，这也是 Treble 架构中对老版本 HAL 的兼容：在 HIDL 之前， HAL 都是通过 dlopen 来直接加载的。 libhwbinder 目录libhwbinder 库目录，主要是实现了 hwbinder 通信，它的实现方式绝大部分都和 Framework Binder 中一致，参考Android Binder 机制 。libhwbinder 目录的代码基本是从 Framework Binder 代码拷贝过来，修改了部分 Bp, Bn Binder 的名称，以及 /dev/hwbinder 驱动设备文件。 hwBinder 类图结构 BpHwRefBase 中的 mRemote 指向了 BpHwBinder BpHwBinder 中的 mHandle 是一个句柄，指向 BHwBinder ，它们两个之间通过 Binder Driver 来通信 IBase 类图结构 IBase 是所有 HIDL 服务的基类， BnHwBase 中的 _hidl_mImpl 指向了 HIDL 服务的具体实现类。 ProcessState这里主要介绍 ProcessState 中两个函数：构造函数和 getContextObject 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// ProcessState.cpp// 大约 1 M#define BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)#define DEFAULT_MAX_BINDER_THREADS 0 // 默认最大线程数为 0static int open_driver()&#123; // 打开驱动文件 int fd = open("/dev/hwbinder", O_RDWR | O_CLOEXEC); if (fd &gt;= 0) &#123; int vers = 0; status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); ... size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; // 设置默认最大线程数 result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); if (result == -1) &#123; ALOGE("...); &#125; &#125; else &#123; ALOGW(...); &#125; return fd;&#125;ProcessState::ProcessState() : mDriverFD(open_driver()) , mVMStart(MAP_FAILED) , ...&#123; if (mDriverFD &gt;= 0) &#123; // mmap the binder, providing a chunk of virtual // address space to receive transactions. // 映射内存空间 mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); if (mVMStart == MAP_FAILED) &#123; // *sigh* ALOGE("Using /dev/hwbinder failed...\n"); close(mDriverFD); mDriverFD = -1; &#125; &#125; else &#123; ALOGE("..."); &#125;&#125; ProcessState 构造函数中实现了如下功能： 打开 /dev/hwbinder 设备，该文件节点和 Binder 通信 初始配置驱动的最大线程数为 0 ，后续可以通过 setThreadPoolConfiguration 来修改 mmap 映射内存空间，大概 1MB 12345678910111213141516171819202122232425262728293031323334353637// ProcessState.cppsp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; /*caller*/)&#123; return getStrongProxyForHandle(0);&#125;sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); handle_entry* e = lookupHandleLocked(handle); if (e != NULL) &#123; // We need to create a new BpHwBinder if there isn't currently // one, OR we are unable to acquire a weak reference on this // current one. See comment in getWeakProxyForHandle() // for more info about this. IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; b = new BpHwBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; // This little bit of nastyness is to allow us to add a // primary reference to the remote proxy when this // team doesn't have one but another team is // sending the handle to us. result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; getContextObject 函数中调用 getStrongProxyForHandle(0) ，即返回句柄为 0 的代理，而句柄为 0 表示是服务大管家，后面 hwservicemanager 中会详细介绍。当查到句柄存在时，新建 BpHwBinder ，它是所有 Bp***Binder 的父类。 hwservicemanager 进程hwservicemanager 是 HIDL 服务大管家，负责管理系统中的所有 HIDL 注册的绑定式服务，由 init 进程启动。 Binder 通信基础知识先复习下 Framework Binder 通信的基础知识： IInterface 表示服务端能够提供的服务 IBinder 用来实现跨进程通信，分为 BnBinder, BpBinder 客户端和服务端通信过程： 服务端通过 BnBinder 实现 IInterface 对应功能 客户端通过 BpBinder 调用 IInterface 对应功能； BpBinder 是 BnBinder 的代理，代理的实现过程为通过 Binder Driver 转发 Framework Binder 中两个重要概念： service_manager 进程：它是服务大管家，负责保存注册的服务 IServiceManager 供客户端和服务端查询和注册服务，它和 service_manager 是跨进程通信 IServiceManager.cpp 作为客户端和服务大管家 service_manager 进程通过 Binder 来通信；其他 aidl 服务进程作为客户端，通过 IServiceManager.cpp 注册服务；其他 app 进程作为客户端，通过 IServiceManager.cpp 查询服务。 IServiceManager 类图结构IServiceManager 类图结构，查看大图 这个类图体现了一般的 HIDL 服务的类结构： IServiceManager 可以看做一个标准的 HIDL 服务，默认继承 IBase IServiceManager 服务的实现类有两个： PassthroughServiceManager, ServiceManager BnHwServiceManager 中 _hidl_mImpl 指向 IServiceManager 的具体实现类，这里具体是 ServiceManager BpHwServiceManager 是代理类，父类 BpHwRefBase 中的 mRemote 指向了 BpHwBinder ，而 BpHwBinder 中的 mHandle 是指向 BHwBinder 的句柄，这里实际指向的是它的子类 BnHwServiceManager Bp** 和 Bn** 是通过 Binder 驱动来通信的，设备名 /dev/hwbinder hwBinder 简述hwBinder 和 Binder 模型基本一样，而且是共用 Binder Driver ，仅仅是设备关键字不一样。 hwBinder 中，服务端持有 BnHw 并实现 IInterface 的具体功能；客户端持有 BpHw 调用 IInterface 对应功能， BpHw 是 BnHw 的代理，通过 Binder Driver 来通信。 BpHw, BnHw 的通信过程（读写 Parcel ），都是在自动生成的 IFooAll.cpp 中实现的。hwservicemanager 进程功能和 Framework Binder 中的 service_manager 进程相同，它是 HIDL 的服务大管家；但具体由 ServiceManager.cpp 来保存注册的服务， ServiceManager 属于 hwservicemanager 进程，所以通信过程是函数直接调用。客户端和服务端通过 ServiceManagement.cpp 来和 hwservicemanager 通信。 ServiceManagement 会根据绑定式或是直通式来返回 IServiceManager 的具体实现：如果是绑定式，则 ServiceManagement 持有 BpHwServiceManager （即 BnHwServiceManager 的代理），它会和 hwservicemanager 通过 Binder 通信，查询并返回服务接口。 rc 文件hwservicemanager.rc 文件定义了 hwservicemanager 进程的启动方式： 1234567891011service hwservicemanager /system/bin/hwservicemanager user system disabled group system readproc critical onrestart setprop hwservicemanager.ready false onrestart class_restart hal onrestart class_restart early_hal writepid /dev/cpuset/system-background/tasks class animation shutdown critical main 方法主进程文件为 service.cpp ，对应的 main 方法为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// service.cppint main() &#123; configureRpcThreadpool(1, true /* callerWillJoin */); ServiceManager *manager = new ServiceManager(); if (!manager-&gt;add(serviceName, manager)) &#123; ALOGE("Failed to register hwservicemanager with itself."); &#125; TokenManager *tokenManager = new TokenManager(); if (!manager-&gt;add(serviceName, tokenManager)) &#123; ALOGE("Failed to register ITokenManager with hwservicemanager."); &#125; sp&lt;Looper&gt; looper(Looper::prepare(0 /* opts */)); int binder_fd = -1; IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd); if (binder_fd &lt; 0) &#123; ALOGE("Failed to aquire binder FD. Aborting..."); return -1; &#125; // Flush after setupPolling(), to make sure the binder driver // knows about this thread handling commands. IPCThreadState::self()-&gt;flushCommands(); sp&lt;BinderCallback&gt; cb(new BinderCallback); if (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb, nullptr) != 1) &#123; ALOGE("Failed to add hwbinder FD to Looper. Aborting..."); return -1; &#125; // Tell IPCThreadState we're the service manager sp&lt;BnHwServiceManager&gt; service = new BnHwServiceManager(manager); IPCThreadState::self()-&gt;setTheContextObject(service); // Then tell binder kernel ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, 0); ... while (true) &#123; looper-&gt;pollAll(-1 /* timeoutMillis */); &#125; return 0;&#125; main 中主要实现了这些功能： 新建 ServiceManager 对象，并将它注册到 hwservicemanager 中（注册过程实际是存储到一个 map 中） 新建 TokenManager 对象，并将它注册为服务 轮询 /dev/hwbinder 设备文件，监听事件 新建 BnHwServiceManager 对象，并将 ServiceManager 传入作为 IServiceManager 的实现 ioctl 向驱动发送消息，将 hwservicemanager 进程，以句柄 0 向驱动注册为服务大管家 BINDER_SET_CONTEXT_MGR （这就是为什么拿到句柄 0 ，即表示为 hwservicemanager ） ServiceManagerServiceManager 用于管理服务的注册和查询， mServiceMap 中保存了服务端相关信息，以全限定名称作为 key 保存。 1234567891011121314151617181920212223242526272829303132struct ServiceManager : public IServiceManager, hidl_death_recipient &#123; //Methods from::android::hidl::manager::V1_0::IServiceManager follow Return&lt;sp&lt;IBase&gt;&gt; get(const hidl_string&amp; fqName, const hidl_string&amp; name) override; Return&lt;bool&gt; add(const hidl_string&amp; name, const sp&lt;IBase&gt;&amp; service) override; ... using InstanceMap = std::map&lt; std::string, // instance name e.x. "manager" std::unique_ptr&lt;HidlService&gt; &gt;; struct PackageInterfaceMap &#123; ... private: InstanceMap mInstanceMap&#123;&#125;; ... &#125;; /** * Access to this map doesn't need to be locked, since hwservicemanager * is single-threaded. * * e.x. * mServiceMap["android.hidl.manager@1.0::IServiceManager"]["manager"] * -&gt; HidlService object */ std::map&lt; std::string, // package::interface // e.x. "android.hidl.manager@1.0::IServiceManager" PackageInterfaceMap &gt; mServiceMap;&#125;; mServiceMap关键字为全限定名： package::interface ，比如：android.hidl.manager@1.0::IServiceManager 。 mInstanceMap关键字为服务名称，默认为 default ；服务端也可以在注册时，指定服务名称；比如 CameraProvider 中注册时，指定为 &quot;legacy/0&quot; 。 因为先通过全限定从 mServiceMap 中取 mInstanceMap ，而全限定名称包含软件包、主次版本号、接口名称，全限定名称一定不会重复，所以拿到的是唯一的 mInstanceMap ；此时再根据服务名称获取服务端接口时，服务名已经不是很重要，所以通常服务名称使用的默认的 default 。 服务注册服务端通过 Binder 注册，最终是在 ServiceManager 中实现的，并保存在 mServiceMap 中。注意： add 来注册服务，是 hwbinder 机制内部使用的；服务端应该使用 registerAsService 来注册，而自动生成代码 IFooAll.cpp 中在实现 registerAsService 时，会调用 add 来完成注册。 12345678910111213141516171819202122232425262728293031// ServiceManager.cppReturn&lt;bool&gt; ServiceManager::add(const hidl_string&amp; name, const sp&lt;IBase&gt;&amp; service) &#123; ... auto ret = service-&gt;interfaceChain( [&amp;](const auto &amp;interfaceChain) &#123; ... for(size_t i = 0; i &lt; interfaceChain.size(); i++) &#123; // 拿到全限定名 std::string fqName = interfaceChain[i]; // 根据全限定名查找 mInstanceMap PackageInterfaceMap &amp;ifaceMap = mServiceMap[fqName]; // 根据服务名称查找对应服务 HidlService *hidlService = ifaceMap.lookup(name); // 没有找到或找到为空，则添加或更新 if (hidlService == nullptr) &#123; ifaceMap.insertService(std::make_unique&lt;HidlService&gt;( fqName, name, service, pid)); &#125; else &#123; ... hidlService-&gt;setService(service, pid); &#125; ifaceMap.sendPackageRegistrationNotification(fqName, name); &#125; ... &#125;); ...&#125; 注册的过程为： 先根据全限定名和服务名，查找服务是否存在 如果不存在，则添加并保存；如果存在则更新 服务查询查询 Binder 服务，最终是在 ServiceManager 中实现的，也就是从 mServiceMap 中查找。注意： get 来查询服务，是 hwbinder 机制内部使用的；客户端应该通过接口 Interface::getService 获取：它会先使用 defaultServiceManager 来获取 IServiceManager ，然后再调用 get 方法。 12345678910111213141516171819202122// ServiceManager.cppReturn&lt;sp&lt;IBase&gt;&gt; ServiceManager::get(const hidl_string&amp; fqName, const hidl_string&amp; name) &#123; pid_t pid = IPCThreadState::self()-&gt;getCallingPid(); if (!mAcl.canGet(fqName, pid)) &#123; return nullptr; &#125; auto ifaceIt = mServiceMap.find(fqName); if (ifaceIt == mServiceMap.end()) &#123; return nullptr; &#125; const PackageInterfaceMap &amp;ifaceMap = ifaceIt-&gt;second; const HidlService *hidlService = ifaceMap.lookup(name); if (hidlService == nullptr) &#123; return nullptr; &#125; return hidlService-&gt;getService();&#125; 查询过程很简单：就是从 mServiceMap 中根据全限定名和服务名查找。 示例hardware/interfaces/tests 中有简单的 HIDL 服务示例： 123456789101112131415tests/├── Android.bp├── bar├── baz├── expression├── extension├── foo├── hash├── inheritance├── libhwbinder├── memory├── msgq├── multithread├── myintere└── pointer 小结Binder 总结Binder 域有三个，但它们都是共用了 Binder Driver ，只是设备文件名称不一样（在 kernel 编译配置中设定 CONFIG_ANDROID_BINDER_DEVICES=&quot;binder,hwbinder,vndbinder&quot; ）： /dev/binder标准的 Framework Binder ，使用 AIDL 接口；服务大管家对应的是 servicemanager 进程。 /dev/hwbinderHIDL 服务相关，使用 HIDL 接口；服务大管家对应的是 hwservicemanager 进程。 /dev/vndbinder供应商之间的通信，使用 AIDL 接口；服务大管家对应的是 vndservicemanager 进程。 在 HIDL 服务中，除了使用 /dev/hwbinder 和 Framework 通信外；还可以同时使用 /dev/vndbinder 和 vendor 通信： 1234567// hardware/interfacescamera/provider/2.4/default/service.cpp:32: android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);cas/1.0/default/service.cpp:37: android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);drm/1.0/default/service.cpp:38: android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);gnss/1.0/default/service.cpp:15: android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);graphics/composer/2.1/default/service.cpp:31: android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;);hal-server/hal-server.cpp:107:android::ProcessState::initWithDriver(&quot;/dev/vndbinder&quot;); 这里 vndservicemanager, servicemanager 进程对应的源码文件都是 service-manager.c 文件，只是在 Android.bp 中做了编译区分。 1234567891011121314151617181920212223242526// frameworks/native/cmds/servicemanager/Android.bpcc_binary &#123; name: &quot;servicemanager&quot;, defaults: [&quot;servicemanager_flags&quot;], srcs: [ &quot;service_manager.c&quot;, &quot;binder.c&quot;, ], shared_libs: [&quot;libcutils&quot;, &quot;libselinux&quot;], init_rc: [&quot;servicemanager.rc&quot;],&#125;cc_binary &#123; name: &quot;vndservicemanager&quot;, defaults: [&quot;servicemanager_flags&quot;], vendor: true, srcs: [ &quot;service_manager.c&quot;, &quot;binder.c&quot;, ], cflags: [ &quot;-DVENDORSERVICEMANAGER=1&quot;, ], shared_libs: [&quot;libcutils&quot;, &quot;libselinux_vendor&quot;], init_rc: [&quot;vndservicemanager.rc&quot;],&#125; 后续 HIDL 分别用 cpp, java 实现两个示例 vts 相关 供应商测试套件 (VTS) 和基础架构 使用 VTS 进行系统测试 参考文档 官网 HIDL Android 架构 HIDL 代码规范 HIDL CPP 示例 hwservicemanager 启动过程 HIDL服务查询过程 HIDL服务注册过程 Android O Treble框架笔记 探索 hidl-gen 使用 Android Treble架构解析 C++ HIDL 示例 helloworld HAL层开发示例]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera 其他]]></title>
    <url>%2F2018%2F12%2F15%2F0109-android-camera-6-extras%2F</url>
    <content type="text"><![CDATA[介绍 Camera build, system, vendor 等等其他相关知识。 编译与调试Android 模块编译方法Android 的编译系统最开始是 make, makefile 体系，但是从 7.0 开始切换到 Android.bp, ninja 等工具。部分源码目录中，Android.mk, Android.bp 两者都有，或者只有其中一个编译配置文件，这里简要介绍下编译区别。 Android.mk查看 LOCAL_MODULE 中定义的名字，在根目录下直接执行：make *** -j32 。 Android.bp由 cc_** 开头，比如： cc_library, cc_library_shared, cc_binary 等等，同样是执行 make *** -j32 。 当然也可以直接到该目录下执行 mm ，但如果该模块存在外部依赖可能会导致编译失败，所以最好还是在根目录下执行 make 。 常见模块的编译下面是 Camera 中常见模块（注意已经发布的 .hal 文件是不能直接修改的，涉及到 hal 版本升级），对应的编译方法及生成文件路径如下： frameworks/av/services/camera/libcameraservice编译命令：make libcameraservice -j32 ，生成文件路径： 12system/lib64/libcameraservice.sosystem/lib/libcameraservice.so hardware/interfaces/camera/common/1.0/default/查看 Android.bp 可以看出，该模块编译后生成一个静态文件。 12345678// Android.bp ，静态库cc_library_static &#123; name: &quot;android.hardware.camera.common@1.0-helper&quot;, vendor_available: true, defaults: [&quot;hidl_defaults&quot;], srcs: [ ...&#125; 编译命令：make android.hardware.camera.common@1.0-helper -j32，生成文件路径： 123// 生成文件路径 ./obj/STATIC_LIBRARIES/android.hardware.camera.common@1.0-helper_intermediates/android.hardware.camera.common@1.0-helper.a./obj_arm/STATIC_LIBRARIES/android.hardware.camera.common@1.0-helper_intermediates/android.hardware.camera.common@1.0-helper.a 所有依赖静态文件的模块，都需要重新编译并 push 到手机中： 12345678// 查找其他 Android.bp 文件可以看到，有多处依赖它interfaces/camera/provider/2.4/vts/functional/Android.bp:34: &quot;android.hardware.camera.common@1.0-helper&quot;,interfaces/camera/provider/2.4/default/Android.bp:29: &quot;android.hardware.camera.common@1.0-helper&quot;interfaces/camera/common/1.0/default/Android.bp:2: name: &quot;android.hardware.camera.common@1.0-helper&quot;,interfaces/camera/device/3.2/default/Android.bp:22: &quot;android.hardware.camera.common@1.0-helper&quot;interfaces/camera/device/1.0/default/Android.bp:28: &quot;android.hardware.camera.common@1.0-helper&quot;interfaces/camera/device/3.3/default/Android.bp:24: &quot;android.hardware.camera.common@1.0-helper&quot;qcom/camera/QCamera2/Android.mk:121:LOCAL_STATIC_LIBRARIES := android.hardware.camera.common@1.0-helper hardware/interfaces/camera/provider/2.4/default编译命令 make android.hardware.camera.provider@2.4-impl -j32 ，生成的文件路径： 12vendor/lib/hw/android.hardware.camera.provider@2.4-impl.sovendor/lib64/hw/android.hardware.camera.provider@2.4-impl.so hardware/qcom/camera/QCamera2编译命令：make camera.msm8937 -j32; ，其中 msm8937 表示当前项目所属平台名称，生成文件路径： 12345678// hardware/qcom/camera/QCamera2/Android.mkLOCAL_MODULE_RELATIVE_PATH := hwLOCAL_MODULE := camera.$(TARGET_BOARD_PLATFORM)LOCAL_VENDOR_MODULE := trueLOCAL_MODULE_TAGS := optional// 生成文件地址vendor/lib/hw/camera.msm8937.so hardware/interfaces/camera/device/1.0/default/编译命令：make camera.device@1.0-impl -j32 ，生成文件路径： 12./vendor/lib/camera.device@1.0-impl.so./vendor/lib64/camera.device@1.0-impl.so hardware/qcom/camera/QCamera2/stack/mm-camera-interface编译命令：make libmmcamera_interface -j32 ，生成文件路径：./vendor/lib/libmmcamera_interface.so vendor/qcom/proprietary/mm-camera/mm-camera2/server-imaging 目录编译命令：make mm-qcamera-daemon -j32 ，生成文件路径：./vendor/bin/mm-qcamera-daemon 调试 Java 文件可以直接在 Log 中打印调用关系： Log.d(&quot;tag&quot;, &quot;message&quot;, new Throwable()); 。 cpp 文件堆栈打印需要添加 libutils ，如果是 Android P 及以上添加 libutilscallstack ，在 cpp 文件中，调用 android:CallStack cs 来打印堆栈。 12#include &lt;utils/CallStack.h&gt;android::CallStack cs(&quot;XMT:tag&quot;); c 文件c 文件打印堆栈比较麻烦，需要先封装一个 cpp 文件，并使用 extern &quot;C&quot; 来给 c 调用。 如果出现堆栈错误，根据地址查找代码行数，使用 addr2line 工具来查看：addr2line -C -f -e ./symbols/vendor/lib/libmmcamera_interface.so 00015414 。 Camera 分层设计模块Camera 是一个比较完整的模块，从 APP, Framework, Hardware, System, Vendor, Kernel Driver 每部分都会涉及到，主要关注的是 Framework, Hardware 两块。 APP 调用 Framework Java 提供的 API 实现对应功能 Framework Java 作为客户端通过 AIDL 和 Framework Native 服务端完成跨进程通信 Framework 服务作为客户端通过 HIDL 和 Hardware AOSP 的 .hal 接口服务完成跨进程通信 Hardware AOSP 通过 dlopen 加载 Hardware qcom 库，实现对应的功能 Hardware qcom 通过 socket （也有可能是一个 mshim 层直接加载库）以及 Kernel V4L2 Driver 和 Vendor 实现通信 System 目录中会提供一些公共的函数或数据结构，方便在各个模块中使用统一结构传递数据 分层设计中，我们只需要关心每一层之间的接口就行，而每层的逻辑处理都封装在这一层内部。 服务Camera 相关一共会注册三个服务： media.cameramain_cameraserver.cpp 注册的， Framework camera 的核心，即 CameraService ，实现所有 api 对应功能。 media.camera.proxyCameraServiceProxy.java 注册的，是代理类，主要实现 CameraService 向系统发回的消息。 legacy/0HIDL 注册的服务，即 CameraProvider ，封装了 HAL 实现的功能；在 hardware/interfaces/camera/provider/2.4/default/service.cpp 中注册。 进程Camera 相关主要涉及到三个进程的通信： cameraserverCameraService 服务所在进程，实现 Framework 对应功能；代码所在位置：frameworks/av/camera/cameraserver/main_cameraserver.cpp android.hardware.camera.provider@2.4-serviceCameraProvider 服务所在进程，实现 HAL 对应功能；代码所在位置：hardware/interfaces/camera/provider/2.4/default/service.cpp mm-qcamera-daemonCamera Vendor 的进程，功能的最终实现；代码所在位置：vendor/qcom/proprietary/mm-camera/mm-camera2/server-imaging/server.c Vendor Qcomvendor qcom 中，并不区分 Camera API 1/2 ，也不区分 HAL 1/3 ；不管上面是什么接口，在 HAL qcom 中都会转换为对应的功能函数，而在 vendor qcom 只会有一套代码架构，不同的函数来响应他们。 mm-camera-daemonmm-camera-daemon 进程源码所在目录： 12345server-imaging/├── Android.mk├── server.c├── server_process.c└── server_process.h mm-camera-daemon 的服务进程是开机自动运行的，主要作用是介于应用和驱动之间翻译 ioctl 的中间层（委托处理），其目的是将 VFE/ISP 具体操作策略的私有化代码封闭等等。在驱动设计中，存在 msm-config, msm-camera 两种 MCT ，前者用于获取事件通知 V4L2 驱动信息；后者用于获取 sensor 操作 V4L2 驱动信息。一个完整的调用流程大致是： app==&gt;v4l2(stream)==&gt;daemon==&gt;v4l2(control)==&gt;app ： app 到 daemon 主要是在 v4l2(stream) 中事件通知方式进行的，对于 map/unmap 则直接通过 domain socket 方式进行 daemon 到 app 是通过 v4l2(control) 的事件通知机制进行的 v4l2(stream) 是通过 msm-camera 获取到相关信息的， v4l2(control) 是通过 msm-config 获取到相关信息的 mm-camera-daemon 是老版本的架构图，新版本中使用了 mct_shim_layer 来管理，取消了 IPC 通信，简化了流程。 mm-camera-daemon 老版本架构图： mct_shim_layer 新版本架构图，通过 dlopen/dlsym 加载 vendor 库： 模块和端口Camera 的所有功能划分为不同的模块，让模块自己来决定自己的事情（高内聚，低耦合），模块需要有统一的接口和格式。模块中有端口，通过端口把模块连接起来，又把模块挂在总线上。每一个端口的连接就是一个流，把这些流用 pipeline 来管理。每次启动一个 camera 就创建一个会话，由这个会话来管理此 Camera 的一切事物。对于每一个会话，模块是共享的，它可以是 Camera 的硬件资源也可以是其它资源（如一些软件算法等资源）。 端口端口属于模块，如果这个模块只有 source 端口，那么它就是一个 src 模块；如果只有 sink 端口就是 sink 模块；如果都有就是中间模块。没有端口的模块是不能连接到流中的，但他可以完成一些其他的功能，比如接收引擎的设置，报告事件到 bus 等。连接到流中的端口，也就是说流事件 set/get 主要通过端口来处理。而来自于引擎的 set/get 通过模块来处理，当然端口也可以把事件交给模块来处理。 模块线程每个模块可以有一个线程来处理模块的事情。一个线程对应一个队列，线程就是从队列中取出数据处理，然后应答回去。 总线回调当一个模块向总线注册时，总线向其提供一个回调函数，当模块有事件发生时，调用这个函数向 bus 发消息，然后总线把这个消息提交给管道，管道把这个消息顺着流发下去。 核心控制代码路径如下，目录结构为： 123456789101112131415161718192021222324252627// vendor/qcom/proprietary/mm-camera/mm-camera2/media-controllermct├── Android.mk├── bus├── controller├── debug├── event├── module├── object├── pipeline├── port├── stream└── toolsmct_shim_layer├── Android.mk├── mct_shim_layer.c└── mct_shim_layer.hmodules/├── iface2├── imglib // 主要是图片的一些后端处理，如 HDR 等├── includes├── isp├── isp2├── pproc├── pproc-new├── sensors└── stats // 一些统计算法模块，如 3A，ASD,AFD,IS,GRRO 等数据统计的处理 高通控制模块架构图： SystemSystem 中定义的数据结构体，贯穿整个 Framework, HAL, Vendor ，在这三层中定义统一的数据传递格式。 目录结构System 中和 Camera 相关的代码： 12345678910111213141516171819202122232425262728system/core/libsystem/include/system/camera.hsystem/media/private/camera/include/camera_metadata_hidden.hsystem/sepolicy/private/cameraserver.tesystem/sepolicy/vendor/hal_camera_default.tesystem/sepolicy/prebuilts/api/26.0/private/cameraserver.tesystem/sepolicy/prebuilts/api/26.0/public/hal_camera.tesystem/sepolicy/prebuilts/api/26.0/public/cameraserver.tesystem/sepolicy/public/hal_camera.tesystem/sepolicy/public/cameraserver.tesystem/media/camerasystem/media/camera/src/camera_metadata.csystem/media/camera/src/camera_metadata_tag_info.csystem/media/camera/docs/CameraDeviceInfo.makosystem/media/camera/docs/CameraMetadataEnums.makosystem/media/camera/docs/ndk_camera_metadata_tags.makosystem/media/camera/docs/camera_metadata_tags.makosystem/media/camera/docs/camera_device_info.protosystem/media/camera/docs/camera_device_info.makosystem/media/camera/docs/camera_metadata_tag_info.makosystem/media/camera/docs/CameraMetadataKeys.makosystem/media/camera/docs/ACameraMetadata.makosystem/media/camera/docs/CameraCharacteristicsKeys.makosystem/media/camera/docs/images/camera2system/media/camera/include/system/camera_metadata.hsystem/media/camera/include/system/camera_vendor_tags.hsystem/media/camera/include/system/camera_metadata_tags.hsystem/media/camera/tests/camera_metadata_tests.cppsystem/media/camera/tests/camera_metadata_tests_fake_vendor.h 分为几部分： 头文件 12system/core/libsystem/include/system/camera.hsystem/media/private/camera/include/camera_metadata_hidden.h 权限system/sepolicy/ 系统共有文件system/media/camera 生成 Metadata 文件Camera Metadata 相关的属性，都是自动生成的，不能直接在代码中修改。这些属性是在 system/media/docs/ 中的 metadata_properties.xml, ndk_metadata_properties.xml 两个配置文件中定义的， .mako 指定了生成规则，通过解析工具解析后生成对应的 .java, .h 文件。 1234frameworks/base/core/java/android/hardware/camera2/CameraCharacteristics.javaframeworks/base/core/java/android/hardware/camera2/CaptureResult.javaframeworks/base/core/java/android/hardware/camera2/CaptureRequest.javaframeworks/av/camera/ndk/include/camera/NdkCameraMetadataTags.h camera_metadata 数据结构camera_metadata 数据结构贯穿整个 Camera 架构，用于传递 Camera 相关参数设置。camera_metadata_tags.h 中定义了所有的枚举值，特别是 camera_metadata 数据段相关的性质： 1234567891011121314151617181920212223242526272829303132// camera_metadata_tags.htypedef enum camera_metadata_section &#123; ANDROID_COLOR_CORRECTION, ANDROID_CONTROL, ANDROID_DEMOSAIC, ANDROID_EDGE, ANDROID_FLASH, ANDROID_FLASH_INFO, ANDROID_HOT_PIXEL, ANDROID_JPEG, ANDROID_LENS, ANDROID_LENS_INFO, ANDROID_NOISE_REDUCTION, ANDROID_QUIRKS, ANDROID_REQUEST, ANDROID_SCALER, ANDROID_SENSOR, ANDROID_SENSOR_INFO, ANDROID_SHADING, ANDROID_STATISTICS, ANDROID_STATISTICS_INFO, ANDROID_TONEMAP, ANDROID_LED, ANDROID_INFO, ANDROID_BLACK_LEVEL, ANDROID_SYNC, ANDROID_REPROCESS, ANDROID_DEPTH, ANDROID_SECTION_COUNT, VENDOR_SECTION = 0x8000&#125; camera_metadata_section_t; 主要包含如上几个数据段，且每个数据段大小为 1 &lt;&lt; 16 即 64K 大小，也是定义的枚举值： 123456789101112131415161718192021222324252627282930// camera_metadata_tags.htypedef enum camera_metadata_section_start &#123; ANDROID_COLOR_CORRECTION_START = ANDROID_COLOR_CORRECTION &lt;&lt; 16, ANDROID_CONTROL_START = ANDROID_CONTROL &lt;&lt; 16, ANDROID_DEMOSAIC_START = ANDROID_DEMOSAIC &lt;&lt; 16, ANDROID_EDGE_START = ANDROID_EDGE &lt;&lt; 16, ANDROID_FLASH_START = ANDROID_FLASH &lt;&lt; 16, ANDROID_FLASH_INFO_START = ANDROID_FLASH_INFO &lt;&lt; 16, ANDROID_HOT_PIXEL_START = ANDROID_HOT_PIXEL &lt;&lt; 16, ANDROID_JPEG_START = ANDROID_JPEG &lt;&lt; 16, ANDROID_LENS_START = ANDROID_LENS &lt;&lt; 16, ANDROID_LENS_INFO_START = ANDROID_LENS_INFO &lt;&lt; 16, ANDROID_NOISE_REDUCTION_START = ANDROID_NOISE_REDUCTION &lt;&lt; 16, ANDROID_QUIRKS_START = ANDROID_QUIRKS &lt;&lt; 16, ANDROID_REQUEST_START = ANDROID_REQUEST &lt;&lt; 16, ANDROID_SCALER_START = ANDROID_SCALER &lt;&lt; 16, ANDROID_SENSOR_START = ANDROID_SENSOR &lt;&lt; 16, ANDROID_SENSOR_INFO_START = ANDROID_SENSOR_INFO &lt;&lt; 16, ANDROID_SHADING_START = ANDROID_SHADING &lt;&lt; 16, ANDROID_STATISTICS_START = ANDROID_STATISTICS &lt;&lt; 16, ANDROID_STATISTICS_INFO_START = ANDROID_STATISTICS_INFO &lt;&lt; 16, ANDROID_TONEMAP_START = ANDROID_TONEMAP &lt;&lt; 16, ANDROID_LED_START = ANDROID_LED &lt;&lt; 16, ANDROID_INFO_START = ANDROID_INFO &lt;&lt; 16, ANDROID_BLACK_LEVEL_START = ANDROID_BLACK_LEVEL &lt;&lt; 16, ANDROID_SYNC_START = ANDROID_SYNC &lt;&lt; 16, ANDROID_REPROCESS_START = ANDROID_REPROCESS &lt;&lt; 16, ANDROID_DEPTH_START = ANDROID_DEPTH &lt;&lt; 16, VENDOR_SECTION_START = VENDOR_SECTION &lt;&lt; 16&#125; camera_metadata_section_start_t; 这里举例说明 ANDROID_FLASH 相关参数，都是从 ANDROID_FLASH_START 位置开始，并以 ANDROID_FLASH_END 结尾，在 64K 空间内包含了如下几个参数： 1234567891011121314151617// camera_metadata_tags.htypedef enum camera_metadata_tag &#123; ... ANDROID_EDGE_END, ANDROID_FLASH_FIRING_POWER = // byte | system ANDROID_FLASH_START, ANDROID_FLASH_FIRING_TIME, // int64 | system ANDROID_FLASH_MODE, // enum | public ANDROID_FLASH_COLOR_TEMPERATURE, // byte | system ANDROID_FLASH_MAX_ENERGY, // byte | system ANDROID_FLASH_STATE, // enum | public ANDROID_FLASH_END, ANDROID_FLASH_INFO_AVAILABLE = // enum | public ANDROID_FLASH_INFO_START, ... 而 camera_metadata 的内存结构体定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// camera_metadata.c/** * A packet of metadata. This is a list of entries, each of * which may point to its values stored at an offset in data. * * It is assumed by the utility functions that the memory * layout of the packet is as follows: * * |-----------------------------------------------| * | camera_metadata_t | * | | * |-----------------------------------------------| * | reserved for future expansion | * |-----------------------------------------------| * | camera_metadata_buffer_entry_t #0 | * |-----------------------------------------------| * | .... | * |-----------------------------------------------| * | camera_metadata_buffer_entry_t #entry_count-1 | * |-----------------------------------------------| * | free space for | * | (entry_capacity-entry_count) entries | * |-----------------------------------------------| * | start of camera_metadata.data | * | | * |-----------------------------------------------| * | free space for | * | (data_capacity-data_count) bytes | * |-----------------------------------------------| * * With the total length of the whole packet being * camera_metadata.size bytes. * * In short, the entries and data are contiguous in memory * after the metadata header. */#define METADATA_ALIGNMENT ((size_t) 4)struct camera_metadata &#123; metadata_size_t size; uint32_t version; uint32_t flags; metadata_size_t entry_count; metadata_size_t entry_capacity; metadata_uptrdiff_t entries_start; //Offset from camera_metadata metadata_size_t data_count; metadata_size_t data_capacity; metadata_uptrdiff_t data_start; // Offset from camera_metadata uint32_t padding; // padding to 8 bytes boundary metadata_vendor_id_t vendor_id;&#125;; 常见调试对应属性 persist.camera.dumpimg设置为 1 时，每次拍照预览都会在 /data/misc/camera 目录记录当前帧图片。 persist.camera.global.debug 全局调试输出 LOG persist.camera.hal.debug HAL 模块输出 LOG persist.camera.mci.debug mci 模块输出 LOG persist.camera.mmstill.logs JPEG 拍照输出 LOG 参考文档 [高通：kba-160629230034：how_to_catch_android_log] [高通 linux_android_camera_overview] 高通camera学习笔记概述（一二三四五） CameraMetadata用于从APP到HAL的参数交互 CameraMetadata分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera Hardware 分析]]></title>
    <url>%2F2018%2F12%2F10%2F0109-android-camera-5-hardware%2F</url>
    <content type="text"><![CDATA[Camera Hardware 分析，主要是分析 HAL 3 。 简述术语表 HAL: Hardware abstraction layer 硬件抽象层 CPP: Camera Post Processor 相机后处理 VFE：VIDEO front-end 视频前端 VPE：Video preprocessing 视频预处理 类文件速查表121. HAL AOSP: hardware/interfaces/camera2. HAL qcom: hardware/qcom/camera 从 Android 8.0 开始，由于 Google 引入 Treble 架构，Framework 和 vendor 之间需要通过 HIDL 来通信，所以重写了 hardware 的代码结构。HAL 分为 AOSP ：Google 标准代码部分；以及 HAL qcom ：厂商具体实现部分。 HIDL 相关HIDL 是复用了 Binder 机制，用于跨进程通信；所有跨进程通信相关的接口，都集中在 HIDL 这几个文件中。 123456789101112131415// hardware/interfaces/camera./device/3.3/ICameraDeviceSession.hal./device/3.3/types.hal./device/3.2/ICameraDevice.hal./device/3.2/ICameraDeviceSession.hal./device/3.2/ICameraDeviceCallback.hal./device/3.2/types.hal./device/1.0/ICameraDevice.hal./device/1.0/ICameraDevicePreviewCallback.hal./device/1.0/ICameraDeviceCallback.hal./device/1.0/types.hal./metadata/3.2/types.hal./common/1.0/types.hal./provider/2.4/ICameraProvider.hal./provider/2.4/ICameraProviderCallback.hal 文件生成规则.hal 文件可以生成对应的 .h, .cpp 文件，编译规则通常在同级目录的 Android.bp 中定义，这里选取 ICameraProvider.hal 为例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Android.bpfilegroup &#123; name: &quot;android.hardware.camera.provider@2.4_hal&quot;, srcs: [ &quot;ICameraProvider.hal&quot;, &quot;ICameraProviderCallback.hal&quot;, ],&#125;genrule &#123; name: &quot;android.hardware.camera.provider@2.4_genc++&quot;, tools: [&quot;hidl-gen&quot;], cmd: &quot;$(location hidl-gen) -o $(genDir) -Lc++-sources -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.camera.provider@2.4&quot;, srcs: [ &quot;:android.hardware.camera.provider@2.4_hal&quot;, ], out: [ &quot;android/hardware/camera/provider/2.4/CameraProviderAll.cpp&quot;, &quot;android/hardware/camera/provider/2.4/CameraProviderCallbackAll.cpp&quot;, ],&#125;genrule &#123; name: &quot;android.hardware.camera.provider@2.4_genc++_headers&quot;, tools: [&quot;hidl-gen&quot;], cmd: &quot;$(location hidl-gen) -o $(genDir) -Lc++-headers -randroid.hardware:hardware/interfaces -randroid.hidl:system/libhidl/transport android.hardware.camera.provider@2.4&quot;, srcs: [ &quot;:android.hardware.camera.provider@2.4_hal&quot;, ], out: [ &quot;android/hardware/camera/provider/2.4/ICameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/IHwCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/BnHwCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/BpHwCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/BsCameraProvider.h&quot;, &quot;android/hardware/camera/provider/2.4/ICameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/IHwCameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/BnHwCameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/BpHwCameraProviderCallback.h&quot;, &quot;android/hardware/camera/provider/2.4/BsCameraProviderCallback.h&quot;, ],&#125; 源文件只有两个 ICameraProvider.hal, ICameraProviderCallback.hal ，通过 hidl-gen 工具来生成对应的 .h, .cpp 文件，生成文件的目录为 out/soong/.intermediates/hardware/interfaces/camera/provider/2.4 目录下： 头文件目录名 android.hardware.camera.provider@2.4_genc++_headers，每个 .hal 会生成 4 个头文件，其中三个是 HIDL 通信机制对应的文件。 源文件目录名 android.hardware.camera.provider@2.4_genc++，每个 .hal 文件生成一个对应的 *All.cpp 文件。 types.hal这类 HIDL 文件用于定义数据类型，而其他 HIDL 文件参数中可能会使用到这些数据结构。 ICameraProvider.hal 相关ICameraProvider.hal 中的函数为 Framework 向 HAL 层发起的请求；ICameraProviderCallback.hal 中函数为 HAL 向 Framework 返回的回调。 1234567891011121314151617181920212223242526272829303132333435363738394041// ICameraProvider.halinterface ICameraProvider &#123; // 设置 ICameraProviderCallback 监听，返回值为 Status setCallback(ICameraProviderCallback callback) generates (Status status); // 获取厂商自定义参数，返回值类型为 VendorTagSection getVendorTags() generates (Status status, vec&lt;VendorTagSection&gt; sections); // 返回 Camera 设备 id 列表，比如支持几个摄像头 getCameraIdList() generates (Status status, vec&lt;string&gt; cameraDeviceNames); // 是否支持手电筒模式 isSetTorchModeSupported() generates (Status status, bool support); // 根据设备名，返回 ICameraDevice 实例 getCameraDeviceInterface_V1_x(string cameraDeviceName) generates (Status status, android.hardware.camera.device@1.0::ICameraDevice device); getCameraDeviceInterface_V3_x(string cameraDeviceName) generates (Status status, android.hardware.camera.device@3.2::ICameraDevice device);&#125;;// ICameraProviderCallback.halinterface ICameraProviderCallback &#123; // 设备状态改变 cameraDeviceStatusChange(string cameraDeviceName, CameraDeviceStatus newStatus); // 手电筒模式状态改变 torchModeStatusChange(string cameraDeviceName, TorchModeStatus newStatus);&#125;; ICameraDevice.hal 相关1234567891011121314151617181920212223242526272829303132// ICameraDevice.halinterface ICameraDevice &#123; // 获取当前设备的资源耗费信息 getResourceCost() generates (Status status, CameraResourceCost resourceCost); // 获取当前设备的静态属性 getCameraCharacteristics() generates (Status status, CameraMetadata cameraCharacteristics); // 设置闪光灯或手电筒模式 setTorchMode(TorchMode mode) generates (Status status); // 打开当前设备 // 参数：ICameraDeviceCallback 回调 // 返回值：ICameraDeviceSession 会话 open(ICameraDeviceCallback callback) generates (Status status, ICameraDeviceSession session); // 打印当前设备状态信息 dumpState(handle fd);&#125;;// ICameraDeviceCallback.halinterface ICameraDeviceCallback &#123; // 返回捕获到的结果 processCaptureResult(vec&lt;CaptureResult&gt; results); // 异步通知 notify(vec&lt;NotifyMsg&gt; msgs);&#125;; ICameraDeviceSession.hal 相关ICameraDeviceSession.hal 有两个版本： 3.2 和 3.3 ，而 3.3 版本是继承自 3.2 版本的，唯一不同的是使用 configureStreams_3_3 替代 configureStreams 。 123456789101112131415161718192021222324252627282930313233343536373839// V3.2 ICameraDeviceSession.halinterface ICameraDeviceSession &#123; // 根据指定模板，构造默认请求模板设置 constructDefaultRequestSettings(RequestTemplate type) generates (Status status, CameraMetadata requestTemplate); // 配置流信息 configureStreams(StreamConfiguration requestedConfiguration) generates (Status status, HalStreamConfiguration halConfiguration); // 处理捕获请求 processCaptureRequest(vec&lt;CaptureRequest&gt; requests, vec&lt;BufferCache&gt; cachesToRemove) generates (Status status, uint32_t numRequestProcessed); // 获取捕获请求队列 getCaptureRequestMetadataQueue() generates (fmq_sync&lt;uint8_t&gt; queue); // 获取捕获结果队列 getCaptureResultMetadataQueue() generates (fmq_sync&lt;uint8_t&gt; queue); // 写入当前管道所有信息 flush() generates (Status status); // 关闭当前设备 close();&#125;;// V3.3 ICameraDeviceSession.halinterface ICameraDeviceSession extends @3.2::ICameraDeviceSession &#123; // 配置流信息 configureStreams_3_3(StreamConfiguration requestedConfiguration) generates (Status status, @3.3::HalStreamConfiguration halConfiguration);&#125;; HAL 1 对应文件ICameraDevice.hal, ICameraDevicePreviewCallback.hal, ICameraDeviceCallback.hal 三个文件是 HAL 1 对应的文件，暂不做分析。 Hardware AOSP对应文件目录为 hardware/interface/camera ，该文件夹主要是定义了很多 hal 文件及对应实现。 12345678910111213141516├── Android.bp├── common│ ├── 1.0│ └── README.md├── device│ ├── 1.0│ ├── 3.2│ ├── 3.3│ └── README.md├── metadata│ ├── 3.2│ └── README.md├── provider│ ├── 2.4│ └── README.md└── README.md common 目录123456789101112131415161718├── 1.0│ ├── Android.bp│ ├── Android.mk│ ├── default│ │ ├── Android.bp│ │ ├── CameraMetadata.cpp // HAL 3 CameraMetadata 元数据│ │ ├── CameraModule.cpp // 封装了 qcom camera│ │ ├── CameraParameters.cpp // HAL 1 参数│ │ ├── HandleImporter.cpp // 导入请求时的 buffer 管理│ │ ├── include│ │ │ ├── CameraMetadata.h│ │ │ ├── CameraModule.h│ │ │ ├── CameraParameters.h│ │ │ ├── HandleImporter.h│ │ │ └── VendorTagDescriptor.h│ │ └── VendorTagDescriptor.cpp // 厂商定制 tag│ └── types.hal└── README.md CameraModule.cpp 封装了 qcom camera 库中相关函数，所有的交互都在这个文件中处理。 device 目录123456789101112131415161718192021222324252627282930313233343536373839404142├── 1.0│ ├── Android.bp│ ├── default│ │ ├── Android.bp│ │ ├── CameraDevice_1_0.h│ │ ├── CameraDevice.cpp│ │ └── OWNERS│ ├── ICameraDeviceCallback.hal│ ├── ICameraDevice.hal│ ├── ICameraDevicePreviewCallback.hal│ └── types.hal├── 3.2│ ├── Android.bp│ ├── default│ │ ├── Android.bp│ │ ├── CameraDevice_3_2.h│ │ ├── CameraDevice.cpp // 设备│ │ ├── CameraDeviceSession.cpp // 会话│ │ ├── CameraDeviceSession.h│ │ ├── convert.cpp // 数据格式的转换│ │ ├── include│ │ │ └── convert.h│ │ └── OWNERS│ ├── ICameraDeviceCallback.hal│ ├── ICameraDevice.hal│ ├── ICameraDeviceSession.hal│ └── types.hal├── 3.3│ ├── Android.bp│ ├── default│ │ ├── Android.bp│ │ ├── CameraDevice_3_3.h│ │ ├── CameraDevice.cpp│ │ ├── CameraDeviceSession.cpp│ │ ├── CameraDeviceSession.h│ │ ├── convert.cpp│ │ ├── include│ │ │ └── convert.h│ │ └── OWNERS│ ├── ICameraDeviceSession.hal│ └── types.hal└── README.md device 目录有三个版本：1.0, 3.2, 3.3 ，分别实现对应的 HAL 版本。注意：当前代码中并没有 3.4 版本！！！3.3 版本的类都是继承了 3.2 版本，区别仅仅是针对 CameraDeviceSession ，以下是 3.3 版本差异部分： 1234567891011121314151617// CameraDevice.cppsp&lt;V3_2::implementation::CameraDeviceSession&gt; CameraDevice::createSession( camera3_device_t* device, const camera_metadata_t* deviceInfo, const sp&lt;V3_2::ICameraDeviceCallback&gt;&amp; callback) &#123; sp&lt;CameraDeviceSession&gt; session = new CameraDeviceSession(device, deviceInfo, callback); ... return session;&#125;// CameraDeviceSession.cppReturn&lt;void&gt; CameraDeviceSession::configureStreams_3_3( const StreamConfiguration&amp; requestedConfiguration, ICameraDeviceSession::configureStreams_3_3_cb _hidl_cb) &#123; ...&#125; 从实际代码比对中， 3.2 和 3.3 版本的代码，并没有什么差异！查看官网版本支持 ， 3.3 版本主要有以下不同： OPAQUE 和 YUV 重新处理 API 更新 对深度输出缓冲区的基本支持 为 camera3_stream_t 添加了 data_space 缓存字段 为 camera3_stream_t 添加了 rotation 旋转字段 为 camera3_stream_configuration_t 添加了 camera3 流配置操作模式 operation_mode metadata 目录1234567metadata/├── 3.2│ ├── Android.bp│ ├── Android.mk│ ├── docs.html│ └── types.hal└── README.md 有效文件为 types.hal ，定义了 CameraMetadata 相关的数据结构。 provider 目录123456789101112131415161718provider/├── 2.4│ ├── Android.bp│ ├── default│ │ ├── Android.bp│ │ ├── android.hardware.camera.provider@2.4-service.rc│ │ ├── CameraProvider.cpp│ │ ├── CameraProvider.h│ │ ├── OWNERS│ │ └── service.cpp│ ├── ICameraProviderCallback.hal│ ├── ICameraProvider.hal│ └── vts│ ├── functional│ │ ├── Android.bp│ │ └── VtsHalCameraProviderV2_4TargetTest.cpp│ └── OWNERS└── README.md provider 中包含进程启动文件 service.cpp ，以及 CameraProvider.cpp 文件。 camera.provider 进程进程全名为： android.hardware.camera.provider@2.4-service ，可以通过 adb shell &quot;ps -A | grep camera.provider&quot; 中查看到。进程源码文件所在目录：hardware/interfaces/camera/provider/2.4/default ，主要是 .rc, service.cpp 两个文件。 rc 文件1234567891011121314// android.hardware.camera.provider@2.4-service.rc// init 进程启动名字为 camera-provider-2-4 的进程及对应路径// 不过实际解析过程中是以路径中的二进制文件名作为进程名的// 也就是这个进程名为：android.hardware.camera.provider@2.4-serviceservice camera-provider-2-4 /vendor/bin/hw/android.hardware.camera.provider@2.4-service // class 表示类别，hal 类别的进程同时启动 class hal // 进程用户名 user cameraserver // 进程分组 group audio camera input drmrpc ioprio rt 4 capabilities SYS_NICE writepid /dev/cpuset/camera-daemon/tasks /dev/stune/foreground/tasks main进程的 main 方法很简单，仅有两条有效语句： 12345678910// service.cppint main()&#123; ALOGI("Camera provider Service is starting."); // The camera HAL may communicate to other vendor components via // /dev/vndbinder android::ProcessState::initWithDriver("/dev/vndbinder"); return defaultPassthroughServiceImplementation&lt;ICameraProvider&gt;( "legacy/0", /*maxThreads*/ 6);&#125; initWithDriverBinder 通信时驱动设备名为 /dev/vndbinder 。 defaultPassthroughServiceImplementation默认的直通式 HAL 服务注册。 这里先简单介绍一个概念：Binder 化直通式 HAL （摘选自官网）。它实际是直通模式的 HAL 实现 Binder 化。比如 HAL 接口 a.b.c.d@M.N::IFoo，系统会创建两个软件包： a.b.c.d@M.N::IFoo-impl包含 HAL 的实现，并暴露函数 IFoo* HIDL_FETCH_IFoo(const char* name)。在旧版设备上，此软件包经过 dlopen 处理，且实现使用 HIDL_FETCH_IFoo 进行了实例化。也可以使用 hidl-gen 和 -Lc++-impl 以及 -Landroidbp-impl 来生成基础代码。 a.b.c.d@M.N::IFoo-service打开直通式 HAL，并将其自身注册为 Binder 化服务，从而使同一 HAL 实现能够同时以直通模式和 Binder 化模式使用。如果有一个 IFoo ，可以调用 sp&lt;IFoo&gt; IFoo::getService(string name, bool getStub) ，以获取对 IFoo 实例的访问权限。如果 getStub 为 True，则 getService 会尝试仅在直通模式下打开 HAL。如果 getStub 为 False，则 getService 会尝试找到 Binder 化服务；如果未找到，则它会尝试找到直通式服务。除了在 defaultPassthroughServiceImplementation 中，其余情况一律不得使用 getStub 参数。（搭载 Android O 的设备是完全 Binder 化的设备，因此不得在直通模式下打开服务。） 从 main 源码来看，defaultPassthroughServiceImplementation 注册的是 Binder 化的直通式 HAL ，从 ICameraProvider.hal 生成的头文件中，可以看到 getStub 默认为 false ，即在 Framework 中 CameraProviderManager 通过 getService 找到的是 Binder 化服务。 12345678910// android/hardware/camera/provider/2.4/ICameraProvider.hstatic ::android::sp&lt;ICameraProvider&gt; getService(const std::string &amp;serviceName="default", bool getStub=false);static ::android::sp&lt;ICameraProvider&gt; getService( const ::android::hardware::hidl_string&amp; serviceName, bool getStub=false) &#123; std::string str(serviceName.c_str()); return getService(str, getStub); &#125; 服务注册流程图注册流程，查看大图 CameraProvider 初始化从 main 方法中的 defaultPassthroughServiceImplementation 展开： 12345678910111213141516// LegacySupport.htemplate&lt;class Interface&gt;__attribute__((warn_unused_result))status_t defaultPassthroughServiceImplementation(std::string name, size_t maxThreads = 1) &#123; configureRpcThreadpool(maxThreads, true); status_t result = registerPassthroughServiceImplementation&lt;Interface&gt;(name); if (result != OK) &#123; return result; &#125; joinRpcThreadpool(); return 0;&#125; 除了配置 Binder 机制中 RPC 线程池，就是注册直通式 HAL ： 1234567891011121314// LegacySupport.htemplate&lt;class Interface&gt;__attribute__((warn_unused_result))status_t registerPassthroughServiceImplementation( std::string name = "default") &#123; // 获取服务 sp&lt;Interface&gt; service = Interface::getService(name, // getStub 为 true，表示通过 dlopen 的方式加载 HAL true /* getStub */); ... status_t status = service-&gt;registerAsService(name); ... return status;&#125; 传入模板的类为 ICameraProvider ，我们来看获取服务的代码，CameraProviderAll.cpp 文件是根据 ICameraProvider.hal 自动生成的 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// CameraProviderAll.cppconst char* ICameraProvider::descriptor( "android.hardware.camera.provider@2.4::ICameraProvider");::android::sp&lt;ICameraProvider&gt; ICameraProvider::getService( const std::string &amp;serviceName, const bool getStub) &#123; using ::android::hardware::defaultServiceManager; using ::android::hardware::details::waitForHwService; using ::android::hardware::getPassthroughServiceManager; using ::android::hardware::Return; using ::android::sp; using Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport; ... const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm = defaultServiceManager(); ... // Binder HAL for (int tries = 0; !getStub &amp;&amp; (vintfHwbinder || (vintfLegacy &amp;&amp; tries == 0)); tries++) &#123; ... if (vintfHwbinder &amp;&amp; tries &gt; 0) &#123; waitForHwService(ICameraProvider::descriptor, serviceName); &#125; Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = sm-&gt;get(ICameraProvider::descriptor, serviceName); ... sp&lt;::android::hidl::base::V1_0::IBase&gt; base = ret; ... Return&lt;sp&lt;ICameraProvider&gt;&gt; castRet = ICameraProvider::castFrom( base, true /* emitError */); ... iface = castRet; ... return iface; &#125; // 直通式 HAL if (getStub || vintfPassthru || vintfLegacy) &#123; const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager(); if (pm != nullptr) &#123; Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = pm-&gt;get(ICameraProvider::descriptor, serviceName); if (ret.isOk()) &#123; sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface=ret; if (baseInterface != nullptr) &#123; iface = ICameraProvider::castFrom(baseInterface); if (!getStub || trebleTestingOverride) &#123; iface = new BsCameraProvider(iface); &#125; &#125; &#125; &#125; &#125; return iface;&#125; getStub 的值决定 getService 是 Binder 式或者直通式来获取 HAL ，主要区别在于获取 IServiceManager 方式及对应实例会不一样： Binder通过 defaultServiceManager 获取，实际实例为 ServiceManager 。 直通式通过 getPassthroughServiceManager 获取，实际实例为 ServiceManagement 。 getStub 为 false ，所以采用直通式，get 方法获取服务实例分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// ServiceManagement.cppsp&lt;IServiceManager1_0&gt; getPassthroughServiceManager() &#123; return getPassthroughServiceManager1_1();&#125;sp&lt;IServiceManager1_1&gt; getPassthroughServiceManager1_1() &#123; static sp&lt;PassthroughServiceManager&gt; manager( new PassthroughServiceManager()); return manager;&#125;struct PassthroughServiceManager : IServiceManager1_1 &#123; static void openLibs(const std::string&amp; fqName, std::function&lt;bool /* continue */(void* /* handle */, const std::string&amp; /* lib */, const std::string&amp; /* sym */)&gt; eachLib) &#123; //fqName looks like android.hardware.foo@1.0::IFoo ... std::string packageAndVersion = fqName.substr(0, idx); std::string ifaceName = fqName.substr(idx + strlen("::")); const std::string prefix = packageAndVersion + "-impl"; // 获取函数名，以 HIDL_FETCH_ 开头 const std::string sym = "HIDL_FETCH_" + ifaceName; const int dlMode = RTLD_LAZY; void *handle = nullptr; dlerror(); // clear std::vector&lt;std::string&gt; paths = &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR, HAL_LIBRARY_PATH_VNDK_SP, HAL_LIBRARY_PATH_SYSTEM&#125;; ... for (const std::string&amp; path : paths) &#123; std::vector&lt;std::string&gt; libs = search(path, prefix, ".so"); for (const std::string &amp;lib : libs) &#123; const std::string fullPath = path + lib; // dlopen 加载 HAL 库 if (path != HAL_LIBRARY_PATH_SYSTEM) &#123; handle = android_load_sphal_library(fullPath.c_str(), dlMode); &#125; else &#123; handle = dlopen(fullPath.c_str(), dlMode); &#125; ... // 调用函数指针 if (!eachLib(handle, lib, sym)) &#123; return; &#125; &#125; &#125; &#125; Return&lt;sp&lt;IBase&gt;&gt; get(const hidl_string&amp; fqName, const hidl_string&amp; name) override &#123; sp&lt;IBase&gt; ret = nullptr; // dlopen 打开库文件 openLibs(fqName, [&amp;](void* handle, const std::string &amp;lib, const std::string &amp;sym) &#123; IBase* (*generator)(const char* name); // 获取 HIDL_FETCH_ICameraProvider 函数 *(void **)(&amp;generator) = dlsym(handle, sym.c_str()); ... // 调用 HIDL_FETCH_ICameraProvider 函数 ret = (*generator)(name.c_str()); ... return false; &#125;); return ret; &#125; ...&#125; IServiceManager 直通式对应的实例为 PassthroughServiceManager ，它的 get 方法会先通过 openLibs 打开 HAL 库文件，并从库文件中 dlsym 调用以 HIDL_FETCH_ 开头的函数，获取对应实例： 1234567891011121314151617181920// ICameraProvider.hextern "C" ICameraProvider* HIDL_FETCH_ICameraProvider(const char* name);// ICameraProvider.cppICameraProvider* HIDL_FETCH_ICameraProvider(const char* name) &#123; if (strcmp(name, kLegacyProviderName) != 0) &#123; return nullptr; &#125; CameraProvider* provider = new CameraProvider(); if (provider == nullptr) &#123; ALOGE("%s: cannot allocate camera provider!", __FUNCTION__); return nullptr; &#125; if (provider-&gt;isInitFailed()) &#123; ALOGE("%s: camera provider init failed!", __FUNCTION__); delete provider; return nullptr; &#125; return provider;&#125; HIDL_FETCH_ICameraProvider 主要任务是新建 ICameraProvider 对象。整个流程下来，从 service.cpp 开启进程，注册 Binder 化直通式 HAL 时，通过 dlopen 方式加载 HAL 库，并通过 HIDL_FETCH_ICameraProvider 来新建 ICameraProvider 对象。 Hardware AOSP 和 Hardware qcom 关联过程hardware/interfaces/camera 是 Android 系统的标准接口，即 Hardware AOSP ；但是每个芯片厂商的具体实现都会不一样，高通平台在 hardware/qcom/camera 中实现了对 vendor camera 代码中的封装，即 Hardware qcom。hardware/qcom/camera 代码生成对应库文件为 camera.msm8937.so ，hardware/interfaces/camera 是通过 dlopen 来加载这个库的，具体由 CameraProvider.cpp 加载，我们分析加载及函数指针关联的过程： 12345678910111213141516// Camera_common.h#define CAMERA_HARDWARE_MODULE_ID "camera"// CameraProvider.cppCameraProvider::CameraProvider() : camera_module_callbacks_t(&#123;sCameraDeviceStatusChange, sTorchModeStatusChange&#125;) &#123; mInitFailed = initialize();&#125;bool CameraProvider::initialize() &#123; camera_module_t *rawModule; int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); ...&#125; CameraProvider::initialize 初始化过程中，通过 hw_get_module 来加载库，并拿到 camera_module_t 结构体对应的函数指针；CAMERA_HARDWARE_MODULE_ID 是在 Camera_common.h 中定义的 camera： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// hardware.cint hw_get_module(const char *id, const struct hw_module_t **module)&#123; return hw_get_module_by_class(id, NULL, module);&#125;int hw_get_module_by_class(const char *class_id, const char *inst, const struct hw_module_t **module)&#123; int i = 0; char prop[PATH_MAX] = &#123;0&#125;; char path[PATH_MAX] = &#123;0&#125;; char name[PATH_MAX] = &#123;0&#125;; char prop_name[PATH_MAX] = &#123;0&#125;; if (inst) snprintf(name, PATH_MAX, "%s.%s", class_id, inst); else strlcpy(name, class_id, PATH_MAX); // 先通过 ro.hardware.camera 查找库文件是否存在 snprintf(prop_name, sizeof(prop_name), "ro.hardware.%s", name); if (property_get(prop_name, prop, NULL) &gt; 0) &#123; if (hw_module_exists(path, sizeof(path), name, prop) == 0) &#123; goto found; &#125; &#125; // 再根据其他可能存在的变种查找 for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) &#123; if (property_get(variant_keys[i], prop, NULL) == 0) &#123; continue; &#125; if (hw_module_exists(path, sizeof(path), name, prop) == 0) &#123; goto found; &#125; &#125; // 如果都找不到，再查找 camera.default.so if (hw_module_exists(path, sizeof(path), name, "default") == 0) &#123; goto found; &#125; return -ENOENT;found: // 找到了就加载 return load(class_id, path, module);&#125; 整个代码流程，是逐步查找库文件的过程，如果找到了再加载，这里重点看下几个可能存在的变种命名方式，规则是 &lt;MODULE_ID&gt;.variant.so ： 123456789101112// hardware.cstatic const char *variant_keys[] = &#123; "ro.hardware", /* This goes first so that it can pick up a different file on the emulator. */ "ro.product.board", "ro.board.platform", "ro.arch"&#125;;static const int HAL_VARIANT_KEYS_COUNT = (sizeof(variant_keys)/sizeof(variant_keys[0])); 当前平台，camera 库文件变种可能为：caemra.qcom.so, camera.QC_Reference_Phone.so, camera.msm8937.so ，实际上只有 camera.8937.so 是存在的： 1234567891011121314151617181920212223242526272829303132// hardware.c/** Base path of the hal modules */#if defined(__LP64__)#define HAL_LIBRARY_PATH1 "/system/lib64/hw"#define HAL_LIBRARY_PATH2 "/vendor/lib64/hw"#define HAL_LIBRARY_PATH3 "/odm/lib64/hw"#else#define HAL_LIBRARY_PATH1 "/system/lib/hw"#define HAL_LIBRARY_PATH2 "/vendor/lib/hw"#define HAL_LIBRARY_PATH3 "/odm/lib/hw"#endifstatic int hw_module_exists(char *path, size_t path_len,const char *name, const char *subname)&#123; snprintf(path, path_len, "%s/%s.%s.so", HAL_LIBRARY_PATH3, name, subname); if (access(path, R_OK) == 0) return 0; snprintf(path, path_len, "%s/%s.%s.so", HAL_LIBRARY_PATH2, name, subname); if (access(path, R_OK) == 0) return 0; snprintf(path, path_len, "%s/%s.%s.so", HAL_LIBRARY_PATH1, name, subname); if (access(path, R_OK) == 0) return 0; return -ENOENT;&#125; 根据平台是否为 64 位，分别从 /system, /vendor/, /odm 几个目录下去搜索，直到找到为止，当前平台库文件绝对路径为：/vendor/lib/hw/camera.msm8937.so ，找到后加载： 123456789101112131415161718192021222324252627// hardware.h#define HAL_MODULE_INFO_SYM HMI#define HAL_MODULE_INFO_SYM_AS_STR "HMI"// hardware.cstatic int load(const char *id, const char *path, const struct hw_module_t **pHmi)&#123; int status = -EINVAL; void *handle = NULL; struct hw_module_t *hmi = NULL; if (strncmp(path, "/system/", 8) == 0) &#123; handle = dlopen(path, RTLD_NOW); &#125; else &#123; handle = android_load_sphal_library(path, RTLD_NOW); &#125; ... /* Get the address of the struct hal_module_info. */ const char *sym = HAL_MODULE_INFO_SYM_AS_STR; hmi = (struct hw_module_t *)dlsym(handle, sym); ... *pHmi = hmi; return status;&#125; 通过 dlopen 的方式加载库文件 /vendor/lib/hw/camera.msm8937.so ，并找到 HAL_MODULE_INFO_SYM 结构体变量，它是一组函数指针的关联，返回的是 hw_module_t 结构体指针，我们看头文件的定义： 1234567891011121314151617181920212223242526272829303132333435// hardware.h/** * Every hardware module must have a data structure * named HAL_MODULE_INFO_SYM * and the fields of this data structure must begin with hw_module_t * followed by module specific information. */typedef struct hw_module_t &#123; uint32_t tag; uint16_t module_api_version; #define version_major module_api_version uint16_t hal_api_version;#define version_minor hal_api_version const char *id; const char *name; const char *author; struct hw_module_methods_t* methods; void* dso;#ifdef __LP64__ uint64_t reserved[32-7];#else uint32_t reserved[32-7];#endif&#125; hw_module_t;typedef struct hw_module_methods_t &#123; /** Open a specific device */ int (*open)(const struct hw_module_t* module, const char* id, struct hw_device_t** device);&#125; hw_module_methods_t; 从注释中可以看到，hardware 中任何模块，必须有一个命名为 HAL_MODULE_INFO_SYM 数据结构（dlsym 查找时固定命名），并且结构体的第一个数据结构必须是 hw_module_t 的。在 CameraProvider::initialize 中 camera_module_t, hw_module_t 这两个结构体直接转换了，我们来看 camera_module_t 的定义： 12345678910111213141516// Camera_common.htypedef struct camera_module &#123; hw_module_t common; int (*get_number_of_cameras)(void); int (*get_camera_info)(int camera_id, struct camera_info *info); int (*set_callbacks)(const camera_module_callbacks_t *callbacks); void (*get_vendor_tag_ops)(vendor_tag_ops_t* ops); int (*open_legacy)(const struct hw_module_t* module, const char* id, uint32_t halVersion, struct hw_device_t** device); int (*set_torch_mode)(const char* camera_id, bool enabled); int (*init)(); /* reserved for future use */ void* reserved[5];&#125; camera_module_t; camera_module_t 结构体的定义完全符合 hardware.h 中对 hw_module_t 的注释，因为是第一个数据结构，所以可以直接转换。我们到 camera.msm8937.so 对应代码模块 hardware/qcom/camera 中去查找定义了 HAL_MODULE_INFO_SYM 的文件 QCamera2Hal.cpp ： 123456789101112131415161718192021222324// QCamera2Hal.cppstatic hw_module_t camera_common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_2_4, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = "QCamera Module", .author = "Qualcomm Innovation Center Inc", .methods = &amp;qcamera::QCamera2Factory::mModuleMethods, .dso = NULL, .reserved = &#123;0&#125;&#125;;camera_module_t HAL_MODULE_INFO_SYM = &#123; .common = camera_common, .get_number_of_cameras = qcamera::QCamera2Factory::get_number_of_cameras, .get_camera_info = qcamera::QCamera2Factory::get_camera_info, .set_callbacks = qcamera::QCamera2Factory::set_callbacks, .get_vendor_tag_ops = qcamera::QCamera3VendorTags::get_vendor_tag_ops, .open_legacy = qcamera::QCamera2Factory::open_legacy, .set_torch_mode = qcamera::QCamera2Factory::set_torch_mode, .init = NULL, .reserved = &#123;0&#125;&#125;; 至此：CameraProvider::initialize 中，通过 hw_get_module 加载了 camera.msm8937.so 库，并拿到了 HAL_MODULE_INFO_SYM 对应的数据结构指针，最终会保存到 CameraModule 中。 Hardware qcom 目录123456789101112131415161718192021222324camera/├── Android.mk├── CleanSpec.mk├── common.mk├── mm-image-codec│ ├── Android.mk│ ├── qexif│ └── qomx_core├── MODULE_LICENSE_BSD├── QCamera2│ ├── Android.mk│ ├── HAL│ ├── HAL3│ ├── QCamera2Factory.cpp│ ├── QCamera2Factory.h│ ├── QCamera2Hal.cpp│ ├── QCameraFormat.h│ ├── stack│ └── util├── QCamera_Intf.h├── QCameraParameters.h└── usbcamcore ├── inc └── src QCamera_Intf.h 定义了很多数据结构（接口层）； QCameraParameters.h 是 HAL 1 中使用的参数； mm-image-codec 目录涉及到高通平台图片的软硬解码； usbcamcore 是 usb 摄像头相关代码； 而 QCamera2 目录用来封装高通平台私有代码，也是需要重点熟悉的目录。 QCamera2 目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283QCamera2├── Android.mk├── HAL│ ├── android│ ├── CameraParameters.cpp│ ├── CameraParameters.h│ ├── DCSBokehProcessor.cpp│ ├── DCSBokehProcessor.h│ ├── DCSSuperNightProcessor.cpp│ ├── DCSSuperNightProcessor.h│ ├── QCamera2HWICallbacks.cpp│ ├── QCamera2HWI.cpp│ ├── QCamera2HWI.h│ ├── QCameraAllocator.h│ ├── QCameraChannel.cpp│ ├── QCameraChannel.h│ ├── QCameraMem.cpp│ ├── QCameraMem.h│ ├── QCameraMuxer.cpp│ ├── QCameraMuxer.h│ ├── QCameraParameters.cpp│ ├── QCameraParameters.h│ ├── QCameraParametersIntf.cpp│ ├── QCameraParametersIntf.h│ ├── QCameraPostProc.cpp│ ├── QCameraPostProc.h│ ├── QCameraStateMachine.cpp│ ├── QCameraStateMachine.h│ ├── QCameraStream.cpp│ ├── QCameraStream.h│ ├── QCameraThermalAdapter.cpp│ ├── QCameraThermalAdapter.h│ ├── test│ ├── tsMakeuplib│ ├── westalgo│ └── wrapper├── HAL3│ ├── android│ ├── QCamera3Channel.cpp│ ├── QCamera3Channel.h│ ├── QCamera3CropRegionMapper.cpp│ ├── QCamera3CropRegionMapper.h│ ├── QCamera3HALHeader.h│ ├── QCamera3HWI.cpp│ ├── QCamera3HWI.h│ ├── QCamera3Mem.cpp│ ├── QCamera3Mem.h│ ├── QCamera3PostProc.cpp│ ├── QCamera3PostProc.h│ ├── QCamera3Stream.cpp│ ├── QCamera3Stream.h│ ├── QCamera3StreamMem.cpp│ ├── QCamera3StreamMem.h│ ├── QCamera3VendorTags.cpp│ ├── QCamera3VendorTags.h│ └── test├── QCamera2Factory.cpp├── QCamera2Factory.h├── QCamera2Hal.cpp├── QCameraFormat.h├── stack│ ├── Android.mk│ ├── common│ ├── mm-camera-interface│ ├── mm-camera-test│ ├── mm-jpeg-interface│ └── mm-lib2d-interface└── util ├── QCameraBufferMaps.cpp ├── QCameraBufferMaps.h ├── QCameraCmdThread.cpp ├── QCameraCmdThread.h ├── QCameraCommon.cpp ├── QCameraCommon.h ├── QCameraDisplay.cpp ├── QCameraDisplay.h ├── QCameraFlash.cpp ├── QCameraFlash.h ├── QCameraPerf.cpp ├── QCameraPerf.h ├── QCameraQueue.cpp ├── QCameraQueue.h └── QCameraTrace.h QCamera2 目录中，QCamera2Hal.cpp 函数指针和结构体赋值，用于关联 hardware AOSP 和 hardware qcom ； QCamera2Factory.h/cpp 工厂类，封装了 HAL 1/3 作为统一入口；子目录有如下几个： HALHAL 1 对应代码目录，其中 QCamera2HWI.cpp 为统一的接口文件。 HAL3HAL 3 对应代码目录，其中 QCamera3HWI.cpp 为统一的接口文件；QCamera3Channel 信道处理对应的流 QCamera3Stream 。 stackcommon 目录仅仅定义了头文件，其他三个 interface 目录分别为：mm-camera-interface 用于和 vendor/qcom/mm-camera 目录通信的接口目录；mm-jpeg-interface 软硬解码的接口目录；mm-lib2d-interface 没有参与编译。 util工具目录。 stack 目录1234567891011121314151617181920212223242526272829303132333435363738394041424344454647stack/├── Android.mk├── common│ ├── cam_intf.h│ ├── cam_list.h│ ├── cam_queue.h│ ├── cam_semaphore.h│ ├── cam_types.h│ ├── mm_camera_interface.h│ ├── mm_camera_shim.h│ └── mm_jpeg_interface.h├── mm-camera-interface│ ├── Android.mk│ ├── inc│ │ ├── mm_camera_dbg.h│ │ ├── mm_camera.h│ │ └── mm_camera_sock.h│ └── src│ ├── mm_camera.c // 总控制│ ├── mm_camera_channel.c // channel 处理│ ├── mm_camera_interface.c // 对 HAL 的统一接口│ ├── mm_camera_sock.c // 和 vendor 是通过 socket 通信│ ├── mm_camera_stream.c // stream 处理│ └── mm_camera_thread.c // 多线程├── mm-camera-test│ ├── ...├── mm-jpeg-interface│ ├── Android.mk│ ├── inc│ │ ├── mm_jpeg_dbg.h│ │ ├── mm_jpeg.h│ │ ├── mm_jpeg_inlines.h│ │ ├── mm_jpeg_ionbuf.h│ │ └── mm_jpeg_mpo.h│ ├── src│ │ ├── mm_jpeg.c│ │ ├── mm_jpegdec.c│ │ ├── mm_jpegdec_interface.c│ │ ├── mm_jpeg_exif.c│ │ ├── mm_jpeg_interface.c│ │ ├── mm_jpeg_ionbuf.c│ │ ├── mm_jpeg_mpo_composer.c│ │ └── mm_jpeg_queue.c│ └── test│ ├── ...└── mm-lib2d-interface ├── ... 这个目录的核心代码主要是 mm-camera-interface 目录下的代码： 接口层 mm_camera_interface.c不管 HAL 1 还是 HAL 3 ，高通平台 vendor 下的代码都是同一套，是没有区别的， mm_camera_interface.c 是对 HAL 统一的接口。 实现层 mm_camera.c管理 channel, stream, thread, socket 等，实现和 vendor 的通信。当前高通平台 msm8937 中 HAL 和 vendor 的通信有两部分：一是通过 socket 来映射内存信息；二是 ioctl 向 v4l2 驱动发送命令做信息交互（查看高通网站上的文档，后续会取消 socket 通信，统一使用 mshim 管理；在 mm_camera 中，这两套方式都实现了：如果定义了 DAEMON_PRESENT 则 socket 通信，否则 mshim 方式管理）。 接口层的几个基本概念 Channel信道，一个松散的概念，用于将多个图像流捆绑在一起处理；即一个信道包含多个流（这句话更准确的说法是：一个信道 ID 对应多个信道实例 QCamera3MetadataChannel, QCamera3PicChannel 等，而每个信道实例仅对应一个流 QCamera3Stream ；也就是说实际上是一个信道 ID 包含多个流）。常见信道：ZSL, Capture, Preview, Snapshot, Video, Raw, Metadata 。 Stream流，最小流元素，每个流只能有一种格式；它是在相机硬件和应用程序之间交换捕获图像缓冲区的接口。常见流有：Preview, Postview, Metadata, Raw, Snapshot, Video, Reprocessing 。 Stream bundling流集合，在信道内捆绑的多个流：在打开所有捆绑流之前，硬件不会启动流；当第一个捆绑流关闭时，硬件停止。在捕获请求开始时，会查询信道 ID 中所有的流，并捆绑设置到每个信道实例中。 Socket 通信的意义Socket 在这里主要功能是在 Hardware qcom 和 vendor qcom 两个进程间共享缓存信息。交换的缓存信息有如下几种类型： CAM_MAPPING_BUF_TYPE_CAPABILITY ：缓存区大小 CAM_MAPPING_BUF_TYPE_PARM_BUF ：参数缓存区 CAM_MAPPING_BUF_TYPE_STREAM_BUF ：流缓存区 CAM_MAPPING_BUF_TYPE_STREAM_INFO ：流信息缓存区 CAM_MAPPING_BUF_TYPE_OFFLINE_INPUT_BUF ：离线重新处理输入的缓存区 Socket 相关代码位置及对应功能： 实现类：QCamera2\stack\mm-camera-interface\src\mm_camera_sock.c 消息发送者：QCamera2\stack\mm-camera-interface\src\mm_camera_stream.c 消息接收者：mm-camera\mm-camera2\server-imaging\server.c ioctl 支持的命令高通 Camera HAL 和 kernel 通信是通过 V4L2 IOCTLs 命令来和 /dev/videoX 节点通信的，支持的命令列表如下： VIDIOC_S_FMT ：设置预览和拍照的格式为 YUV420 VIDIOC_S_CTRL ：向设备传输控制信息 VIDIOC_G_CTRL ：从设备获取控制信息 VIDIOC_QBUF ：入队或分配预览缓存区 Buffers VIDIOC_DQBUF ：出队或释放预览缓存区 Buffers VIDIOC_STREAMON 开始预览 VIDIOC_STREAMOFF ：停止预览 VIDIOC_QUERYCAP ：查询设备支持的能力 VIDIOC_QUERYBUF ：查询缓存区 Buffers 的信息 VIDIOC_REQBUFS ：请求注册缓存区 Buffers VIDIOC_DQEVENT ：注册到 kernel 的事件出队 HAL 1/3 差异API 1/2 设计的目的 Camera API 1 子系统被设计为具备高级控制功能的黑盒 应用程序能够发出请求，但无法控制图像缓冲区和元数据 应用程序无法在帧层面控制传感器特性 应用程序无法通过访问和修改元数据信息（如 3A 信息）对捕获的帧应用任何增强功能 Camera API 2 旨在大幅提高应用程序控制摄像头子系统的能力 应用程序框架向摄像头子系统请求一帧图像，摄像头子系统将请求结果与相关元数据信息（如色彩空间）一起返回到输出流；同时为每个结果数据流生成镜头阴影信息 应用程序对整个摄像头管道的控制能力得到提升。每个拍摄请求会产生一个带有拍摄元数据的结果对象和一些图像数据缓冲区 元数据信息有助于应用程序了解摄像头管道的当前状态（ 3A 和 ISP 状态）以对缓冲区进行相关处理 通常情况下搭配原则：API 1 + HAL 1 和 API 2 + HAL 3 。 HAL 1/3 对应功能概述 HAL 1 被设计为具有高级控件和以下三种运行模式的黑盒子：预览、视频录制、静态拍摄。三种模式具有略有不同又相互重叠的功能，这样就难以实现介于其中两种运行模式之间的新功能，例如连拍模式等。 HAL 3 子系统将多个运行模式整合为一个统一的视图，可以使用这种视图实现之前的任何模式以及一些其他模式，例如连拍模式。相机子系统被塑造为一个管道，该管道可按照 1:1 的基准将传入的帧捕获请求转化为帧。这些请求会封装有关帧的捕获和处理的所有配置信息：分辨率、像素格式、手动传感器、镜头、闪光灯控件、3A 运行模式、RAW-&gt;YUV 处理控件/统计信息生成等等。这样一来，便可以提高用户对聚焦、曝光以及更多后期处理（例如降噪、对比度和锐化）效果的控制能力。简单来说，应用框架从相机子系统请求帧，然后相机子系统将结果返回到输出流。此外系统还会针对每组结果生成包含色彩空间和镜头阴影等信息的元数据。 可以将 HAL 3 看作 HAL 1 的单向流管道，它会将每个捕获请求转化为传感器捕获的一张图像，这张图像将被处理成： 包含有关捕获的元数据的结果对象 图像数据的 1 到 N 个缓冲区，每个缓冲区会进入自己的目的地 Surface 可能的输出 Surface 组经过预配置： 每个 Surface 都是一个固定分辨率的图像缓冲区流的目标位置 一次只能将少量 Surface 配置为输出（约 3 个） 一个请求中包含所需的全部捕获设置，以及要针对该请求将图像缓冲区（从总配置组）推送到其中的输出 Surface 的列表。请求可以只发生一次 capture() ，也可以无限重复 setRepeatingRequest() ，捕获的优先级高于重复请求的优先级。 HAL 3 原理总结 异步拍摄请求来源于框架 硬件抽象层 HAL 按顺序处理这些请求。收到请求后，HAL 产生输出结果元数据以及一个或多个输出图像缓冲区 该进程遵循先进先出 FIFO 原则处理请求、结果以及后续请求参考的流 给定请求的所有输出的时间戳必须相同。如有需要，框架会一同匹配这些时间戳 所有拍摄配置和状态均属于拍摄请求和结果的一部分 应用程序可以请求带有特定设置的帧，例如，曝光设置和 HAL3（ FULL 模式），从而确保拍摄请求设置和产生的实际图像保持精确同步 接口区别HAL 1 VS HAL 3，查看原图 HAL, DEVICE, MODULE 各版本这些版本号都是在 Camera_common.h 文件中定义的。 Module 版本Module 没有兼容性问题，总是使用最新版本；当前为 CAMERA_MODULE_API_VERSION_2_4 。 12345678#define CAMERA_MODULE_API_VERSION_1_0 HARDWARE_MODULE_API_VERSION(1, 0)#define CAMERA_MODULE_API_VERSION_2_0 HARDWARE_MODULE_API_VERSION(2, 0)#define CAMERA_MODULE_API_VERSION_2_1 HARDWARE_MODULE_API_VERSION(2, 1)#define CAMERA_MODULE_API_VERSION_2_2 HARDWARE_MODULE_API_VERSION(2, 2)#define CAMERA_MODULE_API_VERSION_2_3 HARDWARE_MODULE_API_VERSION(2, 3)#define CAMERA_MODULE_API_VERSION_2_4 HARDWARE_MODULE_API_VERSION(2, 4)#define CAMERA_MODULE_API_VERSION_CURRENT CAMERA_MODULE_API_VERSION_2_4 HAL 版本HAL 版本在代码中实际指的是 Device 的版本。因为要兼容早期的 Camera API ，通常必须支持 1.0 版本；2.x 版本已经废弃不再支持；而 3.0 及以上版本是为 Camera API 2 使用的。 123456789101112#define CAMERA_DEVICE_API_VERSION_1_0 HARDWARE_DEVICE_API_VERSION(1, 0) // DEPRECATED#define CAMERA_DEVICE_API_VERSION_2_0 HARDWARE_DEVICE_API_VERSION(2, 0) // NO LONGER SUPPORTED#define CAMERA_DEVICE_API_VERSION_2_1 HARDWARE_DEVICE_API_VERSION(2, 1) // NO LONGER SUPPORTED#define CAMERA_DEVICE_API_VERSION_3_0 HARDWARE_DEVICE_API_VERSION(3, 0) // NO LONGER SUPPORTED#define CAMERA_DEVICE_API_VERSION_3_1 HARDWARE_DEVICE_API_VERSION(3, 1) // NO LONGER SUPPORTED#define CAMERA_DEVICE_API_VERSION_3_2 HARDWARE_DEVICE_API_VERSION(3, 2)#define CAMERA_DEVICE_API_VERSION_3_3 HARDWARE_DEVICE_API_VERSION(3, 3)#define CAMERA_DEVICE_API_VERSION_3_4 HARDWARE_DEVICE_API_VERSION(3, 4)// Device version 3.4 is current, older HAL camera device versions are not// recommended for new devices.#define CAMERA_DEVICE_API_VERSION_CURRENT CAMERA_DEVICE_API_VERSION_3_4 每个 DEVICE_API_VERSION 对应的值为： 1234567CAMERA_DEVICE_API_VERSION_1_0 = 256CAMERA_DEVICE_API_VERSION_2_0 = 512CAMERA_DEVICE_API_VERSION_3_0 = 768CAMERA_DEVICE_API_VERSION_3_1 = 769CAMERA_DEVICE_API_VERSION_3_2 = 770CAMERA_DEVICE_API_VERSION_3_3 = 771CAMERA_DEVICE_API_VERSION_3_4 = 772 我们通常所说的 HAL 1 指的是 CAMERA_DEVICE_API_VERSION_1_0 版本；HAL 3 泛指 CAMERA_DEVICE_API_VERSION_3_0 及以上版本。 HIDL 中生成的 deviceName返回值格式：&#39;device@&lt;major&gt;.&lt;minor&gt;/&lt;type&gt;/&lt;id&gt;&#39; ，比如： device@1.0/legacy/1 ：表示 HAL 版本号为 CAMERA_DEVICE_API_VERSION_1_0 ， id=1 表示摄像头为前置摄像头 device@3.3/legacy/0 ：表示 HAL 版本号为 CAMERA_DEVICE_API_VERSION_3_3 ，id=0 表示摄像头为后置摄像头 源码分析： 12345678910111213141516171819202122232425262728293031323334// CameraProvider.cppstd::string CameraProvider::getHidlDeviceName( std::string cameraId, int deviceVersion) &#123; if (deviceVersion != CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp; deviceVersion != CAMERA_DEVICE_API_VERSION_3_2 &amp;&amp; deviceVersion != CAMERA_DEVICE_API_VERSION_3_3 &amp;&amp; deviceVersion != CAMERA_DEVICE_API_VERSION_3_4 ) &#123; return hidl_string(""); &#125; bool isV1 = deviceVersion == CAMERA_DEVICE_API_VERSION_1_0; int versionMajor = isV1 ? 1 : 3; int versionMinor = isV1 ? 0 : mPreferredHal3MinorVersion; char deviceName[kMaxCameraDeviceNameLen]; snprintf(deviceName, sizeof(deviceName), "device@%d.%d/legacy/%s", versionMajor, versionMinor, cameraId.c_str()); return deviceName;&#125;// CameraProvider 在初始化时，mPreferredHal3MinorVersion 赋值为 3bool CameraProvider::initialize() &#123; ... mPreferredHal3MinorVersion = property_get_int32("ro.camera.wrapper.hal3TrebleMinorVersion",3); switch(mPreferredHal3MinorVersion) &#123; case 2: case 3: // OK break; default: ALOGW(...); mPreferredHal3MinorVersion = 3; &#125; ...&#125; 从代码中可以看出，通过 CameraProvider::getHidlDeviceName 对外提供的 HAL 版本只有两种：CAMERA_DEVICE_API_VERSION_1_0 和 CAMERA_DEVICE_API_VERSION_3_3 。 平台当前使用哪个 HAL 版本平台当前使用哪个 HAL 版本，是在 QCamera2Factory 的构造函数中决定的，当 isHAL3Enabled 并且 is_yuv_sensor 当前摄像头不是 yuv sensor 时，才会设置为 HAL 3 。 12345678910111213141516171819202122232425262728293031323334QCamera2Factory::QCamera2Factory()&#123; ... // 1. 是否启用 HAL 3 property_get("persist.camera.HAL3.enabled", prop, "0"); int isHAL3Enabled = atoi(prop);#ifndef QCAMERA_HAL1_SUPPORT isHAL3Enabled = 1;#endif ... if((mNumOfCameras &gt; 0) &amp;&amp;(mNumOfCameras &lt;= MM_CAMERA_MAX_NUM_SENSORS))&#123; mHalDescriptors = new hal_desc[mNumOfCameras]; if ( NULL != mHalDescriptors) &#123; uint32_t cameraId = 0; for (int i = 0; i &lt; mNumOfCameras ; i++, cameraId++) &#123; mHalDescriptors[i].cameraId = cameraId; // Set Device version to 3.x when both HAL3 is enabled // &amp; its BAYER sensor // 2. 是否为 yuv sensor if (isHAL3Enabled &amp;&amp; !(is_yuv_sensor(cameraId))) &#123; mHalDescriptors[i].device_version = CAMERA_DEVICE_API_VERSION_3_0; &#125; else &#123; mHalDescriptors[i].device_version = CAMERA_DEVICE_API_VERSION_1_0; &#125; &#125; &#125; else &#123; LOGE("Not enough resources to allocate HAL descriptor table!"); &#125; &#125; &#125; 高通平台开启 HAL 3 的情况下，为了兼容性同时也会支持 HAL 1 。 高通代码中混乱的 HAL 版本号高通代码中 HAL/DEVICE 的具体版本号，不同的函数返回的版本号不一样，有点混乱： QCamera2Factory 中mHalDescriptors[camera_id].device_version 保存的版本号，在构造函数中初始化为 CAMERA_DEVICE_API_VERSION_3_0 (768) ；mHalDescriptors 并不对外提供信息，仅在 QCamera2Factory::cameraDeviceOpen 时会用来区分 HAL1/3 。 1234567891011121314151617181920212223242526272829303132333435363738394041int QCamera2Factory::cameraDeviceOpen(int camera_id, struct hw_device_t **hw_device)&#123; ... if ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123; // HAL 3 使用 QCamera3HardwareInterface QCamera3HardwareInterface *hw = new QCamera3HardwareInterface( mHalDescriptors[camera_id].cameraId, mCallbacks); if (!hw) &#123; LOGE("Allocation of hardware interface failed"); return NO_MEMORY; &#125; rc = hw-&gt;openCamera(hw_device); if (rc != 0) &#123; delete hw; &#125; &#125;#ifdef QCAMERA_HAL1_SUPPORT else if (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123; // HAL 1 使用 QCamera2HardwareInterface QCamera2HardwareInterface *hw = new QCamera2HardwareInterface((uint32_t)camera_id); if (!hw) &#123; LOGE("Allocation of hardware interface failed"); return NO_MEMORY; &#125; rc = hw-&gt;openCamera(hw_device); if (rc != NO_ERROR) &#123; delete hw; &#125; &#125;#endif else &#123; LOGE("Device version for camera id %d invalid %d", camera_id, mHalDescriptors[camera_id].device_version); return BAD_VALUE; &#125; ...&#125; QCamera3HWI 中函数 getCamInfo 获取到的版本号为 CAMERA_DEVICE_API_VERSION_3_4 (772) ；这导致所有通过 CameraModule.getCameraInfo 获取到的版本号都将是该值。 1234567891011121314// QCamera3HWI.cppint QCamera3HardwareInterface::getCamInfo(uint32_t cameraId, struct camera_info *info)&#123;...// 不管之前 HAL 版本是多少，在这都会被更新为 3.4 或者 3.3// 这里代码实际走到的是 3.4#ifndef USE_HAL_3_3 info-&gt;device_version = CAMERA_DEVICE_API_VERSION_3_4;#else info-&gt;device_version = CAMERA_DEVICE_API_VERSION_3_3;#endif..&#125; CameraProviderManager 中函数 getHighestSupportedVersion 获取到的版本号为 CAMERA_DEVICE_API_VERSION_3_3 (771) ，它是根据 CameraProvider::getHidlDeviceName 来解析的，而这个名字默认的只提供两种版本号 3.3 和 1.0 。 所以在 Framework 中 CameraService.cpp 将 halVersion 和 deviceVersion 做了区分（实际上如果代码全部统一，就没必要区分了）；而 Hardware 中通常简化为 HAL 1, HAL 3 。 12345// cam_types.htypedef enum &#123; CAM_HAL_V1 = 1, CAM_HAL_V3 = 3&#125; cam_hal_version_t; 高通 HAL 架构整体架构图高通 Camera 架构图 ，查看原图 API 和 Framework 之间基于 AIDL 的 Binder 跨进程通信。 Framework 和 HAL AOSP 之间Android 8 开始，Framework 和 HAL 是基于 HIDL 的 Binder 跨进程通信的。 HAL AOSP 和 HAL qcom 之间通过 dlopen, dlsym 动态加载库文件，直接调用方法的。 HAL qcom 和 vendor qcom 之间主要是通过 ioctl 和 v4l2 驱动交互的（老版本平台两者之间会通过 socket 映射缓存区，或者 mshim 层加载库文件直接调用）。 hal 到 vendor 主要是在 v4l2(stream) 中事件通知方式进行；对于 map/unmap 则直接通过 domain socket 方式进行 vendor 到 hal 是通过 v4l2(control) 的事件通知机制进行的 v4l2(stream) 是通过 msm-camera 获取到相关信息； v4l2(control) 是通过 msm-config 获取到相关信息 高通文档对 HAL, vendor 的解释： CameraService (libcamerservice) Camera service layer interacts with: HAL for camera control APIs SurfaceFlinger for delivering preview frames on LCD CameraHardwareInterface (derived object) HAL for actual camera hardware QTI’s HAL implements Google HAL APIs to hook up QTI native camera driver in kernel QTI Linux V4L2 camera driver (kernel) Controls access to camera hardware Proxy to access the QTI-proprietary modules on user space Camera 子系统架构图子系统架构图，查看原图 Camera 前端子系统Frontend 子系统，查看原图 HAL 1 流程图HAL 1 流程图，查看原图 HAL 3 流程图HAL 3 流程图，查看原图 kernel 架构图kernel 架构，查看原图 HAL 3 请求和回调流程图预览预览一，查看原图 , 预览二，查看原图 拍照拍照流程，查看原图 录像录像流程，查看原图 请求流程CameraProvider 初始化CameraProvider 初始化，查看大图 configureStreams 配置流CameraDeviceSession 配置流，查看原图 捕获请求流程 processCaptureRequest捕获请求流程 processCaptureRequest ，查看大图 回调流程捕获结果 Callback 关联过程当 HAL qcom 产生捕获结果后，将数据一路传递到 Framework ，我们重点分析下回调函数的关联过程！先从 hal 文件入手分析： 123456789// ICameraDeviceCallback.halinterface ICameraDeviceCallback &#123; // 返回捕获到的结果 processCaptureResult(vec&lt;CaptureResult&gt; results); // 异步通知 notify(vec&lt;NotifyMsg&gt; msgs);&#125;; 在 Framework 层，由 Camera3Device 实现并完成回调： 123456789101112131415161718192021222324252627// Camera3Device.hclass Camera3Device : public CameraDeviceBase, virtual public hardware::camera::device::V3_2::ICameraDeviceCallback, private camera3_callback_ops &#123; ...private: /** * Implementation of * android::hardware::camera::device::V3_2::ICameraDeviceCallback */ hardware::Return&lt;void&gt; processCaptureResult( const hardware::hidl_vec&lt; hardware::camera::device::V3_2::CaptureResult&gt;&amp; results) override; hardware::Return&lt;void&gt; notify( const hardware::hidl_vec&lt; hardware::camera::device::V3_2::NotifyMsg&gt;&amp; msgs) override; ... /** * Static callback forwarding methods from HAL to instance */ static callbacks_process_capture_result_t sProcessCaptureResult; static callbacks_notify_t sNotify;&#125; 从头文件中可以看出， Camera3Device 继承并实现了 ICameraDeviceCallback.hal 以及 camera3_callback_ops ，实际上这两个都是实现了相同的回调函数。从 LOG 上看，主要是 hal 文件接口回调的。在 open 流程中，这个 ICameraDeviceCallback 会经过如下流程； 1234Camera3Device -&gt;CameraProviderManager -&gt;CameraDevice -&gt;CameraDeviceSession 传入 HAL AOSP 的 CameraDeviceSession 中，并保存在 ResultBatcher 中： 1234567891011121314CameraDeviceSession::CameraDeviceSession( camera3_device_t* device, const camera_metadata_t* deviceInfo, const sp&lt;ICameraDeviceCallback&gt;&amp; callback) : camera3_callback_ops(&#123;&amp;sProcessCaptureResult, &amp;sNotify&#125;), mDevice(device), mDeviceVersion(device-&gt;common.version), mIsAELockAvailable(false), mDerivePostRawSensKey(false), mNumPartialResults(1), mResultBatcher(callback) &#123;...&#125; CameraDeviceSession::ResultBatcher::ResultBatcher( const sp&lt;ICameraDeviceCallback&gt;&amp; callback) : mCallback(callback) &#123;&#125;; 从构造函数中，同时看到将 camera3_callback_ops 中函数指针进行了关联，它定义的函数指针对应的是 ICameraDeviceCallback.hal 的函数： 1234567// camera3.htypedef struct camera3_callback_ops &#123; void (*process_capture_result)(const struct camera3_callback_ops *, const camera3_capture_result_t *result); void (*notify)(const struct camera3_callback_ops *, const camera3_notify_msg_t *msg);&#125; camera3_callback_ops_t; 而 camera3_callback_ops 是 HAL qcom 向 HAL AOSP 发出的回调；在初始化过程中，传递到 QCamera3HardwareInterface 中： 1234567891011121314151617181920// CameraDeviceSession.hstruct CameraDeviceSession : public virtual RefBase, protected camera3_callback_ops &#123;..&#125; // CameraDeviceSession.cppbool CameraDeviceSession::initialize() &#123; /** Initialize device with callback functions */ status_t res = mDevice-&gt;ops-&gt;initialize(mDevice, this); ...&#125;// QCamera3HardwareInterface.cppint QCamera3HardwareInterface::initialize( const struct camera3_callback_ops *callback_ops)&#123; ... mCallbackOps = callback_ops; ...&#125; 至此，在 QCamera3HardwareInterface 中通过 mCallbackOps 可以直接回调到 Framework 中，关联完毕。 processCaptureResult 触发流程图捕获结果回调流程，查看原图 从回调流程图中可以看出，由三个线程负责处理回调： mm_camera_poll_fn 线程负责轮训处理 pipe 管道事件，如果是数据事件 MM_CAMERA_POLL_TYPE_DATA 触发回调。 mm_camera_cmd_thread 线程负责循环处理 cmd 命令，如果有数据结果 MM_CAMERA_CMD_TYPE_DATA_CB 触发回调。 QCameraCmdThread 线程负责循环处理流命令，如果拿到了数据结果 CAMERA_CMD_TYPE_DO_NEXT_JOB 触发回调。 回调函数指针关联流程图中三个线程的回调函数关联过程，我们先从 QCamera3HardwareInterface 逐步分析： 12345678910111213141516171819// QCamera3HWI.cppvoid QCamera3HardwareInterface::orchestrateResult( camera3_capture_result_t *result)&#123; uint32_t frameworkFrameNumber; int32_t rc = _orchestrationDb.getFrameworkFrameNumber( result-&gt;frame_number, frameworkFrameNumber); if (rc != NO_ERROR) &#123; LOGE("Cannot find translated frameworkFrameNumber"); assert(0); &#125; else &#123; if (frameworkFrameNumber == EMPTY_FRAMEWORK_FRAME_NUMBER) &#123; LOGD("CAM_DEBUG Internal Request drop the result"); &#125; else &#123; result-&gt;frame_number = frameworkFrameNumber; mCallbackOps-&gt;process_capture_result(mCallbackOps, result); &#125; &#125;&#125; 查找 QCamera3HardwareInterface 整个文件，只有 orchestrateResult 函数中调用了回调 process_capture_result 。从 LOG 中查看的调用关系，该函数是在 captureResultCb 中调用的，而它会在新建信道对象时传入到 QCamera3Channel 中： 1234567891011121314151617181920// QCamera3Channel.cppQCamera3Channel::QCamera3Channel(uint32_t cam_handle, uint32_t channel_handle, mm_camera_ops_t *cam_ops, channel_cb_routine cb_routine, channel_cb_buffer_err cb_buffer_err, cam_padding_info_t *paddingInfo, cam_feature_mask_t postprocess_mask, void *userData, uint32_t numBuffers)&#123; ... mChannelCB = cb_routine; ...&#125;// QCamera3Channel.htypedef void (*channel_cb_routine)(mm_camera_super_buf_t *metadata, camera3_stream_buffer_t *buffer, uint32_t frame_number, bool isInputBuffer, void *userdata); channel_cb_routine 是一个函数指针，指向 QCamera3HardwareInterface::captureResultCb 函数；而 mChannelCB 大部分都是在 QCamera3Channel 子类的 streamCbRoutine 函数中调用的，而 streamCbRoutine 会在 QCamera3Stream 初始化时传入： 12345678910111213141516171819202122// QCamera3Channel.cppint32_t QCamera3Channel::addStream(cam_stream_type_t streamType, cam_format_t streamFormat, cam_dimension_t streamDim, cam_rotation_t streamRotation, uint8_t minStreamBufNum, cam_feature_mask_t postprocessMask, cam_is_type_t isType, uint32_t batchSize)&#123; ... QCamera3Stream *pStream = new QCamera3Stream(m_camHandle, m_handle, m_camOps, &amp;mPaddingInfo, this); ... rc = pStream-&gt;init(streamType, streamFormat, streamDim, streamRotation, NULL, minStreamBufNum, postprocessMask, isType, batchSize, streamCbRoutine, this); ...&#125; 而在 QCamera3Stream::init 初始化时，会将 stream_cb 保存在 mDataCB 中， hal3_stream_cb_routine 是一个函数指针，指向 QCamera3Channel::streamCbRoutine ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// mm_camera_interface.htypedef void (*mm_camera_buf_notify_t) (mm_camera_super_buf_t *bufs, void *user_data);// mm_camera_interface.htypedef struct &#123; cam_stream_info_t *stream_info; cam_padding_info_t padding_info; mm_camera_stream_mem_vtbl_t mem_vtbl; mm_camera_buf_notify_t stream_cb_sync; mm_camera_buf_notify_t stream_cb; void *userdata;&#125; mm_camera_stream_config_t;// QCamera3Stream.htypedef void (*hal3_stream_cb_routine)(mm_camera_super_buf_t *frame, QCamera3Stream *stream, void *userdata);static void dataNotifyCB(mm_camera_super_buf_t *recvd_frame, void *userdata);// QCamera3Stream.cppint32_t QCamera3Stream::init(cam_stream_type_t streamType, cam_format_t streamFormat, cam_dimension_t streamDim, cam_rotation_t streamRotation, cam_stream_reproc_config_t* reprocess_config, uint8_t minNumBuffers, cam_feature_mask_t postprocess_mask, cam_is_type_t is_type, uint32_t batchSize, hal3_stream_cb_routine stream_cb, void *userdata)&#123; ... // Configure the stream ... stream_config.stream_cb = dataNotifyCB; stream_config.stream_cb_sync = NULL; rc = mCamOps-&gt;config_stream(mCamHandle, mChannelHandle, mHandle, &amp;stream_config); ... mDataCB = stream_cb; ...&#125; 同时，在流配置时将 dataNotifyCB 函数作为流回调赋值给了 stream_config.stream_cb ，stream_cb 是指向它的函数指针，在流配置时向下传递到 mm_camera_stream ： 12345678910111213141516171819202122232425262728293031// mm_camera.hmm_stream_data_cb_t buf_cb[MM_CAMERA_STREAM_BUF_CB_MAX];typedef struct &#123; mm_camera_buf_notify_t cb; void *user_data; /* cb_count = -1: infinite * cb_count &gt; 0: register only for required times */ int8_t cb_count; mm_camera_stream_cb_type cb_type;&#125; mm_stream_data_cb_t;// mm_camera_stream.cint32_t mm_stream_config(mm_stream_t *my_obj, mm_camera_stream_config_t *config)&#123; ... if (config-&gt;stream_cb_sync != NULL) &#123; /* SYNC callback is always placed at index 0*/ my_obj-&gt;buf_cb[cb_index].cb = config-&gt;stream_cb_sync; my_obj-&gt;buf_cb[cb_index].user_data = config-&gt;userdata; my_obj-&gt;buf_cb[cb_index].cb_count = -1; /* infinite by default */ my_obj-&gt;buf_cb[cb_index].cb_type = MM_CAMERA_STREAM_CB_TYPE_SYNC; cb_index++; &#125; my_obj-&gt;buf_cb[cb_index].cb = config-&gt;stream_cb; my_obj-&gt;buf_cb[cb_index].user_data = config-&gt;userdata; my_obj-&gt;buf_cb[cb_index].cb_count = -1; /* infinite by default */ my_obj-&gt;buf_cb[cb_index].cb_type = MM_CAMERA_STREAM_CB_TYPE_ASYNC; ...&#125; 最终回调函数实际保存在了 buf_cb[cb_index].cb 中，而它是在 mm_stream_dispatch_app_data 中触发调用的： 12345678910111213141516171819202122232425262728// mm_camera_stream.cstatic void mm_stream_dispatch_app_data(mm_camera_cmdcb_t *cmd_cb, void* user_data)&#123; int i; mm_stream_t * my_obj = (mm_stream_t *)user_data; mm_camera_buf_info_t* buf_info = NULL; mm_camera_super_buf_t super_buf; ... for(i = 0; i &lt; MM_CAMERA_STREAM_BUF_CB_MAX; i++) &#123; if(NULL != my_obj-&gt;buf_cb[i].cb &amp;&amp; (my_obj-&gt;buf_cb[i].cb_type != MM_CAMERA_STREAM_CB_TYPE_SYNC)) &#123; if (my_obj-&gt;buf_cb[i].cb_count != 0) &#123; /* if &lt;0, means infinite CB * if &gt;0, means CB for certain times * both case we need to call CB */ ... /* callback */ my_obj-&gt;buf_cb[i].cb(&amp;super_buf, my_obj-&gt;buf_cb[i].user_data); &#125; ... &#125; &#125; ...&#125; 在开启流过程中，如果有回调函数则启动 CAM_StrmAppData 回调线程，并将 mm_stream_dispatch_app_data 加到线程中： 1234567891011121314151617181920212223242526272829303132333435// mm_camera_stream.cint32_t mm_stream_fsm_reg(mm_stream_t * my_obj, mm_stream_evt_type_t evt, void * in_val, void * out_val)&#123; ... case MM_STREAM_EVT_START: &#123; uint8_t has_cb = 0; uint8_t i; /* launch cmd thread if CB is not null */ pthread_mutex_lock(&amp;my_obj-&gt;cb_lock); for (i = 0; i &lt; MM_CAMERA_STREAM_BUF_CB_MAX; i++) &#123; if((NULL != my_obj-&gt;buf_cb[i].cb) &amp;&amp; (my_obj-&gt;buf_cb[i].cb_type != MM_CAMERA_STREAM_CB_TYPE_SYNC)) &#123; has_cb = 1; break; &#125; &#125; pthread_mutex_unlock(&amp;my_obj-&gt;cb_lock); pthread_mutex_lock(&amp;my_obj-&gt;cmd_lock); if (has_cb) &#123; snprintf(my_obj-&gt;cmd_thread.threadName, THREAD_NAME_SIZE, "CAM_StrmAppData"); mm_camera_cmd_thread_launch(&amp;my_obj-&gt;cmd_thread, mm_stream_dispatch_app_data, (void *)my_obj); &#125; ... &#125; ...&#125; 再到 mm_camera_thread 线程中查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// mm_camera_thread.cstatic void *mm_camera_cmd_thread(void *data)&#123; int running = 1; int ret; mm_camera_cmd_thread_t *cmd_thread = (mm_camera_cmd_thread_t *)data; mm_camera_cmdcb_t* node = NULL; mm_camera_cmd_thread_name(cmd_thread-&gt;threadName); do &#123; do &#123; ret = cam_sem_wait(&amp;cmd_thread-&gt;cmd_sem); if (ret != 0 &amp;&amp; errno != EINVAL) &#123; LOGE("cam_sem_wait error (%s)", strerror(errno)); return NULL; &#125; &#125; while (ret != 0); /* we got notified about new cmd avail in cmd queue */ node = (mm_camera_cmdcb_t*)cam_queue_deq(&amp;cmd_thread-&gt;cmd_queue); while (node != NULL) &#123; switch (node-&gt;cmd_type) &#123; case MM_CAMERA_CMD_TYPE_EVT_CB: case MM_CAMERA_CMD_TYPE_DATA_CB: case MM_CAMERA_CMD_TYPE_REQ_DATA_CB: case MM_CAMERA_CMD_TYPE_SUPER_BUF_DATA_CB: case MM_CAMERA_CMD_TYPE_CONFIG_NOTIFY: case MM_CAMERA_CMD_TYPE_START_ZSL: case MM_CAMERA_CMD_TYPE_STOP_ZSL: case MM_CAMERA_CMD_TYPE_GENERAL: case MM_CAMERA_CMD_TYPE_FLUSH_QUEUE: if (NULL != cmd_thread-&gt;cb) &#123; cmd_thread-&gt;cb(node, cmd_thread-&gt;user_data); &#125; break; case MM_CAMERA_CMD_TYPE_EXIT: default: running = 0; break; &#125; free(node); node = (mm_camera_cmdcb_t*)cam_queue_deq(&amp;cmd_thread-&gt;cmd_queue); &#125; /* (node != NULL) */ &#125; while (running); return NULL;&#125;int32_t mm_camera_cmd_thread_launch(mm_camera_cmd_thread_t * cmd_thread, mm_camera_cmd_cb_t cb, void* user_data)&#123; int32_t rc = 0; cam_sem_init(&amp;cmd_thread-&gt;cmd_sem, 0); cam_sem_init(&amp;cmd_thread-&gt;sync_sem, 0); cam_queue_init(&amp;cmd_thread-&gt;cmd_queue); cmd_thread-&gt;cb = cb; cmd_thread-&gt;user_data = user_data; cmd_thread-&gt;is_active = TRUE; /* launch the thread */ pthread_create(&amp;cmd_thread-&gt;cmd_pid, NULL, mm_camera_cmd_thread, (void *)cmd_thread); return rc;&#125; 线程 launch 时，指定了 mm_camera_cmd_thread 函数，而该函数的主要功能就是执行回调 cmd_thread-&gt;cb(node, cmd_thread-&gt;user_data); ，当满足执行条件： cmd_sem 通知以及 cmd_queue 中有数据时，就会执行回调。继续跟踪代码，查看哪里触发满足执行条件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// mm_camera_stream.cstatic void mm_stream_data_notify(void* user_data)&#123; mm_stream_t *my_obj = (mm_stream_t*)user_data; int32_t i, rc; uint8_t has_cb = 0, length = 0; mm_camera_buf_info_t buf_info; ... memset(&amp;buf_info, 0, sizeof(mm_camera_buf_info_t)); rc = mm_stream_read_msm_frame(my_obj, &amp;buf_info, (uint8_t)length); if (rc != 0) &#123; return; &#125; ... mm_stream_handle_rcvd_buf(my_obj, &amp;buf_info, has_cb);&#125;void mm_stream_handle_rcvd_buf(mm_stream_t *my_obj, mm_camera_buf_info_t *buf_info, uint8_t has_cb)&#123; int32_t rc = 0; ... if(has_cb &amp;&amp; my_obj-&gt;cmd_thread.is_active) &#123; mm_camera_cmdcb_t* node = NULL; /* send cam_sem_post to wake up cmd thread to dispatch dataCB */ node = (mm_camera_cmdcb_t *)malloc(sizeof(mm_camera_cmdcb_t)); if (NULL != node) &#123; memset(node, 0, sizeof(mm_camera_cmdcb_t)); node-&gt;cmd_type = MM_CAMERA_CMD_TYPE_DATA_CB; node-&gt;u.buf = *buf_info; /* enqueue to cmd thread */ cam_queue_enq(&amp;(my_obj-&gt;cmd_thread.cmd_queue), node); /* wake up cmd thread */ cam_sem_post(&amp;(my_obj-&gt;cmd_thread.cmd_sem)); &#125; else &#123; LOGE("No memory for mm_camera_node_t"); &#125; &#125; pthread_mutex_unlock(&amp;my_obj-&gt;cmd_lock);&#125; mm_stream_handle_rcvd_buf 触发了回调流程，由 mm_stream_data_notify 发起，而在信道开启流程过程中，会为每个流分配及注册 Buffer ： 12345678910111213141516171819202122232425262728293031323334// mm_camera_stream.cint32_t mm_stream_reg_buf(mm_stream_t * my_obj)&#123; int32_t rc = 0; uint8_t i; rc = mm_stream_request_buf(my_obj); ... my_obj-&gt;queued_buffer_count = 0; for(i = 0; i &lt; my_obj-&gt;buf_num; i++)&#123; /* check if need to qbuf initially */ if (my_obj-&gt;buf_status[i].initial_reg_flag) &#123; rc = mm_stream_qbuf(my_obj, &amp;my_obj-&gt;buf[i]); ... &#125; &#125; return rc;&#125;int32_t mm_stream_qbuf(mm_stream_t *my_obj, mm_camera_buf_def_t *buf)&#123; ... if (1 == my_obj-&gt;queued_buffer_count) &#123; /* Add fd to data poll thread */ rc = mm_camera_poll_thread_add_poll_fd( &amp;my_obj-&gt;ch_obj-&gt;poll_thread[0], my_obj-&gt;my_hdl, my_obj-&gt;fd, mm_stream_data_notify, (void*)my_obj, mm_camera_async_call); ... &#125; ... return rc;&#125; 在注册 Buffer 的过程中，将 mm_stream_data_notify 添加到 mm_camera_poll_thread 线程中，而这个线程的功能是监听 pipe 管道，如果管道中有数据则触发回调，这个线程循环执行的函数为： 123456789101112131415161718192021222324252627282930313233343536373839404142// mm_camera.htypedef void (*mm_camera_poll_notify_t)(void *user_data);typedef struct &#123; int32_t fd; mm_camera_poll_notify_t notify_cb; uint32_t handler; void* user_data;&#125; mm_camera_poll_entry_t;// mm_camera_thread.cstatic void *mm_camera_poll_fn(mm_camera_poll_thread_t *poll_cb)&#123; int rc = 0, i; ... do &#123; ... rc=poll(poll_cb-&gt;poll_fds,poll_cb-&gt;num_fds, poll_cb-&gt;timeoutms); if(rc &gt; 0) &#123; if ((poll_cb-&gt;poll_fds[0].revents &amp; POLLIN) &amp;&amp; ... &#125; else &#123; for(i=1; i&lt;poll_cb-&gt;num_fds; i++) &#123; ... if ((MM_CAMERA_POLL_TYPE_DATA==poll_cb-&gt;poll_type) &amp;&amp; (poll_cb-&gt;poll_fds[i].revents &amp; POLLIN) &amp;&amp; (poll_cb-&gt;poll_fds[i].revents &amp; POLLRDNORM)) &#123; if(NULL != poll_cb-&gt;poll_entries[i-1].notify_cb)&#123; poll_cb-&gt;poll_entries[i-1].notify_cb( poll_cb-&gt;poll_entries[i-1].user_data); &#125; &#125; &#125; &#125; &#125; else &#123; ... &#125; &#125; while ((poll_cb != NULL) &amp;&amp; (poll_cb-&gt;state == MM_CAMERA_POLL_TASK_STATE_POLL)); return NULL;&#125; 而代码中的 notify_cb 函数指针指向的就是 mm_stream_data_notify 函数。至此，回调过程全部关联完毕！ 其他类关联及 hal 文件下面这幅图是使用 UML 组件图画的，仅仅是因为组件的方框和依赖的箭头画起来方便，并不是体现组件关系。该图的意义： 体现 hal 文件调用及回调关系 体现各个类之间通过变量连接的关系（代码中有较多的函数指针，类中变量在调用函数时有时候不记得指向的是哪个类了，通过该图能直观的找到对应关系） 关系查看大图 常见数据结构图 HAL AOSP类图查看大图 HAL qcom类图查看大图 摄像头默认属性摄像头的默认属性，比如 ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL 硬件支持级别等，都是在 QCamera3HardwareInterface::initStaticMetadata 中初始化的。 123456789101112131415161718192021222324252627282930313233// Camera3HWI.cppint QCamera3HardwareInterface::initStaticMetadata(uint32_t cameraId)&#123; int rc = 0; CameraMetadata staticInfo; size_t count = 0; bool limitedDevice = false; char prop[PROPERTY_VALUE_MAX]; bool supportBurst = false; supportBurst = supportBurstCapture(cameraId); /* If sensor is YUV sensor (no raw support) or if per-frame control is not * guaranteed or if min fps of max resolution is less than 20 fps, its * advertised as limited device*/ limitedDevice = gCamCapability[cameraId]-&gt;no_per_frame_control_support || (CAM_SENSOR_YUV == gCamCapability[cameraId]-&gt;sensor_type.sens_type) || (CAM_SENSOR_MONO == gCamCapability[cameraId]-&gt;sensor_type.sens_type) || !supportBurst; uint8_t supportedHwLvl = limitedDevice ? ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED :#ifndef USE_HAL_3_3 // LEVEL_3 - This device will support level 3. ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL_3;#else ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL_FULL;#endif staticInfo.update(ANDROID_INFO_SUPPORTED_HARDWARE_LEVEL, &amp;supportedHwLvl, 1); ...&#125; resource_cost 的计算方法1234567891011121314151617181920212223// Camera3HWI.cppint QCamera3HardwareInterface::getCamInfo(uint32_t cameraId, struct camera_info *info)&#123; ... //resource cost is 100 * MIN(1.0, m/M), //where m is throughput requirement with maximum stream configuration //and M is CPP maximum throughput. float max_fps = 0.0; for (uint32_t i = 0; i &lt; gCamCapability[cameraId]-&gt;fps_ranges_tbl_cnt; i++) &#123; if(max_fps&lt;gCamCapability[cameraId]-&gt;fps_ranges_tbl[i].max_fps) max_fps=gCamCapability[cameraId]-&gt;fps_ranges_tbl[i].max_fps; &#125; float ratio = 1.0 * MAX_PROCESSED_STREAMS * gCamCapability[cameraId]-&gt;active_array_size.width * gCamCapability[cameraId]-&gt;active_array_size.height * max_fps / gCamCapability[cameraId]-&gt;max_pixel_bandwidth; info-&gt;resource_cost = 100 * MIN(1.0, ratio); LOGI("camera %d resource cost is %d", cameraId, info-&gt;resource_cost); ...&#125; poll 机制参考转载：camera 中的 poll 机制 poll 机制，查看大图 这里的 poll 机制里面是嵌套了一个 pipe 机制；每次添加一个 poll thread 时，会给这个 poll thread 创建一个 pipe ，对于这个 poll thread 来说 pipe 也是文件 fd ，调用一次 poll 时可以传递给该函数 fd 数组，poll 会去查看每一个 fd ，一旦哪个 fd 的 poll 有返回，则该 poll thread 就会对其进行处理。那么 qcom 这里期望做一个可以动态添加 poll fd 的机制，他们利用了 pipe ，这个 pipe 就是 fds[0] ，也就是每个 poll thread 自带 fds[0] ，该 fd 响应添加新 fd 的操作，所以当 open 一个 dev 就可以把这个 dev 的 fd 通过 write fds[0] 添加进来。 信道 Channel 与流 Stream先看一段代码，在信道中添加流时的注释： 1234567891011121314151617int32_t QCamera3Channel::addStream(cam_stream_type_t streamType, cam_format_t streamFormat, cam_dimension_t streamDim, cam_rotation_t streamRotation, uint8_t minStreamBufNum, cam_feature_mask_t postprocessMask, cam_is_type_t isType, uint32_t batchSize)&#123; int32_t rc = NO_ERROR; if (m_numStreams &gt;= 1) &#123; LOGE("Only one stream per channel supported in v3 Hal"); return BAD_VALUE; &#125; ...&#125; 注释为： HAL 3 中一个信道实例中只能有一个流！每个信道都有一个信道 ID ，它是在 QCamera3HardwareInterface 初始化时创建的 ID 号，也就是只会存在同一个信道 ID 。信道 QCamera3Channel 有很多实现类： QCamera3MetadataChannel, QCamera3PicChannel 等等，它们都共享了同一个 channel id 。 信道类继承关系，查看原图 示例：在预览和拍照时，设置两个输出 Surface ，这个过程中会创建一个信道 id，5 个信道实例，4 条流： QCamera3MetadataChannel获取 Metadata 元信息，对应的流类型和格式为 stream type: CAM_STREAM_TYPE_METADATA 7, format: 124 。 QCamera3SupportChannelHAL 内部消费会使用到，对应的流类型和格式为 stream type: CAM_STREAM_TYPE_ANALYSIS 11, format: CAM_FORMAT_YUV_420_NV12_VENUS 7 。 QCamera3RegularChannel预览，对应的流类型和格式为 stream type: CAM_STREAM_TYPE_PREVIEW 1, format: CAM_FORMAT_YUV_420_NV12_VENUS 7 。 QCamera3PicChannel拍照，对应的流类型和格式为 stream type: CAM_STREAM_TYPE_SNAPSHOT 3, format: CAM_FORMAT_YUV_420_NV21 2 。 QCamera3ProcessingChannel不需要添加流，参考其头文件注释：是用来处理直接从 HAL 发回给 Framework 所有的流，这些流并没有经过 HAL 后处理 QCamera3PostProc 。 对应的 Log 为，公共信道 ID: 2048 ： 12345678E QCamera : mm_camera_intf_add_stream: 773: E handle = 1792 ch_id = 2048E QCamera : mm_camera_intf_config_stream: 852: E handle = 1792, ch_id = 2048,stream_id = 2304E QCamera : mm_camera_intf_add_stream: 773: E handle = 1792 ch_id = 2048E QCamera : mm_camera_intf_config_stream: 852: E handle = 1792, ch_id = 2048,stream_id = 2561E QCamera : mm_camera_intf_add_stream: 773: E handle = 1792 ch_id = 2048E QCamera : mm_camera_intf_config_stream: 852: E handle = 1792, ch_id = 2048,stream_id = 2818E QCamera : mm_camera_intf_add_stream: 773: E handle = 1792 ch_id = 2048E QCamera : mm_camera_intf_config_stream: 852: E handle = 1792, ch_id = 2048,stream_id = 3075 常用 LOG 开关 开启 HAL 层 LOG 信息 adb root;adb shell setprop persist.camera.hal.debug 1 persist.camera.dumpimg 设置为 1 时，每次拍照预览都会在 /data/misc/camera 目录保存当前帧图片 Buffer 管理Camera Buffer 相关管理，需要先搞清楚 Android 的图形显示系统；简单来讲：图形显示系统是按照生产者和消费者模型来架构的，在打开 Camera 时，需要创建需要显示（消费者）的 Surface ，当 Camera 设备捕获到帧数据时（生产者），直接将缓存区 Buffers 交给 Surface 来显示。 buffer_handle_t 的作用先看几个数据结构： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// native_handle.htypedef struct native_handle&#123; int version; /* sizeof(native_handle_t) */ int numFds; /* number of file-descriptors at &amp;data[0] */ int numInts; /* number of ints at &amp;data[numFds] */#if defined(__clang__)#pragma clang diagnostic push#pragma clang diagnostic ignored "-Wzero-length-array"#endif int data[0]; /* numFds + numInts ints */#if defined(__clang__)#pragma clang diagnostic pop#endif&#125; native_handle_t;typedef const native_handle_t* buffer_handle_t;// gralloc_priv.h#ifdef __cplusplusstruct private_handle_t : public native_handle &#123;#else struct private_handle_t &#123; native_handle_t nativeHandle;#endif enum &#123; PRIV_FLAGS_FRAMEBUFFER = 0x00000001, ... &#125;; // file-descriptors int fd; int fd_metadata; // fd for the meta-data // ints int magic; int flags; unsigned int size; unsigned int offset; int bufferType; uint64_t base __attribute__((aligned(8))); unsigned int offset_metadata; // The gpu address mapped into the mmu. uint64_t gpuaddr __attribute__((aligned(8))); int format; int width; // holds aligned width of the actual buffer allocated int height; // holds aligned height of the actual buffer allocated uint64_t base_metadata __attribute__((aligned(8))); int unaligned_width; // holds width client asked to allocate int unaligned_height; // holds height client asked to allocate#ifdef __cplusplus static const int sNumFds = 2; static inline int sNumInts() &#123; return ((sizeof(private_handle_t) - sizeof(native_handle_t)) / sizeof(int)) - sNumFds; &#125; static const int sMagic = 'gmsm'; ... &#125; 简单来说：native_handle_t, buffer_handle_t, private_handle_t 都是用来描述一块缓存区的，可以将它们理解为一个句柄，用于跨进程传输数据；将 Camera 设备捕获到的帧数据缓存区，传递给显示系统直接显示。buffer_handle_t 是一个 native_handle_t 型指针；这里重点关注成员 data ，它是一个大小为 0 的数组，data 指向成员 numInts 后的一个地址，这个地址通常表示 private_handle_t 结构中的数据；numFds 表示 private_handle_t 中有几个文件描述符；numInts 表示 private_handle_t 中有几个整形数据。下图为一个大致的描述： 所以 buffer_handle_t 可以理解为是传递给 Framework 中的 Surface 来消费的；因为涉及跨进程，直接拿到数据帧的地址指针并没有实际意义。 携带 Buffer 的数据结构 HAL qcom 中携带捕获帧数据的数据结构 12345678910111213141516171819202122232425262728// mm_camera_interface.htypedef struct mm_camera_buf_def &#123; uint32_t stream_id; cam_stream_type_t stream_type; cam_stream_buf_type buf_type; uint32_t buf_idx; uint8_t is_uv_subsampled; struct timespec ts; uint32_t frame_idx; union &#123; mm_camera_plane_buf_def_t planes_buf; mm_camera_user_buf_def_t user_buf; &#125;; int fd; void *buffer; // 捕获的帧数据指针 size_t frame_len; void *mem_info; uint32_t flags;&#125; mm_camera_buf_def_t;typedef struct &#123; uint32_t camera_handle; uint32_t ch_id; uint32_t num_bufs; uint8_t bUnlockAEC; uint8_t bReadyForPrepareSnapshot; mm_camera_buf_def_t* bufs[MAX_STREAM_NUM_IN_BUNDLE];&#125; mm_camera_super_buf_t; HAL AOSP 中携带捕获帧数据的数据结构 1234567891011121314151617// camera3.htypedef struct camera3_capture_result &#123; uint32_t frame_number; const camera_metadata_t *result; // 元信息 uint32_t num_output_buffers; const camera3_stream_buffer_t *output_buffers; // 输出缓冲区 const camera3_stream_buffer_t *input_buffer; uint32_t partial_result;&#125; camera3_capture_result_t;typedef struct camera3_stream_buffer &#123; camera3_stream_t *stream; // 流信息 buffer_handle_t *buffer; // 句柄，指向帧数据 int status; int acquire_fence; int release_fence;&#125; camera3_stream_buffer_t; 从数据结构中可以看出，在 HAL qcom 中，mm_camera_buf_def_t-&gt;buffer 可以直接拿到设备捕获帧数据的地址；而 HAL AOSP 因为需要将数据返回给 Framework ，涉及到跨进程通信，所以并不是直接地址，而是一个 buffer_handle_t 句柄 camera3_stream_buffer_t-&gt;buffer 。Framework 中 CaptureResult 只保留了这个句柄以及图像的元信息。 QCamera3Mem这个文件中有三个类： QCamera3Memory基类 QCamera3HeapMemory派生类，主要用于 HAL qcom 内部交互，getPtr 获取捕获的每帧数据地址 mm_camera_buf_def_t-&gt;buffer ，拿到这个地址可以直接做图像处理。 QCamera3GrallocMemory派生类，用于传递给 Framework 中，因为并不会直接向 Framework 返回帧地址，而是返回 buffer_handle_t 指针，即 camera3_stream_buffer-&gt;buffer ，图形显示时需要的数据结构。它实际对应的是同一块内存中的帧数据，只是把这块内存封装好了（暂时不清楚如何通过它获取帧数据）。 HAL AOSP, Framework 中拿到的都是 buffer_handle_t 指针，会直接在 Surface 中使用，我理解如果想对 Camera 捕获帧数据做实时处理，只能在 HAL qcom, vendor 这两层处理。 示例：灰度化帧数据整个数据回调过程中，图像帧数据是以指针的形式传回来的，所以不会超过 Binder 1M 大小；但并不是每个 result 都包含图片 buffer 信息，按照信道不同，回调的数据是不一样的，比如 QCamera3MetadataChannel::streamCbRoutine 回调的结果中，只向 Framework 上报元信息，数据 output_buffers 是空的。示例将预览的实时图像灰度化，预览流的格式为 CAM_FORMAT_YUV_420_NV12_VENUS ，即帧数据存储是 YUV_420_NV12 格式的，而当前平台这个格式存储特点（以 QCIF: 176*144 为例）是： NV12-QCIF 存储格式，查看大图 plane 有两条：一条为 Y 数据，一条为 UV 数据 stride 行步进值，因为会数据对齐，所以每行并不是实际的宽度 width 想把 YUV 格式像素数据变成灰度图像，只需要将 U, V 分量设置成 128 即可。这是因为 U, V 是图像中的经过偏置处理的色度分量，色度分量在偏置处理前的取值范围是 -128~127，这时候的无色对应的是 0 值。经过偏置后色度分量取值变成了 0~255，因此无色对应的就是 128 了。算法结果就是找到 UV 分量的地址，全部设置为 128 ，如下为代码： 123456789101112131415// QCamera3Channel.cpp// QCamera3ProcessingChannel::streamCbRoutine 函数中添加如下代码//start&#123; void *data=NULL; if(offset.num_planes &gt; 1)&#123; // UV plane uint32_t index = offset.mp[0].len; for (int j=0; j &lt; offset.mp[1].height; j++) &#123; data=(void*)((uint8_t*)super_frame-&gt;bufs[0]-&gt;buffer + index); memset(data, 128, (size_t)offset.mp[1].width); // 灰度化 index += (uint32_t)offset.mp[1].stride; // 行步进 &#125; &#125;&#125;//end 后续 画中画 多屏显示 如何利用平台的硬件来做图像识别和处理，都使用软件效率是否能达到？ 参考文档 Binder 化直通式 HAL camera 版本支持 CameraProvider 注册 camera provider启动 [高通 HAL 1 代码流 80-NF499-2 C: Camera Frontend Code Walkthrough] msm8996平台的 camera 框架笔记 Android GDI之共享缓冲区机制-native_handle_t Android buffer_handle_t 和 Surface 的关系 图文详解YUV420数据格式 高通camera结构 openCamera-HAL 启动过程 CameraService 到 HAL Service MSM8940 Camera 架构以及移植手册 高通第三方算法（单帧数据）添加流程 图形显示系统：surface 生产者和消费者间的处理框架 HAL 常见数据结构 HAL3中预览preview模式下的数据流]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera Framework 分析]]></title>
    <url>%2F2018%2F12%2F06%2F0109-android-camera-4-framework%2F</url>
    <content type="text"><![CDATA[Camera Framework 分析，本文主要介绍 Camera API2 相关。 类文件速查表类文件目录1234561. Framework Java API1:frameworks/base/core/java/android/hardware/Camera.java2. Framework Java API2:frameworks/base/core/java/android/hardware/camera23. Framework JNI: frameworks/base/core/jni/4. AIDL: frameworks/av/camera/aidl5. Framework Native: frameworks/av/camera 6. Framework Service: frameworks/av/services/camera/libcameraservice JNI 相关12345678// frameworks/base/core/jni./android_hardware_camera2_legacy_LegacyCameraDevice.cpp./android_hardware_Camera.cpp./android/graphics/Camera.cpp./include/android_runtime/android_hardware_camera2_CameraMetadata.h./android_hardware_camera2_DngCreator.cpp./android_hardware_camera2_CameraMetadata.cpp./android_hardware_camera2_legacy_PerfMeasurement.cpp API 1 中，使用 jni 通过 Binder 机制和 CameraService 通信。API 2 中，直接在 CameraManager.java 中通过 Binder 机制和 CameraService 通信。 AIDL 相关Framework Camere AIDL 是 Camera 中客户端和服务端跨进程通信时使用的 AIDL 文件，代码都在 frameworks/av/camera/ 目录下，其中 aidl 文件一共有 16 个： 123456789101112131415161718192021222324xmt@server005:~/frameworks/av/camera/aidl/android/hardware$ tree.├── camera2│ ├── CaptureRequest.aidl│ ├── ICameraDeviceCallbacks.aidl│ ├── ICameraDeviceUser.aidl│ ├── impl│ │ ├── CameraMetadataNative.aidl│ │ └── CaptureResultExtras.aidl│ ├── params│ │ ├── OutputConfiguration.aidl│ │ ├── VendorTagDescriptor.aidl│ │ └── VendorTagDescriptorCache.aidl│ └── utils│ └── SubmitInfo.aidl├── CameraInfo.aidl├── CameraStatus.aidl├── ICamera.aidl├── ICameraClient.aidl├── ICameraService.aidl├── ICameraServiceListener.aidl└── ICameraServiceProxy.aidl4 directories, 16 files frameworks/av/camera/aidl/ 目录下的 aidl 文件有两种类型： 作为 Binder 中的 IInterface 跨进程通信中能提供的方法 作为 Binder 中的 parcelable 跨进程通信数据传输的数据结构 很容易从名字上区分这两种类型的文件，IInterface 类型的文件都是以 I 开头的，比如：ICameraService.aidl, ICameraDeviceUser.aidl 等。不管是哪种类型的 aidl 文件，它们都会生成对应的 .java, .h, .cpp 文件，分别供 Java 层和 CPP 层调用。 IInterface 类型文件IInterface 类型文件一共有 7 个，它们的 .java, .h, .cpp 文件，绝大部分都是自动生成的。 Java 文件是在 frameworks/base/Android.mk 中定义规则，在编译时自动生成： 1234567891011// frameworks/base/Android.mkLOCAL_SRC_FILES += \ ... ../av/camera/aidl/android/hardware/ICameraService.aidl \ ../av/camera/aidl/android/hardware/ICameraServiceListener.aidl \ ../av/camera/aidl/android/hardware/ICameraServiceProxy.aidl \ ../av/camera/aidl/android/hardware/ICamera.aidl \ ../av/camera/aidl/android/hardware/ICameraClient.aidl \ ../av/camera/aidl/android/hardware/camera2/ICameraDeviceUser.aidl \ ../av/camera/aidl/android/hardware/camera2/ICameraDeviceCallbacks.aidl \ ... 在 out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/dotdot/ 目录下生成对应的 Java 文件： 12345678// out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/dotdot/av/camera/aidl/android/hardware/ICameraService.javaav/camera/aidl/android/hardware/ICameraServiceListener.javaav/camera/aidl/android/hardware/ICameraServiceProxy.javaav/camera/aidl/android/hardware/ICamera.javaav/camera/aidl/android/hardware/ICameraClient.javaav/camera/aidl/android/hardware/camera2/ICameraDeviceUser.javaav/camera/aidl/android/hardware/camera2/ICameraDeviceCallbacks.java .h, .cpp 文件中，ICamera.aidl, ICameraClient.aidl 两个文件是直接以代码形式手动实现的： 123456789// 1. ICameraClient.aidlframeworks/av/camera/aidl/android/hardware/ICameraClient.aidlframeworks/av/camera/include/camera/android/hardware/ICameraClient.hframeworks/av/camera/ICameraClient.cpp// 2. ICamera.aidlframeworks/av/camera/aidl/android/hardware/ICamera.aidlframeworks/av/camera/include/camera/android/hardware/ICamera.hframeworks/av/camera/ICamera.cpp 其他 5 个 aidl 文件是在 frameworks/av/camera/Android.bp 中定义规则，编译时自动生成对应的 .h, .cpp 文件： 12345678910111213141516171819202122232425262728293031// frameworks/av/camera/Android.bpcc_library_shared &#123; name: &quot;libcamera_client&quot;, aidl: &#123; export_aidl_headers: true, local_include_dirs: [&quot;aidl&quot;], include_dirs: [ &quot;frameworks/native/aidl/gui&quot;, ], &#125;, srcs: [ // AIDL files for camera interfaces // The headers for these interfaces will be // available to any modules that // include libcamera_client, at the path &quot;aidl/package/path/BnFoo.h&quot; &quot;aidl/android/hardware/ICameraService.aidl&quot;, &quot;aidl/android/hardware/ICameraServiceListener.aidl&quot;, &quot;aidl/android/hardware/ICameraServiceProxy.aidl&quot;, &quot;aidl/android/hardware/camera2/ICameraDeviceCallbacks.aidl&quot;, &quot;aidl/android/hardware/camera2/ICameraDeviceUser.aidl&quot;, // Source for camera interface parcelables, // and manually-written interfaces &quot;Camera.cpp&quot;, &quot;CameraMetadata.cpp&quot;, &quot;CameraParameters.cpp&quot;, ...&#125; 在 out/soong/.intermediates/frameworks/av/camera/libcamera_client/ 目录下生成对应的 .h, .cpp 文件，通常在该目录下会同时生成 32 和 64 位两套代码，但实际两份代码是一样的，这里选取 64 位的： 64 位：android_arm64_armv8-a_shared_core 32 位：android_arm_armv7-a-neon_cortex-a53_shared_core 123456789101112131415161718192021// 目录 out/soong/.intermediates/frameworks/av/camera/libcamera_client// 64 位 android_arm64_armv8-a_shared_core/gen/aidl/android/hardware/ICameraService.handroid/hardware/BnCameraService.hframeworks/av/camera/aidl/android/hardware/ICameraService.cppandroid/hardware/ICameraServiceListener.handroid/hardware/BnCameraServiceListener.hframeworks/av/camera/aidl/android/hardware/ICameraServiceListener.cppandroid/hardware/ICameraServiceProxy.handroid/hardware/BnCameraServiceProxy.hframeworks/av/camera/aidl/android/hardware/ICameraServiceProxy.cppandroid/hardware/camera2/ICameraDeviceUser.handroid/hardware/camera2/BnCameraDeviceUser.hframeworks/av/camera/aidl/android/hardware/camera2/ICameraDeviceUser.cppandroid/hardware/camera2/ICameraDeviceCallbacks.handroid/hardware/camera2/BnCameraDeviceCallbacks.hframeworks/av/camera/aidl/android/hardware/camera2/ICameraDeviceCallbacks.cpp parcelable 类型文件parcelable 类型文件一共有 9 个，它们都是手动编写的代码。 Java 文件目录为 frameworks/base/core/java/android/hardware/ ： 12345678910// frameworks/base/core/java/android/hardware/camera2/CaptureRequest.javacamera2/impl/CameraMetadataNative.javacamera2/impl/CaptureResultExtras.javacamera2/params/OutputConfiguration.javacamera2/params/VendorTagDescriptor.javacamera2/params/VendorTagDescriptorCache.javacamera2/utils/SubmitInfo.javaCameraInfo.javaCameraStatus.java .h, .cpp 文件并不一定是和 aidl 文件名称一一对应的，而是在 aidl 文件中定义的，比如 CameraStatus.aidl 定义如下： 1234package android.hardware;/** @hide */parcelable CameraStatus cpp_header &quot;camera/CameraBase.h&quot;; parcelable 类型的 aidl 文件对应的 .h, .cpp 文件目录为 frameworks/av/camera ，对应关系整理如下： 12345678910111213141516171819202122232425262728// .h, .cpp 文件目录 frameworks/av/camera// CaptureRequest.aidlinclude/camera/camera2/CaptureRequest.hcamera2/CaptureRequest.cpp// CameraMetadataNative.aidlinclude/camera/CameraMetadata.hCameraMetadata.cpp// CaptureResultExtras.aidlinclude/camera/CaptureResult.hCaptureResult.cpp// OutputConfiguration.aidlinclude/camera/camera2/OutputConfiguration.hcamera2/OutputConfiguration.cpp// VendorTagDescriptor.aidl 和 VendorTagDescriptorCache.aidlinclude/camera/VendorTagDescriptor.hVendorTagDescriptor.cpp// SubmitInfo.aidlinclude/camera/camera2/SubmitInfo.hcamera2/SubmitInfo.cpp// CameraInfo.aidl 和 CameraStatus.aidlinclude/camera/CameraBase.hCameraBase.cpp ICameraService 相关分为客户端向服务端的请求 ICameraService.aidl 和客户端监听服务端的变化 ICameraServiceListener.aidl 。这两个 AIDL 是在 CameraService.cpp 中实现对应功能的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 1. ICameraService.aidlinterface ICameraService&#123; ... const int CAMERA_TYPE_BACKWARD_COMPATIBLE = 0; const int CAMERA_TYPE_ALL = 1; // 返回指定类型的相机设备数量 int getNumberOfCameras(int type); // 根据 id 返回当前相机设备信息 CameraInfo getCameraInfo(int cameraId); ... const int CAMERA_HAL_API_VERSION_UNSPECIFIED = -1; // api1 + hal1 ICamera connect(ICameraClient client, int cameraId, String opPackageName, int clientUid, int clientPid); // api2 + hal3 ICameraDeviceUser connectDevice(ICameraDeviceCallbacks callbacks, String cameraId, String opPackageName, int clientUid); // api1 + 指定 hal 版本（通常为 hal1） ICamera connectLegacy(ICameraClient client, int cameraId, int halVersion, String opPackageName, int clientUid); // 添加和移除 ICameraServiceListener 监听 CameraStatus[] addListener(ICameraServiceListener listener); void removeListener(ICameraServiceListener listener); // 根据 id 返回相机支持的属性 CameraMetadataNative getCameraCharacteristics(String cameraId); // 获取 vendor tag VendorTagDescriptor getCameraVendorTagDescriptor(); VendorTagDescriptorCache getCameraVendorTagCache(); // camera api 1 获取参数信息 String getLegacyParameters(int cameraId); const int API_VERSION_1 = 1; const int API_VERSION_2 = 2; // 指定 id 支持的 API 版本 boolean supportsCameraApi(String cameraId, int apiVersion); // 指定 id 设置手电筒模式 void setTorchMode(String cameraId, boolean enabled, IBinder clientBinder); // 服务端向系统打印系统消息 const int EVENT_NONE = 0; const int EVENT_USER_SWITCHED = 1; oneway void notifySystemEvent(int eventId, in int[] args);&#125;// 2. ICameraServiceListener.aidlinterface ICameraServiceListener&#123; const int STATUS_NOT_PRESENT = 0; const int STATUS_PRESENT = 1; const int STATUS_ENUMERATING = 2; const int STATUS_NOT_AVAILABLE = -2; const int STATUS_UNKNOWN = -1; // 相机设备状态变化事件 oneway void onStatusChanged(int status, String cameraId); const int TORCH_STATUS_NOT_AVAILABLE = 0; const int TORCH_STATUS_AVAILABLE_OFF = 1; const int TORCH_STATUS_AVAILABLE_ON = 2; const int TORCH_STATUS_UNKNOWN = -1; // 手电筒状态变化事件 oneway void onTorchStatusChanged(int status, String cameraId);&#125; ICameraServiceProxy.aidl 文件CameraServiceProxy 服务是在 Java 层注册的： 1234567891011121314151617interface ICameraServiceProxy&#123; // CameraService 向代理服务发送消息，通知用户更新 oneway void pingForUserUpdate(); const int CAMERA_STATE_OPEN = 0; const int CAMERA_STATE_ACTIVE = 1; const int CAMERA_STATE_IDLE = 2; const int CAMERA_STATE_CLOSED = 3; const int CAMERA_FACING_BACK = 0; const int CAMERA_FACING_FRONT = 1; const int CAMERA_FACING_EXTERNAL = 2; // CameraService 向代理服务发送消息，通知相机设备状态更新 oneway void notifyCameraState(String cameraId, int facing, int newCameraState, String clientName);&#125; ICamera 相关Camera API1 才会使用到，分为 ICamera.aidl, ICameraClient.aidl它们的代码是手动实现的，参考：CameraClient.h/cpp, Camera.h/cpp ICameraDevice 相关Camera API2 才会使用到，分为客户端向服务端的请求 ICameraDeviceUser.aidl 和服务端发给客户端的回调 ICameraDeviceCallbacks.aidl 。表示相机设备具备的能力，能够提供的函数；这两个 AIDL 是在 CameraDeviceClient 中实现对应功能的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 1. ICameraDeviceUser.aidl interface ICameraDeviceUser&#123; void disconnect(); const int NO_IN_FLIGHT_REPEATING_FRAMES = -1; // 向设备提交捕获请求 SubmitInfo submitRequest(in CaptureRequest request, boolean streaming); SubmitInfo submitRequestList(in CaptureRequest[] requestList, boolean streaming); // 取消置顶 id 的重复请求，并返回上次请求的帧 id long cancelRequest(int requestId); const int NORMAL_MODE = 0; const int CONSTRAINED_HIGH_SPEED_MODE = 1; const int VENDOR_MODE_START = 0x8000; // 在流处理前执行配置请求 void beginConfigure(); // 根据指定输出配置，创建流 int createStream(in OutputConfiguration outputConfiguration); void endConfigure(int operatingMode); void deleteStream(int streamId); // 创建输入流，返回流 id int createInputStream(int width, int height, int format); // 返回输入流的 Surface Surface getInputSurface(); // Keep in sync with public API in // frameworks/base/core/java/android/hardware/camera2/CameraDevice.java const int TEMPLATE_PREVIEW = 1; const int TEMPLATE_STILL_CAPTURE = 2; const int TEMPLATE_RECORD = 3; const int TEMPLATE_VIDEO_SNAPSHOT = 4; const int TEMPLATE_ZERO_SHUTTER_LAG = 5; const int TEMPLATE_MANUAL = 6; // 根据模板创建默认请求，返回相机参数信息 CameraMetadataNative createDefaultRequest(int templateId); // 获取相机参数信息 CameraMetadataNative getCameraInfo(); void waitUntilIdle(); long flush(); void prepare(int streamId); void tearDown(int streamId); void prepare2(int maxCount, int streamId); void finalizeOutputConfigurations(int streamId, in OutputConfiguration outputConfiguration);&#125;// 2. ICameraDeviceCallbacks.aidlinterface ICameraDeviceCallbacks&#123; ... oneway void onDeviceError(int errorCode, in CaptureResultExtras resultExtras); oneway void onDeviceIdle(); oneway void onCaptureStarted(in CaptureResultExtras resultExtras, long timestamp); oneway void onResultReceived(in CameraMetadataNative result, in CaptureResultExtras resultExtras); oneway void onPrepared(int streamId); // 重复请求引起的错误回调 oneway void onRepeatingRequestError(in long lastFrameNumber, in int repeatingRequestId); oneway void onRequestQueueEmpty();&#125; Services 目录下的文件介绍frameworks/av/services/camera/libcameraserviceAOSP 中这个目录下是 87 个文件，而 Qcom 的基线中增加了 27 个文件，分别为 api1/qticlient2 目录下的 25 个文件，以及 QTICamera2Client.cpp, QTICamera2Client.h 两个文件。 123456789101112131415161718.├── Android.mk├── api1│ ├── client2│ └── qticlient2├── api2├── CameraFlashlight.cpp├── CameraFlashlight.h├── CameraService.cpp├── CameraService.h├── common├── device1├── device3├── gui├── MODULE_LICENSE_APACHE2├── NOTICE├── tests└── utils 从目录结构上可以看出，API1/2 和 HAL1/3 就是在这一层体现的。 API1/API2APP Java 客户端调用服务端方法时，Camera API1/2 接口对应功能都是在 CameraService 中实现的，而这里的 API1/2 目录对应的就是对上层不同版本接口的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354api1├── Camera2Client.cpp├── Camera2Client.h├── CameraClient.cpp├── CameraClient.h├── client2│ ├── CallbackProcessor.cpp│ ├── CallbackProcessor.h│ ├── Camera2Heap.h│ ├── CaptureSequencer.cpp│ ├── CaptureSequencer.h│ ├── FrameProcessor.cpp│ ├── FrameProcessor.h│ ├── JpegCompressor.cpp│ ├── JpegCompressor.h│ ├── JpegProcessor.cpp│ ├── JpegProcessor.h│ ├── Parameters.cpp│ ├── Parameters.h│ ├── StreamingProcessor.cpp│ ├── StreamingProcessor.h│ ├── ZslProcessor.cpp│ └── ZslProcessor.h├── QTICamera2Client.cpp├── QTICamera2Client.h└── qticlient2 ├── CallbackProcessor.cpp ├── CallbackProcessor.h ├── Camera2Heap.h ├── CaptureSequencer.cpp ├── CaptureSequencer.h ├── FrameProcessor.cpp ├── FrameProcessor.h ├── JpegCompressor.cpp ├── JpegCompressor.h ├── JpegProcessor.cpp ├── JpegProcessor.h ├── Parameters.cpp ├── Parameters.h ├── QTICaptureSequencer.cpp ├── QTICaptureSequencer.h ├── QTIFrameProcessor.cpp ├── QTIFrameProcessor.h ├── QTIParameters.cpp ├── QTIParameters.h ├── RawProcessor.cpp ├── RawProcessor.h ├── StreamingProcessor.cpp ├── StreamingProcessor.h ├── ZslProcessor.cpp └── ZslProcessor.hapi2├── CameraDeviceClient.cpp└── CameraDeviceClient.h BasicClient 有三个重要的子类： CameraClient如果平台仅支持 HAL 1，即 CAMERA_DEVICE_API_VERSION_1_0 ；使用 API 1/2 + HAL 1 都会对应该客户端。 Camera2Client如果平台支持 HAL 3 ，即 CAMERA_DEVICE_API_VERSION_3_0 及以上版本；使用 API 1 + HAL 3 对应的客户端。Camera2Client 会将 API1 中的接口转换为 API2 中对应的功能。 CameraDeviceClient如果平台支持 HAL 3 ，使用 API 2 + HAL 3 对应的客户端。 平台仅支持 HAL 1 时，API 2 在 openCamera 时，通过 CameraDeviceUserShim 将 API 2 转换为 API 1 ，即 HAL 1 + API 1 向下发起请求。LegacyCameraDevice 会将 CAMERA API2 转换为 CAMERA API1 ，而 CameraDeviceUserShim 封装了 LegacyCameraDevice 。 QTICamera2ClientQcom 的基线中增加了 27 个文件，分别为 api1/qticlient2 目录下的 25 个文件，以及 QTICamera2Client.cpp, QTICamera2Client.h 两个文件。而 QTICamera2Client 是高通针对 API1 做的优化？在什么情况下会转换为 QTICamera2Client 呢？看如下源码： 12345678910111213141516171819202122232425262728293031323334// 1. Camera2Client.hclass Camera2Client : public Camera2ClientBase&lt;CameraService::Client&gt;&#123;#ifdef USE_QTI_CAMERA2CLIENTfriend class QTICamera2Client;#endif...#ifdef USE_QTI_CAMERA2CLIENT sp&lt;camera2::RawProcessor&gt; mRawProcessor;#endif...#ifdef USE_QTI_CAMERA2CLIENT sp&lt;QTICamera2Client&gt; mQTICamera2Client;#endif...&#125;// 2. Camera2Client.cpptemplate&lt;typename TProviderPtr&gt;status_t Camera2Client::initializeImpl(TProviderPtr providerPtr)&#123;...#ifdef USE_QTI_CAMERA2CLIENT mQTICamera2Client = new QTICamera2Client(this);#endif...#ifdef USE_QTI_CAMERA2CLIENT mRawProcessor = new RawProcessor(this, mCaptureSequencer); threadName = String8::format("C2-%d-RawProc", mCameraId); mRawProcessor-&gt;run(threadName.string());#endif...&#125; QTICamera2Client 是高通对 API 1 中 Camera2Client 做的一层封装，添加了部分功能，主要是向上提供 raw 数据。 12345678910111213141516// 1. QTICamera2Client.hclass QTICamera2Client: public virtual RefBase&#123;private: wp&lt;Camera2Client&gt; mParentClient; status_t stopPreviewExtn();public: QTICamera2Client(sp&lt;Camera2Client&gt; client); ~QTICamera2Client(); ...&#125;// 2. QTICamera2Client.cppQTICamera2Client::QTICamera2Client(sp&lt;Camera2Client&gt; client): mParentClient(client) &#123;&#125; device1/device3device1/device3 可以理解为 Framework 层对应 HAL 层的 HAL 1/3 。 12345678910111213141516171819202122232425262728device1├── CameraHardwareInterface.cpp└── CameraHardwareInterface.hdevice3├── Camera3BufferManager.cpp├── Camera3BufferManager.h├── Camera3Device.cpp├── Camera3Device.h├── Camera3DummyStream.cpp├── Camera3DummyStream.h├── Camera3InputStream.cpp├── Camera3InputStream.h├── Camera3IOStreamBase.cpp├── Camera3IOStreamBase.h├── Camera3OutputStream.cpp├── Camera3OutputStream.h├── Camera3OutputStreamInterface.h├── Camera3SharedOutputStream.cpp├── Camera3SharedOutputStream.h├── Camera3StreamBufferFreedListener.h├── Camera3StreamBufferListener.h├── Camera3Stream.cpp├── Camera3Stream.h├── Camera3StreamInterface.h├── Camera3StreamSplitter.cpp├── Camera3StreamSplitter.h├── StatusTracker.cpp└── StatusTracker.h API1/device1/HAL1 的连接过程 12345// API1: CameraClient.hsp&lt;CameraHardwareInterface&gt; mHardware;// device1: CameraHardwareInterface.hsp&lt;hardware::camera::device::V1_0::ICameraDevice&gt; mHidlDevice;// 这里的 ICameraDevice 即为 HAL1 API1 的客户端 CameraClient 对应的 device1: CameraHardwareInterface，而它直接包含了 HAL1 中 ICameraDevice 。 API1/3/device3/HAL3 的连接过程 123456789101112131415161718192021222324252627282930313233343536// API1: Camera2Client.hclass Camera2Client : public Camera2ClientBase&lt;CameraService::Client&gt;&#123;...&#125;// API2: CameraDeviceClient.hclass CameraDeviceClient : public Camera2ClientBase&lt;CameraDeviceClientBase&gt;, public camera2::FrameProcessorBase::FilteredListener&#123;...&#125;// Camera2ClientBase.hsp&lt;CameraDeviceBase&gt; mDevice;// Camera2ClientBase.cpptemplate &lt;typename TClientBase&gt;Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase( const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;TCamCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid): TClientBase(cameraService, remoteCallback, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid), mSharedCameraCallbacks(remoteCallback), mDeviceVersion(cameraService-&gt;getDeviceVersion( TClientBase::mCameraIdStr)), mDeviceActive(false)&#123; ... mInitialClientPid = clientPid; // 只要是 HAL3 ，则 device 都是对应的 Camera3Device mDevice = new Camera3Device(cameraId); ...&#125; 从源码可以看出，不管是 API1/2 ，只要是 HAL 3 ，Camera2Client, CameraDeviceClient 两个客户端对应的都是 device3: Camera3Device 。 Camera3Device::HalInterface 内部类，用于和 HAL 层通信，实现了 HAL 层 ICameraDeviceSession.hal 部分代码： 123456789101112131415161718192021// Camera3Device.hclass Camera3Device : ... class HalInterface : public camera3::Camera3StreamBufferFreedListener &#123; public: ... // Calls into the HAL interface // Caller takes ownership of requestTemplate status_t constructDefaultRequestSettings( camera3_request_template_t templateId, /*out*/ camera_metadata_t **requestTemplate); status_t configureStreams( /*inout*/ camera3_stream_configuration *config); status_t processCaptureRequest(camera3_capture_request_t *request); status_t flush(); status_t close(); ... &#125; ...&#125; cameraserver 进程cameraserver 进程的源码在 frameworks/av/camera/cameraserver 目录下，该目录只有三个文件： 1234.├── Android.mk ├── cameraserver.rc // rc 文件└── main_cameraserver.cpp // 主进程 cameraserver 进程在启动时，做了三件事： 设置 Socket 通信时，对端关闭读取时进程不退出，返回错误信息（Socket 用在了哪？） HIDL 通信初始化 Native Binder 初始化，CameraService 向 service_manager 注册服务 123456789101112131415161718// frameworks/av/camera/cameraserver/main_cameraserver.cppint main(int argc __unused, char** argv __unused)&#123; // 1. Socket 通信时，对端关闭读取时进程不退出，返回错误信息 signal(SIGPIPE, SIG_IGN); // 2. HIDL 通信初始化 // Set 3 threads for HIDL calls hardware::configureRpcThreadpool(3, /*willjoin*/ false); // 3. Native Binder 初始化，CameraService 是具体的服务 sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI("ServiceManager: %p", sm.get()); CameraService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();&#125; 12345678910// init 进程启动名字为 cameraserver 的进程及对应路径service cameraserver /system/bin/cameraserver // class 表示类别，同一类别的进程同时启动 class main // 用户名 user cameraserver // 分组 group audio camera input drmrpc ioprio rt 4 writepid /dev/cpuset/camera-daemon/tasks /dev/stune/top-app/tasks CameraService 启动服务注册流程图： CameraService 服务CameraService 服务的名称为：media.camera ，主要有两个功能： 作为服务端实现 AIDL 对应功能，当 API1/2 客户端发出请求后，作为服务端响应并处理这些功能。 作为客户端实现 HIDL 回调，用于响应 HAL 层发回的回调。并且通过 CameraProviderManager 和 HAL 层实现双向通信。 服务名称CameraService 继承了 BinderService&lt;CameraService&gt; ，将 CameraService::instantiate(); 代码展开： 12345678910111213141516171819202122232425262728293031323334353637383940// BinderService.htemplate&lt;typename SERVICE&gt;class BinderService&#123;public: static status_t publish(bool allowIsolated = false) &#123; sp&lt;IServiceManager&gt; sm(defaultServiceManager()); return sm-&gt;addService( String16(SERVICE::getServiceName()), new SERVICE(), allowIsolated); &#125; ... static void instantiate() &#123; publish(); &#125; ...&#125;// IServiceManager.hclass IServiceManager : public IInterface&#123;public: ... virtual status_t addService( const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated = false) = 0; ...&#125;// CameraService.hclass CameraService : public BinderService&lt;CameraService&gt;, public virtual ::android::hardware::BnCameraService, public virtual IBinder::DeathRecipient, public camera_module_callbacks_t, public virtual CameraProviderManager::StatusListener&#123; ... // Implementation of BinderService&lt;T&gt; static char const* getServiceName() &#123; return "media.camera"; &#125; ...&#125; 从继承关系及 CameraService.h 源码，getServiceName 设置了 CameraService 服务的名称为 media.camera 。 注册流程图CameraService 注册流程，查看原图 源码分析先来看 CameraService.h 头文件相关定义： 1234567891011// CameraService.hclass CameraService : public BinderService&lt;CameraService&gt;, public virtual ::android::hardware::BnCameraService, public virtual IBinder::DeathRecipient, public camera_module_callbacks_t, public virtual CameraProviderManager::StatusListener&#123; static char const* getServiceName() &#123; return "media.camera"; &#125;&#125; BinderService继承了 BinderService ，用于注册服务。服务名称为 media.camera 。 camera_module_callbacks_t继承了 camera_module_callbacks_t ，它是在 HAL 中定义的，用于 HAL 向 Framework 发送通知。 StatusListener继承了 StatusListener ，它是在 CameraProviderManager.h 中定义的，用于 CameraProviderManager 向 CameraService 发送通知。 现在查看 CameraService 的构造方法，因为在注册服务时 BinderService 会对 CameraService 强指针引用，所以会调用对应函数 onFirstRef ： 1234567891011121314151617181920212223242526272829303132// CameraService.cppCameraService::CameraService() : mEventLog(DEFAULT_EVENT_LOG_LENGTH), mNumberOfCameras(0), mNumberOfNormalCameras(0), mSoundRef(0), mInitialized(false) &#123; // camera_module_callbacks_t 结构体的函数指针赋值 this-&gt;camera_device_status_change = android::camera_device_status_change; this-&gt;torch_mode_status_change = android::torch_mode_status_change; ...&#125;void CameraService::onFirstRef()&#123; ... BatteryNotifier&amp; notifier(BatteryNotifier::getInstance()); notifier.noteResetCamera(); notifier.noteResetFlashlight(); status_t res = INVALID_OPERATION; // 实例化 CameraProviderManager ，并连接 Hardware res = enumerateProviders(); if (res == OK) &#123; mInitialized = true; &#125; // CameraServiceProxy 服务是 Java 代码注册的 // 但是 CameraService 启动时间很早，CameraServiceProxy 可能还并没有注册 // 实际调试结果也是，这段代码实际不会调用 CameraServiceProxy 对应方法 CameraService::pingCameraServiceProxy();&#125; 构造函数中非常简单，仅仅是将 camera_module_callbacks_t 结构体的函数指针赋值；在 onFirstRef 中，主要通过 enumerateProviders 来实例化对应的 CameraProviderManager 并连接 HAL ，最后去 ping 一次 CameraServiceProxy 代理服务，实际上是 ping 不通的，因为 CameraService.cpp 一定是比 CameraServiceProxy.java 启动的早。 12345678910111213141516171819202122232425262728// CameraService.cppstatus_t CameraService::enumerateProviders() &#123; ... // 实例化 CameraProviderManager if (nullptr == mCameraProviderManager.get()) &#123; mCameraProviderManager = new CameraProviderManager(); res = mCameraProviderManager-&gt;initialize(this); ... &#125; mNumberOfCameras = mCameraProviderManager-&gt;getCameraCount(); mNumberOfNormalCameras = mCameraProviderManager-&gt;getAPI1CompatibleCameraCount(); mCameraProviderManager-&gt;setUpVendorTags(); if (nullptr == mFlashlight.get()) &#123; mFlashlight = new CameraFlashlight(mCameraProviderManager, this); &#125; res = mFlashlight-&gt;findFlashUnits(); ... for (auto&amp; cameraId : mCameraProviderManager-&gt;getCameraDeviceIds())&#123; ... onDeviceStatusChanged(id8, CameraDeviceStatus::PRESENT); ... &#125; return OK;&#125; 如果 mCameraProviderManager 为空，则实例化并调用 initialize ；接着实例化 CameraFlashlight ；先看头文件 CameraProviderManager.h 中定义的几个重要数据结构和函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// CameraProviderManager.hclass CameraProviderManager : virtual public hidl::manager::V1_0::IServiceNotification &#123;public: ... // 定义纯虚函数 struct ServiceInteractionProxy &#123; virtual bool registerForNotifications( const std::string &amp;serviceName, const sp&lt;hidl::manager::V1_0::IServiceNotification&gt; &amp;notification) = 0; virtual sp&lt;hardware::camera::provider::V2_4::ICameraProvider&gt; getService(const std::string &amp;serviceName) = 0; virtual ~ServiceInteractionProxy() &#123;&#125; &#125;; // 调用 ICameraProvider 实现这些方法 struct HardwareServiceInteractionProxy : public ServiceInteractionProxy &#123; virtual bool registerForNotifications( const std::string &amp;serviceName, const sp&lt;hidl::manager::V1_0::IServiceNotification&gt; &amp;notification) override &#123; return hardware::camera::provider::V2_4:: ICameraProvider::registerForNotifications( serviceName, notification); &#125; virtual sp&lt;hardware::camera::provider::V2_4::ICameraProvider&gt; getService(const std::string &amp;serviceName) override &#123; return hardware::camera::provider::V2_4:: ICameraProvider::getService(serviceName); &#125; &#125;; struct StatusListener : virtual public RefBase &#123; ~StatusListener() &#123;&#125; virtual void onDeviceStatusChanged(const String8 &amp;cameraId, hardware::camera::common::V1_0::CameraDeviceStatus newStatus) = 0; virtual void onTorchStatusChanged(const String8 &amp;cameraId, hardware::camera::common::V1_0::TorchModeStatus newStatus) = 0; virtual void onNewProviderRegistered() = 0; &#125;; virtual hardware::Return&lt;void&gt; onRegistration( const hardware::hidl_string&amp; fqName, const hardware::hidl_string&amp; name, bool preexisting) override; status_t initialize(wp&lt;StatusListener&gt; listener, ServiceInteractionProxy *proxy = &amp;sHardwareServiceInteractionProxy);private: static HardwareServiceInteractionProxy sHardwareServiceInteractionProxy; ServiceInteractionProxy定义了几个纯虚函数，用于向 HAL 系统服务中注册 registerForNotifications 监听 ICameraProvider.hal 的消息；getService 返回 ICameraProvider 的实例。 HardwareServiceInteractionProxyServiceInteractionProxy 的实现结构体，具体调用 ICameraProvider 对应的 registerForNotifications, getService ；也就是 CameraProviderManager 持有 ICameraProvider 的远程实例。 onRegistrationregisterForNotifications 的回调函数，注册成功后回调。 StatusListener状态监听接口，这些接口是在 CameraService 中实现的；用于 CameraProviderManager 回调 CameraService 。 sHardwareServiceInteractionProxy静态变量，是初始化 initialize 函数形参 ServiceInteractionProxy 的默认值。 从 CameraService 中调用 CameraProviderManager::initialize 时，传入的是 CameraService 的实例，仅仅一个参数，所以 ServiceInteractionProxy 使用的是默认的 sHardwareServiceInteractionProxy 实例。 1234567891011121314151617181920// CameraProviderManager.cpp// 实例化 HAL 代理CameraProviderManager::HardwareServiceInteractionProxyCameraProviderManager::sHardwareServiceInteractionProxy&#123;&#125;;status_t CameraProviderManager::initialize( wp&lt;CameraProviderManager::StatusListener&gt; listener, ServiceInteractionProxy* proxy) &#123; ... mListener = listener; mServiceProxy = proxy; bool success = mServiceProxy-&gt;registerForNotifications( /* instance name, empty means no filter */ &quot;&quot;, this); ... addProviderLocked(kLegacyProviderName, /*expected*/ false); return OK;&#125; CameraProviderManager::initialize 中主要是初始化赋值 mListener, mServiceProxy ，并通过 sHardwareServiceInteractionProxy-&gt;registerForNotifications 向 HIDL 服务管理注册了自己，最后调用 addProviderLocked 。 1234567891011121314151617181920212223242526272829// CameraProviderManager.cppstatus_t CameraProviderManager::addProviderLocked( const std::string&amp; newProvider, bool expected) &#123; for (const auto&amp; providerInfo : mProviders) &#123; if (providerInfo-&gt;mProviderName == newProvider) &#123; ALOGW(...); return ALREADY_EXISTS; &#125; &#125; // HIDL 通信，通过 ICameraProvider 和 HAL 层通信 sp&lt;provider::V2_4::ICameraProvider&gt; interface; interface = mServiceProxy-&gt;getService(newProvider); if (interface == nullptr) &#123; ... &#125; sp&lt;ProviderInfo&gt; providerInfo = new ProviderInfo(newProvider, interface, this); status_t res = providerInfo-&gt;initialize(); if (res != OK) &#123; return res; &#125; mProviders.push_back(providerInfo); return OK;&#125; addProviderLocked 中有如下信息： 通过代理获取 ICameraProvider 实例，用于和 HAL 通信 新建 ProviderInfo 并初始化，保存 ICameraProvider 实例 mProviders 保存所有的 ProviderInfo （实测只有一个实例元素，名称为 legacy/0） 123456789101112// CameraProviderManager.hstruct ProviderInfo : virtual public hardware::camera::provider::V2_4::ICameraProviderCallback, virtual public hardware::hidl_death_recipient&#123; const std::string mProviderName; const sp&lt;hardware::camera::provider::V2_4::ICameraProvider&gt; mInterface; const metadata_vendor_id_t mProviderTagid; ...&#125; ProviderInfo 继承了 ICameraProviderCallback, hidl_death_recipient ，它会处理来着 ICameraProvider 的回调。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// CameraProviderManager.cppCameraProviderManager::ProviderInfo::ProviderInfo( const std::string &amp;providerName, sp&lt;provider::V2_4::ICameraProvider&gt;&amp; interface, CameraProviderManager *manager) : mProviderName(providerName), mInterface(interface), mProviderTagid(generateVendorTagId(providerName)), mUniqueDeviceCount(0), mManager(manager) &#123; (void) mManager;&#125;status_t CameraProviderManager::ProviderInfo::initialize() &#123; status_t res = parseProviderName(mProviderName, &amp;mType, &amp;mId); ... // 设置回调 hardware::Return&lt;Status&gt; status = mInterface-&gt;setCallback(this); ... // HIDL 连接 hardware::Return&lt;bool&gt; linked = mInterface-&gt;linkToDeath(this, /*cookie*/ mId); ... // Get initial list of camera devices, if any std::vector&lt;std::string&gt; devices; // 获取 CameraIdList ，实际是获取的一组设备名 hardware::Return&lt;void&gt; ret = mInterface-&gt;getCameraIdList([&amp;status, &amp;devices]( Status idStatus, const hardware::hidl_vec&lt;hardware::hidl_string&gt;&amp; cameraDeviceNames) &#123; status = idStatus; if (status == Status::OK) &#123; for (size_t i = 0; i &lt; cameraDeviceNames.size(); i++) &#123; devices.push_back(cameraDeviceNames[i]); &#125; &#125; &#125;); ... for (auto&amp; device : devices) &#123; std::string id; // 添加从 HAL 返回的每个设备名 status_t res = addDevice(device, hardware::camera::common::V1_0::CameraDeviceStatus::PRESENT, &amp;id); ... &#125; ... return OK;&#125; ProviderInfo::initialize 初始化，主要是从 HAL 获取设备名后，添加具体的设备信息。 123456789101112131415161718192021222324252627282930// CameraProviderManager.hstruct DeviceInfo &#123; const std::string mName; // Full instance name const std::string mId; // ID section of full name const hardware::hidl_version mVersion; const metadata_vendor_id_t mProviderTagid; ...protected: bool mHasFlashUnit; template&lt;class InterfaceT&gt; static status_t setTorchMode(InterfaceT&amp; interface, bool enabled);&#125;;// HALv1-specific camera fields, including the actual device interfacestruct DeviceInfo1 : public DeviceInfo &#123; typedef hardware::camera::device::V1_0::ICameraDevice InterfaceT; const sp&lt;InterfaceT&gt; mInterface; ...private: CameraParameters2 mDefaultParameters;&#125;;// HALv3-specific camera fields, including the actual device interfacestruct DeviceInfo3 : public DeviceInfo &#123; typedef hardware::camera::device::V3_2::ICameraDevice InterfaceT; const sp&lt;InterfaceT&gt; mInterface; ...private: CameraMetadata mCameraCharacteristics;&#125;; 头文件中可以看出，DeviceInfo 有两个子类，分别对应 HAL 1 和 HAL 3 ，并将具体的 ICameraDevice 版本保存到 mInterface 中；所以设备添加时也会根据不同版本分别添加： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// CameraProviderManager.cppstatus_t CameraProviderManager::ProviderInfo::addDevice( const std::string&amp; name, CameraDeviceStatus initialStatus, /*out*/ std::string* parsedId) &#123; ... status_t res = parseDeviceName(name, &amp;major, &amp;minor, &amp;type, &amp;id); ... std::unique_ptr&lt;DeviceInfo&gt; deviceInfo; switch (major) &#123; case 1: deviceInfo = initializeDeviceInfo&lt;DeviceInfo1&gt;( name, mProviderTagid, id, minor); break; case 3: deviceInfo = initializeDeviceInfo&lt;DeviceInfo3&gt;( name, mProviderTagid, id, minor); break; default: ALOGE(...); return BAD_VALUE; &#125; ... return OK;&#125;template&lt;class DeviceInfoT&gt;std::unique_ptr&lt;CameraProviderManager::ProviderInfo::DeviceInfo&gt; CameraProviderManager::ProviderInfo::initializeDeviceInfo( const std::string &amp;name, const metadata_vendor_id_t tagId, const std::string &amp;id, uint16_t minorVersion) const &#123; Status status; auto cameraInterface = getDeviceInterface&lt;typename DeviceInfoT::InterfaceT&gt;(name); if (cameraInterface == nullptr) return nullptr; CameraResourceCost resourceCost; cameraInterface-&gt;getResourceCost([&amp;status, &amp;resourceCost]( Status s, CameraResourceCost cost) &#123; status = s; resourceCost = cost; &#125;); ... return std::unique_ptr&lt;DeviceInfo&gt;( new DeviceInfoT(name, tagId, id, minorVersion, resourceCost, cameraInterface));&#125; 根据传入的 deviceName 解析版本号、类型、设备 Id （前后摄），并根据 major 版本号（表示 HAL 1 或者 HAL 3） 分别初始化对应的 DeviceInfo ；在 initializeDeviceInfo 中通过 getDeviceInterface 获取对应的 ICameraDevice 版本，在对应版本 DeviceInfo 实例化时保存；也就是将 DeviceInfo 和 HAL 层的 ICameraDevice 绑定。 123456789101112131415161718192021222324252627282930313233343536373839404142// CameraProviderManager.cppCameraProviderManager::ProviderInfo::DeviceInfo3::DeviceInfo3( const std::string&amp; name, const metadata_vendor_id_t tagId, const std::string &amp;id, uint16_t minorVersion, const CameraResourceCost&amp; resourceCost, sp&lt;InterfaceT&gt; interface) : DeviceInfo(name, tagId, id, hardware::hidl_version&#123;3, minorVersion&#125;, resourceCost), mInterface(interface) &#123; // Get camera characteristics and initialize flash unit availability Status status; hardware::Return&lt;void&gt; ret; // 获取 Camera 设备配置信息 ret = mInterface-&gt;getCameraCharacteristics([&amp;status, this](Status s, device::V3_2::CameraMetadata metadata) &#123; status = s; if (s == Status::OK) &#123; camera_metadata_t *buffer = reinterpret_cast&lt;camera_metadata_t*&gt;(metadata.data()); size_t expectedSize = metadata.size(); int res = validate_camera_metadata_structure(buffer, &amp;expectedSize); if (res==OK||res==CAMERA_METADATA_VALIDATION_SHIFTED) &#123; set_camera_metadata_vendor_id(buffer, mProviderTagid); mCameraCharacteristics = buffer; &#125; else &#123; ALOGE(...); status = Status::INTERNAL_ERROR; &#125; &#125; &#125;); ... camera_metadata_entry flashAvailable = mCameraCharacteristics.find(ANDROID_FLASH_INFO_AVAILABLE); if (flashAvailable.count == 1 &amp;&amp; flashAvailable.data.u8[0] == ANDROID_FLASH_INFO_AVAILABLE_TRUE) &#123; mHasFlashUnit = true; &#125; else &#123; mHasFlashUnit = false; &#125;&#125; 这里分析的是 DeviceInfo3 的构造函数，它会向 HAL 层请求当前设备的配置信息，并保存 mCameraCharacteristics ，后续查看属性时都会通过这个变量查询。CameraService::enumerateProviders 中，首先新建并初始化 CameraProviderManager ，其持有和 HAL 通信的实例；接着新建并初始化 CameraFlashlight ，用于控制闪光灯。先看头文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// CameraFlashlight.hclass FlashControlBase : public virtual VirtualLightRefBase &#123;public: ... virtual status_t hasFlashUnit(const String8&amp; cameraId, bool *hasFlash) = 0; virtual status_t setTorchMode(const String8&amp; cameraId, bool enabled) = 0;&#125;;// HAL 3 闪光灯控制class ProviderFlashControl : public FlashControlBase &#123;public: ... // FlashControlBase status_t hasFlashUnit(const String8&amp; cameraId, bool *hasFlash); status_t setTorchMode(const String8&amp; cameraId, bool enabled);private: sp&lt;CameraProviderManager&gt; mProviderManager;...&#125;;// HAL 1 闪光灯控制，通过 CameraHardwareInterface 向下调用class CameraHardwareInterfaceFlashControl : public FlashControlBase &#123;public: ... // FlashControlBase status_t setTorchMode(const String8&amp; cameraId, bool enabled); status_t hasFlashUnit(const String8&amp; cameraId, bool *hasFlash);private: sp&lt;CameraProviderManager&gt; mProviderManager; const camera_module_callbacks_t *mCallbacks; sp&lt;CameraHardwareInterface&gt; mDevice; String8 mCameraId; CameraParameters mParameters; ...&#125;class CameraFlashlight : public virtual VirtualLightRefBase &#123;public: ... bool hasFlashUnit(const String8&amp; cameraId); status_t setTorchMode(const String8&amp; cameraId, bool enabled);private: sp&lt;FlashControlBase&gt; mFlashControl; sp&lt;CameraProviderManager&gt; mProviderManager; const camera_module_callbacks_t *mCallbacks; 头文件定义的几个信息： CameraHardwareInterfaceFlashControlHAL 1 闪光灯控制类，通过 CameraHardwareInterface 向下调用。 ProviderFlashControlHAL 3 闪光灯控制类。 FlashControlBase基类。 CameraProviderManager主要用于 ProviderFlashControl 向下发送信息。 camera_module_callbacks_tHAL 层的回调。 123456789101112131415161718192021222324252627282930313233343536373839// CameraFlashlight.cppCameraFlashlight::CameraFlashlight( sp&lt;CameraProviderManager&gt; providerManager, camera_module_callbacks_t* callbacks) : mProviderManager(providerManager), mCallbacks(callbacks), mFlashlightMapInitialized(false) &#123;&#125;status_t CameraFlashlight::findFlashUnits() &#123; ... mFlashControl.clear(); for (auto &amp;id : cameraIds) &#123; ssize_t index = mHasFlashlightMap.indexOfKey(id); if (0 &lt;= index) &#123; continue; &#125; bool hasFlash = false; res = createFlashlightControl(id); ... &#125; ... return OK;&#125;status_t CameraFlashlight::createFlashlightControl( const String8&amp; cameraId) &#123; ... if (mProviderManager-&gt;supportSetTorchMode(cameraId.string())) &#123; mFlashControl = new ProviderFlashControl(mProviderManager); &#125; else &#123; // Only HAL1 devices do not support setTorchMode mFlashControl = new CameraHardwareInterfaceFlashControl(mProviderManager, *mCallbacks); &#125; return OK;&#125; CameraFlashlight 的构造函数仅仅初始化了几个本地变量，CameraService 中调用 CameraFlashlight::findFlashUnits 时，会根据 HAL 1/3 分别来创建对应的闪光灯控制类。至此整个 CameraService 注册流程结束。 小结CameraService 初始化和注册流程中，实例化了两个对象： CameraProviderManager mCameraProviderManager 对象 Flashlight mFlashlight 对象 CameraProviderManager 初始化完后： mProviders 保存了 ProviderInfo 对象；并关联了 ICameraProvider ，用于和 HAL 通信 ProviderInfo 中 mDevices 保存了所有的 DeviceInfo1, DeviceInfo3 设备信息，并关联 ICameraDevice 实例，用于直接通信 DeviceInfo1 中保存了 CameraParameters2 mDefaultParameters 参数信息 DeviceInfo3 中保存了 CameraMetadata mCameraCharacteristics 参数信息 CameraFlashlight 新建和初始化后： 如果是 HAL 1 会实例化控制类 CameraHardwareInterfaceFlashControl 如果是 HAL 3 会实例化控制类 ProviderFlashControl Camera Open 流程APICamera API 2 开启摄像头设备时，通过 CameraManager.openCamera 来打开： 123456789// CameraManager.java@RequiresPermission(android.Manifest.permission.CAMERA)public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException &#123; openCameraForUid(cameraId, callback, handler, USE_CALLING_UID);&#125; String cameraId表示前后摄的 ID ，通常 0 表示后摄。 CameraDevice.StateCallback callback打开设备时，状态回调接口。 Handler handler表示回调接口在哪个线程执行。 示例打开一个设备，在回调中保存 CameraDevice ： 123456789101112131415161718192021222324252627CameraDevice.StateCallback mCameraDeviceStateCallback = new CameraDevice.StateCallback() &#123; @Override public void onOpened(@NonNull CameraDevice camera) &#123; mCameraDevice = camera; //createCameraCaptureSession(); &#125; @Override public void onDisconnected(@NonNull CameraDevice camera) &#123; camera.close(); mCameraDevice = null; &#125; @Override public void onError(@NonNull CameraDevice camera, int error) &#123; camera.close(); mCameraDevice = null; &#125;&#125;;try &#123; mCameraManager.openCamera(mCameraId, mCameraDeviceStateCallback, mBackHandler);&#125; catch (CameraAccessException e) &#123; e.printStackTrace();&#125; CameraDevice.StateCallback 接口在打开设备时，会传入 StateCallback 回调接口，它有四个方法，都是在 CameraDeviceImpl 中回调的： onOpened在 CameraManager.openCameraDeviceUserAsync 方法中，CameraDeviceImpl.setRemoteDevice(cameraUser); 会触发 StateCallback.onOpened 回调。 onClosedCameraDevice.close 是在 CameraDeviceImpl.close 中实现的，同时会触发 StateCallback.onClosed 回调。 onDisconnectedCameraDeviceImpl.setRemoteDevice(cameraUser); 中如果远程连接断开，或者 ICameraDeviceCallbacks.onDeviceError 返回了 ERROR_CAMERA_DISCONNECTED 错误码，都会触发 StateCallback.onDisconnected 回调。 onError在 Binder 通信中绑定失败 binderDied ，setRemoteFailure 以及 ICameraDeviceCallbacks.onDeviceError 返回了 ERROR_CAMERA_DEVICE/ERROR_CAMERA_SERVICE 错误码，都会触发 StateCallback.onError 回调。 在设备打开时，会通过 StateCallback 回调返回打开状态，从代码可以看出，只要 ICameraService.connectDevice 成功后，直接调用 CameraDeviceImpl.setRemoteDevice(cameraUser); 来触发 StateCallback.onOpened ，表示设备打开成功。StateCallback 是 Java 接口，它的 onDisconnected, onError 两个回调方法，需要真实的与物理设备交互；所以需要通过 ICameraDeviceCallbacks.aidl 从 Framework Service 中获取真实的信息回调。 流程图Camera API 2 开启相机设备流程图： 打开设备，查看原图 连接设备，查看原图 源码分析通过 CameraManager.openCamera 打开设备，我们重点分析如下代码，代码执行路径为 ：openCamera -&gt; openCameraForUid -&gt; openCameraDeviceUserAsync 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// CameraManager.java@RequiresPermission(android.Manifest.permission.CAMERA)public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException &#123; openCameraForUid(cameraId, callback, handler, USE_CALLING_UID);&#125;private CameraDevice openCameraDeviceUserAsync(String cameraId, CameraDevice.StateCallback callback, Handler handler, final int uid) throws CameraAccessException &#123; CameraCharacteristics characteristics = getCameraCharacteristics(cameraId); CameraDevice device = null; synchronized (mLock) &#123; ICameraDeviceUser cameraUser = null; // 新建 CameraDeviceImpl 实例 android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = new android.hardware.camera2.impl.CameraDeviceImpl( cameraId, callback, handler, characteristics, mContext.getApplicationInfo().targetSdkVersion); // 获取 ICameraDeviceCallbacks 回调 ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks(); try &#123; if (supportsCamera2ApiLocked(cameraId)) &#123; // Use cameraservice's cameradeviceclient // implementation for HAL3.2+ devices ICameraService cameraService = CameraManagerGlobal.get().getCameraService(); if (cameraService == null) &#123; throw new ServiceSpecificException(...); &#125; // 连接设备，并获取 ICameraDeviceUser cameraUser = cameraService.connectDevice(callbacks, cameraId, mContext.getOpPackageName(), uid); &#125; else &#123; // Use legacy camera implementation for HAL1 devices int id; try &#123; id = Integer.parseInt(cameraId); &#125; catch (NumberFormatException e) &#123; throw new IllegalArgumentException(...); &#125; Log.i(TAG, "Using legacy camera HAL."); cameraUser = CameraDeviceUserShim.connectBinderShim(callbacks, id); &#125; &#125; catch (ServiceSpecificException e) &#123; ... &#125; catch (RemoteException e) &#123; ... &#125; // 关联 CameraDeviceImpl 和 ICameraDeviceUser ，方便直接通信 deviceImpl.setRemoteDevice(cameraUser); device = deviceImpl; &#125; return device;&#125;// CameraDeviceImpl.javapublic void setRemoteDevice(ICameraDeviceUser remoteDevice) throws CameraAccessException &#123; synchronized(mInterfaceLock) &#123; ... // 新建包装类，包装接口并处理对应访问异常 mRemoteDevice = new ICameraDeviceUserWrapper(remoteDevice); ... &#125;&#125; 从上面展示的 API 部分代码中可以看出： 支持 API 2如果系统开启了 HAL 3 ，则支持 API 2 ；此时通过 ICameraService 访问服务。 不支持 API 2如果系统仅支持 HAL 1 ，则 API 2 需要通过 CameraDeviceUserShim 转换为对应的 API 1 + HAL 1 来实现对应功能。CameraDeviceUserShim 是 ICameraDeviceUser 的实现类；整个 frameworks/base/core/java/android/hardware/camera2/legacy 目录下的代码都是为了实现这个转换功能。 整个打开设备的动作有如下功能： 新建了 CameraDeviceImpl 实例，它是 CameraDevice 的实现类 CameraManager 通过 CameraService.connectDevice 连接设备，获取到 ICameraDeviceUser, ICameraDeviceCallbacks 对象，它们用于后续 CameraDeviceImpl.java 和 CameraDeviceClient.cpp 绑定通信 新建 ICameraDeviceUserWrapper 实例，它是对 ICameraDeviceUser 的包装类，捕获并处理远程访问异常等 这里需要重点分析 connectDevice ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// CameraService.cppStatus CameraService::connectDevice( const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; cameraCb, const String16&amp; cameraId, const String16&amp; clientPackageName, int clientUid, /*out*/ sp&lt;hardware::camera2::ICameraDeviceUser&gt;* device) &#123; ATRACE_CALL(); Status ret = Status::ok(); String8 id = String8(cameraId); sp&lt;CameraDeviceClient&gt; client = nullptr; ret = connectHelper&lt;hardware::camera2::ICameraDeviceCallbacks, CameraDeviceClient&gt;(cameraCb, id, CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, USE_CALLING_PID, API_2, /*legacyMode*/ false, /*shimUpdateOnly*/ false, /*out*/client); ... *device = client; return ret;&#125;template&lt;class CALLBACK, class CLIENT&gt;Status CameraService::connectHelper(const sp&lt;CALLBACK&gt;&amp; cameraCb, const String8&amp; cameraId, int halVersion, const String16&amp; clientPackageName, int clientUid, int clientPid, apiLevel effectiveApiLevel, bool legacyMode, bool shimUpdateOnly, /*out*/sp&lt;CLIENT&gt;&amp; device) &#123; ... &#123; sp&lt;BasicClient&gt; tmp = nullptr; if(!(ret = makeClient(this, cameraCb, clientPackageName, cameraId, facing, clientPid, clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel, /*out*/&amp;tmp)).isOk()) &#123; return ret; &#125; ... err = client-&gt;initialize(mCameraProviderManager); ... if (shimUpdateOnly) &#123; mServiceLock.unlock(); client-&gt;disconnect(); mServiceLock.lock(); &#125; else &#123; // Otherwise, add client to active clients list finishConnectLocked(client, partial); &#125; &#125; // lock is destroyed, allow further connect calls device = client; return ret;&#125; CameraService::connectDevice 函数调用了模板函数 connectHelper ，而该模板主要的两个功能就是：makeClient 新建客户端，initialize 初始化客户端。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Status CameraService::makeClient(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;IInterface&gt;&amp; cameraCb, const String16&amp; packageName, const String8&amp; cameraId, int facing, int clientPid, uid_t clientUid, int servicePid, bool legacyMode, int halVersion, int deviceVersion, apiLevel effectiveApiLevel, /*out*/sp&lt;BasicClient&gt;* client) &#123; if (halVersion &lt; 0 || halVersion == deviceVersion) &#123; switch(deviceVersion) &#123; case CAMERA_DEVICE_API_VERSION_1_0: if (effectiveApiLevel == API_1) &#123; // Camera1 API route sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get()); *client = new CameraClient(cameraService, tmp, packageName, cameraIdToInt(cameraId), facing, clientPid, clientUid, getpid(), legacyMode); &#125; else &#123; // Camera2 API route ALOGW("Camera using old HAL version: %d", deviceVersion); return STATUS_ERROR_FMT(...); &#125; break; case CAMERA_DEVICE_API_VERSION_3_0: case CAMERA_DEVICE_API_VERSION_3_1: case CAMERA_DEVICE_API_VERSION_3_2: case CAMERA_DEVICE_API_VERSION_3_3: case CAMERA_DEVICE_API_VERSION_3_4: if (effectiveApiLevel == API_1) &#123; // Camera1 API route sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get()); *client = new Camera2Client(cameraService, tmp, packageName, cameraIdToInt(cameraId), facing, clientPid, clientUid, servicePid, legacyMode); &#125; else &#123; // Camera2 API route sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt; tmp = static_cast&lt;hardware::camera2:: ICameraDeviceCallbacks*&gt;(cameraCb.get()); *client = new CameraDeviceClient(cameraService, tmp, packageName, cameraId, facing, clientPid, clientUid, servicePid); &#125; break; default: // Should not be reachable ALOGE("Unknown camera device HAL version:%d", deviceVersion); return STATUS_ERROR_FMT(...); &#125; &#125; else &#123; if (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp; halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123; sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get()); *client = new CameraClient(cameraService, tmp, packageName, cameraIdToInt(cameraId), facing, clientPid, clientUid, servicePid, legacyMode); &#125; else &#123; ALOGE("Invalid camera HAL version .."); return STATUS_ERROR_FMT(...; &#125; &#125; return Status::ok();&#125; makeClient 主要是根据 device, HAL 版本和调用 API 的版本来创建对应的客户端： HAL 1 + API 1 ：新建 CameraClient HAL 1 + API 2 ：不支持 HAL 3 + API 1 ：新建 Camera2Client HAL 3 + API 2 ：新建 CameraDeviceClient 这里的三个变量 effectiveApiLevel, legacyMode=0, halVersion ，主要是有三个连接函数决定： connect, connectLegacy, connectDevice ，其中 connectLegacy 可以指定 HAL 版本（来决定到底使用哪个 client）： 使用系统自带相机effectiveApiLevel=1, legacyMode=1, halVersion=256(HAL 1) ，系统自带应用使用的是 connectLegacy 。 使用标准 API2 接口effectiveApiLevel=2, legacyMode=0, halVersion=-1 ，其中 -1 表示 CAMERA_HAL_API_VERSION_UNSPECIFIED 。 所谓的 HAL 版本，实际指的就是 Device 的版本：其中 HAL 1 对应 CAMERA_DEVICE_API_VERSION_1_0 ；HAL 3 对应的是 CAMERA_DEVICE_API_VERSION_3_0 及以上版本。而 HAL 2 和 CAMERA_DEVICE_API_VERSION_2_0 已经废弃。因为手机平台使用 HAL 3 时，为了满足部分应用中使用了 API 1 的接口，常常需要兼容 HAL 1，所以支持 HAL 3 即意味着同时会支持 HAL 1 。 这里流程跟踪的是新建 CameraDeviceClient ，先看头文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// CameraService.hclass BasicClient : public virtual RefBase &#123;public: virtual status_t initialize(sp&lt;CameraProviderManager&gt; manager) = 0; ...private: ... class OpsCallback : public BnAppOpsCallback &#123; public: explicit OpsCallback(wp&lt;BasicClient&gt; client); virtual void opChanged(int32_t op, const String16&amp; packageName); private: wp&lt;BasicClient&gt; mClient; &#125;; // class OpsCallback sp&lt;OpsCallback&gt; mOpsCallback; ...&#125;// Camera3Device.hclass Camera3Device : public CameraDeviceBase, virtual public hardware::camera::device::V3_2::ICameraDeviceCallback, private camera3_callback_ops &#123;...&#125;// Camera2ClientBase.htemplate &lt;typename TClientBase&gt;class Camera2ClientBase : public TClientBase, public CameraDeviceBase::NotificationListener&#123;public: typedef typename TClientBase::TCamCallbacks TCamCallbacks; ...protected: // 实例为 Camera3Device sp&lt;CameraDeviceBase&gt; mDevice; ...private: ... template&lt;typename TProviderPtr&gt; status_t initializeImpl(TProviderPtr providerPtr);&#125;;// CameraDeviceClient.hstruct CameraDeviceClientBase : public CameraService::BasicClient, public hardware::camera2::BnCameraDeviceUser&#123; typedef hardware::camera2::ICameraDeviceCallbacks TCamCallbacks; ...protected: CameraDeviceClientBase(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid); sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt; mRemoteCallback;&#125;;class CameraDeviceClient : public Camera2ClientBase&lt;CameraDeviceClientBase&gt;, public camera2::FrameProcessorBase::FilteredListener&#123;...&#125; 从类图结构来看：BasicClient 是三个客户端 CameraClient, Camera2Client, CameraDeviceClient 的基类；而 Camera2ClientBase 中的变量 CameraDeviceBase 实际的子类是 Camera3Device 。来看构造函数的流程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// CameraDeviceClient.cppCameraDeviceClient::CameraDeviceClient( const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid) : Camera2ClientBase(cameraService, remoteCallback, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid), mInputStream(), mStreamingRequestId(REQUEST_ID_NONE), mRequestIdCounter(0), mPrivilegedClient(false) &#123; ...&#125;// Camera2ClientBase.cpptemplate &lt;typename TClientBase&gt;Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase( const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;TCamCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid): TClientBase(cameraService, remoteCallback, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid), mSharedCameraCallbacks(remoteCallback), mDeviceVersion(cameraService-&gt;getDeviceVersion( TClientBase::mCameraIdStr)), mDeviceActive(false)&#123; ... // 实例化 Camera3Device mDevice = new Camera3Device(cameraId);&#125;// CameraDeviceClient.cppCameraDeviceClientBase::CameraDeviceClientBase( const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid) : BasicClient(cameraService, IInterface::asBinder(remoteCallback), clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid), mRemoteCallback(remoteCallback) &#123;&#125;// CameraService.cppCameraService::BasicClient::BasicClient( const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;IBinder&gt;&amp; remoteCallback, const String16&amp; clientPackageName, const String8&amp; cameraIdStr, int cameraFacing, int clientPid, uid_t clientUid, int servicePid): mCameraIdStr(cameraIdStr), mCameraFacing(cameraFacing), mClientPackageName(clientPackageName), mClientPid(clientPid), mClientUid(clientUid), mServicePid(servicePid), mDisconnected(false), mRemoteBinder(remoteCallback)&#123; ...&#125; 根据类继承关系，一条链路实例化各个子类，最终会新建 Camera3Device 实例。makeClient 新建完客户端后，调用客户端的初始化： 12345678910111213141516171819// CameraDeviceClient.cpptemplate&lt;typename TProviderPtr&gt;status_t CameraDeviceClient::initializeImpl(TProviderPtr providerPtr) &#123; ... res = Camera2ClientBase::initialize(providerPtr); ... String8 threadName; mFrameProcessor = new FrameProcessorBase(mDevice); threadName = String8::format("CDU-%s-FrameProc", mCameraIdStr.string()); mFrameProcessor-&gt;run(threadName.string()); mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID, FRAME_PROCESSOR_LISTENER_MAX_ID, /*listener*/this, /*sendPartials*/true); return OK;&#125; CameraDeviceClient::initializeImpl 是一个模板函数，主要有两个功能：调用 Camera2ClientBase 及其父类初始化；新建 FrameProcessorBase 实例，它主要功能是在发出预览、拍照、录像请求后，HAL 层向 Framework 层返回结果的回调类，后面讲预览流程时会详细分析。 12345678910111213141516// Camera2ClientBase.cpptemplate &lt;typename TClientBase&gt;status_t Camera2ClientBase&lt;TClientBase&gt;::initialize( sp&lt;CameraProviderManager&gt; manager) &#123; return initializeImpl(manager);&#125;template &lt;typename TClientBase&gt;template &lt;typename TProviderPtr&gt;status_t Camera2ClientBase&lt;TClientBase&gt;::initializeImpl( TProviderPtr providerPtr) &#123; ... res = mDevice-&gt;initialize(providerPtr); ... return OK;&#125; Camera2ClientBase::initialize 也是一个模板函数，最终会调用 Camera3Device 的初始化： 1234567891011121314151617181920212223242526272829303132// Camera3Device.cppstatus_t Camera3Device::initialize(sp&lt;CameraProviderManager&gt; manager) &#123; ... sp&lt;ICameraDeviceSession&gt; session; // 打开会话，获取 ICameraDeviceSession status_t res = manager-&gt;openSession(mId.string(), this, /*out*/ &amp;session); ... // 获取当前设备的配置信息，并保存到 CameraMetadata mDeviceInfo res = manager-&gt;getCameraCharacteristics(mId.string(), &amp;mDeviceInfo); ... // 通过 ICameraDeviceSession 获取请求队列 std::shared_ptr&lt;RequestMetadataQueue&gt; queue; auto requestQueueRet = session-&gt;getCaptureRequestMetadataQueue( [&amp;queue](const auto&amp; descriptor) &#123; queue = std::make_shared&lt;RequestMetadataQueue&gt;(descriptor); ... &#125;); ... // 通过 ICameraDeviceSession 获取结果队列 std::unique_ptr&lt;ResultMetadataQueue&gt;&amp; resQueue=mResultMetadataQueue; auto resultQueueRet = session-&gt;getCaptureResultMetadataQueue( [&amp;resQueue](const auto&amp; descriptor) &#123; resQueue=std::make_unique&lt;ResultMetadataQueue&gt;(descriptor); ... &#125;); ... // 新建 HalInterface 实例，并绑定 ICameraDeviceSession 以及请求队列 mInterface = new HalInterface(session, queue); ... return initializeCommonLocked();&#125; Camera3Device::initialize 初始化中，重点实现的功能为打开物理设备，并获取 ICameraDeviceSession 用于后续直接和 HAL 通信，并通过它从 HAL 获取请求队列和结果队列；最后新建 HalInterface 实例，并将 ICameraDeviceSession 保存并绑定。 123456789101112131415161718192021222324252627// CameraProviderManager.cppstatus_t CameraProviderManager::openSession(const std::string &amp;id, const sp&lt;hardware::camera::device::V3_2::ICameraDeviceCallback&gt;&amp; callback, /*out*/ sp&lt;hardware::camera::device::V3_2::ICameraDeviceSession&gt; *session)&#123; std::lock_guard&lt;std::mutex&gt; lock(mInterfaceMutex); auto deviceInfo = findDeviceInfoLocked(id, /*minVersion*/ &#123;3,0&#125;, /*maxVersion*/ &#123;4,0&#125;); if (deviceInfo == nullptr) return NAME_NOT_FOUND; auto *deviceInfo3=static_cast&lt;ProviderInfo::DeviceInfo3*&gt;(deviceInfo); Status status; hardware::Return&lt;void&gt; ret; // 向 HAL 打开设备，并返回 ICameraDeviceSession ret = deviceInfo3-&gt;mInterface-&gt;open(callback, [&amp;status, &amp;session] (Status s, const sp&lt;device::V3_2::ICameraDeviceSession&gt;&amp; cameraSession) &#123; status = s; if (status == Status::OK) &#123; *session = cameraSession; &#125; &#125;); ...&#125; CameraProviderManager::openSession 打开设备时，会向 HAL 打开设备，将 ICameraDeviceCallback 传入 HAL 并获取 ICameraDeviceSession 实例。接着看 Camera3Device::initializeCommonLocked ： 1234567891011121314151617181920212223242526// Camera3Device.cppstatus_t Camera3Device::initializeCommonLocked() &#123; /** Start up status tracker thread */ mStatusTracker = new StatusTracker(this); status_t res = mStatusTracker-&gt;run( String8::format("C3Dev-%s-Status", mId.string()).string()); ... /** Register in-flight map to the status tracker */ mInFlightStatusId = mStatusTracker-&gt;addComponent(); /** Create buffer manager */ mBufferManager = new Camera3BufferManager(); mTagMonitor.initialize(mVendorTagId); /** Start up request queue thread */ mRequestThread = new RequestThread(this, mStatusTracker, mInterface); res = mRequestThread-&gt;run( String8::format("C3Dev-%s-ReqQueue", mId.string()).string()); ... mPreparerThread = new PreparerThread(); ... return OK;&#125; 在 initializeCommonLocked 中新建了很多实例： StatusTracker ：状态跟踪线程 Camera3BufferManager ：输出流的图形缓冲区管理，比如 Camera3OutputStream 的管理 TagMonitor ：相机元数据 metadata 的监视器，比如 3A 信息等 RequestThread ：请求线程，比如拍照、录像、预览的数据请求 PreparerThread ：监测数据已经准备好流的线程 小结以上流程图都是基于 API 2 + HAL 3，当 Camera Open 流程结束后： 客户端调用 API 时，得到了 CameraDevice 的实例，并将 ICameraDeviceUser 和 CameraDeviceImpl 绑定 根据 HAL 1/3 生成了对应的 Device 客户端，当前生成的是 CameraDeviceClient 实例 Camera3Device 在初始化时，调用 CameraProviderManager.openSession ，它会通过 HIDL 通知 HAL 层打开摄像头物理设备；打开成功会 Camera3Device::HalInterface 和 ICameraDeviceSession 实例绑定 新建 RequestThread 对象，后台运行线程，用于监听 API 发起的请求 CaptureRequest ：预览、拍照、录像等 新建 FrameProcessorBase 对象，后台运行线程，用于监听 HAL 返回的请求结果 CaptureResult 打开设备时，实际上 Framework, HAL 已经创建好会话 ICameraDeviceSession ；而下面分析的 API 创建会话流程，实际是根据不同需求（预览、拍照、录像）来创建和配置输出流。 创建会话流程API在打开设备后，获取到了 CameraDevice 的实例，通过它来创建会话 Session ： 12345// CameraDevice.javapublic abstract void createCaptureSession(@NonNull List&lt;Surface&gt; outputs, @NonNull CameraCaptureSession.StateCallback callback, @Nullable Handler handler) throws CameraAccessException; List&lt;Surface&gt; outputs表示有多少个输出流，通常为预览流和拍照/录像，两个输出流。 CameraCaptureSession.StateCallback callback创建会话状态回调。 Handler handler回调方法使用哪个线程响应，如果为 null 表示当前线程。 API 创建会话过程源码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// CameraDeviceImpl.java@Overridepublic void createCaptureSession(List&lt;Surface&gt; outputs, CameraCaptureSession.StateCallback callback, Handler handler) throws CameraAccessException &#123; // 将 Surface 转换为 OutputConfiguration List&lt;OutputConfiguration&gt; outConfigurations = new ArrayList&lt;&gt;(outputs.size()); for (Surface surface : outputs) &#123; outConfigurations.add(new OutputConfiguration(surface)); &#125; createCaptureSessionInternal(null, outConfigurations, callback, handler, ICameraDeviceUser.NORMAL_MODE);&#125;private void createCaptureSessionInternal(InputConfiguration inputConfig, List&lt;OutputConfiguration&gt; outputConfigurations, CameraCaptureSession.StateCallback callback, Handler handler, int operatingMode) throws CameraAccessException &#123; ... // 创建会话时，输入 Surface 为空 Surface input = null; try &#123; // configure streams and then block until IDLE // 向 Framework, HAL 发送信息，配置设备 configureSuccess = configureStreamsChecked(inputConfig, outputConfigurations, operatingMode); if (configureSuccess == true &amp;&amp; inputConfig != null) &#123; input = mRemoteDevice.getInputSurface(); &#125; &#125; catch (CameraAccessException e) &#123; ... &#125; ... CameraCaptureSessionCore newSession = null; // 根据模式来实例化对应的 Session if (isConstrainedHighSpeed) &#123; newSession = new CameraConstrainedHighSpeedCaptureSessionImpl( mNextSessionId++, callback, handler, this, mDeviceHandler, configureSuccess, mCharacteristics); &#125; else &#123; // 假设实例化 CameraCaptureSessionImpl newSession = new CameraCaptureSessionImpl(mNextSessionId++, input, callback, handler, this, mDeviceHandler, configureSuccess); &#125; mCurrentSession = newSession; ...&#125; 将 List&lt;Surface&gt; 转换为 List&lt;OutputConfiguration&gt; createCaptureSession 创建会话时，输入 Surface, InputConfiguration 都为空，即只有输出流 根据 isConstrainedHighSpeed 来创建 CameraCaptureSession 实例；如果支持高速模式，则创建 CameraConstrainedHighSpeedCaptureSessionImpl 实例；否则创建普通 CameraCaptureSessionImpl 实例 示例创建预览 mTextureSurface 和拍照 ImageReader.getSurface 两个输出流的会话，使用当前线程处理回调接口： 1234567891011121314151617181920mCameraDevice.createCaptureSession( Arrays.asList(mTextureSurface, mImageReader.getSurface()), new CameraCaptureSession.StateCallback() &#123; @Override public void onConfigured(@NonNull CameraCaptureSession session) &#123; Log.d(TAG, "onConfigured: "); mCameraCaptureSession = session; preview(); &#125; @Override public void onConfigureFailed( @NonNull CameraCaptureSession session) &#123; Log.e(TAG, "onConfigureFailed: "); &#125; &#125;, null);&#125; catch (CameraAccessException e) &#123; e.printStackTrace();&#125; CameraCaptureSession.StateCallback 回调CameraCaptureSession.StateCallback 回调用来处理 createCaptureSession 创建会话过程中出现的各种状态，比如创建成功、失败等，这些回调处理直接在 API Java 层实现的；回调接口中会获取到 CameraCaptureSession 实例。 1234567891011121314151617181920212223public static abstract class StateCallback &#123; public abstract void onConfigured( @NonNull CameraCaptureSession session); public abstract void onConfigureFailed( @NonNull CameraCaptureSession session); public void onReady(@NonNull CameraCaptureSession session) &#123; // default empty implementation &#125; public void onActive(@NonNull CameraCaptureSession session) &#123; // default empty implementation &#125; public void onCaptureQueueEmpty( @NonNull CameraCaptureSession session) &#123; // default empty implementation &#125; public void onClosed(@NonNull CameraCaptureSession session) &#123; // default empty implementation &#125; public void onSurfacePrepared(@NonNull CameraCaptureSession session, @NonNull Surface surface) &#123; // default empty implementation &#125;&#125; createCaptureSession 创建会话时，会创建 CameraCaptureSessionImpl 实例，而 CameraCaptureSession.StateCallback 接口的回调都是在 CameraCaptureSessionImpl 中实现的： 1234567891011121314151617181920212223242526272829303132333435363738394041// CameraCaptureSessionImpl.javapublic class CameraCaptureSessionImpl extends CameraCaptureSession implements CameraCaptureSessionCore &#123; CameraCaptureSessionImpl(int id, Surface input, CameraCaptureSession.StateCallback callback, Handler stateHandler, android.hardware.camera2.impl.CameraDeviceImpl deviceImpl, Handler deviceStateHandler, boolean configureSuccess) &#123; ... mStateCallback = createUserStateCallbackProxy(mStateHandler, callback); ... // 根据传入的参数，响应 CameraCaptureSession.StateCallback 回调 if (configureSuccess) &#123; mStateCallback.onConfigured(this); if (DEBUG) Log.v(...); mConfigureSuccess = true; &#125; else &#123; mStateCallback.onConfigureFailed(this); mClosed = true; Log.e(...); mConfigureSuccess = false; &#125; &#125; ... // 用户指定并传入的回调实现及对应线程 private final CameraCaptureSession.StateCallback mStateCallback; private final Handler mStateHandler; private StateCallback createUserStateCallbackProxy(Handler handler, StateCallback callback) &#123; InvokeDispatcher&lt;StateCallback&gt; userCallbackSink = new InvokeDispatcher&lt;&gt;(callback); HandlerDispatcher&lt;StateCallback&gt; handlerPassthrough = new HandlerDispatcher&lt;&gt;(userCallbackSink, handler); // 创建代理类 return new CallbackProxies.SessionStateCallbackProxy( handlerPassthrough); &#125;&#125; 用户指定的 StateCallback 传入后，在方法 createUserStateCallbackProxy 中，通过 CallbackProxies 重新生成一个代理 mStateCallback 对象，通过反射的方式，完成所有回调响应过程。 如果 configureStreamsChecked 创建 Stream 成功，则响应回调 mStateCallback.onConfigured 如果失败则响应 mStateCallback.onConfigureFailed ，其他场景会产生剩余的回调 动态代理类 CallbackProxies 源码注释（JDK 中的动态代理只支持接口 interface，对于抽象类只能自己实现了）： 12345678910/** * Proxy out invocations to the camera2 API callbacks into * a &#123;@link Dispatchable&#125;. * * &lt;p&gt;Since abstract classes do not support Java's dynamic &#123;@code Proxy&#125;, * we have to to use our own proxy mechanism.&lt;/p&gt; */public class CallbackProxies &#123;&#125; 流程图创建会话流程，查看原图 源码分析API 中创建捕获会话 createCaptureSession 时，CameraDeviceImpl.configureStreamsChecked 源码中可以看到；CameraDeviceImpl 是通过 ICameraDeviceUser 来向 Framework, HAL 层发送配置信息的： 123456789101112131415161718192021222324252627282930313233343536373839// CameraDeviceImpl.javapublic boolean configureStreamsChecked(InputConfiguration inputConfig, List&lt;OutputConfiguration&gt; outputs, int operatingMode) throws CameraAccessException &#123; ... // createCaptureSession 时，imputConfig 为空 checkInputConfiguration(inputConfig); boolean success = false; synchronized(mInterfaceLock) &#123; ... mDeviceHandler.post(mCallOnBusy); stopRepeating(); try &#123; waitUntilIdle(); mRemoteDevice.beginConfigure(); ... // Delete all streams first (to free up HW resources) for (Integer streamId : deleteList) &#123; mRemoteDevice.deleteStream(streamId); mConfiguredOutputs.delete(streamId); &#125; // Add all new streams for (OutputConfiguration outConfig : outputs) &#123; if (addSet.contains(outConfig)) &#123; int streamId = mRemoteDevice.createStream(outConfig); mConfiguredOutputs.put(streamId, outConfig); &#125; &#125; operatingMode = (operatingMode | (customOpMode &lt;&lt; 16)); mRemoteDevice.endConfigure(operatingMode); success = true; &#125; catch (...) &#125; return success;&#125; configureStreamsChecked 配置流有三个主要过程：beginConfigure, createStream, endConfigure ，都是通过 ICameraDeviceUser 向下发送信息。 native 代码中由 CameraDeviceClient.cpp 实现了 ICameraDeviceUser 中的所有功能，这里重点分析 createStream 函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// CameraDeviceClient.cppbinder::Status CameraDeviceClient::createStream( const hardware::camera2::params::OutputConfiguration &amp;outputConfiguration, /*out*/int32_t* newStreamId) &#123; ... // 获取 IGraphicBufferProducer 的个数 const std::vector&lt;sp&lt;IGraphicBufferProducer&gt;&gt;&amp; bufferProducers = outputConfiguration.getGraphicBufferProducers(); size_t numBufferProducers = bufferProducers.size(); ... std::vector&lt;sp&lt;Surface&gt;&gt; surfaces; std::vector&lt;sp&lt;IBinder&gt;&gt; binders; ... OutputStreamInfo streamInfo; bool isStreamInfoValid = false; for (auto&amp; bufferProducer : bufferProducers) &#123; ... // 创建 Native Surface sp&lt;Surface&gt; surface; res = createSurfaceFromGbp(streamInfo, isStreamInfoValid, surface, bufferProducer); if (!res.isOk()) return res; ... binders.push_back(IInterface::asBinder(bufferProducer)); surfaces.push_back(surface); &#125; int streamId = camera3::CAMERA3_STREAM_ID_INVALID; // 调用 Camera3Device 创建流 err = mDevice-&gt;createStream(surfaces, deferredConsumer, streamInfo.width, streamInfo.height, streamInfo.format, streamInfo.dataSpace, static_cast&lt;camera3_stream_rotation_t&gt;( outputConfiguration.getRotation()), &amp;streamId, outputConfiguration.getSurfaceSetID(), isShared); if (err != OK) &#123; ... &#125; else &#123; ... mStreamInfoMap[streamId] = streamInfo; ... // Set transform flags to ensure preview to be rotated correctly. res = setStreamTransformLocked(streamId); *newStreamId = streamId; &#125; return res;&#125; CameraDeviceClient.createStream 中，将 API 传入的 OutputConfiguration 数据，转换成 native Surface, OutputStreamInfo ；根据 OutputConfiguration 中 IGraphicBufferProducer 的个数创建对应的 native Surface ，并最终通过设备来创建流。 1234567891011121314151617181920212223242526272829303132333435363738binder::Status CameraDeviceClient::createSurfaceFromGbp( OutputStreamInfo&amp; streamInfo, bool isStreamInfoValid, sp&lt;Surface&gt;&amp; surface, const sp&lt;IGraphicBufferProducer&gt;&amp; gbp) &#123; ... // 根据 IGraphicBufferProducer 创建 Surface surface = new Surface(gbp, useAsync); ANativeWindow *anw = surface.get(); int width, height, format; android_dataspace dataSpace; // 查询对应的长、宽、格式、数据空间 if ((err = anw-&gt;query(anw, NATIVE_WINDOW_WIDTH, &amp;width)) != OK) &#123; ... &#125; if ((err = anw-&gt;query(anw, NATIVE_WINDOW_HEIGHT, &amp;height)) != OK) &#123; ... &#125; if ((err = anw-&gt;query(anw, NATIVE_WINDOW_FORMAT, &amp;format)) != OK) &#123; ... &#125; if ((err = anw-&gt;query(anw, NATIVE_WINDOW_DEFAULT_DATASPACE, reinterpret_cast&lt;int*&gt;(&amp;dataSpace))) != OK) &#123; ... &#125; ... // 赋值给输出流 if (!isStreamInfoValid) &#123; streamInfo.width = width; streamInfo.height = height; streamInfo.format = format; streamInfo.dataSpace = dataSpace; streamInfo.consumerUsage = consumerUsage; return binder::Status::ok(); &#125; ...&#125; 这里的 NATIVE_WINDOW_FORMAT 格式代表着不同流的类型，在 system\core\libsystem\include\system\graphics-base.h 文件中定义： 123456789101112131415161718192021222324252627typedef enum &#123; HAL_PIXEL_FORMAT_RGBA_8888 = 1, HAL_PIXEL_FORMAT_RGBX_8888 = 2, HAL_PIXEL_FORMAT_RGB_888 = 3, HAL_PIXEL_FORMAT_RGB_565 = 4, HAL_PIXEL_FORMAT_BGRA_8888 = 5, HAL_PIXEL_FORMAT_RGBA_1010102 = 43, // 0x2B HAL_PIXEL_FORMAT_RGBA_FP16 = 22, // 0x16 HAL_PIXEL_FORMAT_YV12 = 842094169, // 0x32315659 HAL_PIXEL_FORMAT_Y8 = 538982489, // 0x20203859 HAL_PIXEL_FORMAT_Y16 = 540422489, // 0x20363159 HAL_PIXEL_FORMAT_RAW16 = 32, // 0x20 HAL_PIXEL_FORMAT_RAW10 = 37, // 0x25 HAL_PIXEL_FORMAT_RAW12 = 38, // 0x26 HAL_PIXEL_FORMAT_RAW_OPAQUE = 36, // 0x24 HAL_PIXEL_FORMAT_BLOB = 33, // 0x21 HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED = 34, // 0x22 HAL_PIXEL_FORMAT_YCBCR_420_888 = 35, // 0x23 HAL_PIXEL_FORMAT_YCBCR_422_888 = 39, // 0x27 HAL_PIXEL_FORMAT_YCBCR_444_888 = 40, // 0x28 HAL_PIXEL_FORMAT_FLEX_RGB_888 = 41, // 0x29 HAL_PIXEL_FORMAT_FLEX_RGBA_8888 = 42, // 0x2A HAL_PIXEL_FORMAT_YCBCR_422_SP = 16, // 0x10 HAL_PIXEL_FORMAT_YCRCB_420_SP = 17, // 0x11 HAL_PIXEL_FORMAT_YCBCR_422_I = 20, // 0x14 HAL_PIXEL_FORMAT_JPEG = 256, // 0x100&#125; android_pixel_format_t; HAL_PIXEL_FORMAT_BLOB 拍照流值为 33 ，通常对应 mImageReader.getSurface() HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED 预览和录像流值为 34 ，通常对应预览 new Surface(mTextureView.getSurfaceTexture()) 和录像 mMediaRecorder.getSurface 。 CameraDeviceClient::createStream 最终会调用 Camera3Device::createStream ，它会根据 NATIVE_WINDOW_FORMAT 格式创建不同配置的流： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Camera3Device.cppstatus_t Camera3Device::createStream( const std::vector&lt;sp&lt;Surface&gt;&gt;&amp; consumers, bool hasDeferredConsumer, uint32_t width, uint32_t height, int format, android_dataspace dataSpace, camera3_stream_rotation_t rotation, int *id, int streamSetId, bool isShared, uint64_t consumerUsage) &#123; ... // 拍照流 if (format == HAL_PIXEL_FORMAT_BLOB) &#123; ssize_t blobBufferSize; if (dataSpace != HAL_DATASPACE_DEPTH) &#123; blobBufferSize = getJpegBufferSize(width, height); if (blobBufferSize &lt;= 0) &#123; SET_ERR_L(...); return BAD_VALUE; &#125; &#125; else &#123; blobBufferSize = getPointCloudBufferSize(); if (blobBufferSize &lt;= 0) &#123; SET_ERR_L(...); return BAD_VALUE; &#125; &#125; newStream = new Camera3OutputStream(mNextStreamId, consumers[0], width, height, blobBufferSize, format, dataSpace, rotation, mTimestampOffset, streamSetId); &#125; else if (format == HAL_PIXEL_FORMAT_RAW_OPAQUE) &#123; ssize_t rawOpaqueBufferSize = getRawOpaqueBufferSize(width, height); if (rawOpaqueBufferSize &lt;= 0) &#123; SET_ERR_L(...); return BAD_VALUE; &#125; newStream = new Camera3OutputStream(mNextStreamId, consumers[0], width, height, rawOpaqueBufferSize, format, dataSpace, rotation, mTimestampOffset, streamSetId); &#125; ... else &#123; newStream = new Camera3OutputStream(mNextStreamId, consumers[0], width, height, format, dataSpace, rotation, mTimestampOffset, streamSetId); &#125; newStream-&gt;setStatusTracker(mStatusTracker); newStream-&gt;setBufferManager(mBufferManager); res = mOutputStreams.add(mNextStreamId, newStream); if (res &lt; 0) &#123; SET_ERR_L(...); return res; &#125; *id = mNextStreamId++; mNeedConfig = true; ... ALOGV("Camera %s: Created new stream", mId.string()); return OK;&#125; 注意：每配置一个输出 Surface ，都会创建对应的输出流 Camera3OutputStream ，这是一个 for 循环过程。在 API 调用过程中，CameraDeviceImpl.configureStreamsChecked 的第三步为 endConfigure，而 CameraDeviceClient::endConfigure 代码流程如下： 1234567// CameraDeviceClient.cppbinder::Status CameraDeviceClient::endConfigure(int operatingMode) &#123; ... status_t err = mDevice-&gt;configureStreams(operatingMode); ... return res;&#125; 它的主要作用就是通过 Camera3Device 来配置流，configureStreamsLocked 配置流主要有三个过程：startConfiguration, configureStreams, endConfigure ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Camera3Device.cppstatus_t Camera3Device::configureStreams(int operatingMode) &#123; ... return configureStreamsLocked(operatingMode);&#125;status_t Camera3Device::configureStreamsLocked(int operatingMode) &#123; ... camera3_stream_configuration config; config.operation_mode = mOperatingMode; config.num_streams = (mInputStream != NULL) + mOutputStreams.size(); Vector&lt;camera3_stream_t*&gt; streams; streams.setCapacity(config.num_streams); if (mInputStream != NULL) &#123; camera3_stream_t *inputStream; inputStream = mInputStream-&gt;startConfiguration(); if (inputStream == NULL) &#123; CLOGE("Can't start input stream configuration"); cancelStreamsConfigurationLocked(); return INVALID_OPERATION; &#125; streams.add(inputStream); &#125; for (size_t i = 0; i &lt; mOutputStreams.size(); i++) &#123; if (mOutputStreams[i].get() == static_cast&lt;Camera3StreamInterface*&gt;(mInputStream.get())) &#123; config.num_streams--; continue; &#125; camera3_stream_t *outputStream; outputStream = mOutputStreams.editValueAt(i)-&gt;startConfiguration(); if (outputStream == NULL) &#123; CLOGE("Can't start output stream configuration"); cancelStreamsConfigurationLocked(); return INVALID_OPERATION; &#125; streams.add(outputStream); &#125; config.streams = streams.editArray(); // Do the HAL configuration; will potentially touch stream // max_buffers, usage, priv fields. // 向 HAL 层发送配置信息 res = mInterface-&gt;configureStreams(&amp;config); ... if (mInputStream != NULL &amp;&amp; mInputStream-&gt;isConfiguring()) &#123; res = mInputStream-&gt;finishConfiguration(); if (res != OK) &#123; CLOGE("Can't finish configuring input stream %d: %s (%d)", mInputStream-&gt;getId(), strerror(-res), res); cancelStreamsConfigurationLocked(); return BAD_VALUE; &#125; &#125; for (size_t i = 0; i &lt; mOutputStreams.size(); i++) &#123; sp&lt;Camera3OutputStreamInterface&gt; outputStream = mOutputStreams.editValueAt(i); if (outputStream-&gt;isConfiguring() &amp;&amp; !outputStream-&gt;isConsumerConfigurationDeferred()) &#123; res = outputStream-&gt;finishConfiguration(); if (res != OK) &#123; CLOGE(...); cancelStreamsConfigurationLocked(); return BAD_VALUE; &#125; &#125; &#125; ...&#125; 最终通过 Camera3Device::HalInterface::configureStreams 向 HAL 层发起配置信息： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// Camera3Device.cppstatus_t Camera3Device::HalInterface::configureStreams( camera3_stream_configuration *config) &#123; ... // Invoke configureStreams device::V3_3::HalStreamConfiguration finalConfiguration; common::V1_0::Status status; // See if we have v3.3 HAL sp&lt;device::V3_3::ICameraDeviceSession&gt; hidlSession_3_3; auto castResult = device::V3_3::ICameraDeviceSession::castFrom(mHidlSession); if (castResult.isOk()) &#123; hidlSession_3_3 = castResult; &#125; else &#123; ALOGE(...); &#125; if (hidlSession_3_3 != nullptr) &#123; // We do; use v3.3 for the call ALOGV("%s: v3.3 device found", __FUNCTION__); auto err = hidlSession_3_3-&gt;configureStreams_3_3( requestedConfiguration, [&amp;status, &amp;finalConfiguration] (common::V1_0::Status s, const device::V3_3::HalStreamConfiguration&amp; halConfiguration) &#123; finalConfiguration = halConfiguration; status = s; &#125;); if (!err.isOk()) &#123; ALOGE(...); return DEAD_OBJECT; &#125; &#125; else &#123; // We don't; use v3.2 call and // construct a v3.3 HalStreamConfiguration ALOGV("%s: v3.2 device found", __FUNCTION__); HalStreamConfiguration finalConfiguration_3_2; auto err = mHidlSession-&gt;configureStreams(requestedConfiguration, [&amp;status, &amp;finalConfiguration_3_2] (common::V1_0::Status s, const HalStreamConfiguration&amp; halConfiguration) &#123; finalConfiguration_3_2 = halConfiguration; status = s; &#125;); if (!err.isOk()) &#123; ALOGE(...); return DEAD_OBJECT; &#125; finalConfiguration.streams.resize( finalConfiguration_3_2.streams.size()); for (size_t i = 0; i&lt;finalConfiguration_3_2.streams.size(); i++)&#123; finalConfiguration.streams[i].v3_2 = finalConfiguration_3_2.streams[i]; finalConfiguration.streams[i].overrideDataSpace = requestedConfiguration.streams[i].dataSpace; &#125; &#125; ...&#125; 这里需要注意的是 HAL 3.3, 3.2 的配置是有区别的；执行完配置后，Camera3Stream::finishConfiguration 结束配置： 123456789101112131415161718192021222324252627282930313233343536// Camera3Stream.cppstatus_t Camera3Stream::finishConfiguration() &#123; .... res = configureQueueLocked(); ...&#125;// Camera3OutputStream.cppstatus_t Camera3OutputStream::configureConsumerQueueLocked() &#123; ... // Configure consumer-side ANativeWindow interface. // to notify buffer manager (if it is used) of the returned buffers. res = mConsumer-&gt;connect(NATIVE_WINDOW_API_CAMERA, /*listener*/mBufferReleasedListener, /*reportBufferRemoval*/true); if (res != OK) &#123; ALOGE(...); return res; &#125; mConsumerName = mConsumer-&gt;getConsumerName(); res = native_window_set_usage(mConsumer.get(), mUsage); if (res != OK) &#123; ALOGE(...); return res; &#125; res = native_window_set_scaling_mode(mConsumer.get(), NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW); if (res != OK) &#123; ALOGE(...); return res; &#125; ...&#125; 这里 mConsumer 是 native Surface，也就是将生产者-消费者模型连接起来；同时 configureConsumerQueueLocked 有非常多的 native window 配置。 小结创建会话 createCaptureSession 过程中，小结如下： API 调用时，最终通过 CameraCaptureSession.StateCallback 获取到 CameraCaptureSessionImpl 实例 ICameraDeviceUser.createStream 由输入的 Surface 信息，根据不同的 format 创建对应输出流 Camera3OutputStream ICameraDeviceUser.endConfigure 最终通过 CameraDeviceSession.configureStream_3_3 会向 HAL 层发送配置信息 相机预览过程中，如果 session 创建成功，会出现正常的预览界面；如果 session 创建失败，则预览会出现黑屏。 预览/拍照/录像流程API创建会话 createCaptureSession 成功后，通过拿到的 CameraCaptureSession 来预览、拍照、录像： 12345678910// CameraCaptureSession.java// 预览和录像使用同一个 APIpublic abstract int setRepeatingRequest(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException;// 拍照public abstract int capture(@NonNull CaptureRequest request, @Nullable CaptureCallback listener, @Nullable Handler handler) throws CameraAccessException; CaptureRequest request捕获请求，比如创建一个预览模板的请求 CameraDevice.TEMPLATE_PREVIEW ；拍照模板的请求 CameraDevice.TEMPLATE_STILL_CAPTURE ；录像模板的请求 CameraDevice.TEMPLATE_RECORD 。 CameraCaptureSession.CaptureCallback listener捕获状态的回调接口。 Handler handler回调接口使用哪个线程响应，如果是 null 表示当前线程。 CameraDevice 请求模板是一组常量： 1234567// CameraDevice.javapublic static final int TEMPLATE_PREVIEW = 1;public static final int TEMPLATE_STILL_CAPTURE = 2;public static final int TEMPLATE_RECORD = 3;public static final int TEMPLATE_VIDEO_SNAPSHOT = 4;public static final int TEMPLATE_ZERO_SHUTTER_LAG = 5;public static final int TEMPLATE_MANUAL = 6; 各模板对应的含义： TEMPLATE_PREVIEW创建适合相机预览的窗口，高帧率优于高质量的后期处理。 TEMPLATE_STILL_CAPTURE创建适合拍照的请求，优先考虑帧速率的图像质量。 TEMPLATE_RECORD创建适合录像的请求，使用稳定的帧率。 TEMPLATE_VIDEO_SNAPSHOT创建录像时快照的请求，在不中断录像的前提下最大化图像质量。 TEMPLATE_ZERO_SHUTTER_LAG创建 ZSL 零延时拍照请求，也就是连拍功能，在不影响帧率的前提下最大化图像质量，并开启 3A 算法。 TEMPLATE_MANUAL手动控制模板，禁用所有的自动控制 3A 算法。 示例给 mTextureSurface 创建预览请求 TEMPLATE_PREVIEW ，使用后台线程处理回调接口： 123456789101112131415CaptureRequest.Builder previewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);previewRequestBuilder.addTarget(mTextureSurface);CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureCompleted( @NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; //Log.d(TAG, "preview, onCaptureCompleted: "); &#125;&#125;;mCameraCaptureSession.setRepeatingRequest( previewRequestBuilder.build(), captureCallback, mBackHandler); 给 ImageReader 创建拍照请求 TEMPLATE_STILL_CAPTURE ，使用后台线程处理回调： 123456789101112131415161718192021CaptureRequest.Builder captureRequestBuild = mCameraDevice .createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);captureRequestBuild.addTarget(mImageReader.getSurface());captureRequestBuild.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);captureRequestBuild.set(CaptureRequest.JPEG_ORIENTATION, mImageOrientation);CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureCompleted( @NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; // Log.d(TAG, "takePicture, onCaptureCompleted: "); &#125;&#125;;mCameraCaptureSession.stopRepeating();mCameraCaptureSession.abortCaptures();mCameraCaptureSession.capture(captureRequestBuild.build(), captureCallback, mBackHandler); 给 MediaRecorder 创建录像请求 TEMPLATE_RECORD ，不处理回调： 1234567CaptureRequest.Builder recordCaptureBuild = mCameraDevice .createCaptureRequest(CameraDevice.TEMPLATE_RECORD);recordCaptureBuild.addTarget(mMediaRecorder.getSurface());recordCaptureBuild.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);mCameraCaptureSession.setRepeatingRequest( recordCaptureBuild.build(), null, null); CameraCaptureSession.CaptureCallback 回调CameraCaptureSession 在请求预览、拍照、录像等功能时，出现的各种状态通过 CameraCaptureSession.CaptureCallback 回调来处理，回调是由 HAL 层发起向上传递的；回调接口中通常包含当前会话信息 CameraCaptureSession ，捕获请求 CaptureRequest ，捕获的结果 CaptureResult 等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// CameraCaptureSession.javapublic static abstract class CaptureCallback &#123; public static final int NO_FRAMES_CAPTURED = -1; // 设备开始拍照时 public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber) &#123; // default empty implementation &#125; // 返回部分数据 public void onCapturePartial(CameraCaptureSession session, CaptureRequest request, CaptureResult result) &#123; // default empty implementation &#125; // 返回部分数据时，表示正在捕获数据过程中 public void onCaptureProgressed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureResult partialResult) &#123; // default empty implementation &#125; // 数据捕获已经完成，回调最终总的结果集 public void onCaptureCompleted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; // default empty implementation &#125; // 捕获失败 public void onCaptureFailed(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull CaptureFailure failure) &#123; // default empty implementation &#125; // 所有捕获结果已经发送完毕 public void onCaptureSequenceCompleted( @NonNull CameraCaptureSession session, int sequenceId, long frameNumber) &#123; // default empty implementation &#125; // 请求捕获被中止 public void onCaptureSequenceAborted( @NonNull CameraCaptureSession session, int sequenceId) &#123; // default empty implementation &#125; // 捕获的 buffer 不能成功显示 public void onCaptureBufferLost(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull Surface target, long frameNumber) &#123; // default empty implementation &#125;&#125; API 在发起请求 CameraCaptureSession.setRepeatingRequest/capture 时，用户会创建 CaptureCallback 的实例，这些接口都在 CameraDeviceImpl 中实现回调。 onCaptureStarted该回调接口从 HAL 回调路径为：CameraDeviceClient::notifyShutter -&gt; CameraDeviceImpl.onCaptureStarted -&gt; onCaptureStarted 。 onCapturePartial该回调接口搜索整个 framework ，发现没有任何地方会回调它。 onCaptureProgressed, onCaptureCompleted, onCaptureSequenceCompleted三个接口都是在 CameraDeviceImpl.onResultReceived 中回调的。 onCaptureSequenceAbortedCameraDeviceClient.cpp 中的 submitCaptureRequest, stopRepeating, flush 这三个函数会回调该接口。 onCaptureFailed, onCaptureBufferLost从 HAL 回调路径为 CameraDeviceClient::notifyError -&gt; CameraDeviceImpl.onDeviceError ，而这两个接口在 CameraDeviceImpl 中的回调路径为 onDeviceError -&gt; onCaptureErrorLocked -&gt; onCaptureFailed/onCaptureBufferLost 。 流程图创建捕获请求流程，查看原图 预览/拍照/录像流程基本一致，这里仅给出预览的流程图：预览流程，查看原图 源码分析在分析预览、拍照、录像流程前，先回顾下打开设备 openCamera 时，做的一些初始化： 1234567891011121314151617181920212223242526// CameraDeviceClient.cppstatus_t CameraDeviceClient::initialize(sp&lt;CameraProviderManager&gt; manager) &#123; return initializeImpl(manager);&#125;template&lt;typename TProviderPtr&gt;status_t CameraDeviceClient::initializeImpl(TProviderPtr providerPtr) &#123; ... res = Camera2ClientBase::initialize(providerPtr); if (res != OK) &#123; return res; &#125; String8 threadName; mFrameProcessor = new FrameProcessorBase(mDevice); threadName = String8::format("CDU-%s-FrameProc", mCameraIdStr.string()); mFrameProcessor-&gt;run(threadName.string()); mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID, FRAME_PROCESSOR_LISTENER_MAX_ID, /*listener*/this, /*sendPartials*/true); return OK;&#125; 在 CameraDeviceClient::initializeImpl 中，调用了 Camera2ClientBase::initialize 的初始化，以及实例化一个 FrameProcessorBase 对象； 123456789101112131415// Camera2ClientBase.cpptemplate &lt;typename TClientBase&gt;status_t Camera2ClientBase&lt;TClientBase&gt;::initialize( sp&lt;CameraProviderManager&gt; manager) &#123; return initializeImpl(manager);&#125;template &lt;typename TClientBase&gt;template &lt;typename TProviderPtr&gt;status_t Camera2ClientBase&lt;TClientBase&gt;::initializeImpl( TProviderPtr providerPtr) &#123; ... res = mDevice-&gt;initialize(providerPtr); ...&#125; 这里 Camera2ClientBase::initializeImpl 中主要是调用了 Camera3Device::initialize 函数，下面只关心和捕获请求有关的代码： 123456789101112131415// Camera3Device.cppstatus_t Camera3Device::initialize(sp&lt;CameraProviderManager&gt; manager) &#123; ... return initializeCommonLocked();&#125;status_t Camera3Device::initializeCommonLocked() &#123; ... /** Start up request queue thread */ mRequestThread = new RequestThread(this, mStatusTracker, mInterface); res = mRequestThread-&gt;run( String8::format("C3Dev-%s-ReqQueue", mId.string()).string()); ... return OK;&#125; 在 Camera3Device::initializeCommonLocked 中实例化了 RequestThread 对象。至此，捕获流程中的发起请求的对象 RequestThread 和响应回调的对象 FrameProcessorBase 都实例化完毕，并开始运行。他们两个都继承的是线程，参看 system 目录下的 Thread.h/Threads.cpp 源码，可以看到 threadLoop 是在一个 while 中被循环调用的。当 threadLoop 返回 true 时就会不停的循环；返回 false 时会退出循环： 123456789101112131415161718192021222324252627282930// Threads.cppint Thread::_threadLoop(void* user)&#123; Thread* const self = static_cast&lt;Thread*&gt;(user); ... bool first = true; do &#123; bool result; if (first) &#123; first = false; self-&gt;mStatus = self-&gt;readyToRun(); result = (self-&gt;mStatus == NO_ERROR); if (result &amp;&amp; !self-&gt;exitPending()) &#123; result = self-&gt;threadLoop(); &#125; &#125; else &#123; result = self-&gt;threadLoop(); &#125; ... if (result == false || self-&gt;mExitPending) &#123; ... break; &#125; ... &#125; while(strong != 0); return 0;&#125; 先来看发送捕获请求的线程 RequestThread ： 12345678910111213141516171819202122// Camera3Device.hclass RequestThread : public Thread &#123; ... protected: ... virtual bool threadLoop(); private: ... // Used to prepare a batch of requests. struct NextRequest &#123; sp&lt;CaptureRequest&gt; captureRequest; camera3_capture_request_t halRequest; Vector&lt;camera3_stream_buffer_t&gt; outputBuffers; bool submitted; &#125;; Vector&lt;NextRequest&gt; mNextRequests; ... Condition mRequestSignal; RequestList mRequestQueue; RequestList mRepeatingRequests; ...&#125; 这里只关注 RequestThread 类中几个关键函数和变量，NextRequest 结构体包含了请求信息，逐个向 HAL 发送这些信息；类中定义了多个条件变量，重点关注 mRequestSignal 条件变量， threadLoop 运行时，会通过 mRequestSignal.waitRelative 阻塞等待 50 ms；直到等到捕获请求后 mRequestSignal.signal 发出通知，threadLoop 继续运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Camera3Device.cppbool Camera3Device::RequestThread::threadLoop() &#123; ... status_t res; // Handle paused state. if (waitIfPaused()) &#123; return true; &#125; // Wait for the next batch of requests. waitForNextRequestBatch(); if (mNextRequests.size() == 0) &#123; return true; &#125; ... // Prepare a batch of HAL requests and output buffers. res = prepareHalRequests(); ...&#125;void Camera3Device::RequestThread::waitForNextRequestBatch() &#123; ... NextRequest nextRequest; nextRequest.captureRequest = waitForNextRequestLocked(); if (nextRequest.captureRequest == nullptr) &#123; return; &#125; ...&#125;sp&lt;Camera3Device::CaptureRequest&gt; Camera3Device::RequestThread::waitForNextRequestLocked() &#123; status_t res; sp&lt;CaptureRequest&gt; nextRequest; while (mRequestQueue.empty()) &#123; if (!mRepeatingRequests.empty()) &#123; const RequestList &amp;requests = mRepeatingRequests; RequestList::const_iterator firstRequest = requests.begin(); nextRequest = *firstRequest; mRequestQueue.insert(mRequestQueue.end(), ++firstRequest, requests.end()); mRepeatingLastFrameNumber = mFrameNumber+requests.size()-1; break; &#125; // 条件变量 mRequestSignal 阻塞等待 kRequestTimeout res = mRequestSignal.waitRelative(mRequestLock, kRequestTimeout); ... &#125;&#125; RequestThread 在没有捕获请求时，会循环调用 threadLoop ，并阻塞等待 mRequestSignal 的通知。再看响应回调的线程 FrameProcessorBase ： 123456789101112131415161718192021222324252627282930313233// FrameProcessorBase.hclass FrameProcessorBase: public Thread &#123; public: ... struct FilteredListener: virtual public RefBase &#123; virtual void onResultAvailable(const CaptureResult &amp;result) = 0; &#125;; protected: static const nsecs_t kWaitDuration = 10000000; // 10 ms wp&lt;CameraDeviceBase&gt; mDevice; virtual bool threadLoop(); ...&#125;// FrameProcessorBase.cppbool FrameProcessorBase::threadLoop() &#123; status_t res; sp&lt;CameraDeviceBase&gt; device; &#123; device = mDevice.promote(); if (device == 0) return false; &#125; res = device-&gt;waitForNextFrame(kWaitDuration); if (res == OK) &#123; processNewFrames(device); &#125; else if (res != TIMED_OUT) &#123; ALOGE(...); &#125; return true;&#125; FrameProcessorBase::threadLoop 代码非常简单，device-&gt;waitForNextFrame 阻塞等待 10ms ，这里 CameraDeviceBase 实际类型为 Camera3Device ： 1234567891011121314151617181920212223242526// Camera3Device.hclass Camera3Device : public CameraDeviceBase, virtual public hardware::camera::device::V3_2::ICameraDeviceCallback, private camera3_callback_ops &#123; ... private: List&lt;CaptureResult&gt; mResultQueue; Condition mResultSignal; ...&#125;// Camera3Device.cppstatus_t Camera3Device::waitForNextFrame(nsecs_t timeout) &#123; ... while (mResultQueue.empty()) &#123; res = mResultSignal.waitRelative(mOutputLock, timeout); if (res == TIMED_OUT) &#123; return res; &#125; else if (res != OK) &#123; ALOGW(...); return res; &#125; &#125; return OK;&#125; Camera3Device::waitForNextFrame 代码也很简单，调用条件变量 mResultSignal.waitRelative 实现阻塞等待 10 ms。至此初始化过程中，捕获请求线程 RequestThread 循环执行 threadLoop ，并会阻塞等待 mRequestSignal 的通知；回调响应线程 FrameProcessorBase 循环执行 threadLoop ，并会阻塞等待 mResultSignal 的通知。 当用户调用 API 创建捕获请求时，mRequestSignal 会发出通知；因为预览、拍照、录像流程基本一样，一起分析： 1234567891011121314151617181920212223242526272829// CameraCaptureSessionImpl.java// 预览和录像@Overridepublic int setRepeatingRequest(CaptureRequest request, CaptureCallback callback, Handler handler) throws CameraAccessException &#123; ... synchronized (mDeviceImpl.mInterfaceLock) &#123; ... return addPendingSequence(mDeviceImpl.setRepeatingRequest( request, createCaptureCallbackProxy(handler, callback), mDeviceHandler)); &#125;&#125;// 拍照@Overridepublic int capture(CaptureRequest request, CaptureCallback callback, Handler handler) throws CameraAccessException &#123; ... synchronized (mDeviceImpl.mInterfaceLock) &#123; ... return addPendingSequence(mDeviceImpl.capture(request, createCaptureCallbackProxy(handler, callback), mDeviceHandler)); &#125;&#125; createCaptureCallbackProxy 创建了一个回调动态代理，通过 CameraDeviceImpl.setRepeatingRequest/capture 下发预览或者拍照的捕获请求： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// CameraDeviceImpl.java// 预览和录像public int setRepeatingRequest(CaptureRequest request, CaptureCallback callback, Handler handler) throws CameraAccessException &#123; List&lt;CaptureRequest&gt; requestList = new ArrayList&lt;CaptureRequest&gt;(); requestList.add(request); return submitCaptureRequest(requestList, callback, handler, /*streaming*/true);&#125;// 拍照public int capture(CaptureRequest request, CaptureCallback callback, Handler handler) throws CameraAccessException &#123; List&lt;CaptureRequest&gt; requestList = new ArrayList&lt;CaptureRequest&gt;(); requestList.add(request); return submitCaptureRequest(requestList, callback, handler, /*streaming*/false);&#125;private int submitCaptureRequest(List&lt;CaptureRequest&gt; requestList, CaptureCallback callback, Handler handler, boolean repeating) throws CameraAccessException &#123; ... synchronized(mInterfaceLock) &#123; checkIfCameraClosedOrInError(); if (repeating) &#123; stopRepeating(); &#125; SubmitInfo requestInfo; CaptureRequest[] requestArray = requestList.toArray( new CaptureRequest[requestList.size()]); requestInfo = mRemoteDevice.submitRequestList(requestArray, repeating); ... if (callback != null) &#123; mCaptureCallbackMap.put(requestInfo.getRequestId(), new CaptureCallbackHolder( callback, requestList, handler, repeating, mNextSessionId - 1)); &#125; else &#123; ... &#125; if (repeating) &#123; if (mRepeatingRequestId != REQUEST_ID_NONE) &#123; checkEarlyTriggerSequenceComplete(mRepeatingRequestId, requestInfo.getLastFrameNumber()); &#125; mRepeatingRequestId = requestInfo.getRequestId(); &#125; else &#123; mRequestLastFrameNumbersList.add( new RequestLastFrameNumbersHolder(requestList, requestInfo)); &#125; ... &#125;&#125; 从代码流程来看，预览和录像使用同一个接口；预览和拍照的主要区别是 repeating 的值；当为 true 时，表示预览/录像；当为 false 时，表示为拍照。通过 ICameraDeviceUser.submitRequestList 向下发送请求： 123456789101112131415161718// CameraDeviceClient.cppbinder::Status CameraDeviceClient::submitRequestList( const std::vector&lt;hardware::camera2::CaptureRequest&gt;&amp; requests, bool streaming, /*out*/ hardware::camera2::utils::SubmitInfo *submitInfo) &#123; ... if (streaming) &#123; err = mDevice-&gt;setStreamingRequestList(metadataRequestList, surfaceMapList, &amp;(submitInfo-&gt;mLastFrameNumber)); ... &#125; else &#123; err = mDevice-&gt;captureList(metadataRequestList, surfaceMapList, &amp;(submitInfo-&gt;mLastFrameNumber)); ... &#125; return res;&#125; 如果是预览/录像，则调用 Camera3Device-&gt;setStreamingRequestList ；如果是拍照，则调用 Camera3Device-&gt;captureList ： 12345678910111213141516171819202122232425262728293031323334353637383940//Camera3Device.cpp// 预览和录像status_t Camera3Device::setStreamingRequestList( const List&lt;const CameraMetadata&gt; &amp;requests, const std::list&lt;const SurfaceMap&gt; &amp;surfaceMaps, int64_t *lastFrameNumber) &#123; ... return submitRequestsHelper(requests, surfaceMaps, /*repeating*/true, lastFrameNumber);&#125;// 拍照status_t Camera3Device::captureList( const List&lt;const CameraMetadata&gt; &amp;requests, const std::list&lt;const SurfaceMap&gt; &amp;surfaceMaps, int64_t *lastFrameNumber) &#123; ... return submitRequestsHelper(requests, surfaceMaps, /*repeating*/false, lastFrameNumber);&#125;status_t Camera3Device::submitRequestsHelper( const List&lt;const CameraMetadata&gt; &amp;requests, const std::list&lt;const SurfaceMap&gt; &amp;surfaceMaps, bool repeating, /*out*/ int64_t *lastFrameNumber) &#123; ... RequestList requestList; res = convertMetadataListToRequestListLocked(requests, surfaceMaps, repeating, /*out*/&amp;requestList); ... if (repeating) &#123; res = mRequestThread-&gt;setRepeatingRequests(requestList, lastFrameNumber); &#125; else &#123; res = mRequestThread-&gt;queueRequestList(requestList, lastFrameNumber); &#125; ... return res;&#125; 同样，预览/录像和拍照请求在 Camera3Device 中的区别也主要是 repeating 的值，都会调用 Camera3Device::submitRequestsHelper ，并通过 RequestThread 发起捕获请求；当预览/录像时，调用 setRepeatingRequests ；当拍照时，调用 queueRequestList ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// Camera3Device.cpp// 预览和录像status_t Camera3Device::RequestThread::setRepeatingRequests( const RequestList &amp;requests, /*out*/ int64_t *lastFrameNumber) &#123; ... if (lastFrameNumber != NULL) &#123; *lastFrameNumber = mRepeatingLastFrameNumber; &#125; mRepeatingRequests.clear(); mRepeatingRequests.insert(mRepeatingRequests.begin(), requests.begin(), requests.end()); unpauseForNewRequests(); mRepeatingLastFrameNumber = ...ICameraDeviceUser::NO_IN_FLIGHT_REPEATING_FRAMES; return OK;&#125;// 拍照status_t Camera3Device::RequestThread::queueRequestList( List&lt;sp&lt;CaptureRequest&gt; &gt; &amp;requests, /*out*/ int64_t *lastFrameNumber) &#123; ... for (List&lt;sp&lt;CaptureRequest&gt; &gt;::iterator it = requests.begin(); it != requests.end(); ++it) &#123; mRequestQueue.push_back(*it); &#125; if (lastFrameNumber != NULL) &#123; *lastFrameNumber = mFrameNumber + mRequestQueue.size() - 1; ALOGV(...); &#125; unpauseForNewRequests(); return OK;&#125;void Camera3Device::RequestThread::unpauseForNewRequests() &#123; ... mRequestSignal.signal(); ...&#125; 预览/录像时会将捕获请求存入 mRepeatingRequests 列表中；拍照时会将捕获请求存入 mRequestQueue 列表中；它们最终都会调用 unpauseForNewRequests ，而该函数的核心功能就是通过 mRequestSignal.signal 发出消息，通知在开启设备初始化过程中 waitForNextRequestLocked 的阻塞等待。我们重新进入 RequestThread::threadLoop 中，继续向下分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Camera3Device.cppbool Camera3Device::RequestThread::threadLoop() &#123; ... status_t res; ... // Wait for the next batch of requests. // 阻塞等待 waitForNextRequestBatch(); if (mNextRequests.size() == 0) &#123; return true; &#125; ... bool submitRequestSuccess = false; nsecs_t tRequestStart = systemTime(SYSTEM_TIME_MONOTONIC); if (mInterface-&gt;supportBatchRequest()) &#123; submitRequestSuccess = sendRequestsBatch(); &#125; else &#123; submitRequestSuccess = sendRequestsOneByOne(); &#125; ... return submitRequestSuccess;&#125;bool Camera3Device::RequestThread::sendRequestsBatch() &#123; status_t res; size_t batchSize = mNextRequests.size(); std::vector&lt;camera3_capture_request_t*&gt; requests(batchSize); uint32_t numRequestProcessed = 0; for (size_t i = 0; i &lt; batchSize; i++) &#123; requests[i] = &amp;mNextRequests.editItemAt(i).halRequest; &#125; ... res = mInterface-&gt;processBatchCaptureRequests(requests, &amp;numRequestProcessed); ...&#125;status_t Camera3Device::HalInterface::processBatchCaptureRequests( std::vector&lt;camera3_capture_request_t*&gt;&amp; requests, /*out*/uint32_t* numRequestProcessed) &#123; ... hardware::hidl_vec&lt;device::V3_2::CaptureRequest&gt; captureRequests; size_t batchSize = requests.size(); captureRequests.resize(batchSize); ... auto err = mHidlSession-&gt;processCaptureRequest(captureRequests, cachesToRemove, [&amp;status, &amp;numRequestProcessed] (auto s, uint32_t n) &#123; status = s; *numRequestProcessed = n; &#125;); ... return CameraProviderManager::mapToStatusT(status);&#125; 当 waitForNextRequestBatch 拿到请求通知后，会将捕获请求存入 mNextRequests 中，当前平台支持批量请求处理，sendRequestsBatch -&gt; processBatchCaptureRequests 流程，向 HAL 层发送捕获请求 mHidlSession-&gt;processCaptureRequest ，至此捕获请求从 API 发送到 HAL 整个流程全部分析完毕。 当 HAL 拿到捕获的结果后，会从 ICameraDeviceSession.processCaptureResult 回调到 Framework 层： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// Camera3Device.cpphardware::Return&lt;void&gt; Camera3Device::processCaptureResult( const hardware::hidl_vec&lt; hardware::camera::device::V3_2::CaptureResult&gt;&amp; results) &#123; ... for (const auto&amp; result : results) &#123; processOneCaptureResultLocked(result); &#125; mProcessCaptureResultLock.unlock(); return hardware::Void();&#125;void Camera3Device::processOneCaptureResultLocked( const hardware::camera::device::V3_2::CaptureResult&amp; result) &#123; camera3_capture_result r; ... processCaptureResult(&amp;r);&#125;void Camera3Device::processCaptureResult( const camera3_capture_result *result) &#123; ... if (result-&gt;partial_result != 0) request.resultExtras.partialResultCount = result-&gt;partial_result; // Check if this result carries only partial metadata if (mUsePartialResult &amp;&amp; result-&gt;result != NULL) &#123; ... if (isPartialResult &amp;&amp; request.hasCallback) &#123; // Send partial capture result sendPartialCaptureResult(result-&gt;result, request.resultExtras, frameNumber); &#125; &#125; ... if (result-&gt;result != NULL &amp;&amp; !isPartialResult) &#123; if (shutterTimestamp == 0) &#123; request.pendingMetadata = result-&gt;result; request.collectedPartialResult = collectedPartialResult; &#125; else if (request.hasCallback) &#123; CameraMetadata metadata; metadata = result-&gt;result; sendCaptureResult(metadata, request.resultExtras, collectedPartialResult, frameNumber, hasInputBufferInRequest); &#125; &#125; ...&#125;void Camera3Device::sendPartialCaptureResult( const camera_metadata_t * partialResult, const CaptureResultExtras &amp;resultExtras, uint32_t frameNumber) &#123; ... CaptureResult captureResult; captureResult.mResultExtras = resultExtras; captureResult.mMetadata = partialResult; insertResultLocked(&amp;captureResult, frameNumber);&#125;void Camera3Device::sendCaptureResult(CameraMetadata &amp;pendingMetadata, CaptureResultExtras &amp;resultExtras, CameraMetadata &amp;collectedPartialResult, uint32_t frameNumber, bool reprocess) &#123; ... CaptureResult captureResult; captureResult.mResultExtras = resultExtras; captureResult.mMetadata = pendingMetadata; ... insertResultLocked(&amp;captureResult, frameNumber);&#125;void Camera3Device::insertResultLocked(CaptureResult *result, uint32_t frameNumber) &#123; ... camera_metadata_t *meta = const_cast&lt;camera_metadata_t *&gt;( result-&gt;mMetadata.getAndLock()); set_camera_metadata_vendor_id(meta, mVendorTagId); result-&gt;mMetadata.unlock(meta); ... // Valid result, insert into queue List&lt;CaptureResult&gt;::iterator queuedResult = mResultQueue.insert(mResultQueue.end(), CaptureResult(*result)); ... mResultSignal.signal();&#125; 从代码流程来看，从 HAL 传过来的捕获结果，不管是发回部分结果 sendPartialCaptureResult 还是最终结果 sendCaptureResult ，最终都会调用 insertResultLocked ，它的主要功能就是将捕获结果放入 mResultQueue 队列，并由 mResultSignal.signal 发出消息，通知在开启设备初始化过程中 waitForNextFrame 的阻塞等待。一旦 FrameProcessorBase::threadLoop 获取到捕获结果后，逐个处理： 12345678910111213141516171819202122232425262728293031323334// FrameProcessorBase.cppvoid FrameProcessorBase::processNewFrames( const sp&lt;CameraDeviceBase&gt; &amp;device) &#123; status_t res; ... while ( (res = device-&gt;getNextResult(&amp;result)) == OK) &#123; camera_metadata_entry_t entry; entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT); ... if (!processSingleFrame(result, device)) &#123; break; &#125; ... &#125; ... return;&#125;bool FrameProcessorBase::processSingleFrame(CaptureResult &amp;result, const sp&lt;CameraDeviceBase&gt; &amp;device) &#123; ... return processListeners(result, device) == OK;&#125;status_t FrameProcessorBase::processListeners( const CaptureResult &amp;result, const sp&lt;CameraDeviceBase&gt; &amp;device) &#123; ... List&lt;sp&lt;FilteredListener&gt; &gt;::iterator item = listeners.begin(); for (; item != listeners.end(); item++) &#123; (*item)-&gt;onResultAvailable(result); &#125; return OK;&#125; 代理流程可以看出，逐个取出 CaptureResult 并处理，最终调用 CameraDeviceClient::onResultAvailable 向 API 发送捕获结果： 12345678910// CameraDeviceClient.cppvoid CameraDeviceClient::onResultAvailable(const CaptureResult&amp; result) &#123; ... sp&lt;hardware::camera2::ICameraDeviceCallbacks&gt; remoteCb = mRemoteCallback; if (remoteCb != NULL) &#123; remoteCb-&gt;onResultReceived(result.mMetadata, result.mResultExtras); &#125;&#125; 而 API 中的回调是在 CameraDeviceImpl.java 中实现的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// CameraDeviceImpl.java@Overridepublic void onResultReceived(CameraMetadataNative result, CaptureResultExtras resultExtras) throws RemoteException &#123; int requestId = resultExtras.getRequestId(); long frameNumber = resultExtras.getFrameNumber(); ... synchronized(mInterfaceLock) &#123; ... final CaptureCallbackHolder holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId); final CaptureRequest request = holder.getRequest(resultExtras.getSubsequenceId()); boolean isPartialResult = (resultExtras.getPartialResultCount() &lt; mTotalPartialCount); ... if (isPartialResult) &#123; final CaptureResult resultAsCapture = new CaptureResult(result, request, resultExtras); // Partial result resultDispatch = new Runnable() &#123; @Override public void run() &#123; if (!CameraDeviceImpl.this.isClosed()) &#123; if (holder.hasBatchedOutputs()) &#123; for (int i = 0; i &lt; holder.getRequestCount(); i++) &#123; CameraMetadataNative resultLocal = new CameraMetadataNative(resultCopy); CaptureResult resultInBatch = new CaptureResult( resultLocal, holder.getRequest(i), resultExtras); holder.getCallback().onCaptureProgressed( CameraDeviceImpl.this, holder.getRequest(i), resultInBatch); &#125; &#125; else &#123; holder.getCallback().onCaptureProgressed( CameraDeviceImpl.this, request, resultAsCapture); &#125; &#125; &#125; &#125;; finalResult = resultAsCapture; &#125; else &#123; List&lt;CaptureResult&gt; partialResults = mFrameNumberTracker.popPartialResults(frameNumber); ... final TotalCaptureResult resultAsCapture = new TotalCaptureResult(result, request, resultExtras, partialResults, holder.getSessionId()); // Final capture result resultDispatch = new Runnable() &#123; @Override public void run() &#123; if (!CameraDeviceImpl.this.isClosed())&#123; if (holder.hasBatchedOutputs()) &#123; for (int i = 0; i &lt; holder.getRequestCount(); i++) &#123; ... TotalCaptureResult resultInBatch = new TotalCaptureResult( resultLocal, holder.getRequest(i), resultExtras, partialResults, holder.getSessionId()); holder.getCallback().onCaptureCompleted( CameraDeviceImpl.this, holder.getRequest(i), resultInBatch); &#125; &#125; else &#123; holder.getCallback().onCaptureCompleted( CameraDeviceImpl.this, request, resultAsCapture); &#125; &#125; &#125; &#125;; finalResult = resultAsCapture; &#125; ... // Fire onCaptureSequenceCompleted if (!isPartialResult) &#123; checkAndFireSequenceComplete(); &#125; &#125;&#125; 在 CameraDeviceImpl 中处理 CameraCaptureSession.CaptureCallback 各回调结果：如果返回的是部分结果，则回调 onCaptureProgressed ；如果返回最终结果，则回调 onCaptureCompleted 。整个预览、拍照、录像流程及回调分析完毕。 小结 Camera3Device::RequestThread这个类主要是处理预览、拍照、录像的请求 CaptureRequest 。 FrameProcessorBase.cpp这个类主要是处理请求后的回调函数，回调中会包含捕获的结果 CaptureResult 。 Condition不管是请求还是结果回调，因为是多线程处理，都涉及到条件变量的阻塞等待和通知机制。 CameraDeviceSession.CaptureCallback该回调接口都是在 CameraDeviceImpl 中实现的。 三者异同预览、拍照、录像三者的流程基本一致，它们之间有如下异同： 预览捕获请求模板为 CameraDevice.TEMPLATE_PREVIEW ；API 接口为 CameraCaptureSession.setRepeatingRequest ；repeating 值为 true 。 拍照捕获请求模板为 CameraDevice.TEMPLATE_STILL_CAPTURE ；API 接口为 CameraCaptureSession.Capture ；repeating 值为 false 。 录像捕获请求模板为 CameraDevice.TEMPLATE_RECORD ；API 接口为 CameraCaptureSession.setRepeatingRequest ；repeating 值为 true 。 也就是说，预览和录像仅仅是捕获请求模板不一样；而预览和拍照不管是模板，接口，repeating 值都不一样；但是它们三者最终在 Framework 中代码流程基本一致。 CameraServiceProxy 注册服务AIDL1234567891011121314151617interface ICameraServiceProxy&#123; // CameraService 向代理服务发送消息，通知用户更新 oneway void pingForUserUpdate(); const int CAMERA_STATE_OPEN = 0; const int CAMERA_STATE_ACTIVE = 1; const int CAMERA_STATE_IDLE = 2; const int CAMERA_STATE_CLOSED = 3; const int CAMERA_FACING_BACK = 0; const int CAMERA_FACING_FRONT = 1; const int CAMERA_FACING_EXTERNAL = 2; // CameraService 向代理服务发送消息，通知相机设备状态更新 oneway void notifyCameraState(String cameraId, int facing, int newCameraState, String clientName);&#125; 从 AIDL 文件看出，CameraServiceProxy 主要是响应 CameraService 的请求，也就是向 Framework Java 发送消息。 流程图CameraServiceProxy 服务名称：media.camera.proxy ；CameraServiceProxy 继承了 SystemService ，注册流程如下： 源码分析先来看注册流程的源码，服务的标准注册流程： 12345678910111213141516171819202122232425262728293031323334353637383940414243// CameraServiceProxy.javapublic class CameraServiceProxy extends SystemService implements Handler.Callback, IBinder.DeathRecipient &#123; ... private static final String CAMERA_SERVICE_BINDER_NAME = "media.camera"; public static final String CAMERA_SERVICE_PROXY_BINDER_NAME = "media.camera.proxy"; ... // 构造方法中，初始化线程相关 public CameraServiceProxy(Context context) &#123; super(context); mContext = context; mHandlerThread = new ServiceThread(TAG, Process.THREAD_PRIORITY_DISPLAY, /*allowTo*/false); mHandlerThread.start(); mHandler = new Handler(mHandlerThread.getLooper(), this); mNotifyNfc = SystemProperties.getInt(NFC_NOTIFICATION_PROP, 0)&gt;0; if (DEBUG) Slog.v(...); &#125; // onStart 主要是注册服务，并监听 User 相关广播 @Override public void onStart() &#123; mUserManager = UserManager.get(mContext); ... IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_USER_ADDED); filter.addAction(Intent.ACTION_USER_REMOVED); filter.addAction(Intent.ACTION_USER_INFO_CHANGED); filter.addAction(Intent.ACTION_MANAGED_PROFILE_ADDED); filter.addAction(Intent.ACTION_MANAGED_PROFILE_REMOVED); mContext.registerReceiver(mIntentReceiver, filter); // 注册 CameraServiceProxy 服务 publishBinderService(CAMERA_SERVICE_PROXY_BINDER_NAME, mCameraServiceProxy); publishLocalService(CameraServiceProxy.class, this); CameraStatsJobService.schedule(mContext); &#125; ...&#125; 类中的 User 指的是 Android 多用户；再看回调接口的实现： 1234567891011121314151617// CameraServiceProxy.javaprivate final ICameraServiceProxy.Stub mCameraServiceProxy = new ICameraServiceProxy.Stub() &#123; @Override public void pingForUserUpdate() &#123; notifySwitchWithRetries(30); &#125; @Override public void notifyCameraState(String cameraId, int newCameraState, int facing, String clientName) &#123; String state = cameraStateToString(newCameraState); String facingStr = cameraFacingToString(facing); if (DEBUG) Slog.v(...); updateActivityCount(cameraId, newCameraState,facing,clientName); &#125;&#125;; 小结通常情况下 API 中，CameraManager 通过 ICameraService.aidl 向 CameraService 下发请求；而 CameraService 通过 ICameraServiceListener.aidl 发回回调。而如果没有 API 请求的情况下，CameraService 无法向 Framework Java 发送信息，所以系统开机时注册了 CameraServiceProxy 服务，用于响应 CameraService 的回调。 其他Camera 相关声音1234567891011121314void CameraService::loadSound() &#123; ATRACE_CALL(); Mutex::Autolock lock(mSoundLock); LOG1("CameraService::loadSound ref=%d", mSoundRef); if (mSoundRef++) return; mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer( "/system/media/audio/ui/camera_click.ogg"); mSoundPlayer[SOUND_RECORDING_START] = newMediaPlayer( "/system/media/audio/ui/VideoRecord.ogg"); mSoundPlayer[SOUND_RECORDING_STOP] = newMediaPlayer( "/system/media/audio/ui/VideoStop.ogg");&#125; CameraMetadataCameraMetadataNative 和 CameraMetadata 是同一个类型，只是命名空间不一样。 123456789101112131415namespace android &#123;...class CameraMetadata: public Parcelable &#123;...&#125;namespace hardware &#123;namespace camera2 &#123;namespace impl &#123;using ::android::CameraMetadata;typedef CameraMetadata CameraMetadataNative;&#125;&#125;&#125; 常见问题API 2 + HAL 1平台仅支持 HAL 1 时，API 2 在 openCamera 时，通过 CameraDeviceUserShim 将 API 2 转换为 API 1 ，即 HAL 1 + API 1 向下发起请求。LegacyCameraDevice 会将 CAMERA API2 转换为 CAMERA API1 ，而 CameraDeviceUserShim 封装了 LegacyCameraDevice 。 AIDL 生成多类型文件AIDL 可以同时生成 .java, .h, .cpp 文件，编译规则在 Android.bp 中配置。 总结后续 数据传递Binder 通信机制，数据传输限制在 1M ，那整个通信机制是如何传递图片的呢？以及预览的呢？传递的是什么？createCaptureSession 创建捕获会话时，配置输出流；当 setRepeatingRequest 发起预览请求时，回调结果为 CaptureResult ，它是如何和输出流关联的呢？ SurfaceFlinger 显示相关知识 Buffer 相关管理 这些都是 API 1 模式下的数据流，不过有参考意义。 预览preview模式下的数据流 Surface 缓存区 生产者与消费者 参考文档 木子一秋：Android Camera架构 StoneDemo：HAL3 之 Open Camera2 流程（零）—— 概览]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Camera API2 介绍]]></title>
    <url>%2F2018%2F11%2F28%2F0109-android-camera-3-api2%2F</url>
    <content type="text"><![CDATA[Android Camera 开发相机应用相关 API2 介绍，以及使用示例。 基础camera 各个版本 Camera API1Android 4.4 或更低版本设备上的应用级相机框架，通过 android.hardware.Camera 类提供。 Camera API2Android 5.0 及更高版本设备上的应用级相机框架，通过 android.hardware.camera2 包提供。 Camera HAL由 SoC 供应商实现的相机模块层。该应用级公共框架基于 Camera HAL 构建而成。 Camera HAL3.1随 Android 4.4 发布的相机设备 HAL 版本。 Camera HAL3.2随 Android 5.0 发布的相机设备 HAL 版本。 Camera API1Android 5.0 已弃用 Camera API1，而且随着新平台开发的重点放在 Camera API2 上，Camera API1 会逐渐被淘汰。但是淘汰期限将会很长，而且在一段时间内新 Android 版本会继续支持 Camera API1 应用。具体来说，将继续为以下内容提供支持： 供应用使用的 Camera API1 接口；在 Camera API1 之上构建的相机应用应该像在运行早期 Android 版本的设备上一样工作 Camera HAL 版本，包括对 Camera HAL1.0 的支持 Camera API2Camera API2 框架为应用提供更接近底层的相机控件，包括高效的零复制连拍/视频流以及曝光、增益、白平衡增益、颜色转换、去噪、锐化等方面的每帧控件。Android 5.0 及更高版本提供 Camera API2；但是运行 Android 5.0 及更高版本的设备可能并不支持所有 Camera API2 功能。应用可通过 Camera API2 接口查询 android.info.supportedHardwareLevel 属性。该属性会报告以下支持级别之一： INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY 旧版这些设备通过 Camera API2 接口为应用提供功能，而且这些功能与通过 Camera API1 接口提供给应用的功能大致相同。旧版框架代码在概念上将 Camera API2 调用转换为 Camera API1 调用；旧版设备不支持 Camera API2 功能，例如每帧控件。 INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED 有限这些设备支持部分（但不是全部）Camera API2 功能，并且必须使用 Camera HAL 3.2 或更高版本。 INFO_SUPPORTED_HARDWARE_LEVEL_FULL 全面这些设备支持 Camera API2 的所有主要功能，并且必须使用 Camera HAL 3.2 或更高版本以及 Android 5.0 或更高版本。 INFO_SUPPORTED_HARDWARE_LEVEL_3 级别 3这些设备支持 YUV 重新处理和 RAW 图片捕获，以及其他输出流配置。 INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL 外部这些设备类似于 LIMITED 设备，但有一些例外情况；例如某些传感器或镜头信息可能未被报告或具有较不稳定的帧速率。此级别用于外部相机（如 USB 网络摄像头）。 各个模式支持的功能级别 LEGACY &lt; LIMITED &lt; FULL &lt; LEVEL_3 ；各项功能通过 Camera API2 接口中的 android.request.availableCapabilities 属性提供。FULL 设备需要具备 MANUAL_SENSOR 和 MANUAL_POST_PROCESSING 等功能。但即使是 FULL 设备，也并非必须实现 RAW 功能。 LIMITED 设备可以提供这些功能的任何子集，甚至可以不提供其中任何功能。但是必须始终定义 BACKWARD_COMPATIBLE 功能。 设备支持的硬件级别及其支持的特定 Camera API2 功能采用以下功能标记的形式指明，APP 在使用时，在 AndroidManifest.xml 中通过 uses-feature 来声明使用的功能： 1234android.hardware.camera.hardware_level.fullandroid.hardware.camera.capability.rawandroid.hardware.camera.capability.manual_sensorandroid.hardware.camera.capability.manual_post_processing HAL 新旧版本架构图从 Android 8.0 开始，相机 HAL 实现了 HIDL 接口；而旧版本架构和新版本主要体现在 HIDL 上。 基于 HIDL 的架构图 旧版架构图 Camera 各版本介绍详细参考：Android Camera 架构 ， Android Camera 版本支持 Camera2 类图结构 各个类功能简介 CameraManager相机设备管理员，用于检测相机设备，开启相机设备，获取相机设备支持的特性等等。 CameraDevice表示物理或逻辑摄像头，类似老版本中的 Camera 类，是对传感器相关功能的封装。 CameraCaptureSessionCamera 应用程序和 CameraDevice 硬件之间建立的一个会话类，用于从相机捕获图像或重新处理先前在同一会话中从相机捕获的图像，捕获到的图像输出到目标 Surface 中。为应用程序主要提供预览 setRepeatingRequest 和拍照 capture 功能。 CameraMetadata是一个数据结构，包含了 CameraDevice 控制命令和相关信息。CameraMetadata 用于查询 CameraDevice 属性、捕获结果、设置请求参数的基本键/值映射。CameraMetadata 的所有实例都是不可变的。 CaptureRequest表示从 CameraDevice 获取捕获数据的请求，包含对 CameraDevice 的参数设置，算法控制，输出缓冲区等等。 CaptureResult表示从 CameraDevice 获取到数据的结果子集；包含捕获硬件（传感器，镜头，闪存），控制算法和输出缓冲区的最终配置等的子集；CaptureResult 对象实例是不可变的。 CameraCharacteristics用来描述 CameraDevice 设备的属性，这些属性是不可修改的，设备出厂时提供的；可以通过 CameraManager.getCameraCharacteristics(String cameraID) 来查询当前设备支持哪些属性。 基本结构 在 Camera2 的架构中，APP 和 CameraDevice 之间通过 Pipeline 管道来连接。 CameraCaptureSession 充当管道的功能 APP 向 CameraDevice 发送 CaptureRequest CameraDevices 收到请求后返回对应数据到对应的 Surface ：通常 TextureView 用来预览，ImageReader 用来拍照保存 简化使用流程图 CameraManagerCameraManager 相机设备管理员，用于检测相机设备，开启相机设备，获取相机设备支持的特性等等。 API 方法CameraManager 提供的 API 非常简单，围绕着类的主要功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public final class CameraManager &#123; private static final int USE_CALLING_UID = -1; @SuppressWarnings("unused") private static final int API_VERSION_1 = 1; private static final int API_VERSION_2 = 2; private static final int CAMERA_TYPE_BACKWARD_COMPATIBLE = 0; private static final int CAMERA_TYPE_ALL = 1; private ArrayList&lt;String&gt; mDeviceIdList; private final Context mContext; private final Object mLock = new Object(); public CameraManager(Context context) &#123; synchronized(mLock) &#123; mContext = context; &#125; &#125; // 获取指定设备的属性 public CameraCharacteristics getCameraCharacteristics ( String cameraId)&#123;...&#125; // 获取当前系统中的设备 ID 数组 public String[] getCameraIdList() throws CameraAccessException &#123; return CameraManagerGlobal.get().getCameraIdList(); &#125; // 开启指定 ID 的相机设备 public void openCamera(@NonNull String cameraId, @NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException &#123; openCameraForUid(cameraId, callback, handler, USE_CALLING_UID); &#125; // 使用并发器开启相机设备 public void openCamera (String cameraId, Executor executor, CameraDevice.StateCallback callback)&#123;...&#125; // 注册 AvailabilityCallback public void registerAvailabilityCallback (Executor executor, CameraManager.AvailabilityCallback callback) public void registerAvailabilityCallback ( CameraManager.AvailabilityCallback callback, Handler handler)&#123;...&#125; // 取消 AvailabilityCallback public void unregisterAvailabilityCallback ( CameraManager.AvailabilityCallback callback)&#123;...&#125; // 注册 TorchCallback public void registerTorchCallback ( CameraManager.TorchCallback callback, Handler handler)&#123;...&#125; public void registerTorchCallback (Executor executor, CameraManager.TorchCallback callback)&#123;...&#125; // 取消 TorchCallback public void unregisterTorchCallback ( CameraManager.TorchCallback callback)&#123;...&#125; // 指定 ID 相机设备，设置手电筒模式 public void setTorchMode(@NonNull String cameraId, boolean enabled) throws CameraAccessException &#123; if (CameraManagerGlobal.sCameraServiceDisabled) &#123; throw new IllegalArgumentException("..."); &#125; CameraManagerGlobal.get().setTorchMode(cameraId, enabled); &#125;&#125; AvailabilityCallback 回调CameraManager.AvailabilityCallback 表示相机设备开启后状态，变为有效或无效状态。 1234public static abstract class AvailabilityCallback &#123; public void onCameraAvailable(@NonNull String cameraId) &#123;&#125; public void onCameraUnavailable(@NonNull String cameraId) &#123;&#125;&#125; TorchCallback 回调CameraManager.TorchCallback 闪光灯用作手电筒的回调接口，表示闪光灯处于开启手电筒、关闭、或者无效状态。 12345public static abstract class TorchCallback &#123; public void onTorchModeUnavailable(@NonNull String cameraId) &#123;&#125; public void onTorchModeChanged(@NonNull String cameraId, boolean enabled) &#123;&#125;&#125; CameraDeviceCameraDevice 表示物理或逻辑摄像头，类似老版本中的 Camera 类，是对传感器相关功能的封装。使用前需要注意： 权限CameraDevice 使用前需要申请权限 &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 。 支持功能的级别通过 CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL 查看当前手机平台支持的功能级别。如果支持 LEGACY 级别，则摄像机设备以向后兼容模式运行，并且支持最小的 Camera2 API ；如果支持 LIMITED 级别，则 Camera2 API 是和旧版 Camera API 大致相同的功能集，但界面更清晰效率更高；如果支持 EXTERNAL 级别，则该设备是可移动摄像头，提供与 LIMITED 级别相似但略少的功能；如果支持 FULL, LEVEL3 级别，API 将提供显着改进的功能。如果开发的 Camera 应用程序需要一个完整级别的设备才能正常运行，需要请在清单中声明 android.hardware.camera.level.full 功能。 常量CameraDevice 中控制模板常量： TEMPLATE_MANUAL手动控制模板，禁用所有的自动控制 3A 算法。 TEMPLATE_PREVIEW创建适合相机预览的窗口，高帧率优于高质量的后期处理。 TEMPLATE_RECORD创建适合录像的请求，使用稳定的帧率。 TEMPLATE_STILL_CAPTURE创建适合拍照的请求，优先考虑帧速率的图像质量。 TEMPLATE_VIDEO_SNAPSHOT创建录像时快照的请求，在不中断录像的前提下最大化图像质量。 TEMPLATE_ZERO_SHUTTER_LAG创建 ZSL 零延时拍照请求，在不影响帧率的前提下最大化图像质量，并开启 3A 算法。 API 方法CameraDevice 中 API 简介： 123456789101112131415161718192021222324252627282930313233343536public abstract class CameraDevice implements AutoCloseable &#123; // 关闭设备 public abstract void close (); // 使用指定模板创建请求 public abstract CaptureRequest.Builder createCaptureRequest( @RequestTemplate int templateType) throws CameraAccessException; // 使用指定模板创建请求，同时指定物理摄像头 ID 集 public CaptureRequest.Builder createCaptureRequest (int templateType, Set&lt;String&gt; physicalCameraIdSet)&#123;...&#125; // 根据指定会话配置文件，创建会话 public void createCaptureSession (SessionConfiguration config)&#123;...&#125; // 给定输出列表，创建会话；API 文档中有非常详细的匹配图 public abstract void createCaptureSession (List&lt;Surface&gt; outputs, CameraCaptureSession.StateCallback callback, Handler handler); // 根据给定输出配置文件列表，创建会话 public abstract void createCaptureSessionByOutputConfigurations( List&lt;OutputConfiguration&gt; outputConfigurations, CameraCaptureSession.StateCallback callback, Handler handler)； // 给定输出列表，创建高速会话 public abstract void createConstrainedHighSpeedCaptureSession( List&lt;Surface&gt; outputs, CameraCaptureSession.StateCallback callback, Handler handler); // 创建重新处理请求 public abstract CaptureRequest.Builder createReprocessCaptureRequest( TotalCaptureResult inputResult); // 创建重复处理会话；API 文档中有详细匹配图 public abstract void createReprocessableCaptureSession ( InputConfiguration inputConfig, List&lt;Surface&gt; outputs, CameraCaptureSession.StateCallback callback, Handler handler); // 根据配置文件创建重复处理会话 public abstract void createReprocessableCaptureSessionByConfigurations( InputConfiguration inputConfig, List&lt;OutputConfiguration&gt; outputs, CameraCaptureSession.StateCallback callback, Handler handler); // 获取设备的 ID public abstract String getId();&#125; StateCallback 回调CameraDevice.StateCallback 状态回调接口，在 CameraManager.open 打开摄像头时，必须提供该回调接口；表示当前 CameraDevice 的状态。CameraDevice.StateCallback 中设备错误常量，在 onError() 方法中返回： ERROR_CAMERA_DEVICE ：开启设备时遇到致命错误 ERROR_CAMERA_DISABLED ：由于设备策略，无法开启摄像头 ERROR_CAMERA_IN_USE ：当前开启设备正在被使用 ERROR_CAMERA_SERVICE ：CameraService 致命错误 ERROR_MAX_CAMERAS_IN_USE ：开启的设备已经达到最大数量 1234567891011public static abstract class StateCallback &#123; // 当 CameraDevice.close() 调用时会触发；如果设备已经关闭， // 后续再次调用 CameraDevice 相关方法会抛出异常 IllegalStateException public void onClosed (CameraDevice camera)&#123;...&#125; // 表示设备不能再被使用；再次访问会抛出 CameraAccessException public abstract void onDisconnected (CameraDevice camera)&#123;...&#125; // 开启设备失败；再次访问抛出 CameraAccessException，并给出 error public abstract void onError (CameraDevice camera, int error); // 设备被正常打开 public abstract void onOpened (CameraDevice camera);&#125; CameraCaptureSession抽象类；Camera 应用程序和 CameraDevice 硬件之间建立的一个会话类，用于从相机捕获图像或重新处理先前在同一会话中从相机捕获的图像，捕获到的图像输出到目标 Surface 中。为应用程序主要提供预览 setRepeatingRequest 和拍照 capture 功能。 CameraCaptureSession 创建非常耗时，可能需要几百毫秒，因为它需要配置摄像机设备的内部管道并分配内存缓冲区以将图像发送到所需目标，因此需要异步去完成。在 CameraDevice 中有两种方式创建： createCaptureSession createReprocessableCaptureSession ：可以重新处理先前在同一会话中从摄像机捕获的图像 API 方法CameraCaptureSession 中 API 简介： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public abstract class CameraCaptureSession implements AutoCloseable &#123; // 取消所有的数据捕获 abstract void abortCaptures(); // 拍照：向 CameraDevice 发出拍照请求；返回序列号 abstract int capture(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler); // 提交一个顺序捕获的列表 abstract int captureBurst(List&lt;CaptureRequest&gt; requests, CameraCaptureSession.CaptureCallback listener, Handler handler); // 提交顺序捕获列表，给定并发器 int captureBurstRequests(List&lt;CaptureRequest&gt; requests, Executor executor, CameraCaptureSession.CaptureCallback listener) &#123;...&#125; // 给定并发器，提交一个数据捕获请求 int captureSingleRequest(CaptureRequest request, Executor executor, CameraCaptureSession.CaptureCallback listener)&#123;...&#125; // 关闭 CameraCaptureSession abstract void close(); // 最终确定的输出配置 abstract void finalizeOutputConfigurations( List&lt;OutputConfiguration&gt; outputConfigs); // 获取 CameraDevice abstract CameraDevice getDevice(); // 获取输入 Surface abstract Surface getInputSurface(); // 是否可以从新处理先前获取的图像 abstract boolean isReprocessable(); // 为输出 Surface 分配缓冲区 abstract void prepare(Surface surface); // 预览：设置预览请求列表 abstract int setRepeatingBurst(List&lt;CaptureRequest&gt; requests, CameraCaptureSession.CaptureCallback listener, Handler handler); // 预览：使用指定并发器设置预览请求列表 int setRepeatingBurstRequests(List&lt;CaptureRequest&gt; requests, Executor executor, CameraCaptureSession.CaptureCallback listener) &#123;...&#125; // 预览：设置一个预览请求 abstract int setRepeatingRequest(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler); // 预览：使用指定并发器设置预览请求 int setSingleRepeatingRequest(CaptureRequest request, Executor executor, CameraCaptureSession.CaptureCallback listener) &#123;...&#125; // 停止预览 abstract void stopRepeating(); // 更新输出配置 void updateOutputConfiguration(OutputConfiguration config);&#125; StateCallback 回调CameraCaptureSession.StateCallback 状态回调接口，表示会话创建成功后或者会话有内容变化时会触发回调。CameraCaptureSession 创建成功后处于活动状态，直到摄像机设备创建新会话或关闭摄像机设备。创建成功后会触发 onConfigured 回调；如果无法完成配置，则会触发 onConfigureFailed，并且会话不会变为活动状态。新会话创建成功，则会关闭先前的会话，并会触发其 onClosed 回调。如果在会话关闭后调用，则所有会话方法都将抛出 IllegalStateException。回调接口有如下几个方法，其中 onConfigured, onConfigureFailed 是抽象类，需要在子类中实现： 1234567891011121314151617public static abstract class StateCallback &#123; // 开始处理捕获请求时触发 void onActive(CameraCaptureSession session); // 当 CameraDevice 输入捕获队列为空并准备接受下一个请求时触发 void onCaptureQueueEmpty(CameraCaptureSession session); // 当 CameraCaptureSession 关闭时触发； //如果还有方法被调用将会抛出 IllegalStateException void onClosed(CameraCaptureSession session); // 抽象方法，当请求失败时触发；之后 CameraCaptureSession 会被认为是关闭的 abstract void onConfigureFailed(CameraCaptureSession session); // 当摄像机设备完成自身配置时触发，CameraCaptureSession 可以开始处理捕获请求 abstract void onConfigured(CameraCaptureSession session); // 每次不再有要处理的捕获请求时触发 void onReady(CameraCaptureSession session); // 当输出 Surface 的缓冲区预分配完成时触发 void onSurfacePrepared(CameraCaptureSession session, Surface surface);&#125; CaptureCallback 回调CameraCaptureSession.CaptureCallback 捕获回调接口，表示 CameraDevice 在接收到数据更新时的回调： 123456789101112131415161718192021222324public static abstract class CaptureCallback &#123; // 当单个捕获到的 Buffer 数据无法发送到 Surface 时触发 void onCaptureBufferLost(CameraCaptureSession session, CaptureRequest request, Surface target, long frameNumber); // 图像捕获完成并且所有数据可用时触发 void onCaptureCompleted(CameraCaptureSession session, CaptureRequest request, TotalCaptureResult result); // 当 CameraDevice 无法为请求生成 CaptureResult 时触发 void onCaptureFailed(CameraCaptureSession session, CaptureRequest request, CaptureFailure failure); // 这里的结果是完整结果的一部分，每次捕获可能会多次触发 // 每个结果只可能出现在某一次中，而最终整体的结果在 onCaptureCompleted 中 void onCaptureProgressed(CameraCaptureSession session, CaptureRequest request, CaptureResult partialResult); // 中止捕获时触发 void onCaptureSequenceAborted(CameraCaptureSession session, int sequenceId); // 捕获序列已经完成，并且结果已经返回时触发 void onCaptureSequenceCompleted(CameraCaptureSession session, int sequenceId, long frameNumber); // 当 CameraDevice 开始捕获图像时触发 void onCaptureStarted(CameraCaptureSession session, CaptureRequest request, long timestamp, long frameNumber);&#125; CameraConstrainedHighSpeedCaptureSession抽象类，继承 CameraCaptureSession ，表示高速捕获会话，支持大于等于 120 帧/秒的录像。只有一个公共并且是抽象的方法 createHighSpeedRequestList ，表示创建高速请求列表。 12345public abstract class CameraConstrainedHighSpeedCaptureSession extends CameraCaptureSession &#123; public abstract List&lt;CaptureRequest&gt; createHighSpeedRequestList( @NonNull CaptureRequest request) throws CameraAccessException;&#125; CaptureFailureCaptureFailure 类表示拍照失败，包含了失败的具体信息；在 CameraCaptureSession.CaptureCallback 回调接口的 onCaptureFailed 中返回该类。 常量CaptureFailure 中包含两个表示失败原因的常量： REASON_ERROR ：framework 中出现的错误，导致当前帧丢弃了 CaptureResult REASON_FLUSHED ：因为调用了 CameraCaptureSession.abortCaptures() 导致的捕获失败 API 方法CaptureFailure 中 API 简介： 1234567891011121314151617181920212223242526272829303132333435363738public class CaptureFailure &#123; public static final int REASON_ERROR = 0; public static final int REASON_FLUSHED = 1; private final CaptureRequest mRequest; private final int mReason; private final boolean mDropped; private final int mSequenceId; private final long mFrameNumber; public CaptureFailure(CaptureRequest request, int reason, boolean dropped, int sequenceId, long frameNumber) &#123; mRequest = request; mReason = reason; mDropped = dropped; mSequenceId = sequenceId; mFrameNumber = frameNumber; &#125; public CaptureRequest getRequest() &#123; return mRequest; &#125; // 获取帧编号 public long getFrameNumber() &#123; return mFrameNumber; &#125; public int getReason() &#123; return mReason; &#125; // 确定图像是否从相机捕获；如果是，则可以使用图像缓冲区 public boolean wasImageCaptured() &#123; return !mDropped; &#125; // 获取序列号；该序列号为 CameraCaptureSession.capture 的返回值 public int getSequenceId() &#123; return mSequenceId; &#125;&#125; CameraMetadata抽象类，是一个数据结构，包含了 CameraDevice 控制命令和相关信息。CameraMetadata 用于查询 CameraDevice 属性、捕获结果、设置请求参数的基本键/值映射。CameraMetadata 的所有实例都是不可变的，整个抽象类只提供一个公共方法： 123456public List&lt;TKey&gt; getKeys() &#123; Class&lt;CameraMetadata&lt;TKey&gt;&gt; thisClass = (Class&lt;CameraMetadata&lt;TKey&gt;&gt;) getClass(); return Collections.unmodifiableList( getKeys(thisClass, getKeyClass(), this, /*filterTags*/null));&#125; 从实现中可以看出 getKeys() 方法返回的键列表是永远不会更改的，任何键在整个对象生命周期内返回的值也不会更改。 CameraMetadata 中定义的常量非常多，详细含义需要参考 API 中的详解。 常量CameraMetadata 支持的常量及对应含义： 色差校准模式 COLOR_CORRECTION_ABERRATIONCOLOR_CORRECTION_ABERRATION_MODE_FAST ：色差校准时不会减慢传感器的捕获速率COLOR_CORRECTION_ABERRATION_MODE_HIGH_QUALITY ：色差校准时提高图像质量，但是传感器捕获率会降低COLOR_CORRECTION_ABERRATION_MODE_OFF ：关闭色差校准模式 颜色校准模式 COLOR_CORRECTIONCOLOR_CORRECTION_MODE_FAST ：颜色校准不会减慢传感器的捕获速率COLOR_CORRECTION_MODE_HIGH_QUALITY ：颜色校准时提高图片质量，但是传感器捕获率会被降低；可以用来做高级白平衡调整COLOR_CORRECTION_MODE_TRANSFORM_MATRIX ：使用矩阵转换，但是必须要禁用高级白平衡 避免灯源工频干扰模式 ANTIBANDINGCONTROL_AE_ANTIBANDING_MODE_50HZ ：CameraDevice 调整曝光持续时间以避免 50Hz 照明光源干扰产生的明暗条纹问题CONTROL_AE_ANTIBANDING_MODE_60HZ ：避免 60Hz 照明光源的明暗条纹问题CONTROL_AE_ANTIBANDING_MODE_AUTO ：默认模式，自动适配照明光源的频率，来避免明暗条纹问题CONTROL_AE_ANTIBANDING_MODE_OFF ：不会调整曝光持续时间以避免出现明暗条纹问题 自动曝光模式 AECONTROL_AE_MODE_OFF ：自动曝光关闭CONTROL_AE_MODE_ON ：自动曝光打开CONTROL_AE_MODE_ON_ALWAYS_FLASH ：自动曝光打开并总是闪光CONTROL_AE_MODE_ON_AUTO_FLASH ：自动曝光打开并自动闪光CONTROL_AE_MODE_ON_AUTO_FLASH_REDEYE ：自动曝光打开，自动闪光并消除红眼CONTROL_AE_MODE_ON_EXTERNAL_FLASH ：自动曝光，并打开外接闪光灯 测光序列 PRECAPTURECONTROL_AE_PRECAPTURE_TRIGGER_CANCEL ：自动曝光前的测光序列，取消CONTROL_AE_PRECAPTURE_TRIGGER_IDLE ：测光序列空闲CONTROL_AE_PRECAPTURE_TRIGGER_START ：开启测光序列 自动曝光状态 AE_STATECONTROL_AE_STATE_CONVERGED ：自动曝光状态良好CONTROL_AE_STATE_FLASH_REQUIRED ：自动曝光状态良好，但是需要打开闪光灯CONTROL_AE_STATE_INACTIVE ：自动曝光关闭，或者被重置CONTROL_AE_STATE_LOCKED ：自动曝光锁定CONTROL_AE_STATE_PRECAPTURE ：自动曝光需要发送测光序列CONTROL_AE_STATE_SEARCHING ：这是瞬间状态，表示自动曝光还没设置好，正在搜索 自动对焦 AFCONTROL_AF_MODE_AUTO ：基本自动对焦模式CONTROL_AF_MODE_CONTINUOUS_PICTURE ：自动对焦连续的修改镜头位置以提供恒定对焦的图像流CONTROL_AF_MODE_CONTINUOUS_VIDEO ：录像中的自动对焦CONTROL_AF_MODE_EDOF ：扩展景深模式 Extended depth of fieldCONTROL_AF_MODE_MACRO ：特写聚焦模式CONTROL_AF_MODE_OFF ：自动对焦模式关闭 自动对焦场景 AF_SCENECONTROL_AF_SCENE_CHANGE_DETECTED ：自动对焦区域内检测到场景变化CONTROL_AF_SCENE_CHANGE_NOT_DETECTED ：自动对焦区域场景变化不检测 自动对焦状态 AF_STATECONTROL_AF_STATE_ACTIVE_SCAN ：自动对焦扫描CONTROL_AF_STATE_FOCUSED_LOCKED ：自动对焦，焦点锁定CONTROL_AF_STATE_INACTIVE ：自动对焦被关闭或者没有扫描过CONTROL_AF_STATE_NOT_FOCUSED_LOCKED ：自动对焦焦点锁定失败CONTROL_AF_STATE_PASSIVE_FOCUSED ：瞬态，自动对焦找到焦点，但是随时可能从新扫描CONTROL_AF_STATE_PASSIVE_SCAN ：瞬态，自动对焦正在扫描CONTROL_AF_STATE_PASSIVE_UNFOCUSED ：瞬态，自动对焦扫描后没有找到焦点，随时可以从新扫描 自动对焦触发器 AF_TRIGGERCONTROL_AF_TRIGGER_CANCEL ：取消自动对焦触发器CONTROL_AF_TRIGGER_IDLE ：触发器空闲CONTROL_AF_TRIGGER_START ：触发器触发自动对焦 自动白平衡模式 AWECONTROL_AWB_MODE_AUTO ：基本自动白平衡模式CONTROL_AWB_MODE_CLOUDY_DAYLIGHT ：自动白平衡关闭，使用阴天日光作为白平衡的假定场景照明CONTROL_AWB_MODE_DAYLIGHT ：自动白平衡关闭，日光作为场景照明CONTROL_AWB_MODE_FLUORESCENT ：自动白平衡关闭，荧光灯CONTROL_AWB_MODE_INCANDESCENT ：自动白平衡关闭，白炽灯CONTROL_AWB_MODE_OFF ：自动白平衡关闭CONTROL_AWB_MODE_SHADE ：自动白平衡关闭，阴影CONTROL_AWB_MODE_TWILIGHT ：自动白平衡关闭，暮光CONTROL_AWB_MODE_WARM_FLUORESCENT ：自动白平衡关闭，暖荧光灯 自动白平衡状态 AWE_STATECONTROL_AWB_STATE_CONVERGED ：自动白平衡状态良好CONTROL_AWB_STATE_INACTIVE ：自动白平衡还没有开启自动模式，或者还没有开始测量CONTROL_AWB_STATE_LOCKED ：自动白平衡锁定CONTROL_AWB_STATE_SEARCHING ：瞬态，自动白平衡还没有找到合适的值，处于搜索状态 数据捕获请求 CAPTURE_INTENTCONTROL_CAPTURE_INTENT_CUSTOM ：CameraDevice 默认的数据捕获请求CONTROL_CAPTURE_INTENT_MANUAL ：手动设置参数CONTROL_CAPTURE_INTENT_MOTION_TRACKING ：运动跟踪CONTROL_CAPTURE_INTENT_PREVIEW ：请求预览CONTROL_CAPTURE_INTENT_STILL_CAPTURE ：请求拍照CONTROL_CAPTURE_INTENT_VIDEO_RECORD ：请求录像CONTROL_CAPTURE_INTENT_VIDEO_SNAPSHOT ：请求视频快照CONTROL_CAPTURE_INTENT_ZERO_SHUTTER_LAG ：ZSL 零延时拍照请求 颜色效果模式 EFFECT_MODECONTROL_EFFECT_MODE_AQUA ：蓝色色调 AQUA 模式CONTROL_EFFECT_MODE_BLACKBOARD ：黑板模式，黑色区域带有白色或灰色细节CONTROL_EFFECT_MODE_MONO ：MONO 单色调模式，将图像映射为单一颜色CONTROL_EFFECT_MODE_NEGATIVE ：NEGATIVE 负片模式，图像的颜色反转CONTROL_EFFECT_MODE_OFF ：颜色效果模式关闭CONTROL_EFFECT_MODE_POSTERIZE ：POSTERIZE 色调分离模式，图像使用离散的色调区域而不是连续的CONTROL_EFFECT_MODE_SEPIA ：SEPIA 棕褐色效果模式，图像被映射为暖灰色，红色和棕色色调CONTROL_EFFECT_MODE_SOLARIZE ：SOLARIZE 日晒效果模式，图像的色调完全或部分颠倒CONTROL_EFFECT_MODE_WHITEBOARD ：白板模式，图像通常显示为白色区域，具有黑色或灰色细节 3A 模式CONTROL_MODE_AUTO ：3A: AE, AWE, AF 都设置为自动模式CONTROL_MODE_OFF ：关闭 3A，所有的效果都是手动控制CONTROL_MODE_OFF_KEEP_STATE ：和模式关闭相同，但是使用 3A 算法来更新统计信息CONTROL_MODE_USE_SCENE_MODE ：使用特殊场景模式 场景模式 SCENE_MODECONTROL_SCENE_MODE_ACTION ：对快速移动物体的优化CONTROL_SCENE_MODE_BARCODE ：用于准确捕获条形码照片的优化CONTROL_SCENE_MODE_BEACH ：海滩场景，适合户外、明亮的场景CONTROL_SCENE_MODE_CANDLELIGHT ：火焰场景，适合光源为火焰的昏暗场景CONTROL_SCENE_MODE_DISABLED ：关闭场景模式CONTROL_SCENE_MODE_FACE_PRIORITY ：人脸场景，如果支持人脸检测，使用 3A 优化数据CONTROL_SCENE_MODE_FIREWORKS ：烟火场景，为晚上的烟火优化图片CONTROL_SCENE_MODE_HDR ：HDR 高动态范围模式，需要更长的时间捕获单个图像CONTROL_SCENE_MODE_HIGH_SPEED_VIDEO ：已经废弃，主要用于高速录像场景CONTROL_SCENE_MODE_LANDSCAPE ：风景场景，用于优化远距离拍摄图片CONTROL_SCENE_MODE_NIGHT ：夜间场景，用于优化低光场景下的图片CONTROL_SCENE_MODE_NIGHT_PORTRAIT ：夜间人像，用于优化低光场景下的人像拍摄CONTROL_SCENE_MODE_PARTY ：聚会场景，适合昏暗、室内、多个移动人像的场景CONTROL_SCENE_MODE_PORTRAIT ：人像场景CONTROL_SCENE_MODE_SNOW ：雪景，适合明亮、室外、包含雪的场景CONTROL_SCENE_MODE_SPORTS ：运动场景，适合快速移动的人物CONTROL_SCENE_MODE_STEADYPHOTO ：优化设备小幅移动导致的图像模糊，比如手抖CONTROL_SCENE_MODE_SUNSET ：日落场景CONTROL_SCENE_MODE_THEATRE ：剧场场景，适合昏暗、室内、闪光灯关闭的场景 录像防抖模式 VIDEO_STABILIZATIONCONTROL_VIDEO_STABILIZATION_MODE_OFF ：录像防抖模式关闭CONTROL_VIDEO_STABILIZATION_MODE_ON ：录像防抖模式开启 失真校准模式 DISTORTION_CORRECTIONDISTORTION_CORRECTION_MODE_FAST ：镜头失真校准，在不降低传感器帧率情况下使用镜头失真校准DISTORTION_CORRECTION_MODE_HIGH_QUALITY ：高质量失真校准，但是会降低传感器帧率DISTORTION_CORRECTION_MODE_OFF ：失真校准模式关闭 边缘增强 EDGE_MODEEDGE_MODE_FAST ：边缘增强，不降低传感器帧率EDGE_MODE_HIGH_QUALITY ：高质量边缘增强，但是会降低传感器帧率EDGE_MODE_OFF ：边缘增强关闭EDGE_MODE_ZERO_SHUTTER_LAG ：ZSL 零延时边缘增强 闪光模式 FLASH_MODEFLASH_MODE_OFF ：图片捕获时不使用闪光灯FLASH_MODE_SINGLE ：如果闪光灯有效并有电，则开启闪光灯FLASH_MODE_TORCH ：闪光灯手电筒模式FLASH_STATE_CHARGING ：闪光灯正在充电，不能使用FLASH_STATE_FIRED ：这次图片捕获时，使用闪光灯FLASH_STATE_PARTIAL ：闪光灯部分照亮这帧图片 闪光灯状态 FLASH_STATEFLASH_STATE_READY ：闪光灯已经准备好闪光FLASH_STATE_UNAVAILABLE ：没有闪光灯 热点校正 HOT_PIXELHOT_PIXEL_MODE_FAST ：传感器的热噪声：热点 hot pixel ，是因为芯片温度过高产生的噪点。开启热点校正，但不降低传感器帧率HOT_PIXEL_MODE_HIGH_QUALITY ：高质量的热点校正，但会降低传感器帧率HOT_PIXEL_MODE_OFF ：热点校正关闭 相机硬件设备可控级别 SUPPORTED_HARDWARE_LEVEL各个模式支持的功能级别 LEGACY &lt; LIMITED &lt; FULL &lt; LEVEL_3INFO_SUPPORTED_HARDWARE_LEVEL_3 ：最高权限，全层可控，并且可以进行 YUV 的再处理和原始数据捕获INFO_SUPPORTED_HARDWARE_LEVEL_EXTERNAL ：摄像头设备为外接设备INFO_SUPPORTED_HARDWARE_LEVEL_FULL ：支持对每一帧数据进行控制,还支持高速率的图片拍摄INFO_SUPPORTED_HARDWARE_LEVEL_LIMITED ：受限模式，支持一些基本功能；还有部分额外功能（FULL 子集）INFO_SUPPORTED_HARDWARE_LEVEL_LEGACY ：向后兼容模式 镜头人头方向 LENS_FACINGLENS_FACING_BACK ：摄像头镜头成像方向与屏幕预览的关系，镜头与屏幕预览方向相反LENS_FACING_EXTERNAL ：外置摄像头，镜头与屏幕方向没有关系LENS_FACING_FRONT ：镜头与屏幕预览方向相同 镜头聚焦距离测量 LENS_INFO_FOCUS_DISTANCE_CALIBRATIONLENS_INFO_FOCUS_DISTANCE_CALIBRATION_APPROXIMATE ：镜头焦距以屈光度测量LENS_INFO_FOCUS_DISTANCE_CALIBRATION_CALIBRATED ：镜头焦距以屈光度测量并校准LENS_INFO_FOCUS_DISTANCE_CALIBRATION_UNCALIBRATED ：镜头焦距不准确，没有校准过 镜头光学防抖 OIS: LENS_OPTICAL_STABILIZATIONLENS_OPTICAL_STABILIZATION_MODE_OFF ：镜头光学防抖关闭LENS_OPTICAL_STABILIZATION_MODE_ON ：镜头光学防抖开启 镜头光学中心位置 LENS_POSE_REFERENCELENS_POSE_REFERENCE_GYROSCOPE ：镜头光学中心位置优先使用陀螺仪LENS_POSE_REFERENCE_PRIMARY_CAMERA ：镜头光学中心位置与相机相同方向 镜头状态LENS_STATE_MOVING ：一个或者几个镜头的参数正在改变LENS_STATE_STATIONARY ：镜头参数不会改变 多图像传感器的同步 MULTI_CAMERA_SENSOR_SYNCLOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_APPROXIMATE ：软件同步，图像的时间戳来自于传感器开始曝光的近似值LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE_CALIBRATED ：硬件同步，时间戳为准确值 降噪模式 NOISE_REDUCTIONNOISE_REDUCTION_MODE_FAST ：开启降噪模式，不降低传感器帧率NOISE_REDUCTION_MODE_HIGH_QUALITY ：高质量降噪模式，但会降低传感器帧率NOISE_REDUCTION_MODE_MINIMAL ：在不降低传感器帧率情况下，将噪声降到最小NOISE_REDUCTION_MODE_OFF ：降噪模式关闭NOISE_REDUCTION_MODE_ZERO_SHUTTER_LAG ：ZSL 零延时降噪模式 有效请求功能集 REQUEST_AVAILABLE_CAPABILITIESREQUEST_AVAILABLE_CAPABILITIES_BACKWARD_COMPATIBLE ：向后兼容，每个摄像头设备支持的最小功能集REQUEST_AVAILABLE_CAPABILITIES_BURST_CAPTURE ：当后期处理设置为 FAST 模式时，CameraDevice 支持以大于等于 20帧/秒（至少未压缩的YUV格式）的速度捕获高分辨率图像；也可以大于等于 10帧/秒的速度捕获最大分辨率图像。高分辨率至少 800 万像素或设备的最大分辨率，以较小者为准REQUEST_AVAILABLE_CAPABILITIES_CONSTRAINED_HIGH_SPEED_VIDEO ：设备支持高速视频录制（帧率大于等于 120 帧/秒）REQUEST_AVAILABLE_CAPABILITIES_DEPTH_OUTPUT ：支持景深REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA ：支持两个或多个物理摄像头REQUEST_AVAILABLE_CAPABILITIES_MANUAL_POST_PROCESSING ：支持图像手动后期处理REQUEST_AVAILABLE_CAPABILITIES_MANUAL_SENSOR ：支持传感器获取图像阶段的手动控制，比如 3A 算法控制REQUEST_AVAILABLE_CAPABILITIES_MONOCHROME ：单色相机，U, V 的值都是 128REQUEST_AVAILABLE_CAPABILITIES_MOTION_TRACKING ：支持运动追踪REQUEST_AVAILABLE_CAPABILITIES_PRIVATE_REPROCESSING ：支持零延时 ZSLREQUEST_AVAILABLE_CAPABILITIES_RAW ：支持传感器的原始缓冲区数据REQUEST_AVAILABLE_CAPABILITIES_READ_SENSOR_SETTINGS ：3A 在运行时，支持读取传感器的设置REQUEST_AVAILABLE_CAPABILITIES_YUV_REPROCESSING ：和 PRIVATE_REPROCESSING 类似，支持 YUV_420_888 裁剪类型 CROPPINGSCALER_CROPPING_TYPE_CENTER_ONLY ：仅支持中央裁剪区域SCALER_CROPPING_TYPE_FREEFORM ：支持任意选择裁剪区域 颜色滤镜 COLOR_FILTERSENSOR_INFO_COLOR_FILTER_ARRANGEMENT_BGGR ：颜色滤镜即传感器中 Bayer 格式图像的 RGB 滤色器，从左上角开始每个 2x2 的像素区域使用的颜色滤镜组合；当前为 BGGRSENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GBRG ：2x2 区域为 GBRGSENSOR_INFO_COLOR_FILTER_ARRANGEMENT_GRBG ：2x2 区域为 GRBGSENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGB ：传感器输出不是 Bayer 格式的图像，输出的是每个像素 316 位值，而不是 116SENSOR_INFO_COLOR_FILTER_ARRANGEMENT_RGGB ：2x2 区域为 RGGB 时间戳 TIMESTAMPSENSOR_INFO_TIMESTAMP_SOURCE_REALTIME ：时间戳和系统时间相同SENSOR_INFO_TIMESTAMP_SOURCE_UNKNOWN ：时间戳以纳秒为单位，并不能和其他子系统对比 光源色温 ILLUMINANTSENSOR_REFERENCE_ILLUMINANT1_CLOUDY_WEATHER ：指的是人造标准光源的类型，模拟环境光源。模拟多云天SENSOR_REFERENCE_ILLUMINANT1_COOL_WHITE_FLUORESCENT ：模拟白色荧光，W 3900 - 4500 KSENSOR_REFERENCE_ILLUMINANT1_D50 ：D50, 5000K 模拟太阳光色温SENSOR_REFERENCE_ILLUMINANT1_D55 ：D55SENSOR_REFERENCE_ILLUMINANT1_D65 ：D65 6500K 国际标准人工日光色温SENSOR_REFERENCE_ILLUMINANT1_D75 ：D75 75000K 模拟北方平均太阳光色温SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT ：模拟白天SENSOR_REFERENCE_ILLUMINANT1_DAYLIGHT_FLUORESCENT ：白天荧光 D 5700 - 7100KSENSOR_REFERENCE_ILLUMINANT1_DAY_WHITE_FLUORESCENT ：白天白色荧光 N 4600 - 5400KSENSOR_REFERENCE_ILLUMINANT1_FINE_WEATHER ：模拟好天气SENSOR_REFERENCE_ILLUMINANT1_FLASH ：闪光灯SENSOR_REFERENCE_ILLUMINANT1_FLUORESCENT ：荧光灯SENSOR_REFERENCE_ILLUMINANT1_ISO_STUDIO_TUNGSTEN ：标准钨丝灯SENSOR_REFERENCE_ILLUMINANT1_SHADE ：阴影SENSOR_REFERENCE_ILLUMINANT1_STANDARD_A ：美式橱窗射灯 2856KSENSOR_REFERENCE_ILLUMINANT1_STANDARD_B ：SENSOR_REFERENCE_ILLUMINANT1_STANDARD_C ：SENSOR_REFERENCE_ILLUMINANT1_TUNGSTEN ：白炽灯SENSOR_REFERENCE_ILLUMINANT1_WHITE_FLUORESCENT ：白色荧光灯 WW 3200 - 3700K 测试图案 TEST_PATTERNSENSOR_TEST_PATTERN_MODE_COLOR_BARS ：使用 8 条彩色图案：白、黄、青、绿、品红、红、蓝、黑SENSOR_TEST_PATTERN_MODE_COLOR_BARS_FADE_TO_GRAY ：和 COLOR_BARS 类似，但是从顶部到底部淡化成灰色SENSOR_TEST_PATTERN_MODE_CUSTOM1 ：自定义模式，图片必须是静态的SENSOR_TEST_PATTERN_MODE_OFF ：默认值，没有使用测试图案，直接返回传感器捕获的数据SENSOR_TEST_PATTERN_MODE_PN9 ：所有像素数据由从 PN9 512 位序列生成的伪随机序列SENSOR_TEST_PATTERN_MODE_SOLID_COLOR ：所有像素由颜色通道代替 镜头阴影校正 Lens SHADINGSHADING_MODE_FAST ：镜头均匀性指画面中心的明亮度到四周的明亮度比值。阴影校正，不会降低传感器帧率SHADING_MODE_HIGH_QUALITY ：高质量的阴影校正，但会降低帧率SHADING_MODE_OFF ：没有校正 人脸检测 FACE DETECTSTATISTICS_FACE_DETECT_MODE_FULL ：返回人脸检测所有元数据：面部矩形，分数，ID 等STATISTICS_FACE_DETECT_MODE_OFF ：人脸检测统计数据关闭STATISTICS_FACE_DETECT_MODE_SIMPLE ：仅返回人脸矩形，置信度 镜头均匀性阴影图 LENS SHADING MAPSTATISTICS_LENS_SHADING_MAP_MODE_OFF ：传感器输出的数据中不包含镜头阴影图STATISTICS_LENS_SHADING_MAP_MODE_ON ：传感器输出的数据中包含镜头阴影图 光学防抖数据 OIS DATASTATISTICS_OIS_DATA_MODE_OFF ：传感器输出数据不包含光学防抖位置信息STATISTICS_OIS_DATA_MODE_ON ：传感器输出数据包含光学防抖位置信息 照明闪烁 FLICKERSTATISTICS_SCENE_FLICKER_50HZ ：CameraDevice 检查当前场景照明闪烁 50HZSTATISTICS_SCENE_FLICKER_60HZ ：闪烁为 60HZSTATISTICS_SCENE_FLICKER_NONE ：不去检查 最大延迟同步 LATENCYSYNC_MAX_LATENCY_PER_FRAME_CONTROL ：每帧都去检查最大延迟同步SYNC_MAX_LATENCY_UNKNOWN ：不确定延迟同步 色调映射模式 TONEMAP MODETONEMAP_MODE_CONTRAST_CURVE ：不会降低传感器帧率，使用指定色调映射曲线TONEMAP_MODE_FAST ：不会降低传感器帧率，使用高级伽马映射和颜色增强TONEMAP_MODE_GAMMA_VALUE ：不会降低帧率，使用伽马值进行颜色映射，禁用其他色调映射和颜色增强TONEMAP_MODE_HIGH_QUALITY ：高质量的伽马映射和颜色增强，会降低帧率TONEMAP_MODE_PRESET_CURVE ：不会降低帧率，使用预设的色调映射曲线来执行色调映射，禁用其他色调映射和颜色增强 色调映射曲线预设值 TONEMAP PRESET CURVETONEMAP_PRESET_CURVE_REC709 ：色调映射曲线预设 ITU-R BT.709TONEMAP_PRESET_CURVE_SRGB ：色调映射曲线预设 sRGB CameraCharacteristics继承 CameraMetadata ，用来描述 CameraDevice 设备的属性，这些属性是不可修改的，设备出厂时提供的；可以通过 CameraManager.getCameraCharacteristics(String cameraID) 来查询当前设备支持哪些属性。 Key 常量CameraCharacteristics 支持的 Key 常量及对应含义，这些值都是从 system/media/camera/docs 中自动解析生成的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356 // 相差矫正模式列表 public static final Key&lt;int[]&gt; COLOR_CORRECTION_AVAILABLE_ABERRATION_MODES = new Key&lt;int[]&gt;("android.colorCorrection.availableAberrationModes", int[].class); // 自动曝光避免工频干扰列表 public static final Key&lt;int[]&gt; CONTROL_AE_AVAILABLE_ANTIBANDING_MODES = new Key&lt;int[]&gt;("android.control.aeAvailableAntibandingModes", int[].class); // 自动曝光模式列表 public static final Key&lt;int[]&gt; CONTROL_AE_AVAILABLE_MODES = new Key&lt;int[]&gt;("android.control.aeAvailableModes", int[].class); // 支持的帧率范围 public static final Key&lt;android.util.Range&lt;Integer&gt;[]&gt; CONTROL_AE_AVAILABLE_TARGET_FPS_RANGES = new Key&lt;android.util.Range&lt;Integer&gt;[]&gt;( "android.control.aeAvailableTargetFpsRanges", new TypeReference&lt;android.util.Range&lt;Integer&gt;[]&gt;() &#123;&#123; &#125;&#125;); // 自动曝光补偿值范围 public static final Key&lt;android.util.Range&lt;Integer&gt;&gt; CONTROL_AE_COMPENSATION_RANGE = new Key&lt;android.util.Range&lt;Integer&gt;&gt;( "android.control.aeCompensationRange", new TypeReference&lt;android.util.Range&lt;Integer&gt;&gt;() &#123;&#123; &#125;&#125;); // 自动曝光补偿值最小步进 public static final Key&lt;Rational&gt; CONTROL_AE_COMPENSATION_STEP = new Key&lt;Rational&gt;("android.control.aeCompensationStep", Rational.class); // 是否支持 AE 锁 public static final Key&lt;Boolean&gt; CONTROL_AE_LOCK_AVAILABLE = new Key&lt;Boolean&gt;("android.control.aeLockAvailable",boolean.class); // 自动对焦模式列表 public static final Key&lt;int[]&gt; CONTROL_AF_AVAILABLE_MODES = new Key&lt;int[]&gt;("android.control.afAvailableModes", int[].class); // 颜色效果列表 public static final Key&lt;int[]&gt; CONTROL_AVAILABLE_EFFECTS = new Key&lt;int[]&gt;("android.control.availableEffects", int[].class); // 控制模式列表 public static final Key&lt;int[]&gt; CONTROL_AVAILABLE_MODES = new Key&lt;int[]&gt;("android.control.availableModes", int[].class); // 场景模式列表 public static final Key&lt;int[]&gt; CONTROL_AVAILABLE_SCENE_MODES = new Key&lt;int[]&gt;("android.control.availableSceneModes",int[].class); // 视频防抖模式列表 public static final Key&lt;int[]&gt; CONTROL_AVAILABLE_VIDEO_STABILIZATION_MODES = new Key&lt;int[]&gt;("android.control.availableVideoStabilizationModes", int[].class); // 自动白平衡列表 public static final Key&lt;int[]&gt; CONTROL_AWB_AVAILABLE_MODES = new Key&lt;int[]&gt;("android.control.awbAvailableModes", int[].class); // 是否支持自动白平衡锁 public static final Key&lt;Boolean&gt; CONTROL_AWB_LOCK_AVAILABLE = new Key&lt;Boolean&gt;("android.control.awbLockAvailable",boolean.class); // 自动曝光，测量区域最大值 public static final Key&lt;Integer&gt; CONTROL_MAX_REGIONS_AE = new Key&lt;Integer&gt;("android.control.maxRegionsAe", int.class); // 自动对焦，测量区域最大值 public static final Key&lt;Integer&gt; CONTROL_MAX_REGIONS_AF = new Key&lt;Integer&gt;("android.control.maxRegionsAf", int.class); // 自动白平衡，测量区域最大值 public static final Key&lt;Integer&gt; CONTROL_MAX_REGIONS_AWB = new Key&lt;Integer&gt;("android.control.maxRegionsAwb", int.class); // 传感器灵敏度增强范围 public static final Key&lt;android.util.Range&lt;Integer&gt;&gt; CONTROL_POST_RAW_SENSITIVITY_BOOST_RANGE = new Key&lt;android.util.Range&lt;Integer&gt;&gt;( "android.control.postRawSensitivityBoostRange", new TypeReference&lt;android.util.Range&lt;Integer&gt;&gt;() &#123;&#123; &#125;&#125;); // 指示捕获目标能否同时输出 DEPTH16/DEPTH_POIN // 或者正常模式 YUV_420_888, JPEG, RAW public static final Key&lt;Boolean&gt; DEPTH_DEPTH_IS_EXCLUSIVE = new Key&lt;Boolean&gt;("android.depth.depthIsExclusive", boolean.class); // 失真校准模式列表 public static final Key&lt;int[]&gt; DISTORTION_CORRECTION_AVAILABLE_MODES=.; // 边缘增强模式列表 public static final Key&lt;int[]&gt; EDGE_AVAILABLE_EDGE_MODES = new Key&lt;int[]&gt;("android.edge.availableEdgeModes", int[].class); // 是否有闪光灯 public static final Key&lt;Boolean&gt; FLASH_INFO_AVAILABLE = new Key&lt;Boolean&gt;("android.flash.info.available", boolean.class); // 热点矫正模式列表 public static final Key&lt;int[]&gt; HOT_PIXEL_AVAILABLE_HOT_PIXEL_MODES = new Key&lt;int[]&gt;("android.hotPixel.availableHotPixelModes", int[].class); // 相机全功能支持级别 public static final Key&lt;Integer&gt; INFO_SUPPORTED_HARDWARE_LEVEL = new Key&lt;Integer&gt;("android.info.supportedHardwareLevel",int.class); // 相机设备制造商信息，如 ISP 硬件，传感器等等 public static final Key&lt;String&gt; INFO_VERSION=...; // JPEG 缩略图大小 public static final Key&lt;android.util.Size[]&gt; JPEG_AVAILABLE_THUMBNAIL_SIZES = new Key&lt;android.util.Size[]&gt;("android.jpeg.availableThumbnailSizes", android.util.Size[].class); // 镜头失真校准系数 public static final Key&lt;float[]&gt; LENS_DISTORTION=...; // 相机相对屏幕的方向 public static final Key&lt;Integer&gt; LENS_FACING = new Key&lt;Integer&gt;("android.lens.facing", int.class); // 相机支持的光圈大小列表 public static final Key&lt;float[]&gt; LENS_INFO_AVAILABLE_APERTURES = new Key&lt;float[]&gt;("android.lens.info.availableApertures", float[].class); // 中性密度滤镜值列表 public static final Key&lt;float[]&gt; LENS_INFO_AVAILABLE_FILTER_DENSITIES = new Key&lt;float[]&gt;("android.lens.info.availableFilterDensities", float[].class); // 焦距长度列表 public static final Key&lt;float[]&gt; LENS_INFO_AVAILABLE_FOCAL_LENGTHS = new Key&lt;float[]&gt;("android.lens.info.availableFocalLengths", float[].class); // 光学防抖模式列表 public static final Key&lt;int[]&gt; LENS_INFO_AVAILABLE_OPTICAL_STABILIZATION = new Key&lt;int[]&gt;("android.lens.info.availableOpticalStabilization", int[].class); // 镜头焦距校准质量 public static final Key&lt;Integer&gt; LENS_INFO_FOCUS_DISTANCE_CALIBRATION= new Key&lt;Integer&gt;("android.lens.info.focusDistanceCalibration", int.class); // 镜头超焦距 public static final Key&lt;Float&gt; LENS_INFO_HYPERFOCAL_DISTANCE = new Key&lt;Float&gt;("android.lens.info.hyperfocalDistance", float.class); // 镜头进入清晰焦点的最短距离 public static final Key&lt;Float&gt; LENS_INFO_MINIMUM_FOCUS_DISTANCE = new Key&lt;Float&gt;("android.lens.info.minimumFocusDistance", float.class); // 镜头固有的校准参数 public static final Key&lt;float[]&gt; LENS_INTRINSIC_CALIBRATION = new Key&lt;float[]&gt;("android.lens.intrinsicCalibration", float[].class); // 不同的校准方法或校准用例，产生最好或最坏结果依赖于选取区域 public static final Key&lt;Integer&gt; LENS_POSE_REFERENCE=...; // 镜头坐标体系的方向 public static final Key&lt;float[]&gt; LENS_POSE_ROTATION = new Key&lt;float[]&gt;("android.lens.poseRotation", float[].class); // 镜头光学中心位置 public static final Key&lt;float[]&gt; LENS_POSE_TRANSLATION = new Key&lt;float[]&gt;("android.lens.poseTranslation", float[].class); // 降级，使用 LENS_DISTORTION 替代 public static final Key&lt;float[]&gt; LENS_RADIAL_DISTORTION = new Key&lt;float[]&gt;("android.lens.radialDistortion", float[].class); // 多传感器时间戳同步类型 public static final Key&lt;Integer&gt; LOGICAL_MULTI_CAMERA_SENSOR_SYNC_TYPE=.; // 降噪模式列表 public static final Key&lt;int[]&gt; NOISE_REDUCTION_AVAILABLE_NOISE_REDUCTION_MODES = new Key&lt;int[]&gt;( "android.noiseReduction.availableNoiseReductionModes", int[].class); // 最大的停顿时间 public static final Key&lt;Integer&gt; REPROCESS_MAX_CAPTURE_STALL = new Key&lt;Integer&gt;("android.reprocess.maxCaptureStall", int.class); // 相机支持的功能列表 public static final Key&lt;int[]&gt; REQUEST_AVAILABLE_CAPABILITIES = new Key&lt;int[]&gt;("android.request.availableCapabilities", int[].class); // 最大输入流 public static final Key&lt;Integer&gt; REQUEST_MAX_NUM_INPUT_STREAMS = new Key&lt;Integer&gt;("android.request.maxNumInputStreams", int.class); // 最大输出流（并发） public static final Key&lt;Integer&gt; REQUEST_MAX_NUM_OUTPUT_PROC = new Key&lt;Integer&gt;("android.request.maxNumOutputProc", int.class); // 最大输出流（同步） public static final Key&lt;Integer&gt; REQUEST_MAX_NUM_OUTPUT_PROC_STALLING = new Key&lt;Integer&gt;("android.request.maxNumOutputProcStalling", int.class); // RAW 格式最大输出流 public static final Key&lt;Integer&gt; REQUEST_MAX_NUM_OUTPUT_RAW = new Key&lt;Integer&gt;("android.request.maxNumOutputRaw", int.class); // 定义输出结果可以有多少个子结果 public static final Key&lt;Integer&gt; REQUEST_PARTIAL_RESULT_COUNT = new Key&lt;Integer&gt;("android.request.partialResultCount", int.class); // 最大管道深度 public static final Key&lt;Byte&gt; REQUEST_PIPELINE_MAX_DEPTH = new Key&lt;Byte&gt;("android.request.pipelineMaxDepth", byte.class); // 最大数字变焦比率 public static final Key&lt;Float&gt; SCALER_AVAILABLE_MAX_DIGITAL_ZOOM = new Key&lt;Float&gt;("android.scaler.availableMaxDigitalZoom", float.class); // 支持的裁剪类型 public static final Key&lt;Integer&gt; SCALER_CROPPING_TYPE = new Key&lt;Integer&gt;("android.scaler.croppingType", int.class); // 图像格式对应的输出配置表 public static final Key&lt; android.hardware.camera2.params.StreamConfigurationMap&gt; SCALER_STREAM_CONFIGURATION_MAP = new Key&lt;android.hardware.camera2.params.StreamConfigurationMap&gt;( "android.scaler.streamConfigurationMap", android.hardware.camera2.params.StreamConfigurationMap.class); // 传感器测试图案列表 public static final Key&lt;int[]&gt; SENSOR_AVAILABLE_TEST_PATTERN_MODES = new Key&lt;int[]&gt;("android.sensor.availableTestPatternModes", int[].class); // 滤色器阵列马赛克通道的零光值（黑电平） public static final Key&lt; android.hardware.camera2.params.BlackLevelPattern&gt; SENSOR_BLACK_LEVEL_PATTERN = new Key&lt;android.hardware.camera2.params.BlackLevelPattern&gt;( "android.sensor.blackLevelPattern", android.hardware.camera2.params.BlackLevelPattern.class); // 第一参考光源，校准变换矩阵 public static final Key&lt; android.hardware.camera2.params.ColorSpaceTransform&gt; SENSOR_CALIBRATION_TRANSFORM1 = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.sensor.calibrationTransform1", android.hardware.camera2.params.ColorSpaceTransform.class); // 第二参考光源，校准变换矩阵 public static final Key&lt; android.hardware.camera2.params.ColorSpaceTransform&gt; SENSOR_CALIBRATION_TRANSFORM2 = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.sensor.calibrationTransform2", android.hardware.camera2.params.ColorSpaceTransform.class); // 第一参考光源，颜色转换矩阵 public static final Key&lt; android.hardware.camera2.params.ColorSpaceTransform&gt; SENSOR_COLOR_TRANSFORM1 = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.sensor.colorTransform1", ndroid.hardware.camera2.params.ColorSpaceTransform.class); // 第二参考光源，颜色转换矩阵 public static final Key&lt; android.hardware.camera2.params.ColorSpaceTransform&gt; SENSOR_COLOR_TRANSFORM2 = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.sensor.colorTransform2", android.hardware.camera2.params.ColorSpaceTransform.class); // 第一参考光源，使用 D50 白点的颜色转换矩阵 public static final Key&lt; android.hardware.camera2.params.ColorSpaceTransform&gt; SENSOR_FORWARD_MATRIX1 = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.sensor.forwardMatrix1", android.hardware.camera2.params.ColorSpaceTransform.class); // 第二参考光源，使用 D50 白点的颜色转换矩阵 public static final Key&lt; android.hardware.camera2.params.ColorSpaceTransform&gt; SENSOR_FORWARD_MATRIX2 = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.sensor.forwardMatrix2", android.hardware.camera2.params.ColorSpaceTransform.class); // 使用几何失真校准的矩形大小 public static final Key&lt;android.graphics.Rect&gt; SENSOR_INFO_ACTIVE_ARRAY_SIZE = new Key&lt;android.graphics.Rect&gt;( "android.sensor.info.activeArraySize", android.graphics.Rect.class); // 滤色镜排布 public static final Key&lt;Integer&gt; SENSOR_INFO_COLOR_FILTER_ARRANGEMENT = new Key&lt;Integer&gt;("android.sensor.info.colorFilterArrangement", int.class); // 图像曝光时间范围 public static final Key&lt;android.util.Range&lt;Long&gt;&gt; SENSOR_INFO_EXPOSURE_TIME_RANGE = new Key&lt;android.util.Range&lt;Long&gt;&gt;( "android.sensor.info.exposureTimeRange", new TypeReference&lt;android.util.Range&lt;Long&gt;&gt;() &#123;&#123; &#125;&#125;); // 摄像头原始图像输出是否受镜头阴影矫正 public static final Key&lt;Boolean&gt; SENSOR_INFO_LENS_SHADING_APPLIED = new Key&lt;Boolean&gt;("android.sensor.info.lensShadingApplied", boolean.class); // 最大帧间隔（最小帧率） public static final Key&lt;Long&gt; SENSOR_INFO_MAX_FRAME_DURATION = new Key&lt;Long&gt;("android.sensor.info.maxFrameDuration", long.class); // 全像素数组的物理尺寸 public static final Key&lt;android.util.SizeF&gt; SENSOR_INFO_PHYSICAL_SIZE = new Key&lt;android.util.SizeF&gt;("android.sensor.info.physicalSize", android.util.SizeF.class); // 全像素数组的维度，包括黑色校准像素 public static final Key&lt;android.util.Size&gt; SENSOR_INFO_PIXEL_ARRAY_SIZE= new Key&lt;android.util.Size&gt;("android.sensor.info.pixelArraySize", android.util.Size.class); // 几何失真校准的有效区域 public static final Key&lt;android.graphics.Rect&gt; SENSOR_INFO_PRE_CORRECTION_ACTIVE_ARRAY_SIZE = new Key&lt;android.graphics.Rect&gt;( "android.sensor.info.preCorrectionActiveArraySize", android.graphics.Rect.class); // ISO 感光度范围 public static final Key&lt;android.util.Range&lt;Integer&gt;&gt; SENSOR_INFO_SENSITIVITY_RANGE = new Key&lt;android.util.Range&lt;Integer&gt;&gt;( "android.sensor.info.sensitivityRange", new TypeReference&lt;android.util.Range&lt;Integer&gt;&gt;() &#123;&#123; &#125;&#125;); // 传感器开始捕获时间戳的时基源 public static final Key&lt;Integer&gt; SENSOR_INFO_TIMESTAMP_SOURCE = new Key&lt;Integer&gt;("android.sensor.info.timestampSource", int.class); // 传感器最大输出的原始数值 public static final Key&lt;Integer&gt; SENSOR_INFO_WHITE_LEVEL = new Key&lt;Integer&gt;("android.sensor.info.whiteLevel", int.class); // 通过模拟增益获得的最大灵敏度 public static final Key&lt;Integer&gt; SENSOR_MAX_ANALOG_SENSITIVITY = new Key&lt;Integer&gt;("android.sensor.maxAnalogSensitivity", int.class); // 传感器光学屏蔽的黑色像素不相交区域 public static final Key&lt;android.graphics.Rect[]&gt; SENSOR_OPTICAL_BLACK_REGIONS = new Key&lt;android.graphics.Rect[]&gt;( "android.sensor.opticalBlackRegions", android.graphics.Rect[].class); // 输出图像与屏幕垂直所需要的顺时针角度 public static final Key&lt;Integer&gt; SENSOR_ORIENTATION = new Key&lt;Integer&gt;("android.sensor.orientation", int.class); // 标准参考光源 1 public static final Key&lt;Integer&gt; SENSOR_REFERENCE_ILLUMINANT1 = new Key&lt;Integer&gt;("android.sensor.referenceIlluminant1", int.class); // 标准参考光源 2 public static final Key&lt;Byte&gt; SENSOR_REFERENCE_ILLUMINANT2 = new Key&lt;Byte&gt;("android.sensor.referenceIlluminant2", byte.class); // 镜头均匀性，阴影校准模式 public static final Key&lt;int[]&gt; SHADING_AVAILABLE_MODES = new Key&lt;int[]&gt;("android.shading.availableModes", int[].class); // 人脸识别模式模式 public static final Key&lt;int[]&gt; STATISTICS_INFO_AVAILABLE_FACE_DETECT_MODES = new Key&lt;int[]&gt;("android.statistics.info.availableFaceDetectModes", int[].class); // 热点映射模式 public static final Key&lt;boolean[]&gt; STATISTICS_INFO_AVAILABLE_HOT_PIXEL_MAP_MODES = new Key&lt;boolean[]&gt;( "android.statistics.info.availableHotPixelMapModes", boolean[].class); // 镜头阴影校准映表模式 public static final Key&lt;int[]&gt; STATISTICS_INFO_AVAILABLE_LENS_SHADING_MAP_MODES = new Key&lt;int[]&gt;( "android.statistics.info.availableLensShadingMapModes", int[].class); // 光学防抖位置数据模式public static final Key&lt;int[]&gt; STATISTICS_INFO_AVAILABLE_OIS_DATA_MODES=.; // 同时可检测的最大人脸数 public static final Key&lt;Integer&gt; STATISTICS_INFO_MAX_FACE_COUNT = new Key&lt;Integer&gt;("android.statistics.info.maxFaceCount", int.class); // 最大同步延迟数 public static final Key&lt;Integer&gt; SYNC_MAX_LATENCY = new Key&lt;Integer&gt;("android.sync.maxLatency", int.class); // 色调映射模式 public static final Key&lt;int[]&gt; TONEMAP_AVAILABLE_TONE_MAP_MODES = new Key&lt;int[]&gt;("android.tonemap.availableToneMapModes", int[].class); // 色调映射曲线支持的最大数量点 public static final Key&lt;Integer&gt; TONEMAP_MAX_CURVE_POINTS = new Key&lt;Integer&gt;("android.tonemap.maxCurvePoints", int.class); API 方法CameraCharacteristics 支持的方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public final class CameraCharacteristics extends CameraMetadata&lt;CameraCharacteristics.Key&lt;?&gt;&gt; &#123; private final CameraMetadataNative mProperties; private List&lt;CameraCharacteristics.Key&lt;?&gt;&gt; mKeys; private List&lt;CaptureRequest.Key&lt;?&gt;&gt; mAvailableRequestKeys; private List&lt;CaptureResult.Key&lt;?&gt;&gt; mAvailableResultKeys; public &lt;T&gt; T get(Key&lt;T&gt; key) &#123; return mProperties.get(key); &#125; // 获取相机支持的请求列表 public List&lt;CaptureRequest.Key&lt;?&gt;&gt; getAvailableCaptureRequestKeys() &#123; if (mAvailableRequestKeys == null) &#123; Object crKey = CaptureRequest.Key.class; Class&lt;CaptureRequest.Key&lt;?&gt;&gt; crKeyTyped = (Class&lt;CaptureRequest.Key&lt;?&gt;&gt;)crKey; int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS); if (filterTags == null) &#123; throw new AssertionError("..."); &#125; mAvailableRequestKeys = getAvailableKeyList( CaptureRequest.class, crKeyTyped, filterTags); &#125; return mAvailableRequestKeys; &#125; // 获取相机支持的结果列表 public List&lt;CaptureResult.Key&lt;?&gt;&gt; getAvailableCaptureResultKeys() &#123; if (mAvailableResultKeys == null) &#123; Object crKey = CaptureResult.Key.class; Class&lt;CaptureResult.Key&lt;?&gt;&gt; crKeyTyped = (Class&lt;CaptureResult.Key&lt;?&gt;&gt;)crKey; int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS); if (filterTags == null) &#123; throw new AssertionError("..."); &#125; mAvailableResultKeys = getAvailableKeyList( CaptureResult.class, crKeyTyped, filterTags); &#125; return mAvailableResultKeys; &#125; // getAvailableCaptureRequestKeys 的子集 public List&lt;CaptureRequest.Key&lt;?&gt;&gt; getAvailablePhysicalCameraRequestKeys()&#123;...&#125; // getAvailableCaptureRequestKeys 的子集 public List&lt;CaptureRequest.Key&lt;?&gt;&gt; getAvailableSessionKeys() &#123;&#125; public List&lt;Key&lt;?&gt;&gt; getKeys() &#123; // List of keys is immutable; // cache the results after we calculate them if (mKeys != null) &#123; return mKeys; &#125; int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS); if (filterTags == null) &#123; throw new AssertionError("..."); &#125; mKeys = Collections.unmodifiableList( getKeys(getClass(), getKeyClass(), this, filterTags)); return mKeys; &#125; Set&lt;String&gt; getPhysicalCameraIds()&#123;...&#125; ...&#125; CaptureRequestCaptureRequest 继承了 CameraMetadata ；表示从 CameraDevice 获取捕获数据的请求，包含对 CameraDevice 的参数设置，算法控制，输出缓冲区等等。 创建实例由 CameraDevice.createCaptureRequest 返回的 CaptureRequest.Builder 来创建实例。 请求由 CameraCaptureSession.capture, CameraCaptureSession.setRepeatingRequest 向 CameraDevice 发出请求。 Key 常量CaptureRequest 支持的 Key 常量及其含义，这些值都是 system/media/camera/docs 自动生成的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206// 黑电平补偿是否锁定当前值；对于某些参数（曝光时间）的改变需要重置黑电平 public static final Key&lt;Boolean&gt; BLACK_LEVEL_LOCK = new Key&lt;Boolean&gt;("android.blackLevel.lock", boolean.class);// 色差校准算法的操作模式public static final Key&lt;Integer&gt; COLOR_CORRECTION_ABERRATION_MODE = new Key&lt;Integer&gt;("android.colorCorrection.aberrationMode" , int.class);// 适用于 Bayer 原色通道的白平衡增益public static final Key&lt;android.hardware.camera2.params.RggbChannelVector&gt; COLOR_CORRECTION_GAINS = new Key&lt;android.hardware.camera2.params.RggbChannelVector&gt; ("android.colorCorrection.gains", android.hardware.camera2.params.RggbChannelVector.class);// 原始颜色转换为 sRGB 时的颜色校准模式；当 AWE 开启时，该值不会生效public static final Key&lt;Integer&gt; COLOR_CORRECTION_MODE = new Key&lt;Integer&gt;("android.colorCorrection.mode", int.class);// 颜色校准转换矩阵public static final Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt; COLOR_CORRECTION_TRANSFORM = new Key&lt;android.hardware.camera2.params.ColorSpaceTransform&gt;( "android.colorCorrection.transform", android.hardware.camera2.params.ColorSpaceTransform.class);// 工频干扰模式，自动曝光时需要设置反馈补偿public static final Key&lt;Integer&gt; CONTROL_AE_ANTIBANDING_MODE = new Key&lt;Integer&gt;("android.control.aeAntibandingMode", int.class);// 调整自动曝光图像亮度的补偿值public static final Key&lt;Integer&gt; CONTROL_AE_EXPOSURE_COMPENSATION = new Key&lt;Integer&gt;("android.control.aeExposureCompensation", int.class);// 自动曝光当前是否锁定public static final Key&lt;Boolean&gt; CONTROL_AE_LOCK = new Key&lt;Boolean&gt;("android.control.aeLock", boolean.class);// 自动曝光的控制模式public static final Key&lt;Integer&gt; CONTROL_AE_MODE = new Key&lt;Integer&gt;("android.control.aeMode", int.class);// 自动曝光测光序列开关public static final Key&lt;Integer&gt; CONTROL_AE_PRECAPTURE_TRIGGER = new Key&lt;Integer&gt;("android.control.aePrecaptureTrigger", int.class);// 自动曝光测光区域列表public static final Key&lt;android.hardware.camera2.params.MeteringRectangle[]&gt; CONTROL_AE_REGIONS = new Key&lt;android.hardware.camera2.params.MeteringRectangle[]&gt;( "android.control.aeRegions", android.hardware.camera2.params.MeteringRectangle[].class);// 自动曝光调整帧率来保持良好的曝光范围public static final Key&lt;android.util.Range&lt;Integer&gt;&gt; CONTROL_AE_TARGET_FPS_RANGE = new Key&lt;android.util.Range&lt;Integer&gt;&gt;( "android.control.aeTargetFpsRange", new TypeReference&lt;android.util.Range&lt;Integer&gt;&gt;() &#123;&#123; &#125;&#125;);// 自动对焦模式public static final Key&lt;Integer&gt; CONTROL_AF_MODE = new Key&lt;Integer&gt;("android.control.afMode", int.class);// 自动对焦计量区域列表public static final Key&lt;android.hardware.camera2.params.MeteringRectangle[]&gt; CONTROL_AF_REGIONS = new Key&lt;android.hardware.camera2.params.MeteringRectangle[]&gt;( "android.control.afRegions", android.hardware.camera2.params.MeteringRectangle[].class);// 自动对焦开关public static final Key&lt;Integer&gt; CONTROL_AF_TRIGGER = new Key&lt;Integer&gt;("android.control.afTrigger", int.class);// 自动白平衡是否锁定public static final Key&lt;Boolean&gt; CONTROL_AWB_LOCK = new Key&lt;Boolean&gt;("android.control.awbLock", boolean.class);// 自动白平衡的模式public static final Key&lt;Integer&gt; CONTROL_AWB_MODE = new Key&lt;Integer&gt;("android.control.awbMode", int.class);// 自动白平衡，光源估计的测量区域列表public static final Key&lt;android.hardware.camera2.params.MeteringRectangle[]&gt; CONTROL_AWB_REGIONS = new Key&lt;android.hardware.camera2.params.MeteringRectangle[]&gt;( "android.control.awbRegions", android.hardware.camera2.params.MeteringRectangle[].class);// 设置捕获图像信息时的控制意图，比如 3A 算法等public static final Key&lt;Integer&gt; CONTROL_CAPTURE_INTENT = new Key&lt;Integer&gt;("android.control.captureIntent", int.class);// 设置颜色效果模式public static final Key&lt;Integer&gt; CONTROL_EFFECT_MODE = new Key&lt;Integer&gt;("android.control.effectMode", int.class);// 是否开启 ZSLpublic static final Key&lt;Boolean&gt; CONTROL_ENABLE_ZSL = new Key&lt;Boolean&gt;("android.control.enableZsl", boolean.class);// 设置控制模式，手动、自动等public static final Key&lt;Integer&gt; CONTROL_MODE = new Key&lt;Integer&gt;("android.control.mode", int.class);// 设置传感器捕获数据后，灵敏度增强public static final Key&lt;Integer&gt; CONTROL_POST_RAW_SENSITIVITY_BOOST = new Key&lt;Integer&gt;("android.control.postRawSensitivityBoost", int.class);// 设置场景模式public static final Key&lt;Integer&gt; CONTROL_SCENE_MODE = new Key&lt;Integer&gt;("android.control.sceneMode", int.class);// 设置录像防抖模式public static final Key&lt;Integer&gt; CONTROL_VIDEO_STABILIZATION_MODE = new Key&lt;Integer&gt;("android.control.videoStabilizationMode", int.class);// 设置失真校准模式public static final Key&lt;Integer&gt; DISTORTION_CORRECTION_MODE = ...;// 设置边缘增强模式public static final Key&lt;Integer&gt; EDGE_MODE = new Key&lt;Integer&gt;("android.edge.mode", int.class);// 设置闪光灯模式，手电筒等public static final Key&lt;Integer&gt; FLASH_MODE = new Key&lt;Integer&gt;("android.flash.mode", int.class);// 设置热点校正模式public static final Key&lt;Integer&gt; HOT_PIXEL_MODE = new Key&lt;Integer&gt;("android.hotPixel.mode", int.class);// 生成图像的 GPS 元数据时，使用位置信息public static final Key&lt;android.location.Location&gt; JPEG_GPS_LOCATION = new Key&lt;android.location.Location&gt;("android.jpeg.gpsLocation", android.location.Location.class);// JPEG 图像的旋转方向public static final Key&lt;Integer&gt; JPEG_ORIENTATION = new Key&lt;Integer&gt;("android.jpeg.orientation", int.class);// JPEG 图像的质量，典型值为 85-95 public static final Key&lt;Byte&gt; JPEG_QUALITY = new Key&lt;Byte&gt;("android.jpeg.quality", byte.class);// JPEG 缩略图的质量 1-100public static final Key&lt;Byte&gt; JPEG_THUMBNAIL_QUALITY = new Key&lt;Byte&gt;("android.jpeg.thumbnailQuality", byte.class);// JPEG 缩略图分辨率public static final Key&lt;android.util.Size&gt; JPEG_THUMBNAIL_SIZE = new Key&lt;android.util.Size&gt;("android.jpeg.thumbnailSize", android.util.Size.class);// 镜头光圈大小public static final Key&lt;Float&gt; LENS_APERTURE = new Key&lt;Float&gt;("android.lens.aperture", float.class);// 镜头滤光片密度public static final Key&lt;Float&gt; LENS_FILTER_DENSITY = new Key&lt;Float&gt;("android.lens.filterDensity", float.class);// 镜头光学变焦焦距public static final Key&lt;Float&gt; LENS_FOCAL_LENGTH = new Key&lt;Float&gt;("android.lens.focalLength", float.class);// 镜头到最清晰焦点的距离public static final Key&lt;Float&gt; LENS_FOCUS_DISTANCE = new Key&lt;Float&gt;("android.lens.focusDistance", float.class);// 设置镜头光学防抖模式public static final Key&lt;Integer&gt; LENS_OPTICAL_STABILIZATION_MODE = new Key&lt;Integer&gt;("android.lens.opticalStabilizationMode", int.class);// 设置降噪模式public static final Key&lt;Integer&gt; NOISE_REDUCTION_MODE = new Key&lt;Integer&gt;("android.noiseReduction.mode", int.class);// 重复处理前，原始帧的曝光因子public static final Key&lt;Float&gt; REPROCESS_EFFECTIVE_EXPOSURE_FACTOR = new Key&lt;Float&gt;("android.reprocess.effectiveExposureFactor", float.class);// 设置裁剪区域，可用于数字变焦public static final Key&lt;android.graphics.Rect&gt; SCALER_CROP_REGION = new Key&lt;android.graphics.Rect&gt;("android.scaler.cropRegion", android.graphics.Rect.class);// 传感器自动曝光时间public static final Key&lt;Long&gt; SENSOR_EXPOSURE_TIME = new Key&lt;Long&gt;("android.sensor.exposureTime", long.class);// 从帧曝光开始到下一帧曝光的间隔时间public static final Key&lt;Long&gt; SENSOR_FRAME_DURATION = new Key&lt;Long&gt;("android.sensor.frameDuration", long.class);// 传感器 ISO 感光度public static final Key&lt;Integer&gt; SENSOR_SENSITIVITY = new Key&lt;Integer&gt;("android.sensor.sensitivity", int.class);// 传感器测试模式序列数据 [R, G_even, G_odd, B]public static final Key&lt;int[]&gt; SENSOR_TEST_PATTERN_DATA = new Key&lt;int[]&gt;("android.sensor.testPatternData", int[].class);// 传感器测试模图案模式public static final Key&lt;Integer&gt; SENSOR_TEST_PATTERN_MODE = new Key&lt;Integer&gt;("android.sensor.testPatternMode", int.class);// 镜头阴影校正模式public static final Key&lt;Integer&gt; SHADING_MODE = new Key&lt;Integer&gt;("android.shading.mode", int.class);// 人脸检测模式public static final Key&lt;Integer&gt; STATISTICS_FACE_DETECT_MODE = new Key&lt;Integer&gt;("android.statistics.faceDetectMode", int.class);// 热点映射模式开关public static final Key&lt;Boolean&gt; STATISTICS_HOT_PIXEL_MAP_MODE = new Key&lt;Boolean&gt;("android.statistics.hotPixelMapMode", boolean.class);// 镜头阴影校正映射开关public static final Key&lt;Integer&gt; STATISTICS_LENS_SHADING_MAP_MODE = new Key&lt;Integer&gt;("android.statistics.lensShadingMapMode", int.class);// 光学防抖数据模式public static final Key&lt;Integer&gt; STATISTICS_OIS_DATA_MODE = ...;// 色调映射曲线public static final Key&lt;android.hardware.camera2.params.TonemapCurve&gt; TONEMAP_CURVE = new Key&lt;android.hardware.camera2.params.TonemapCurve&gt;( "android.tonemap.curve", android.hardware.camera2.params.TonemapCurve.class);// 色调映射曲线伽马值public static final Key&lt;Float&gt; TONEMAP_GAMMA = new Key&lt;Float&gt;("android.tonemap.gamma", float.class);// 色调映射模式public static final Key&lt;Integer&gt; TONEMAP_MODE = new Key&lt;Integer&gt;("android.tonemap.mode", int.class);// 色调映射预设曲线public static final Key&lt;Integer&gt; TONEMAP_PRESET_CURVE = new Key&lt;Integer&gt;("android.tonemap.presetCurve", int.class); API 方法CaptureRequest 中 API 简介： 123456789101112131415161718192021222324252627282930public final class CaptureRequest extends CameraMetadata&lt;CaptureRequest.Key&lt;?&gt;&gt; implements Parcelable &#123; private final HashSet&lt;Surface&gt; mSurfaceSet; private final CameraMetadataNative mSettings; private boolean mIsReprocess; private boolean mIsPartOfCHSRequestList = false; private int mReprocessableSessionId; private Object mUserTag; ... // 获取键对应的值 public &lt;T&gt; T get(Key&lt;T&gt; key) &#123; return mSettings.get(key); &#125; // 获取所有的键值列表 public List&lt;Key&lt;?&gt;&gt; getKeys() &#123; return super.getKeys(); &#125; // 当前请求的 tag 信息 public Object getTag() &#123; return mUserTag; &#125; // 是否是在重新处理请求 public boolean isReprocess() &#123; return mIsReprocess; &#125; ...&#125; Builder 内部类CaptureRequest.Builder 内部类，建造者模式，用于创建 CaptureRequest 实例。 12345678910111213141516171819202122232425262728293031323334353637public final static class Builder &#123; private final CaptureRequest mRequest; public Builder(CameraMetadataNative template, boolean reprocess, int reprocessableSessionId) &#123; mRequest = new CaptureRequest(template, reprocess, reprocessableSessionId); &#125; // 添加输出目标 public void addTarget(@NonNull Surface outputTarget) &#123; mRequest.mSurfaceSet.add(outputTarget); &#125; public void removeTarget(@NonNull Surface outputTarget) &#123; mRequest.mSurfaceSet.remove(outputTarget); &#125; // 设置键值对 public &lt;T&gt; void set(@NonNull Key&lt;T&gt; key, T value) &#123; mRequest.mSettings.set(key, value); &#125; public &lt;T&gt; T get(Key&lt;T&gt; key) &#123; return mRequest.mSettings.get(key); &#125; public void setTag(@Nullable Object tag) &#123; mRequest.mUserTag = tag; &#125; public CaptureRequest build() &#123; return new CaptureRequest(mRequest); &#125; public boolean isEmpty() &#123; return mRequest.mSettings.isEmpty(); &#125; public T getPhysicalCameraKey (Key&lt;T&gt; key, String physicalCameraId)&#123;...&#125; public CaptureRequest.Builder setPhysicalCameraKey (Key&lt;T&gt; key, T value, String physicalCameraId)&#123;...&#125; ...&#125; Key 内部类CaptureRequest.Key&lt;T&gt; 内部类，用于设置参数时的 Key 值。 12345678910111213public final static class Key&lt;T&gt; &#123; private final CameraMetadataNative.Key&lt;T&gt; mKey; public Key(String name, Class&lt;T&gt; type, long vendorId) &#123; mKey = new CameraMetadataNative.Key&lt;T&gt;(name, type, vendorId); &#125; ... // 获取键值名称 public String getName() &#123; return mKey.getName(); &#125; ...&#125; CaptureResultCaptureResult 继承了 CameraMetadata ；表示从 CameraDevice 获取到数据的结果子集；包含捕获硬件（传感器，镜头，闪存），控制算法和输出缓冲区的最终配置等的子集；CaptureResult 对象实例是不可变的。 Key 常量通过对比代码 CaptureRequest, CaptureResult 两份代码大部分都相同，特别是 Key 常量的定义（都是在 system/media/camera/docs 中通过脚本生成），CaptureResult 仅仅是新增了几个常量： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182...// 自动曝光算法当前状态：搜索，锁定，转换等等public static final Key&lt;Integer&gt; CONTROL_AE_STATE = new Key&lt;Integer&gt;("android.control.aeState", int.class);// 自动对焦算法当前状态：激活，扫描，锁定等等public static final Key&lt;Integer&gt; CONTROL_AF_STATE = new Key&lt;Integer&gt;("android.control.afState", int.class);// 白平衡算法当前状态：激活，搜索，转换，锁定等public static final Key&lt;Integer&gt; CONTROL_AWB_STATE = new Key&lt;Integer&gt;("android.control.awbState", int.class);// 闪光灯当前状态：充电、闪光、装备好等public static final Key&lt;Integer&gt; FLASH_STATE = new Key&lt;Integer&gt;("android.flash.state", int.class);// 景深距离范围public static final Key&lt;android.util.Pair&lt;Float,Float&gt;&gt; LENS_FOCUS_RANGE = new Key&lt;android.util.Pair&lt;Float,Float&gt;&gt;( "android.lens.focusRange", new TypeReference&lt;android.util.Pair&lt;Float,Float&gt;&gt;() &#123;&#123; &#125;&#125;);// 镜头当前状态：移动、平稳public static final Key&lt;Integer&gt; LENS_STATE = new Key&lt;Integer&gt;("android.lens.state", int.class);// 镜头坐标体系的方向public static final Key&lt;float[]&gt; LENS_POSE_ROTATION = new Key&lt;float[]&gt;("android.lens.poseRotation", float[].class);// 镜头光学中心位置public static final Key&lt;float[]&gt; LENS_POSE_TRANSLATION = new Key&lt;float[]&gt;("android.lens.poseTranslation", float[].class);// 镜头固有的校准参数public static final Key&lt;float[]&gt; LENS_INTRINSIC_CALIBRATION = new Key&lt;float[]&gt;("android.lens.intrinsicCalibration", float[].class);// 降级，使用 LENS_DISTORTION 代替public static final Key&lt;float[]&gt; LENS_RADIAL_DISTORTION = new Key&lt;float[]&gt;("android.lens.radialDistortion", float[].class);// 请求的管道深度public static final Key&lt;Byte&gt; REQUEST_PIPELINE_DEPTH = new Key&lt;Byte&gt;("android.request.pipelineDepth", byte.class);// 返回传感器时间戳public static final Key&lt;Long&gt; SENSOR_TIMESTAMP = new Key&lt;Long&gt;("android.sensor.timestamp", long.class);// 传感器色彩空间中估计的中性色public static final Key&lt;Rational[]&gt; SENSOR_NEUTRAL_COLOR_POINT = new Key&lt;Rational[]&gt;("android.sensor.neutralColorPoint", Rational[].class);// 每个 CFA 马赛克通道的噪声模型系数public static final Key&lt;android.util.Pair&lt;Double,Double&gt;[]&gt; SENSOR_NOISE_PROFILE = new Key&lt;android.util.Pair&lt;Double,Double&gt;[]&gt;( "android.sensor.noiseProfile", new TypeReference&lt;android.util.Pair&lt;Double,Double&gt;[]&gt;() &#123;&#123; &#125;&#125;);// Bayer 阵列中绿色通道最差分割的估计值public static final Key&lt;Float&gt; SENSOR_GREEN_SPLIT = new Key&lt;Float&gt;("android.sensor.greenSplit", float.class);// 第一行到最后一行曝光的时间偏差public static final Key&lt;Long&gt; SENSOR_ROLLING_SHUTTER_SKEW = new Key&lt;Long&gt;("android.sensor.rollingShutterSkew", long.class);// 每个滤色器排列 CFA 马赛克通道的每帧动态黑电平偏移public static final Key&lt;float[]&gt; SENSOR_DYNAMIC_BLACK_LEVEL = new Key&lt;float[]&gt;("android.sensor.dynamicBlackLevel", float[].class);// 每个滤色器排列 CFA 马赛克通道的每帧动态白电平偏移public static final Key&lt;Integer&gt; SENSOR_DYNAMIC_WHITE_LEVEL = new Key&lt;Integer&gt;("android.sensor.dynamicWhiteLevel", int.class);//public static final Key&lt;int[]&gt; STATISTICS_FACE_IDS = new Key&lt;int[]&gt;("android.statistics.faceIds", int[].class);// 检测到的人脸列表public static final Key&lt;android.hardware.camera2.params.Face[]&gt; STATISTICS_FACES = new Key&lt;android.hardware.camera2.params.Face[]&gt;( "android.statistics.faces", android.hardware.camera2.params.Face[].class);// 镜头阴影校正映射图public static final Key&lt;android.hardware.camera2.params.LensShadingMap&gt; STATISTICS_LENS_SHADING_CORRECTION_MAP = new Key&lt;android.hardware.camera2.params.LensShadingMap&gt;( "android.statistics.lensShadingCorrectionMap", android.hardware.camera2.params.LensShadingMap.class);// 传感器估计的灯源照明频率public static final Key&lt;Integer&gt; STATISTICS_SCENE_FLICKER = new Key&lt;Integer&gt;("android.statistics.sceneFlicker", int.class);// 热点映射区域public static final Key&lt;android.graphics.Point[]&gt; STATISTICS_HOT_PIXEL_MAP = new Key&lt;android.graphics.Point[]&gt;( "android.statistics.hotPixelMap", android.graphics.Point[].class); API 方法CaptureResult 中 API 简介： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class CaptureResult extends CameraMetadata&lt;CaptureResult.Key&lt;?&gt;&gt; &#123; private final CameraMetadataNative mResults; private final CaptureRequest mRequest; private final int mSequenceId; private final long mFrameNumber; public CaptureResult(CameraMetadataNative results, CaptureRequest parent, CaptureResultExtras extras) &#123; ... mResults = CameraMetadataNative.move(results); if (mResults.isEmpty()) &#123; throw new AssertionError("Results must not be empty"); &#125; setNativeInstance(mResults); mRequest = parent; mSequenceId = extras.getRequestId(); mFrameNumber = extras.getFrameNumber(); &#125; // 获取键对应的值 public &lt;T&gt; T get(Key&lt;T&gt; key) &#123; T value = mResults.get(key); return value; &#125; // 获取键列表 public List&lt;Key&lt;?&gt;&gt; getKeys() &#123; return super.getKeys(); &#125; // 获取当前结果的请求 CaptureRequest public CaptureRequest getRequest() &#123; return mRequest; &#125; // 获取当前结果的帧号 public long getFrameNumber() &#123; return mFrameNumber; &#125; // 获取序列号；该序列号为 CameraCaptureSession.capture 的返回值 public int getSequenceId() &#123; return mSequenceId; &#125; ...&#125; CaptureResult.Key 和 CaptureRequest.Key 代码几乎一样，主要是提供一个 Key 封装。 TotalCaptureResultTotalCaptureResult 继承了 CaptureResult ；表示传感器捕获的单个图像组成的结果集合。在 CaptureCallback.onCaptureCompleted 回调后，会返回 TotalCaptureResult 总的捕获结果集合。部分源码如下： 123456789101112131415public final class TotalCaptureResult extends CaptureResult &#123; private final List&lt;CaptureResult&gt; mPartialResults; private final int mSessionId; ... // 获取结果集 public List&lt;CaptureResult&gt; getPartialResults() &#123; return Collections.unmodifiableList(mPartialResults); &#125; // 获取当前结果集的会话 ID public int getSessionId() &#123; return mSessionId; &#125;&#125; DngCreatorDngCreator 用于将传感器捕获到的原始图像数据转换为 DNG 格式图片，图片相关处理的方法都是 native 的。 12345678910111213141516171819202122232425public final class DngCreator implements AutoCloseable &#123; // 缩略图最大尺寸 public static final int MAX_THUMBNAIL_DIMENSION = 256; // 根据配置文件 CameraCharacteristics 和捕获结果 CaptureResult // 生成 DNG 图片 public DngCreator (CameraCharacteristics characteristics, CaptureResult metadata)&#123;...&#125; public void close()&#123;...&#125; // 设置图片描述 public DngCreator setDescription(String description)&#123;...&#125; // 设置位置信息 public DngCreator setLocation(Location location)&#123;...&#125; // 设置图片旋转方向 public DngCreator setOrientation(int orientation)&#123;...&#125; // 创建缩略图 public DngCreator setThumbnail(Image pixels)&#123;...&#125; public DngCreator setThumbnail(Bitmap pixels)&#123;...&#125; // 将原始像素中元数据写入 DNG 图片 public void writeByteBuffer (OutputStream dngOutput, Size size, ByteBuffer pixels, long offset)&#123;...&#125; public void writeImage (OutputStream dngOutput, Image pixels)&#123;...&#125; public void writeInputStream (OutputStream dngOutput, Size size, InputStream pixels, long offset)&#123;...&#125;&#125; 示例TextureView 输出显示通过 TextureView 来显示捕获的数据；需要监听 TextureView.SurfaceTextureListener ，当输出 onSurfaceTextureAvailable 可用时，才能向 CameraDevice 请求数据输出。 12345678910111213141516171819202122232425262728293031private TextureView mTextureView;private Surface mTextureSurface;protected void onResume() &#123; super.onResume(); if (mTextureView.isAvailable())&#123; openCamera(); &#125; else &#123; mTextureView.setSurfaceTextureListener(mSurfaceTextureListener); &#125;&#125;private TextureView.SurfaceTextureListener mSurfaceTextureListener = new TextureView.SurfaceTextureListener() &#123; @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; openCamera(); &#125; @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123;&#125; @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; return true; &#125; @Override public void onSurfaceTextureUpdated(SurfaceTexture surface) &#123;&#125;&#125;; 获取 CameraManager1mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE); 获取后置摄像头 ID 及支持级别通过 CameraCharacteristics 了解设备的属性。 1234567891011121314for (String cameraId : mCameraManager.getCameraIdList()) &#123; CameraCharacteristics cameraCharacteristics = mCameraManager.getCameraCharacteristics(cameraId); // support LEVEL Integer level = cameraCharacteristics.get( CameraCharacteristics.INFO_SUPPORTED_HARDWARE_LEVEL); Log.d(TAG, "preview: cameraId = " + cameraId + ", level = " + level); Integer facing = cameraCharacteristics.get( CameraCharacteristics.LENS_FACING); // rear camera if (facing != null &amp;&amp; facing==CameraCharacteristics.LENS_FACING_BACK)&#123; mCameraId = cameraId; &#125;&#125; 打开 CameraDevice 并设置状态监听打开 CameraDevice 时设置状态监听；在设备正确打开后，在 CameraDevice.StateCallback.onOpened 中创建 CameraCaptureSession 会话。 1234567891011121314151617181920212223242526272829CameraDevice.StateCallback mCameraDeviceStateCallback = new CameraDevice.StateCallback() &#123; @Override public void onOpened(@NonNull CameraDevice camera) &#123; mCameraDevice = camera; // 创建会话 createCameraCaptureSession(); &#125; @Override public void onDisconnected(@NonNull CameraDevice camera) &#123; camera.close(); mCameraDevice = null; &#125; @Override public void onError(@NonNull CameraDevice camera, int error) &#123; camera.close(); mCameraDevice = null; Log.e(TAG, "onError: error = " + error); &#125;&#125;;try &#123; mCameraManager.openCamera(mCameraId, mCameraDeviceStateCallback, mBackHandler);&#125; catch (CameraAccessException e) &#123; e.printStackTrace();&#125; 初始化输出 Surface本示例中有两个 Surface ： TextureView 对应 Surface ：预览时用于实时输出 ImageReader 对应 Surface ：拍照时用于保存图片 1234567891011121314151617181920SurfaceTexture texture = mTextureView.getSurfaceTexture();texture.setDefaultBufferSize(WIDTH, HEIGHT);mTextureSurface = new Surface(texture);mImageReader = ImageReader.newInstance(WIDTH, HEIGHT, ImageFormat.JPEG, 2);// 设置监听事件，当 ImageReader 中可以读取图片时保存文件mImageReader.setOnImageAvailableListener( new ImageReader.OnImageAvailableListener() &#123; @Override public void onImageAvailable(ImageReader reader) &#123; File file = createImageFile(); if (null != file) &#123; mBackHandler.post(new ImageSaveRunnable( reader.acquireNextImage(), file)); &#125; else &#123; Toast.makeText(CustomCamera2Activity.this, "create File error!", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;, mBackHandler); 创建会话 CameraCaptureSession通过 mCameraDevice.createCaptureSession 创建会话成功后，在回调方法 CameraCaptureSession.StateCallback.onConfigured 中获取会话 mCameraCaptureSession ，后续所有的 CaptureRequest 都是通过该会话发起。可以在创建会话成功时，同步开启预览请求 preview 。 1234567891011121314151617181920212223242526private void createCameraCaptureSession() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; try &#123; mCameraDevice.createCaptureSession(Arrays.asList( mTextureSurface, mImageReader.getSurface()), new CameraCaptureSession.StateCallback() &#123; @Override public void onConfigured( @NonNull CameraCaptureSession session) &#123; Log.d(TAG, "onConfigured: "); mCameraCaptureSession = session; // 开启预览请求 preview(); &#125; @Override public void onConfigureFailed( @NonNull CameraCaptureSession session) &#123; Log.e(TAG, "onConfigureFailed: "); &#125; &#125;, null); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 发出预览请求 CaptureRequest预览请求为 CameraDevice.TEMPLATE_PREVIEW ，设置输出为 mTextureSurface ，当捕获到预览数据时，会反复响应 CameraCaptureSession.CaptureCallback ： 123456789101112131415161718192021private void preview()&#123; try &#123; CaptureRequest.Builder previewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW); previewRequestBuilder.addTarget(mTextureSurface); CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureCompleted( @NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; //Log.d(TAG, "preview, onCaptureCompleted: "); &#125; &#125;; mCameraCaptureSession.setRepeatingRequest( previewRequestBuilder.build(), captureCallback, mBackHandler); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125;&#125; 发出拍照请求 CaptureRequest拍照请求为 CameraDevice.TEMPLATE_STILL_CAPTURE ，设置输出为 mImageReader.getSurface() ，当存在有效数据时直接触发 ImageReader.OnImageAvailableListener 。 1234567891011121314151617181920212223242526272829303132private void takePicture()&#123; //mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER, //CameraMetadata.CONTROL_AF_TRIGGER_START); try &#123; CaptureRequest.Builder captureRequestBuild = mCameraDevice .createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE); captureRequestBuild.addTarget(mImageReader.getSurface()); captureRequestBuild.set(CaptureRequest.CONTROL_AF_MODE, CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE); // 配置图片方向 captureRequestBuild.set(CaptureRequest.JPEG_ORIENTATION, mImageOrientation); CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureCompleted( @NonNull CameraCaptureSession session, @NonNull CaptureRequest request, @NonNull TotalCaptureResult result) &#123; Log.d(TAG, "takePicture, onCaptureCompleted: "); Toast.makeText(CustomCamera2Activity.this, "Take Picture, OK!", Toast.LENGTH_SHORT).show(); &#125; &#125;; mCameraCaptureSession.stopRepeating(); mCameraCaptureSession.abortCaptures(); mCameraCaptureSession.capture(captureRequestBuild.build(), captureCallback, mBackHandler); &#125; catch (CameraAccessException e) &#123; e.printStackTrace(); &#125;&#125; 这里需要注意的是，拍照前需要根据传感器安装的方向和屏幕旋转角度来配置图片保存方向，否则可能会出现横竖混淆的照片： 获取 Camera sensor 安装方向 12mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION); 获取当前屏幕的旋转角度 12int displayRotation = activity.getWindowManager() .getDefaultDisplay().getRotation(); 如果安装方向和旋转角度一致（比如都是 90° ），则不需要补偿；否则需要按照顺时针方向设置旋转（即屏幕顺时针朝着 sensor 方向旋转角度），参考 Camera.java 中 setDisplayOrientation 方法的代码注释，计算公式如下： 1234567891011121314151617181920212223242526272829// 获取当前摄像头是前置还是后置Integer facing = cameraCharacteristics.get(CameraCharacteristics.LENS_FACING);// 获取当前 sensor 安装方向Integer mSensorOrientation = characteristics.get(CameraCharacteristics.SENSOR_ORIENTATION);// 获取当前屏幕旋转int rotation = activity.getWindowManager() .getDefaultDisplay().getRotation();// 将旋转转换成角度int degrees = 0;switch (rotation) &#123; case Surface.ROTATION_0: degrees = 0; break; case Surface.ROTATION_90: degrees = 90; break; case Surface.ROTATION_180: degrees = 180; break; case Surface.ROTATION_270: degrees = 270; break;&#125;//int result;// 前后摄计算公式不一样if (facing == CameraCharacteristics.LENS_FACING_FRONT) &#123; mImageOrientation = (mSensorOrientation + degrees) % 360; // compensate the mirror mImageOrientation = (360 - mImageOrientation) % 360; &#125; else &#123; // back-facing mImageOrientation = (mSensorOrientation - degrees + 360) % 360;&#125; 我们以后摄为例，屏幕旋转方向和 Camera sensor 安装方向可能出现的如下几种组合： 补偿角度的计算结果按照公式如下，先以 Sensor 方向不变： 1234567890: (0 - 0 + 360) % 360 = 0 180: (180 - 0 + 360) % 360 = 1800: (0 - 90 + 360) % 360 = 270 180: (180 - 90 + 360) % 360 = 900: (0 - 180 + 360) % 360 = 180 180: (180 - 180 + 360) % 360 = 00: (0 - 270 + 360) % 360 = 90 180: (180 - 270 + 360) % 360 = 270 90: (90 - 0 + 360) % 360 = 90 270: (270 - 0 + 360) % 360 = 27090: (90 - 90 + 360) % 360 = 0 270: (270 - 90 + 360) % 360 = 18090: (90 - 180 + 360) % 360 = 270 270: (270 - 180 + 360) % 360 = 9090: (90 - 270 + 360) % 360 = 180 270: (270 - 270 + 360) % 360 = 0 当 Sensor 安装方向为 0 时，如果屏幕旋转角度也为 0 ，则两个是同方向的，不需要补偿（补偿为 0）；当 Sensor 安装方向为 180 时，如果屏幕旋转角度为 90 （向右横屏），则需要补偿 90 （即当前屏幕方向朝 Sensor 方向旋转 90 度）。 小结 需要等待 TextureView 可用后，才能开启预览 图片保存时，需要设置方向，否则可能会出现旋转角度 序列图 小结CameraMetadata 及其子类的 Key 值CameraMetadata, CaptureRequest, CaptureResult, CameraCharacteristics 的几个常量都是 system/media/camera/docs 中脚本自动生成的，在 metadata_properties.xml 中定义，解析时的对应关系为： 12345678## Static properties only##$&#123;single_kind_keys(&apos;CameraCharacteristicsKeys&apos;, &apos;static&apos;)&#125;#### Controls properties only##$&#123;single_kind_keys(&apos;CaptureRequestKeys&apos;, &apos;controls&apos;)&#125;#### Dynamic properties only##$&#123;single_kind_keys(&apos;CaptureResultKeys&apos;, &apos;dynamic&apos;)&#125; CameraCaptureSession 的两个重要方法 setRepeatingRequest ：用于预览 capture ：用于拍照 参考文档 Android training camera Android Camera2 API Summary Android Camera developer GoogleSamples: Camera2Basic Camera API和HAL版本对应关系:Hal 1,3的区别 Camera2 基本结构及流程 Camera2 API 学习笔记 Android照相机基础基于camera2API Camera2 拍照横屏问题 Camera2 自定义实现相机 Camera框架之Camera2补充 Android开发中关于摄像头方向的理解 camera摄像头成像方向与LCD屏预览关系]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Camera 相关名词等]]></title>
    <url>%2F2018%2F11%2F26%2F0109-android-camera-2-basic%2F</url>
    <content type="text"><![CDATA[Camera 中相关名词解释，图像视频基础格式等基础知识。 摄像头摄像头的简单结构： 感光材质摄像头传感器将镜头中的光信号转换为电信号，再经过内部 A/D 转换为数字信号，感光材质分为： CCD, CMOS 两种： CCDCCD: Charge Coupled Device ，电荷耦合器件传感器：使用一种高感光度的半导体材料制成，能把光线转变成电荷，通过模数转换器芯片转换成电信号。 CCD 由许多独立的感光单位组成，通常以百万像素为单位。当 CCD 表面受到光照时，每个感光单位都会将电荷反映在组件上，所有的感光单位产生的信号加在一起，就构成了一幅完整的图像。 CCD 传感器以日本厂商为主导，全球市场上有 90% 被日本厂商垄断，索尼、松下、夏普是龙头。 CMOSCMOS: Complementary Metal-Oxide Semiconductor ，互补性氧化金属半导体：主要是利用硅和锗做成的半导体，使其在 CMOS 上共存着带 N(-) 和 P(+) 级的半导体，这两个互补效应所产生的电流可以被处理芯片记录并解读成影像。 CMOS 传感器主要以美国、韩国和中国台湾为主导，主要生产厂家是美国的 OmnVison, Agilent, Micron ，中国台湾的锐像、原相、泰视等，韩国的三星、现代。 RGBRGB: Red Green Blue ，指的是红黄蓝三基色。传统的红绿蓝格式有： RGB565, RGB888 等，其 16bit 数据格式为 5bit R + 6bit G + 5bit B ， G 多一位是因为人眼对绿色比较敏感。 YUVYUV: luma (Y) + chroma (UV) ，指的是亮度和色度表示的像素格式。这样分开的好处就是不但可以避免相互干扰，还可以降低色度的采样率而不会对图像质量影响太大。色度 UV 定义了颜色的两个方面：色调 Cb 与饱和度 Cr；其中 Cr 反映了 RGB 输入信号红色部分与 RGB 信号亮度值之间的差异； Cb 反映的是 RGB 输入信号蓝色部分与 RGB 信号亮度值之间的差异。主要采样格式有 YCbCr 4:2:0, 4:2:2, 4:1:1, 4:4:4 等：人眼对色度的敏感程度要低于对亮度的敏感程度，人类视网膜上的视网膜杆细胞要多于视网膜锥细胞，说得通俗一些，视网膜杆细胞的作用就是识别亮度，而视网膜锥细胞的作用就是识别色度。所以眼睛对于亮和暗的分辨要比对颜色的分辨精细一些，因此存储时没有必要存储全部颜色信号。不同的采样格式，存储的色度信号不同，比如 YCbCr 4:4:4 即每 4 点 Y 采样，就有相对应的 4 点 Cb 和 4 点 Cr ；换句话说，在这种格式中色度信号的分辨率和亮度信号的分辨率是相同的。每种采样格式对应的图示如下： YUV 与 RGB 是可以相互转换的，转换公式如下：（ RGB 取值范围均为 0-255 ） 123456Y = 0.299R + 0.587G + 0.114BU = -0.147R - 0.289G + 0.436BV = 0.615R - 0.515G - 0.100BR = Y + 1.14VG = Y - 0.39U - 0.58VB = Y + 2.03U Bayer 格式Bayer 格式图片是柯达公司科学家 Bryce Bayer 发明的，Bayer Array 拜耳阵列被广泛运用数字图像。Bayer 格式是相机内部的原始图片, 一般后缀名为 .raw ，因此也成为 RAW 格式。对于彩色图像，通常需要采集 RGB 三种颜色，最简单的方法就是用滤镜的方法，红色的滤镜透过红色的波长，绿色的滤镜透过绿色的波长，蓝色的滤镜透过蓝色的波长。如果要采集 RGB 三基色，则需要三块滤镜；但是 Bayer 阵列很好的解决这个问题。Bayer 格式图片在一块滤镜上设置的不同的颜色，通过分析人眼对颜色的感知发现，人眼对绿色比较敏感，所以滤镜的 RGB 通常为 1:2:1 组合。下图中灰色的一层表示感光元件，每个方块代表一个像素块，上面一层彩色的就是 Bayer 滤镜。 由于感光元件每个像素只记录一种颜色信息，所以需要使用插值算法将 Bayer 图像恢复会彩色图像。 其他术语 Lens SHADING 镜头均匀性镜头均匀性指画面中心的明亮度到四周的明亮度比值。 Lens shading 分为两种：亮度阴影 luma shading 和色彩偏差 color shading ； luma shading 产生的原因是镜头的通光量从中心到边角依次较少，导致图像看起来，中间亮度正常，四周偏暗。 OIS 光学防抖OIS: Optical Stabilization 光学防抖 Tone Map 色调映射Tonemapping 通常被理解为将颜色值从高动态范围 HDR 映射到低动态范围 LDR 的过程。 Tonemapping 只有在相机启用 HDR 时才能正常工作。建议给光源高于正常强度的亮度，从而让其具有更大的范围。 ANTIBANDING 灯源工频干扰模式ANTIBANDING 是指照明光源干扰产生的明暗条纹问题。 HOT_PIXEL 热点校正传感器的热噪声：热点 hot pixel ，是因为芯片温度过高产生的噪点 LENS FACING 镜头人头方向摄像头镜头成像方向与屏幕预览的关系。 APERTURES 光圈 FOCAL LENGTH 光学变焦焦距 AE 自动曝光自动曝光 Auto Exposure ：就是光圈和快门的组合。光圈，快门速度， ISO ； Gamma 即人眼对亮度的响应曲线。 AWE 自动白平衡自动白平衡 Auto White Balance ：简单来说就是：摄像机对白色物体的还原。相关概念：色温。定义：要求在不同色温环境下，照白色的物体，屏幕中的图像应也是白色的。色温表示光谱成份，光的颜色。色温低表示长波光成分多。当色温改变时，光源中三基色(红、绿、蓝)的比例会发生变化，需要调节三基色的比例来达到彩色的平衡，这就是白平衡调节的实际。 AF 自动对焦自动对焦 Auto Focus 可以分成两大类：一类是基于镜头与被拍摄目标之间距离测量的测距自动对焦，另一类是基于对焦屏上成像清晰的聚焦检测自动对焦(清晰度算法)。变焦就是把远处的物体拉近。对焦是让图像清晰。 3A3A 是 AE, AWE, AF 的统称。 ISO 感光度 Shtter 快门 光学变焦和数码变焦通过镜头的调整，拉近拉远所要拍摄的对象，保持像素不变和画质基本不变，却可以拍到自己理想的物像。数码变焦：其实没有什么变焦，只是从原图片中截取出来放大，屏幕上看到变大了，实际上画质并没有本质提高，而像素比相机能拍摄的最大像素降低了。 Black level 黑电平黑电平 Black Level Correction 也就是黑色的最低点，以 8bit 数据来说，指在经过一定校准的显示装置上，没有一行光亮输出的视频信号电平。定义图像数据为 0 时对应的信号电平。8bit 数据，单个像素的有效值为 0-255，但是实际 AD 芯片（模数转换芯片）的精度可能无法将电压值很小的一部分转换出来。因此 sensor 在出厂的时候，厂家会在 AD 的输入之前加上一个固定的偏移量，比如设置为图像数据输出范围 5-250 等，最低电平不为零。因此我们就需要对图像数据范围进行调整，使其最小值为零，这就是黑电平校正。 ZSLZSL:Zero Shutter Lag 直译为零秒延时拍照， Camera 拍照的时候往往会有一些延迟的体验，比如从按下拍照键到照片拍好放到内存里，这有一个时间差； ZSL 就是为了消除这种延迟，提供一种“拍即视”的体验。 普通模式下拍照数据流 ZSL 拍照数据流 ZSL 下的拍照又分为：普通拍照 Single shot 和连拍功能 Brust mode ，它们对应的数据流为： single shot预览之后， sensor 和 VFE 会产生快照和预览帧，并且会把最新的一些帧保留在图像 buffer 中。一旦“取图”事件被触发，系统就会在第一时间内从图像 buffer 中把相关的图像找出并返回给用户，这就是 ZSL 零秒延迟。 brust modeBurst mode 是 single shot 特征的自然延伸。此功能允许用户捕获的不仅是当前帧，但也有几个帧之前和之后的当前帧的少数几个帧，从而捕捉到一个序列的图像到内存。这将为用户提供不同的快照时间，从中选择一个或多个帧来保存。应用了多少帧的选择自由是多少追溯帧和未来帧在记忆的局限性上，追溯和未来帧是相对于真正的快门时间的。 技术指标图像解析度/分辨率(Resolution)： 规格 宽 x 高 像素点 像素简称 QSIF/QQVGA 160 x 120 19200 QCIF 176 x 144 25344 SIF/QVGA 320 x 240 76800 CIF 352 x 288 101376 10万像素 VGA 640 x 480 307200 30万像素(35万是指648X488) SVGA 800 x 600 480000 50万像素 XGA 1024 x 768 786438 80万像素 SXGA 1280 x 1024 1310720 130万像素 UXGA 1600 x 1200 1920000 200万像素 QXGA 2048 x 1536 3145728 300万像素(320W) QSXGA 2592 x 1944 5038848 500万像素 2816 x 2112 2947392 600万像素 3072 x 2304 7077888 700万像素 3200 x 2400 7680000 770万像素 3264 x 2448 7990272 800万像素 3876 x 2584 10015584 1000万像素 彩色深度(色彩位数)： 256 色灰阶：有 256 种灰色（包括黑白） 15 或 16 位彩色（高彩色）： 65536 种颜色 24 位彩色（真彩色）：每种原色都有 256 个层次，它们的组合便有 256*256*256 种颜色 32 位彩色：除了 24 位彩色的颜色外，额外的 8 位是储存重叠图层的图形资料( alpha 频道) 编码格式图像格式 RAWRAW 格式：RAW Image Format ，表示未经加工的图片。可以理解为 RAW 图像就是 CMOS 或者 CCD 图像感应器将捕捉到的光源信号转化为数字信号的原始数据。RAW 文件是一种记录了数码相机传感器的原始信息，同时记录了由相机拍摄所产生的一些元数据（Metadata，如 ISO 的设置、快门速度、光圈值、白平衡等）的文件。RAW 是未经处理、也未经压缩的格式，可以把 RAW 概念化为“原始图像编码数据”或更形象的称为“数字底片”。 TIFFTIFF: Tagged Image File Format 标签图像文件格式，是一种主要用来存储包括照片和艺术图在内的图像的文件格式，与 JPEG, PNG 一起成为流行的高位彩色图像格式。 DNGDNG: Digital News Gathering 数字负片，是一种用于数码相机生成的原始数据文件的公共存档格式。DNG 文件格式是一种跨平台文件格式，用于存储来自摄像机传感器的像素数据，并且应用最少的预处理。DNG 文件允许在用户定义的颜色空间中定义像素数据，并且具有允许在后处理期间将该像素数据转换为标准 CIE XYZ 颜色空间的关联元数据。DNG 解决了不同型号相机的原始数据文件之间缺乏开放式标准的问题, 从而有助于确保摄影师们将来能够访问他们的文件。DNG 格式中的图像数据基于 TIFF 格式。 JPEG PNG 视频格式 YUVYUV 存储格式有两大类： planar ：先连续存储所有像素点的 Y ，紧接着存储所有像素点的 U ，随后是所有像素点的 V packed ：每个像素点的 Y, U, V 是连续交替存储的 参考文档 camera摄像头成像方向与LCD屏预览关系 camera理论基础和工作原理 斐讯：camera基础介绍 图像bayer格式介绍 RGB与Bayer滤镜 色调映射 Tonemapping ZSL功能小结 ZSL简介 摄像头基础介绍 黑电平校正 图文详解YUV420数据格式 雷神：RGB、YUV像素数据处理 YUV 播放器]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Camera 简单使用]]></title>
    <url>%2F2018%2F11%2F22%2F0109-android-camera-1-simple-use%2F</url>
    <content type="text"><![CDATA[调用手机自带的 Camera 应用，并获取图片、视频的简单使用步骤。 本文是基于手机系统已经自带 Camera 应用的前提下，通过发出 Intent 请求 Camera 应用响应拍照和录像。 权限不管是拍照还是录像，都需要申请使用 camera ；Android M 及以上版本还需要动态申请权限。 AndroidManifest.xml 申请功能在 AndroidManifest.xml 文件中申请使用 camera 硬件功能。 12345&lt;manifest ... &gt; &lt;uses-feature android:name="android.hardware.camera" android:required="true" /&gt; ...&lt;/manifest&gt; android:required表示手机中必须有 camera 应用软件（如果为 false 的话，表示不需要存在，通常情况下间接表示当前应用已经实现了 camera 功能）。 运行时判断是否支持 camera 硬件功能PackageManager.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY) 返回当前手机是否支持 camera 硬件。 动态申请权限 检查是否已经授权ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA); 申请权限requestPermissions(new String[]{Manifest.permission.CAMERA}, REQUEST_CAMERA_PERMISSION); 确认用户是否授权 123456789101112public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; if (requestCode == REQUEST_CAMERA_PERMISSION) &#123; if (grantResults.length != 1 || grantResults[0] != PackageManager.PERMISSION_GRANTED) &#123; ... // show error dialog. &#125; &#125; else &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); &#125;&#125; 拍照Intent拍照对应的 Intent 为 MediaStore.ACTION_IMAGE_CAPTURE 。通过 Intent 来启动手机中的 camera 应用： 12345678static final int REQUEST_IMAGE_CAPTURE = 1;private void dispatchTakePictureIntent() &#123; Intent takePictureIntent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null)&#123; startActivityForResult(takePictureIntent,REQUEST_IMAGE_CAPTURE); &#125;&#125; 获取缩略图 thumbnail手机中的 camera 应用在拍完照后，会返回一个 Intent 数据，其中字段 data 包含了一个 Bitmap 格式的缩略图，通过 ImageView 来显示。 12345678910@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Bundle extras = data.getExtras(); Bitmap imageBitmap = (Bitmap) extras.get("data"); mImageView.setImageBitmap(imageBitmap); &#125;&#125; 录像Intent录像对应的 Intent 为 MediaStore.ACTION_VIDEO_CAPTURE ； 12345678static final int REQUEST_VIDEO_CAPTURE = 1;private void dispatchTakeVideoIntent() &#123; Intent takeVideoIntent=new Intent(MediaStore.ACTION_VIDEO_CAPTURE); if (takeVideoIntent.resolveActivity(getPackageManager()) != null)&#123; startActivityForResult(takeVideoIntent,REQUEST_VIDEO_CAPTURE); &#125;&#125; 查看视频手机中的 camera 应用在录像完后，返回的 Intent 中，包含一个录像文件对应的 Uri，根据 Uri 来显示录像，通过 VideoView 来显示。 12345678910@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == REQUEST_VIDEO_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123; Uri videoUri = data.getData(); mVideoView.setVideoURI(videoUri); // mVideoView.start(); &#125;&#125; 图片保存及后期处理外部存储权限外部存储文件分为： 公共文件：getExternalStoragePublicDirectory()可以被其他应用自由访问，应用卸载仍然保留；存储路径为 /sdcard/ 或者 /storage/emulated0/ 。 私有文件：getExternalFilesDir(String customDir)应用私有文件，在应用卸载时会被删除；存储路径为 /Android/data/&lt;package_name&gt;/files/customDir 。 但不管是那种类型，都需要申请权限： 12&lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="18" /&gt; 创建应用私有的图片存储文件： 12345678910111213141516private File createImageFile() throws IOException &#123; // Create an image file name String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss") .format(new Date()); String imageFileName = "JPEG_" + timeStamp + "_"; File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES); File image = File.createTempFile( imageFileName, // prefix ".jpg", // suffix storageDir // directory ); // Save a file: path for use with ACTION_VIEW intents mCurrentPhotoPath = image.getAbsolutePath(); return image;&#125; 应用间文件共享 FileProviderAndroid StrictMode 禁止在应用向外部公开 file://URI ，否则应用发出包含文件 URI 的 Intent 时，会抛出 FileUriExposedException 异常。如果需要在应用间共享文件，可以通过 FileProvider 发送 content://URI，并授予 URI 临时访问权限。在 AndroidManifest.xml 注册 FileProvider ： 123456789&lt;provider android:name="android.support.v4.content.FileProvider" android:authorities="com.example.android.fileprovider" android:exported="false" android:grantUriPermissions="true"&gt; &lt;meta-data android:name="android.support.FILE_PROVIDER_PATHS" android:resource="@xml/file_paths"&gt;&lt;/meta-data&gt;&lt;/provider&gt; 其中需要注意两点： authorities ：在使用 FileProvider.getUriForFile 返回 Uri 时，使用的权限需要和这里匹配 file_paths ：该 xml 配置文件中需要指定应用需要共享文件的目录，通常为应用私有文件目录 12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;external-path name="my_images" path="Android/data/com.*.knowledge/files/Pictures" /&gt;&lt;/paths&gt; 保存到指定路径在发起拍照的 Intent 中，将在外部存储空间存储图片的绝对路径转换为 Uri 后，写入 MediaStore.EXTRA_OUTPUT 字段。 123456789101112131415161718192021private void dispatchTakePictureIntent() &#123; Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); if (takePictureIntent.resolveActivity(getPackageManager()) != null) &#123; //startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE); // Create the File where the photo should go File photoFile = null; try &#123; photoFile = createImageFile(); &#125; catch (IOException ex) &#123; // Error occurred while creating the File &#125; // Continue only if the File was successfully created if (photoFile != null) &#123; Uri photoURI = FileProvider.getUriForFile(this, "com.*.knowledge.camera.file.provider", photoFile); takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT,photoURI); startActivityForResult(takePictureIntent,REQUEST_IMAGE_CAPTURE); &#125; &#125;&#125; 如果指定了保存路径 MediaStore.EXTRA_OUTPUT ，返回的 Intent 将不再带有 Bitmap 缩略图。如果想显示图片，需要通过指定的保存路径来获取。 添加到媒体数据库如果新增了多媒体文件，通过发送广播 Intent.ACTION_MEDIA_SCANNER_SCAN_FILE 来通知系统扫描这个文件，并加入多媒体数据库中。 12345678private void addPicToMediaDB() &#123; Intent mediaScanIntent = new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE); File f = new File(mCurrentPhotoPath); Uri contentUri = Uri.fromFile(f); mediaScanIntent.setData(contentUri); sendBroadcast(mediaScanIntent);&#125; 如果图片存储路径为 getExternalFilesDir ，媒体扫描时无法扫描这些 APP 私有的目录；也就是说，如果希望能添加到多媒体数据中，不能将图片存储到 getExternalFilesDir 目录下。 缩放图片如果按照 ImageView 宽高来缩放图片时，必须要在 xml 中先指定 ImageView 的宽高，不能设置为 wrap_content ，否则获取到的宽高为 0 。通过 BitmapFactory.Options 先获取原始图片的大小，再根据 ImageView 的宽高来计算比率，设置到 BitmapFactory.Options.inSampleSize 中。 1234567891011121314151617181920212223private void scalePic() &#123; // Get the dimensions of the View int targetW = mImageView.getWidth(); int targetH = mImageView.getHeight(); // Get the dimensions of the bitmap BitmapFactory.Options bmOptions = new BitmapFactory.Options(); bmOptions.inJustDecodeBounds = true; BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); int photoW = bmOptions.outWidth; int photoH = bmOptions.outHeight; // Determine how much to scale down the image int scaleFactor = Math.min(photoW/targetW, photoH/targetH); // Decode the image file into a Bitmap sized to fill the View bmOptions.inJustDecodeBounds = false; bmOptions.inSampleSize = scaleFactor; bmOptions.inPurgeable = true; Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions); mImageView.setImageBitmap(bitmap);&#125; 小结权限不管是录像还是拍照，使用前需要定义使用 camera 硬件，并动态申请权限。 拍照和录像的 Intent 拍照：MediaStore.ACTION_IMAGE_CAPTURE 录像：MediaStore.ACTION_VIDEO_CAPTURE 返回数据 拍照：返回 Bitmap ，数据在 Intent.Bundle 中的 data 字段 录像：返回 Uri ，数据在 Intent.getData 保存文件及分享通过 getExternalFilesDir 获取应用的私有文件目录，通过 FileProvider 共享给其他应用。 缩放图片因子通过设置 BitmapFactory.Options.inSampleSize 的值，来达到缩放图片的效果。 参考文档 Android developer Camera]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 类加载机制]]></title>
    <url>%2F2018%2F11%2F05%2F0108-android-classloading%2F</url>
    <content type="text"><![CDATA[介绍 Android 类加载机制，双亲委派模型，BaseDexClassLoader, DexClassLoader, PathClassLoader 加载 dex, jar, apk 等文件。 JVM 虚拟机执行方式Java 的口号是“一次编译，到处运行”；也就是说 Java 程序的可执行文件（class 文件，字节码），是与机器硬件平台无关的；在程序运行时，由 JVM 将字节码翻译成当前运行环境处理器 CPU 的机器指令来执行。JVM 中通常有两种执行方式： 解释执行字节码中每一行代码，由 JVM 解释器解释翻译成机器码再运行，依此循环从字节码中取出下一行解释并执行，因此解释执行的速度比较慢。 编译执行JVM 将字节码编译成机器码后，运行机器码的执行方式，执行效率很高。 通常情况下，JVM 采用混合执行的方式来运行程序的：将高频代码编译成机器码编译执行，其他代码直接解释执行。 编译方式编译执行的过程，有两种常见的编译方式： JIT：Just In Time指在运行时编译，边运行边编译，属于动态编译。在程序启动时，将字节码编译成机器码，然后运行。优点是能更好的利用 Java 动态行为的特性（特别是多态，只有在运行时才能确定执行哪个方法）；缺点是动态编译时间会计算在程序运行时间中，特别是会导致程序启动时间变长，以及程序运行期间编译带来的性能消耗。JIT 通常只会将执行频率高的热方法动态编译，获取更好的效率平衡。 AOT：Ahead Of Time指在运行前编译，编译完后再运行，属于静态编译。在程序运行前，将字节码编译成机器码存储到本地，程序启动时，直接启动对应的机器码。优点是不存在动态编译的内存和性能消耗，直接运行本地机器码启动速度块；缺点是 Java 动态特性带来的复杂性，影响了静态编译的代码质量。 编译方式对比： 动态 JIT 静态 AOT 平台无关性 有 无 代码质量 优秀 良好 利用动态行为 是 否 类和层次结构的知识 有 无 编译时间 有限制，有运行时成本 限制很少，无运行时成本 运行时性能影响 有 无 编译方式 需要谨慎编译，由 JIT 处理 需要谨慎编译，由开发人员处理 总的来说，动态编译 JIT 能提供最好的系统稳定性能；而静态编译 AOT 能提供最好的交互性能。 Android 虚拟机概念Android 虚拟机实现有两个阶段： DalvikAndroid K 4.4 之前的版本都是使用的 Dalvik 虚拟机。Java 生成的 class 文件由 dx 工具转换为 Dalvik 字节码即 dex 文件，之后进行签名对齐等操作变成 APK 文件。而 Dalvik 虚拟机负责将 dex 字节码解释为机器码，解释执行的速度慢效率低；从 Android 2.2 froyo 开始引入 JIT 动态编译执行方式，APP 运行时，JIT 将执行次数较多的 dex 文件动态编译为机器码缓存起来，后续再次执行时大大提高运行速度。JIT 动态编译的特点是：每次打开 APP 运行时，都需要重新编译。 ART: Android RuntimeAndroid K 4.4 采用了 Dalvik 和 ART 共存方式，两者可以相互切换；从 Android L 5.0 开始彻底丢弃 Dalvik 全面转换为 ART 方式。ART 虚拟机采用的是 AOT 静态编译执行方式，APP 在第一次安装时，dex 字节码会被预先编译成机器码；之后打开 APP 运行时，不需要额外的解释翻译工作，直接使用本地机器码执行，提高运行速度。 两者的区别 Dalvik 是运行时编译；ART 是运行前编译（安装时编译） Dalvik 每次运行时都会将执行频繁的 dex 文件编译为机器码，运行启动时间加长，边运行边编译会额外销毁内存和系统性能 ART 在安装时编译，安装时间会延长；把程序代码转换成机器语言存储在本地，会消耗掉更多的存储空间，增幅通常不会超过应用代码包大小的 20% 文件格式 dex 文件格式魔数：dex ，Android 平台可执行文件，字节码；每个 APK 中包含一个或多个 dex 文件格式的可执行文件。 odex 文件格式魔数：dey ，odex: Optimize Dex 即优化后的 dex 文件。Dalvik 虚拟机从 APK 中将 dex 文件提取出来优化后生成 odex 文件，并存储在本地，后期运行时直接编译解释 odex 文件（仍然是字节码，dey 字节码）。而 APK 被提取后可以有也可以没有 dex 文件；在多 dex 文件的 APK 中，提取优化后只会生成一个 odex 文件。 oat 文件格式魔数：.elf ，是 ELF 格式的可执行文件。ART 虚拟机在 APK 安装时，将 dex 编译为本地机器码，并生成对应的 oat 文件格式的文件，可以直接执行。 vdex 文件格式魔数：vdex ，是 APK 中 dex 文件的一份拷贝，同时会将多个 dex 合并为一个文件。在 Android O 8.0 之前，oat 格式文件除了机器码还包含一份 dex 的拷贝；但在 Android O 之后，dex2oat 静态编译时会产生两个文件：odex, vdex ，其中 odex 为机器码，通常很小；而 vdex 则是原始 dex 的一份拷贝，它是一个全新格式的文件（不是 ELF 格式）。 art 文件格式魔数：art ，是一个 img 文件，表示类对象映像；这个 img 文件直接被映射到 ART 虚拟机的堆空间中，包含了 oat 中的某些对象实例以及函数地址。 为保证 Dalvik 和 ART 的兼容性，以及历史遗留问题，可能会使用相同文件后缀表示不同的文件格式，非常容易混淆。比如 .dex 后缀可以是 dex, oat 文件，odex 后缀可以是 odex, oat 文件等。 转换流程图Java 源文件转换为 oat 格式文件的流程图： 文件分析工具 dex 文件生成及分析工具d8.bat/dx.bat ：生成工具，位置路径为 Windows sdk\build-tools\28.0.3 。示例：d8.bat --output=test.jar Test.jar test.class ；其中 output 必须是 .zip, .jar，input 可以是 .dex, .apk, .jar, .class, .zip 。dexdump/dexdump2 ：分析工具，在 AOSP 编译完后 out/host$ cd linux-x86/bin/ 目录下会生成对应工具。 oat 文件因为是 ELF 格式文件，所以通用工具都可以读出，如：readelf ，AOSP 编译完后生成的 otadump 也可以分析。 vdex 文件github: vdexExtractor ，这款工具可以从 vdex 中提取出原始的 dex 文件。 示例如下信息手机系统为 Android O 8.1 ： 系统编译 framework 生成文件按照 out 目录生成文件路径，拷贝到手机对应路径中；在系统启动时，会拷贝一份到 /data/dalvik-cache/arm64 目录下。 123456786.1M system/framework/arm64/boot-framework.art25M system/framework/arm64/boot-framework.oat20M system/framework/arm64/boot-framework.vdex7.4M system/framework/framework.jar// 系统启动后在 /data/dalvik-cache/arm64 目录下生成对应文件 6.0M system@framework@boot-framework.art0 system@framework@boot-framework.oat -&gt; /system/framework/arm64/boot-framework.oat0 system@framework@boot-framework.vdex -&gt; /system/framework/arm64/boot-framework.vdex 系统编译应用 Email 生成文件系统应用在安装时同样会拷贝到 /data/dalvik-cache/arm64 目录下，但是会多生成一个 classes.art 文件。注意：在 data 目录生成的 dex 后缀的文件，实际上是 oat 文件，pull 出来后魔数是 .elf 格式的。 12345676.7M system/app/Email/Email.apk76K system/app/Email/oat/arm64/Email.odex4.1M system/app/Email/oat/arm64/Email.vdex// 系统启动后在 /data/dalvik-cache/ 目录下生成对应文件 32K /data/dalvik-cache/arm64/system@app@Email@Email.apk@classes.art72K /data/dalvik-cache/arm64/system@app@Email@Email.apk@classes.dex4.0M /data/dalvik-cache/arm64/system@app@Email@Email.apk@classes.vdex 安装 qsbk.apk 生成的文件，apk 中包含多个 dex 文件第三方应用在安装时，直接安装到 /data/app/ 目录下，并根据包名随机生成一个字符串做目录区分。注意：生成的 base.odex 实际上是 oat 文件，pull 出来后魔数是 .elf 格式的。 12332M /data/app/qsbk.app-9P***/base.apk276K /data/app/qsbk.app-9P***/oat/arm/base.odex15M /data/app/qsbk.app-9P***/oat/arm/base.vdex 小结系统自带 framework, app 都会生成 art, oat, vdex 三种文件格式的文件；而第三方应用安装后，只会生成 oat, vdex 两种文件格式的文件。其中 framework 中后缀为 .oat、系统 app 中后缀为 dex、第三方 app 中后缀为 odex，这三个 oat, dex, odex 后缀的文件，实际上都是 oat 文件，注意别混淆了，仅仅是后缀不同而已。 代码速查表本文基于 Android O 8.1 源码分析 Android 平台的 ClassLoader ： 123456789101112131415libcore/ojluni/src/main/java/java/lang/Class.javalibcore/ojluni/src/main/java/java/lang/ClassLoader.javalibcore/libart/src/main/java/java/lang/VMClassLoader.javalibcore/dalvik ./src/main/java/dalvik/system/BaseDexClassLoader.java ./src/main/java/dalvik/system/InMemoryDexClassLoader.java ./src/main/java/dalvik/system/DexClassLoader.java ./src/main/java/dalvik/system/PathClassLoader.java ./src/main/java/dalvik/system/DelegateLastClassLoader.java ./src/main/java/dalvik/system/DexPathList.java ./src/main/java/dalvik/system/DexFile.javaart/runtime/native/dalvik_system_DexFile.ccart/runtime/native/java_lang_VMClassLoader.cc Android 类加载器类图结构 本文不分析 SecureClassLoader, URLClassLoader 这两个类加载器。 ClassLoader ：抽象类，类加载器的最终父类 BootClassLoader ：启动类加载器；在双亲委托模型中，是第一级父加载器 BaseDexClassLoader ：Android 平台加载 dex 文件的基类 PathClassLoader ：系统类加载器，也相当于应用类加载器，是用户自定义类加载器默认的父加载器；APK 文件都是该加载器加载的 DexClassLoader ：主要用于从包含 classes.dex 的 .jar, .apk 文件中加载类，而这些文件并没有随着应用一起安装 InMemoryDexClassLoader ：主要用于加载内存中的 dex 文件，而这些内存中的文件并不需要存储在本地 DelegateLastClassLoader ：最近委托查找策略类加载器，并不完全按照双亲委派模型来加载的，会提前执行 findClass 从加载 dex 文件中查找类，然后才是双亲委派模型 从各个博客看下来，Classloader 在 Android 不同大版本中不管是代码位置还是子类都在不停的变化。 自定义类加载器时，如果不指定父加载器，则默认其父加载器为 PathClassLoader ；通过 Class 获取加载器时，如果其加载器为空，则指定其加载器为 BootClassLoader 。 双亲委派模型 类加载器的双亲委派模型：要求除了启动类加载器外，其余的类加载器都应当有自己的父加载器（父子不是继承关系，而是组合关系来复用父类代码）。双亲委派模型并不是强制要求，只是 Java 的推荐方式，可以通过重新加载方法来改变。双亲委派模型原则：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。Android 和标准 Java 对比：没有扩展类加载器，启动加载器 BootClassLoader 也是 Java 实现的。 父加载器和父类加载器是两个不同的概念：父加载器是参考双亲委派模型在构造方法中指定的；父类加载器表示当前加载器的父类（类图结构上是继承关系）。 ClassLoaderClassLoader 是抽象类，其他所有的类加载都是它的继承类；有以下几个特点： 标准 Java 中系统默认加载器为 AppClassLoader；而 Android 中系统类加载器是 PathClassLoader 系统类加载器 PathClassLoader 的父加载器为启动加载器 BootClassLoader Android 启动加载器 BootClassLoader 是 ClassLoader 的内部类，也是其子类；默认为顶层父加载器 ClassLoader 构造方法中指定父加载器，如果不指定：父加载器默认为系统加载器 PathClassLoader ；即：自定义类加载器，如果不指定父加载器，则其父加载器默认为 PathClassLoader loadClass 实现了双亲委派模型 findClass, defineClass 必须在子类中实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public abstract class ClassLoader &#123; // 系统类加载器 static private class SystemClassLoader &#123; public static ClassLoader loader = ClassLoader.createSystemClassLoader(); &#125; // 系统类加载器为 PathClassLoader private static ClassLoader createSystemClassLoader() &#123; String classPath = System.getProperty(&quot;java.class.path&quot;, &quot;.&quot;); String librarySearchPath = System.getProperty(&quot;java.library.path&quot;, &quot;&quot;); // String[] paths = classPath.split(&quot;:&quot;); // URL[] urls = new URL[paths.length]; // for (int i = 0; i &lt; paths.length; i++) &#123; // try &#123; // urls[i] = new URL(&quot;file://&quot; + paths[i]); // &#125; // catch (Exception ex) &#123; // ex.printStackTrace(); // &#125; // &#125; // // return new java.net.URLClassLoader(urls, null); // TODO Make this a java.net.URLClassLoader once we have those? // PathClassLoader 的父加载器为 BootClassLoader return new PathClassLoader(classPath, librarySearchPath, BootClassLoader.getInstance()); &#125; // 系统加载器的类 PathClassLoader.class protected final Class&lt;?&gt; findSystemClass(String name) throws ClassNotFoundException &#123; return Class.forName(name, false, getSystemClassLoader()); &#125; // 系统类加载器为 PathClassLoader public static ClassLoader getSystemClassLoader() &#123; return SystemClassLoader.loader; &#125; // The parent class loader for delegation // Note: VM hardcoded the offset of this field, thus all new fields // must be added *after* it. private final ClassLoader parent; public final ClassLoader getParent() &#123; return parent; &#125; private ClassLoader(Void unused, ClassLoader parent) &#123; this.parent = parent; &#125; protected ClassLoader(ClassLoader parent) &#123; this(checkCreateClassLoader(), parent); &#125; // 如果不指定父加载器，则其父加载器默认为 PathClassLoader protected ClassLoader() &#123; this(checkCreateClassLoader(), getSystemClassLoader()); &#125; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; // 实现双亲委派模型 protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check if the class has already been loaded // 1. 先确认类是否已经被加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; // 2. 如果没有被加载，父加载器是否为空 // 不为空则父加载器加载，依次递归 c = parent.loadClass(name, false); &#125; else &#123; // 3. 这里沿用标准 Java 的双亲加载模型 // 但是 Android 中并没有 Bootstrap c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader // 4. 如果父加载器抛出 ClassNotFoundException // 说明父加载器无法完成类加载请求 &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. // 5. 父加载器无法完成加载或者其他原因没有加载成功 // 则调用本身的 findClass 进行类加载 c = findClass(name); &#125; &#125; return c; &#125; // 通过本地代码在 ART 中查找 protected final Class&lt;?&gt; findLoadedClass(String name) &#123; ClassLoader loader; if (this == BootClassLoader.getInstance()) loader = null; else loader = this; return VMClassLoader.findLoadedClass(loader, name); &#125; // Android 中没有Bootstrap，直接返回 null private Class&lt;?&gt; findBootstrapClassOrNull(String name) &#123; return null; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125; protected final Class&lt;?&gt; defineClass(...) throws ClassFormatError &#123; throw new UnsupportedOperationException(&quot;...&quot;); &#125; ...&#125; 从源码 loadClass 中再描述下双亲委派模型： 先确认类是否已经被加载 如果没有被加载，且父加载器不为空；使用父加载器加载。依次递归 父加载器为空，使用 Bootstrap 来加载，但是 Android 中并不存在该加载器，直接返回 null 父加载器无法完成加载或者其他原因没有加载成功，则调用当前递归到的类加载器 findClass 进行类加载 BootClassLoader启动类加载器 BootClassLoader，是 ClassLoader 的成员内部类，也是 ClassLoader 的子类；是顶层父加载器。和 JVM 不一样，Android 的启动类加载器是 Java 实现的。有如下特点： 启动类加载器 BootClassLoader 的父加载器为 null ，它是最顶层的加载器 因为是最顶层的父加载器，在 loadClass 中如果发现类没有加载，直接在这一层 findClass findClass 是通过反射 Class.classForName （它是一个 native 方法，标准 Java 中并存在） 实现的 1234567891011121314151617181920212223242526272829303132333435363738class BootClassLoader extends ClassLoader &#123; private static BootClassLoader instance; @... public static synchronized BootClassLoader getInstance() &#123; if (instance == null) &#123; instance = new BootClassLoader(); &#125; return instance; &#125; // 启动类加载器的父加载器为 null public BootClassLoader() &#123; super(null); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; // 通过反射加载类，classForName 是 native 方法 return Class.classForName(name, false, null); &#125; @Override protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; clazz = findClass(className); &#125; return clazz; &#125; ...&#125; Class因为 Android 修改了标准 Java 的类加载器，所以在 Class.java 中也做了对应修改。主要有以下几个特点： 默认类加载器和调用者为同一个加载器 获取类加载器时，如果加载器为空，则指定其加载器为 BootClassLoader native 方法 classForName ，从虚拟机中加载类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; ... // defining class loader, or null for the "bootstrap" system loader. private transient ClassLoader classLoader; public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; return forName(className, true, VMStack.getCallingClassLoader()); &#125; public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException &#123; if (loader == null) &#123; loader = BootClassLoader.getInstance(); &#125; Class&lt;?&gt; result; try &#123; result = classForName(name, initialize, loader); &#125; catch (ClassNotFoundException e) &#123; Throwable cause = e.getCause(); if (cause instanceof LinkageError) &#123; throw (LinkageError) cause; &#125; throw e; &#125; return result; &#125; /** Called after security checks have been made. */ @FastNative static native Class&lt;?&gt; classForName(String className, boolean shouldInitialize, ClassLoader classLoader) throws ClassNotFoundException; public ClassLoader getClassLoader() &#123; if (isPrimitive()) &#123; return null; &#125; // 如果其加载器为空，则指定其加载器为 BootClassLoader return (classLoader == null) ? BootClassLoader.getInstance() : classLoader; &#125; ...&#125; PathClassLoaderAndroid 的系统类加载器，也相当于应用类加载器，是用户自定义类加载器默认的父加载器；类中只有构造方法，它继承了 BaseDexClassLoader 。APK 加载时，默认使用该加载器加载到 ART 中。 123456789public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, null, librarySearchPath, parent); &#125;&#125; DexClassLoader继承了 BaseDexClassLoader ，只有构造方法。主要用于从包含 classes.dex 的 .jar, .apk 文件中加载类，而这些文件并没有随着应用一起安装；比如放在 assert 目录下等等。而实际上，从构造方法传递的参数来看：DexClassLoader, PathClassLoader 并没有任何区别！！ 123456public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, null, librarySearchPath, parent); &#125;&#125; InMemoryDexClassLoader继承了 BaseDexClassLoader ，只有构造方法。主要用于加载内存中的 dex 文件，而这些内存中的文件并不需要存储在本地；方便网络下载并加载。 123456789public final class InMemoryDexClassLoader extends BaseDexClassLoader &#123; public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) &#123; super(dexBuffers, parent); &#125; public InMemoryDexClassLoader(ByteBuffer dexBuffer, ClassLoader parent)&#123; this(new ByteBuffer[] &#123; dexBuffer &#125;, parent); &#125;&#125; DelegateLastClassLoaderDelegateLastClassLoader 继承 PathClassLoader，是最近委托查找策略；它加载类和资源的策略如下（代码中也有详细注释）： 首先查看类是否已经被加载 然后使用最顶层启动类加载器 BootClassLoader 来加载 然后使用当前类加载器 findClass ，搜索与此类加载器的 dexPath 关联的 dex 文件列表中，是否已经加载 最后才是委托父加载器加载 从代码中可以看到，DelegateLastClassLoader 并没有完全遵循双亲委派模型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public final class DelegateLastClassLoader extends PathClassLoader &#123; public DelegateLastClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, parent); &#125; public DelegateLastClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super(dexPath, librarySearchPath, parent); &#125; @Override protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check whether the class has already been loaded. // Return it if that's the case. Class&lt;?&gt; cl = findLoadedClass(name); if (cl != null) &#123; return cl; &#125; // Next, check whether the class in question // is present in the boot classpath. try &#123; return Object.class.getClassLoader().loadClass(name); &#125; catch (ClassNotFoundException ignored) &#123; &#125; // Next, check whether the class in question is present // in the dexPath that this classloader operates on. ClassNotFoundException fromSuper = null; try &#123; return findClass(name); &#125; catch (ClassNotFoundException ex) &#123; fromSuper = ex; &#125; // Finally, check whether the class in question // is present in the parent classloader. try &#123; return getParent().loadClass(name); &#125; catch (ClassNotFoundException cnfe) &#123; ... throw fromSuper; &#125; &#125; ...&#125; BaseDexClassLoaderBaseDexClassLoader 是 Android 平台加载 dex 文件的基类，所有从 dex 文件中查找加载的类 findClass 都是在这里实现。构造方法中各参数的含义： dexPath ：包含 dex 文件的绝对路径列表；文件可以是 apk, jar ，文件列表分隔符为 : optimizedDirectory ：没有任何作用，为了兼容早期的版本 librarySearchPath ：native 库所在文件目录的绝对路径列表；文件目录分隔符默认为 : parent ：当前类加载器的父加载器 dexFiles ：包含 dex 文件的二进制数组 1234567891011121314151617181920212223242526272829303132333435363738public class BaseDexClassLoader extends ClassLoader &#123; ... private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String librarySearchPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, librarySearchPath, null); ... &#125; public BaseDexClassLoader(ByteBuffer[] dexFiles, ClassLoader parent) &#123; // TODO We should support giving this a library search path maybe. super(parent); this.pathList = new DexPathList(this, dexFiles); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException(...); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c; &#125; public void addDexPath(String dexPath) &#123; pathList.addDexPath(dexPath, null /*optimizedDirectory*/); &#125; ...&#125; findClass 流程图： dex 文件加载与解析DexFile每个 jar, apk, dex 文件对应一个 DexFile 类实例，它用来将对应的文件加载到虚拟机中。 所有的 dex, jar ,apk 文件，最终都是通过 openDexFile 加载到虚拟机中的 如果是通过 dex 来加载类，最终会走到 defineClass 从虚拟机中加载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public final class DexFile &#123; /** * If close is called, mCookie becomes null but the internal cookie * is preserved if the close failed so that * we can free resources in the finalizer. */ private Object mCookie; private Object mInternalCookie; private final String mFileName; ... public Class loadClass(String name, ClassLoader loader) &#123; String slashName = name.replace('.', '/'); return loadClassBinaryName(slashName, loader, null); &#125; public Class loadClassBinaryName(String name, ClassLoader loader, List&lt;Throwable&gt; suppressed) &#123; return defineClass(name, loader, mCookie, this, suppressed); &#125; private static Class defineClass(String name, ClassLoader loader, Object cookie, DexFile dexFile, List&lt;Throwable&gt; suppressed)&#123; Class result = null; try &#123; result = defineClassNative(name, loader, cookie, dexFile); &#125; catch (NoClassDefFoundError e) &#123; if (suppressed != null) &#123; suppressed.add(e); &#125; &#125; catch (ClassNotFoundException e) &#123; if (suppressed != null) &#123; suppressed.add(e); &#125; &#125; return result; &#125; private static Object openDexFile(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements) throws IOException &#123; // Use absolute paths to enable the use of // relative paths when testing on host. return openDexFileNative(new File(sourceName).getAbsolutePath(), (outputName == null) ? null : new File(outputName).getAbsolutePath(), flags, loader, elements); &#125; private static Object openInMemoryDexFile(ByteBuffer buf) throws IOException &#123; if (buf.isDirect()) &#123; return createCookieWithDirectBuffer(buf, buf.position(), buf.limit()); &#125; else &#123; return createCookieWithArray(buf.array(), buf.position(), buf.limit()); &#125; &#125; private static native Class defineClassNative(String name, ClassLoader loader, Object cookie, DexFile dexFile); private static native Object openDexFileNative(String sourceName, String outputName, int flags, ClassLoader loader, DexPathList.Element[] elements); private static native Object createCookieWithDirectBuffer( ByteBuffer buf, int start, int end); private static native Object createCookieWithArray(byte[] buf, int start, int end); ...&#125; DexPathList内部类： Element可能叫 DexElement 更合适，但是由于历史原因，可能会存在反射调用此类的情形。每个 Element 对应一个 DexFile 文件。 1234567891011121314151617181920212223242526272829303132333435363738394041/*package*/ static class Element &#123; /** * A file denoting a zip file (in case of a resource jar or a dex jar), * or a directory (only when dexFile is null). */ private final File path; private final DexFile dexFile; private ClassPathURLStreamHandler urlHandler; private boolean initialized; ... public Class&lt;?&gt; findClass(String name, ClassLoader definingContext, List&lt;Throwable&gt; suppressed) &#123; return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed) : null; &#125; public URL findResource(String name) &#123; for (Element element : dexElements) &#123; URL url = element.findResource(name); if (url != null) &#123; return url; &#125; &#125; return null; &#125; public Enumeration&lt;URL&gt; findResources(String name) &#123; ArrayList&lt;URL&gt; result = new ArrayList&lt;URL&gt;(); for (Element element : dexElements) &#123; URL url = element.findResource(name); if (url != null) &#123; result.add(url); &#125; &#125; return Collections.enumeration(result); &#125;&#125; NativeLibraryElement库文件元素，每个 native lib 对应一个 NativeLibraryElement，可能会包含系统库。 123456789101112131415161718192021222324252627282930313233/** * Element of the native library path *//*package*/ static class NativeLibraryElement &#123; private final File path; //If path denotes a zip file, this denotes a base path inside the zip. private final String zipDir; private ClassPathURLStreamHandler urlHandler; private boolean initialized; ... public String findNativeLibrary(String name) &#123; maybeInit(); if (zipDir == null) &#123; String entryPath = new File(path, name).getPath(); if (IoUtils.canOpenReadOnly(entryPath)) &#123; return entryPath; &#125; &#125; else if (urlHandler != null) &#123; // Having a urlHandler means the element has a zip file. // In this case Android supports loading the library iff // it is stored in the zip uncompressed. String entryName = zipDir + '/' + name; if (urlHandler.isEntryStored(entryName)) &#123; return path.getPath() + zipSeparator + entryName; &#125; &#125; return null; &#125; ...&#125; DexPathList 是对两个内部类的一个封装，表示每个对象可以包含多个可执行文件 dex, jar, apk 等；同时每个对象可以包含多个库文件等。 Elements[] 数组包含了所有的 dex, jar, apk 文件，热补丁技术通常是从这里 inject findClass 最终通过 DexFile 从虚拟机中加载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/*package*/ final class DexPathList &#123; ... private final ClassLoader definingContext; private Element[] dexElements; private final NativeLibraryElement[] nativeLibraryPathElements; ... public DexPathList(ClassLoader definingContext, ByteBuffer[] dexFiles) &#123; ... this.definingContext = definingContext; ... this.nativeLibraryPathElements = makePathElements(this.systemNativeLibraryDirectories); ... this.dexElements = makeInMemoryDexElements(dexFiles, suppressedExceptions); ... &#125; public DexPathList(ClassLoader definingContext, String dexPath, String librarySearchPath, File optimizedDirectory) &#123; ... this.definingContext = definingContext; ... this.dexElements = makeDexElements(splitDexPath(dexPath), optimizedDirectory, suppressedExceptions, definingContext); ... List&lt;File&gt; allNativeLibraryDirectories = new ArrayList&lt;&gt;(nativeLibraryDirectories); allNativeLibraryDirectories.addAll(systemNativeLibraryDirectories); this.nativeLibraryPathElements = makePathElements(allNativeLibraryDirectories); ... &#125; private static Element[] makeInMemoryDexElements(ByteBuffer[] dexFiles, List&lt;IOException&gt; suppressedExceptions) &#123; Element[] elements = new Element[dexFiles.length]; int elementPos = 0; for (ByteBuffer buf : dexFiles) &#123; try &#123; DexFile dex = new DexFile(buf); elements[elementPos++] = new Element(dex); &#125; catch (IOException suppressed) &#123; ... &#125; &#125; if (elementPos != elements.length) &#123; elements = Arrays.copyOf(elements, elementPos); &#125; return elements; &#125; private static Element[] makeDexElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions, ClassLoader loader) &#123; Element[] elements = new Element[files.size()]; int elementsPos = 0; for (File file : files) &#123; if (file.isDirectory()) &#123; ... elements[elementsPos++] = new Element(file); &#125; else if (file.isFile()) &#123; String name = file.getName(); if (name.endsWith(DEX_SUFFIX)) &#123; // Raw dex file (not inside a zip/jar). try &#123; DexFile dex = loadDexFile(file, optimizedDirectory, loader, elements); if (dex != null) &#123; elements[elementsPos++] = new Element(dex, null); &#125; &#125; catch (IOException suppressed) &#123; ... &#125; &#125; else &#123; DexFile dex = null; try &#123; dex = loadDexFile(file, optimizedDirectory, loader, elements); &#125; catch (IOException suppressed) &#123; ... &#125; if (dex == null) &#123; elements[elementsPos++] = new Element(file); &#125; else &#123; elements[elementsPos++] = new Element(dex, file); &#125; &#125; &#125; else &#123; ... &#125; &#125; ... return elements; &#125; private static DexFile loadDexFile(File file, File optimizedDirectory, ClassLoader loader, Element[] elements) throws IOException &#123; if (optimizedDirectory == null) &#123; return new DexFile(file, loader, elements); &#125; else &#123; String optimizedPath = optimizedPathFor(file, optimizedDirectory); return DexFile.loadDex(file.getPath(), optimizedPath, 0, loader, elements); &#125; &#125; private static Element[] makePathElements(List&lt;File&gt; files, File optimizedDirectory, List&lt;IOException&gt; suppressedExceptions) &#123; return makeDexElements(files, optimizedDirectory, suppressedExceptions, null); &#125; private static NativeLibraryElement[] makePathElements( List&lt;File&gt; files) &#123; NativeLibraryElement[] elements = new NativeLibraryElement[files.size()]; int elementsPos = 0; for (File file : files) &#123; String path = file.getPath(); if (path.contains(zipSeparator)) &#123; String split[] = path.split(zipSeparator, 2); File zip = new File(split[0]); String dir = split[1]; elements[elementsPos++] = new NativeLibraryElement(zip, dir); &#125; else if (file.isDirectory()) &#123; elements[elementsPos++] = new NativeLibraryElement(file); &#125; &#125; if (elementsPos != elements.length) &#123; elements = Arrays.copyOf(elements, elementsPos); &#125; return elements; &#125; public Class&lt;?&gt; findClass(String name, List&lt;Throwable&gt; suppressed) &#123; // 类查找过程是变量 Elements 数组，只要查到了就返回 // 热补丁正是利用这个特性，将 patch 插入 Elements 数组的第一个中 // 即使原先包内有 bug 但不会被加载 for (Element element : dexElements) &#123; Class&lt;?&gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList( dexElementsSuppressedExceptions)); &#125; return null; &#125; ...&#125; Android 预加载系统开机启动会在 ZygoteInit 进程创建 Java 环境，预加载系统常用类，并创建系统的类加载器 PathClassLoader 。 启动路径和系统服务路径启动路径 BOOTCLASSPATH 和系统服务路径 SYSTEMSERVERCLASSPATH 最终都是写入 ./root/init.environ.rc 文件的。 BOOTCLASSPATH编译系统中 PRODUCT_BOOT_JARS 中添加的 jar 包名和路径对应生成的，包含所有 framework 相关 jar 包路径。PRODUCT_BOOT_JARS 最终被编译添加到 BOOTCLASSPATH 变量中，组建过程： 12345./device/qcom/common/base.mk./build/make/core/envsetup.mk./build/make/target/product/core_minimal.mk./device/qcom/common/common.mk./device/qcom/custom/custom.mk SYSTEMSERVERCLASSPATH在 build/make/target/product/core_minimal.mk 文件中定义的 PRODUCT_SYSTEM_SERVER_JARS 变量，会在 system/core/rootdir/Android.mk 中生成 SYSTEMSERVERCLASSPATH 变量。 ./root/init.environ.rc 文件中这两个变量的内容为： 12export BOOTCLASSPATH /system/framework/com.qualcomm.qti.camera.jar:/system/framework/QPerformance.jar:/system/framework/core-oj.jar:/system/framework/core-libart.jar:/system/framework/conscrypt.jar:/system/framework/okhttp.jar:/system/framework/bouncycastle.jar:/system/framework/apache-xml.jar:/system/framework/legacy-test.jar:/system/framework/ext.jar:/system/framework/framework.jar:/system/framework/telephony-common.jar:/system/framework/voip-common.jar:/system/framework/ims-common.jar:/system/framework/org.apache.http.legacy.boot.jar:/system/framework/android.hidl.base-V1.0-java.jar:/system/framework/android.hidl.manager-V1.0-java.jar:/system/framework/qcrilhook.jar:/system/framework/hiqmi.jar:/system/framework/qcnvitems.jar:/system/framework/telephony-qmi.jar:/system/framework/tcmiface.jar:/system/framework/WfdCommon.jar:/system/framework/oem-services.jar:/system/framework/qcom.fmradio.jar:/system/framework/telephony-ext.jarexport SYSTEMSERVERCLASSPATH /system/framework/services.jar:/system/framework/ethernet-service.jar:/system/framework/wifi-service.jar:/system/framework/com.android.location.provider.jar 预加载类 preloadClasses预加载的类大概有 4500+ 个系统常用类，采用的是空间换时间的策略：系统开机时就将常用类加载，后续应用使用时不用重复加载，提高应用运行速度。设置预加载的文件为 preloaded-classes ： AOSP 源码路径为：preloaded-classes: frameworks/base/config/preloaded-classes编译完后会被拷贝到：./system/etc/preloaded-classes ；文件中指定需要加载的常见系统类： 12345678910111213141516171819202122android.app.Activity$HostCallbacksandroid.app.ActivityManagerandroid.app.ActivityManager$1android.app.ActivityManager$AppTask...android.app.ActivityManager$TaskDescription$1android.app.ActivityOptionsandroid.app.ActivityThreadandroid.app.ActivityThread$1...android.app.ContentProviderHolder$1android.app.ContextImplandroid.app.ContextImpl$1...android.app.DexLoadReporterandroid.app.Dialogandroid.app.Dialog$ListenersHandlerandroid.app.DialogFragmentandroid.app.DownloadManagerandroid.app.Fragmentandroid.app.Fragment$1... 预加载类流程图： 创建系统类加载器Android 默认的系统类加载器为 PathClassLoader ，也是在系统启动阶段 ZygoteInit 中创建的，并加载系统服务的 jar 。创建系统类加载器 PathClassLoader ，并加载系统服务 jar 文件流程图： ZygoteInit 处理系统服务进程中，除了生成系统类加载器 PathClassLoader ，并会通过该加载器反射调用 SystemServer.main 方法，启动系统服务进程 system_server 进程，管理整个系统的所有服务。 APK 及四大组件加载过程APK 加载过程LoadedApk 类是整个应用 APK 加载的入口类，最终在类加载器工厂中 ClassLoaderFactory.java 创建具体的加载器 PathClassLoader 。 1234567891011// ClassLoaderFactory.javapublic static ClassLoader createClassLoader(String dexPath, String librarySearchPath, ClassLoader parent, String classloaderName)&#123; if (isPathClassLoaderName(classloaderName)) &#123; return new PathClassLoader(dexPath, librarySearchPath, parent); &#125; else if (isDelegateLastClassLoaderName(classloaderName)) &#123; return new DelegateLastClassLoader(dexPath,librarySearchPath,parent); &#125; throw new AssertionError("Invalid classLoaderName: " + classloaderName);&#125; 调用序列图： 部分 Log 打印： ZygoteInit 新建应用进程 ActivityThread 线程启动进入 main 入口：AMS.attachApplication 启动应用以及进入 Looper.loop() 循环接受主线程消息 AMS.attachApplication 会调用 ActivityThread.bindApplication 启动并绑定该应用 ContextImpl 第一次加载应用时，调用 PathClassLoader 加载整个应用 APK 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1. AMS.attachApplication*: V/ActivityManager(1696): New app record ProcessRecord&#123;5515589 3528:com.*.knowledge/u0a76&#125; thread=android.os.BinderProxy@ca7598e pid=3528, processName = com.*.knowledge, appInfo = ApplicationInfo&#123;8c27ebf com.*.knowledge&#125;*: V/ActivityManager(1696): java.lang.RuntimeException*: V/ActivityManager(1696): at com.android.server.am.ActivityManagerService.attachApplicationLocked(ActivityManagerService.java:7258)*: V/ActivityManager(1696): at com.android.server.am.ActivityManagerService.attachApplication(ActivityManagerService.java:7377)*: V/ActivityManager(1696): at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:291)*: V/ActivityManager(1696): at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2971)*: V/ActivityManager(1696): at android.os.Binder.execTransact(Binder.java:697)// 2. AMS.bindApplication*: V/ActivityThread(3528): bindApplication: processName = com.*.knowledge, instrumentationName = null, appInfo = ApplicationInfo&#123;159d166 com.*.knowledge&#125;*: V/ActivityThread(3528): java.lang.RuntimeException*: V/ActivityThread(3528): at android.app.ActivityThread$ApplicationThread.bindApplication(ActivityThread.java:919)*: V/ActivityThread(3528): at android.app.IApplicationThread$Stub.onTransact(IApplicationThread.java:374)*: V/ActivityThread(3528): at android.os.Binder.execTransact(Binder.java:697)...*: W/ActivityManager(1696): Slow operation: 133ms so far, now at attachApplicationLocked: after mServices.attachApplicationLocked*: W/Looper(1696): Dispatch took 135ms on android.ui, h=Handler (com.android.server.am.ActivityManagerService$UiHandler) &#123;782d25f&#125; cb=null msg=53// 3. ActivityThread.handleBindApplication 处理应用绑定*: V/ActivityThread(3528): Class path: /data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/base.apk, JNI path: /data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/lib/arm64// 4. PathClassLoader 调用过程堆栈*: E/System(3528): XMT, sourceName = /data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/base.apk, outputName = null, classloader = dalvik.system.PathClassLoader[null]*: E/System(3528): java.lang.Exception*: E/System(3528): at dalvik.system.DexFile.openDexFile(DexFile.java:354)*: E/System(3528): at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:100)*: E/System(3528): at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:74)*: E/System(3528): at dalvik.system.DexPathList.loadDexFile(DexPathList.java:374)*: E/System(3528): at dalvik.system.DexPathList.makeDexElements(DexPathList.java:337)*: E/System(3528): at dalvik.system.DexPathList.&lt;init&gt;(DexPathList.java:157)*: E/System(3528): at dalvik.system.BaseDexClassLoader.&lt;init&gt;(BaseDexClassLoader.java:65)*: E/System(3528): at dalvik.system.PathClassLoader.&lt;init&gt;(PathClassLoader.java:64)*: E/System(3528): at com.android.internal.os.ClassLoaderFactory.createClassLoader(ClassLoaderFactory.java:73)*: E/System(3528): at com.android.internal.os.ClassLoaderFactory.createClassLoader(ClassLoaderFactory.java:88)*: E/System(3528): at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:69)*: E/System(3528): at android.app.ApplicationLoaders.getClassLoader(ApplicationLoaders.java:35)*: E/System(3528): at android.app.LoadedApk.createOrUpdateClassLoaderLocked(LoadedApk.java:693)*: E/System(3528): at android.app.LoadedApk.getClassLoader(LoadedApk.java:727)*: E/System(3528): at android.app.LoadedApk.getResources(LoadedApk.java:954)*: E/System(3528): at android.app.ContextImpl.createAppContext(ContextImpl.java:2270)*: E/System(3528): at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5658)*: E/System(3528): at android.app.ActivityThread.-wrap1(Unknown Source:0)*: E/System(3528): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1663)*: E/System(3528): at android.os.Handler.dispatchMessage(Handler.java:106)*: E/System(3528): at android.os.Looper.loop(Looper.java:164)*: E/System(3528): at android.app.ActivityThread.main(ActivityThread.java:6522)*: E/System(3528): at java.lang.reflect.Method.invoke(Native Method)*: E/System(3528): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)*: E/System(3528): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807) Application 类加载过程在 ActivityThread.handleBindApplication 除了加载 APK 外，还加载了 Application 类并启动这个应用；最终调用 Instrumentation.newApplication 来加载 Application 类的： 1234567// Instrumentation.javapublic Application newApplication(ClassLoader cl, String className, Context context) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return newApplication(cl.loadClass(className), context);&#125; 调用序列图： 部分 Log 打印： 12345678910111213141516171819// Application 类加载过程*: E/System(23352): XMT, ClassLoader.loadClass, name = com.*.knowledge.KnowledgeApplication, resolve = false*: E/System(23352): XMT, ClassLoader.findLoadedClass, name = com.*.knowledge.KnowledgeApplication, this = dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/lib/arm64, /system/lib64, /vendor/lib64]]]*: E/System(23352): java.lang.Exception*: E/System(23352): at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:735)*: E/System(23352): at java.lang.ClassLoader.loadClass(ClassLoader.java:364)*: E/System(23352): at java.lang.ClassLoader.loadClass(ClassLoader.java:312)*: E/System(23352): at android.app.Instrumentation.newApplication(Instrumentation.java:1088)*: E/System(23352): at android.app.LoadedApk.makeApplication(LoadedApk.java:983)*: E/System(23352): at android.app.ActivityThread.handleBindApplication(ActivityThread.java:5734)*: E/System(23352): at android.app.ActivityThread.-wrap1(Unknown Source:0)*: E/System(23352): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1663)*: E/System(23352): at android.os.Handler.dispatchMessage(Handler.java:106)*: E/System(23352): at android.os.Looper.loop(Looper.java:164)*: E/System(23352): at android.app.ActivityThread.main(ActivityThread.java:6522)*: E/System(23352): at java.lang.reflect.Method.invoke(Native Method)*: E/System(23352): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)*: E/System(23352): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)*: E/System(23352): XMT, ClassLoader.loadClass, c = class com.*.knowledge.KnowledgeApplication, parent = java.lang.BootClassLoader@b40a08c Activity 类加载过程不管是在启动应用时启动主 Activity ，还是当前 Activity 打开另一个 Activity 时，最终都是通过 ActivityStackSupervisor.realStartActivityLocked 来调用 Activity.scheduleLaunchActivity 来启动指定 Activity ；而每个 Activity 是在 Instrumentation.newActivity 中来加载的： 1234567// Instrumentation.javapublic Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance();&#125; 调用序列图： 部分 Log 打印： 上半部分为启动主 Activity 下半部分为打开另一个 Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. 启动主 Activity*: V/ActivityManager(1508): realStartActivityLocked, r = ActivityRecord&#123;4d4a239 u0 com.*.knowledge/.MainActivity t57&#125;*: V/ActivityManager(1508): java.lang.RuntimeException*: V/ActivityManager(1508): at com.android.server.am.ActivityStackSupervisor.realStartActivityLocked(ActivityStackSupervisor.java:1466)*: V/ActivityManager(1508): at com.android.server.am.ActivityStackSupervisor.attachApplicationLocked(ActivityStackSupervisor.java:983)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.attachApplicationLocked(ActivityManagerService.java:7310)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.attachApplication(ActivityManagerService.java:7377)*: V/ActivityManager(1508): at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:291)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2971)*: V/ActivityManager(1508): at android.os.Binder.execTransact(Binder.java:697)...// Activity 类加载过程*: V/ActivityThread(4162): scheduleLaunchActivity, info = ActivityInfo&#123;a9454ac com.*.knowledge.MainActivity&#125;*: D/:XMT:KnowApplication:(4162): onCreate: *: E/System(4162): XMT, ClassLoader.loadClass, name = com.*.knowledge.MainActivity, resolve = false*: E/System(4162): XMT, ClassLoader.findLoadedClass, name = com.*.knowledge.MainActivity, this = dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/lib/arm64, /system/lib64, /vendor/lib64]]]*: E/System(4162): java.lang.Exception*: E/System(4162): at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:735)*: E/System(4162): at java.lang.ClassLoader.loadClass(ClassLoader.java:364)*: E/System(4162): at java.lang.ClassLoader.loadClass(ClassLoader.java:312)*: E/System(4162): at android.app.Instrumentation.newActivity(Instrumentation.java:1175)*: E/System(4162): at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2678)*: E/System(4162): at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2865)*: E/System(4162): at android.app.ActivityThread.-wrap11(Unknown Source:0)*: E/System(4162): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1598)*: E/System(4162): at android.os.Handler.dispatchMessage(Handler.java:106)*: E/System(4162): at android.os.Looper.loop(Looper.java:164)*: E/System(4162): at android.app.ActivityThread.main(ActivityThread.java:6524)*: E/System(4162): at java.lang.reflect.Method.invoke(Native Method)*: E/System(4162): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)*: E/System(4162): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)*: E/System(4162): XMT, ClassLoader.loadClass, c = class com.*.knowledge.MainActivity, parent = java.lang.BootClassLoader@11b61a...// 2. 应用已经启动后，打开其他 Activity 流程 *: V/ActivityManager(1508): realStartActivityLocked, r = ActivityRecord&#123;6a96a51 u0 com.*.knowledge/.fourcomponents.ShowService t57&#125;*: V/ActivityManager(1508): java.lang.RuntimeException*: V/ActivityManager(1508): at com.android.server.am.ActivityStackSupervisor.realStartActivityLocked(ActivityStackSupervisor.java:1466)*: V/ActivityManager(1508): at com.android.server.am.ActivityStackSupervisor.startSpecificActivityLocked(ActivityStackSupervisor.java:1589)*: V/ActivityManager(1508): at com.android.server.am.ActivityStack.resumeTopActivityInnerLocked(ActivityStack.java:2752)*: V/ActivityManager(1508): at com.android.server.am.ActivityStack.resumeTopActivityUncheckedLocked(ActivityStack.java:2265)*: V/ActivityManager(1508): at com.android.server.am.ActivityStackSupervisor.resumeFocusedStackTopActivityLocked(ActivityStackSupervisor.java:2103)*: V/ActivityManager(1508): at com.android.server.am.ActivityStack.completePauseLocked(ActivityStack.java:1496)*: V/ActivityManager(1508): at com.android.server.am.ActivityStack.activityPausedLocked(ActivityStack.java:1423)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.activityPaused(ActivityManagerService.java:7634)*: V/ActivityManager(1508): at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:317)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2971)*: V/ActivityManager(1508): at android.os.Binder.execTransact(Binder.java:697)*: V/ActivityThread(4162): scheduleLaunchActivity, info = ActivityInfo&#123;59de479 com.*.knowledge.fourcomponents.ShowService&#125; Service 类加载过程不管 Service 是否设置新进程，也不管是 startService 还是 bindService ，系统都是在 ActivityThread.handleCreateService 中加载 Service 类的。 1234567891011121314// ActivityThread.javaprivate void handleCreateService(CreateServiceData data) &#123; ... LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; ... &#125; ...&#125; bindService 的调用序列图： 部分 Log 打印： 12345678910111213141516171819202122232425262728293031323334353637// 1. ComtextImpl.bindService 开始进入 AMS*: V/ActivityManager(1508): requestServiceBindingLocked*: V/ActivityManager(1508): java.lang.RuntimeException*: V/ActivityManager(1508): at com.android.server.am.ActiveServices.requestServiceBindingLocked(ActiveServices.java:1856)*: V/ActivityManager(1508): at com.android.server.am.ActiveServices.requestServiceBindingsLocked(ActiveServices.java:2260)*: V/ActivityManager(1508): at com.android.server.am.ActiveServices.realStartServiceLocked(ActiveServices.java:2335)*: V/ActivityManager(1508): at com.android.server.am.ActiveServices.bringUpServiceLocked(ActiveServices.java:2187)*: V/ActivityManager(1508): at com.android.server.am.ActiveServices.bindServiceLocked(ActiveServices.java:1442)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.bindService(ActivityManagerService.java:18625)*: V/ActivityManager(1508): at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:584)*: V/ActivityManager(1508): at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2971)*: V/ActivityManager(1508): at android.os.Binder.execTransact(Binder.java:697)// 2. 调用 ActivityThread.scheduleBindService *: V/ActivityThread(4162): scheduleBindService*: V/ActivityThread(4162): java.lang.RuntimeException*: V/ActivityThread(4162): at android.app.ActivityThread$ApplicationThread.scheduleBindService(ActivityThread.java:863)*: V/ActivityThread(4162): at android.app.IApplicationThread$Stub.onTransact(IApplicationThread.java:439)*: V/ActivityThread(4162): at android.os.Binder.execTransact(Binder.java:697)// 3. Service 类加载过程*: E/System(4162): XMT, ClassLoader.loadClass, name = com.*.knowledge.fourcomponents.BindService, resolve = false*: E/System(4162): XMT, ClassLoader.findLoadedClass, name = com.*.knowledge.fourcomponents.BindService, this = dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.*.knowledge-kLwif9bg7jNq6haatwl4ZQ==/lib/arm64, /system/lib64, /vendor/lib64]]]*: E/System(4162): java.lang.Exception*: E/System(4162): at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:735)*: E/System(4162): at java.lang.ClassLoader.loadClass(ClassLoader.java:364)*: E/System(4162): at java.lang.ClassLoader.loadClass(ClassLoader.java:312)*: E/System(4162): at android.app.ActivityThread.handleCreateService(ActivityThread.java:3330)*: E/System(4162): at android.app.ActivityThread.-wrap4(Unknown Source:0)*: E/System(4162): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1686)*: E/System(4162): at android.os.Handler.dispatchMessage(Handler.java:106)*: E/System(4162): at android.os.Looper.loop(Looper.java:164)*: E/System(4162): at android.app.ActivityThread.main(ActivityThread.java:6524)*: E/System(4162): at java.lang.reflect.Method.invoke(Native Method)*: E/System(4162): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)*: E/System(4162): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)*: E/System(4162): XMT, ClassLoader.loadClass, c = class com.*.knowledge.fourcomponents.BindService, parent = java.lang.BootClassLoader@11b61a*: D/:XMT:BindService:(4162): onCreate: *: D/:XMT:BindService:(4162): onBind: 静态注册 BroadcastReceiver 类加载过程静态注册的广播接收器是在 ActivityThread.handleReceiver 中响应广播事件，并加载对应的 BroadcastReceiver 类的： 123456789101112131415161718192021222324252627// ActivityThread.javaprivate void handleReceiver(ReceiverData data) &#123; ... String component = data.intent.getComponent().getClassName(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); IActivityManager mgr = ActivityManager.getService(); Application app; BroadcastReceiver receiver; ContextImpl context; try &#123; app = packageInfo.makeApplication(false, mInstrumentation); context = (ContextImpl) app.getBaseContext(); if (data.info.splitName != null) &#123; context = (ContextImpl) context.createContextForSplit( data.info.splitName); &#125; java.lang.ClassLoader cl = context.getClassLoader(); data.intent.setExtrasClassLoader(cl); data.intent.prepareToEnterProcess(); data.setExtrasClassLoader(cl); receiver=(BroadcastReceiver)cl.loadClass(component).newInstance(); &#125; catch (Exception e) &#123; ... &#125; ...&#125; 完整版本可以参考 四大组件 – Broadcast ，简化后的调用序列图： 部分 Log 打印： 1234567891011121314151606-23 10:47:50.276: E/System(19446): XMT, ClassLoader.loadClass, name = com.staqu.essentials.notifications.NotificationActivationReceiver, resolve = false06-23 10:47:50.276: E/System(19446): XMT, ClassLoader.findLoadedClass, name = com.staqu.essentials.notifications.NotificationActivationReceiver, this = dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/system/priv-app/SalesTracker/SalesTracker.apk&quot;],nativeLibraryDirectories=[/system/priv-app/SalesTracker/lib/arm, /system/fake-libs, /system/priv-app/SalesTracker/SalesTracker.apk!/lib/armeabi-v7a, /system/lib, /vendor/lib, /system/lib, /vendor/lib]]]06-23 10:47:50.277: E/System(19446): java.lang.Exception06-23 10:47:50.277: E/System(19446): at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:735)06-23 10:47:50.277: E/System(19446): at java.lang.ClassLoader.loadClass(ClassLoader.java:364)06-23 10:47:50.277: E/System(19446): at java.lang.ClassLoader.loadClass(ClassLoader.java:312)06-23 10:47:50.277: E/System(19446): at android.app.ActivityThread.handleReceiver(ActivityThread.java:3173)06-23 10:47:50.277: E/System(19446): at android.app.ActivityThread.-wrap17(Unknown Source:0)06-23 10:47:50.277: E/System(19446): at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1679)06-23 10:47:50.277: E/System(19446): at android.os.Handler.dispatchMessage(Handler.java:106)06-23 10:47:50.277: E/System(19446): at android.os.Looper.loop(Looper.java:164)06-23 10:47:50.277: E/System(19446): at android.app.ActivityThread.main(ActivityThread.java:6522)06-23 10:47:50.277: E/System(19446): at java.lang.reflect.Method.invoke(Native Method)06-23 10:47:50.277: E/System(19446): at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:438)06-23 10:47:50.277: E/System(19446): at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:807)06-23 10:47:50.277: E/System(19446): XMT, ClassLoader.loadClass, c = class com.staqu.essentials.notifications.NotificationActivationReceiver, parent = java.lang.BootClassLoader@b40a08c Android 动态类加载示例：动态加载 assets 目录下的 dex 文件，并反射调用指定类中的某个方法，返回值在当前 Activity 中显示。 生成 dex 文件在 AS 中新建 Test.java 文件，编译生成对应的 Test.class，使用工具生成对应的 test.jar 文件：d8.bat --output=test.jar Test.class 。将 Test.java, Test.class, test.jar 三个文件剪切到 assets 目录下，避免将 Test.java 打包到当前 APK 中了。 123456789package com.*.knowledge.classloading;public class Test &#123; public String test()&#123; return "Test: from other dex file, classLoader: " + Test.class.getClassLoader(); &#125;&#125; 当前 Activity 动态加载 使用异步任务 AsyncTask 实现动态加载 避免内存泄露，定义静态内部类 LoaderAsyncTask ，并使用弱引用指向当前 Activity 将 assets 目录下的 dex 文件，拷贝到 cache 目录下，方便动态加载 使用 DexClassLoader 动态加载 cache 目录下的 dex 文件，指定父加载器为 null 使用反射调用 test 方法，并在当前 Activity 中显示结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980package com.*.knowledge.classloading;...public class ClassLoadingActivity extends AppCompatActivity &#123; ... // 避免内存泄露，定义静态内部类 private static class LoaderAsyncTask extends AsyncTask&lt;String, Void, String&gt;&#123; // 使用弱引用指向当前 Activity private WeakReference&lt;ClassLoadingActivity&gt; mActivity; public LoaderAsyncTask(ClassLoadingActivity activity)&#123; mActivity = new WeakReference&lt;ClassLoadingActivity&gt;(activity); &#125; @Override protected void onPreExecute() &#123; super.onPreExecute(); mActivity.get().mTvResult.setText("..."); &#125; @Override protected String doInBackground(String... strings) &#123; ... String destFilePath = mActivity.get().getCacheDir().getAbsolutePath() + File.separator + strings[0]; File destFile = new File(destFilePath); if (!destFile.exists()) &#123; copyFile(mActivity.get().getApplicationContext(), strings[0], destFile); &#125; ... Log.d(TAG, "doInBackground: destFilePath = " + destFilePath); try &#123; // 动态加载 dex 文件，父加载器为 null DexClassLoader dcl = new DexClassLoader(destFilePath, null, null, /*mActivity.get().getClassLoader()*/ null); // 反射加载类，并实例化 Class&lt;?&gt; clazz = dcl.loadClass("com.*.knowledge.classloading.Test"); Object object = clazz.newInstance(); Method testMethod = clazz.getMethod("test"); // 反射调用指定方法 Object result = testMethod.invoke(object, null); Log.d(TAG, "doInBackground: result=" + result.toString()); return result.toString(); &#125; catch (...)&#123;...&#125; ... &#125; &#125; // 拷贝 assets 下指定文件到内存中指定目标文件 private static void copyFile(Context context, String fileName, File destFile)&#123; InputStream in=null; OutputStream out=null; try &#123; context = context.getApplicationContext(); in=context.getAssets().open(fileName); out=new FileOutputStream(destFile.getAbsolutePath()); byte[] bytes=new byte[1024]; int len=0; while ((len=in.read(bytes))!=-1) out.write(bytes,0,len); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (in!=null) in.close(); if (out!=null) out.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 这里需要注意下：DexClassLoader 动态加载时，指定父加载器为 null；依据双亲委派模型，只有父加载器加载失败时，才会使用当前加载器加载。这里假定： Test.java 在当前 APK 存在，并且父加载器使用的是 PathClassLoader 。依据双亲委派模型会优先使用 PathClassLoader 加载 Test 类，而我们指定的 DexClassLoader 并不能动态加载 assets 目录下的 Test 。 示例 Log1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253*: I/mmid(518): select timeout: wait for receiving msg*: D/XMT:ClassLoadingAct(16046): doInBackground: // 1. 将 assets 目录下的 dex 文件，拷贝到 cache 目录下*: D/XMT:ClassLoadingAct(16046): copyFile: fileName = test.jar*: D/XMT:ClassLoadingAct(16046): doInBackground: destFilePath = /data/user/0/com.*.knowledge/cache/test.jar// 2. 动态加载 dex 文件 *: E/System(16046): XMT, openDexFile, sourceName = /data/user/0/com.*.knowledge/cache/test.jar, outputName = null, flags = 0, classloader = dalvik.system.DexClassLoader[null]*: E/System(16046): java.lang.Exception*: E/System(16046): at dalvik.system.DexFile.openDexFile(DexFile.java:356)*: E/System(16046): at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:100)*: E/System(16046): at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:74)*: E/System(16046): at dalvik.system.DexPathList.loadDexFile(DexPathList.java:374)*: E/System(16046): at dalvik.system.DexPathList.makeDexElements(DexPathList.java:337)*: E/System(16046): at dalvik.system.DexPathList.&lt;init&gt;(DexPathList.java:157)*: E/System(16046): at dalvik.system.BaseDexClassLoader.&lt;init&gt;(BaseDexClassLoader.java:65)*: E/System(16046): at dalvik.system.DexClassLoader.&lt;init&gt;(DexClassLoader.java:54)*: E/System(16046): at com.*.knowledge.classloading.ClassLoadingActivity$LoaderAsyncTask.doInBackground(ClassLoadingActivity.java:85)*: E/System(16046): at com.*.knowledge.classloading.ClassLoadingActivity$LoaderAsyncTask.doInBackground(ClassLoadingActivity.java:53)*: E/System(16046): at android.os.AsyncTask$2.call(AsyncTask.java:333)*: E/System(16046): at java.util.concurrent.FutureTask.run(FutureTask.java:266)*: E/System(16046): at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:245)*: E/System(16046): at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)*: E/System(16046): at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)*: E/System(16046): at java.lang.Thread.run(Thread.java:764)*: E/System(16046): XMT, element: null*: I/dex2oat(16078): The ClassLoaderContext is a special shared library.*: I/dex2oat(16078): /system/bin/dex2oat --debuggable --debuggable --dex-file=/data/data/com.*.knowledge/cache/test.jar --output-vdex-fd=64 --oat-fd=65 --oat-location=/data/data/com.*.knowledge/cache/oat/arm64/test.odex --compiler-filter=quicken --class-loader-context=&amp;*: I/InputReader(1509): Reconfiguring input devices. changes=0x00000010*: I/Telecom(1509): DefaultDialerCache: Refreshing default dialer for user 0: now com.android.dialer: DDC.oR@AGc*: W/VoiceInteractionManagerService(1509): no available voice interaction services found for user 0*: D/CarrierSvcBindHelper(2041): No carrier app for: 0*: D/CarrierSvcBindHelper(2041): No carrier app for: 1*: D/ImsResolver(2041): maybeAddedImsService, packageName: com.*.knowledge*: I/dex2oat(16078): dex2oat took 934.000ms (1.609s cpu) (threads: 1000) arena alloc=1432B (1432B) java alloc=16KB (16400B) native alloc=492KB (504744B) free=2MB (2116696B)*: I/zygote64(16046): The ClassLoaderContext is a special shared library.// 3. 加载指定类 Test*: E/System(16046): XMT, ClassLoader.loadClass, name = com.*.knowledge.classloading.Test, resolve = false*: E/System(16046): XMT, ClassLoader.findLoadedClass, name = com.*.knowledge.classloading.Test, this = dalvik.system.DexClassLoader[DexPathList[[zip file &quot;/data/user/0/com.*.knowledge/cache/test.jar&quot;],nativeLibraryDirectories=[/system/lib64, /vendor/lib64]]]*: E/System(16046): java.lang.Exception*: E/System(16046): at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:735)*: E/System(16046): at java.lang.ClassLoader.loadClass(ClassLoader.java:364)*: E/System(16046): at java.lang.ClassLoader.loadClass(ClassLoader.java:312)*: E/System(16046): at com.*.knowledge.classloading.ClassLoadingActivity$LoaderAsyncTask.doInBackground(ClassLoadingActivity.java:86)*: E/System(16046): at com.*.knowledge.classloading.ClassLoadingActivity$LoaderAsyncTask.doInBackground(ClassLoadingActivity.java:53)*: E/System(16046): at android.os.AsyncTask$2.call(AsyncTask.java:333)*: E/System(16046): at java.util.concurrent.FutureTask.run(FutureTask.java:266)*: E/System(16046): at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:245)*: E/System(16046): at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)*: E/System(16046): at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)*: E/System(16046): at java.lang.Thread.run(Thread.java:764)*: E/System(16046): XMT, ClassLoader.loadClass, c = class com.*.knowledge.classloading.Test, parent = dalvik.system.PathClassLoader[DexPathList[[zip file &quot;/data/app/com.*.knowledge-8K_G8HZhGrHEo_X_5AJuhg==/base.apk&quot;],nativeLibraryDirectories=[/data/app/com.*.knowledge-8K_G8HZhGrHEo_X_5AJuhg==/lib/arm64, /system/lib64, /vendor/lib64]]]// 4. 反射调用指定方法 test*: D/XMT:ClassLoadingAct(16046): doInBackground: result = Test: from other dex file, classLoader: dalvik.system.DexClassLoader[DexPathList[[zip file &quot;/data/user/0/com.*.knowledge/cache/test.jar&quot;],nativeLibraryDirectories=[/system/lib64, /vendor/lib64]]] 从 Log 中可以看出，Test.test 方法是 DexClassLoader 加载的，对应路径为 /data/user/0/com.*.knowledge/cache/test.jar 。 Android 热补丁在 Android 动态加载中，我们把 Test.java 从源码中删除了，也就是说 APK 中并不包含这个类，所以通过反射来访问的。接下来我们介绍 Android 热补丁，也就是 Test.java 在 APK 中存在，我们需要使用 assets 中的补丁替换它。 热补丁原理Android 的类加载器在加载一个类时，先从当前加载器的 DexPathList 对象中的 Element[] dexElements 数组中，获取对应的类并加载。采用的是数组遍历的方式，遍历每一个 dex 文件；先遍历出来的是 dex 文件，先加载 class，成功加载后就不再遍历后续 dex 文件。热修复的原理就是：将补丁 class 打包成 dex 文件后，放到 Element 数组的第一个元素，这样就能保证获取到的 class 是最新修复好的 class了。 参考 Java 类加载机制 ，对于 new TestClass() 这个语句，会触发类初始化过程。而初始化分为两部分：类初始化过程 &lt;cinit&gt; ，即类加载过程的初始化阶段；类实例化过程 &lt;init&gt; 。而类一旦初始化后，后续再 new 只会执行实例化过程，也就是常说的类只会被加载一次，但是会实例化多次。所以热补丁必须要在类初始化 &lt;cinit&gt; 之前合入，否则不会生效。 Test 类123456789package com.*.knowledge.classloading;public class Test &#123; public String test()&#123; return "Test: from current APK, classLoader: " + Test.class.getClassLoader(); &#125;&#125; 这个 Test.java 跟随其他代码一起编译到 APK 中，而我们 assets 中的 Test.java 的方法中，返回值不一样 return &quot;Test: from other dex file, classLoader: &quot; ... ，后续通过 Log 和界面显示出来。如果最终热加载成功，将显示 ... from other dex ... 而不是 ... from current APK ... 。 当前 Activity 合入热补丁因为 DexPathList, Element 等都是包内可见，所以只能通过反射将补丁包插入到 Element[] 数组的第一个元素中。 获取系统加载器 PathClassLoader, DexPathList, Elements 获取补丁包中的 DexClassLoader, DexPathList, Elements 将补丁包的 Elements 插入到当前系统加载器的 Elements 中 后续加载修复类时，会优先从补丁包中获取 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135public class HotFixActivity extends AppCompatActivity &#123; ... private String getTestResult()&#123; Test test = new Test(); String result = test.test(); return result; &#125; private void handleHotFix()&#123; HotFixAsyncTask hotFixAsyncTask = new HotFixAsyncTask(this); hotFixAsyncTask.execute(); &#125; private static class HotFixAsyncTask extends AsyncTask&lt;String, Void, String&gt;&#123; private WeakReference&lt;HotFixActivity&gt; mActivity; private String mDexFilePath; public HotFixAsyncTask(HotFixActivity activity)&#123; mActivity = new WeakReference&lt;HotFixActivity&gt;(activity); &#125; @Override protected String doInBackground(String... strings) &#123; if (isDexFileExist()) &#123; //hotFix(); return mActivity.get().getTestResult(); &#125; return "Hot Fix Error!"; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); mActivity.get().mBtnHotFix.setEnabled(true); mActivity.get().mTvNew.setText(s); &#125; private boolean isDexFileExist()&#123; String dexFileName = "test.jar"; mDexFilePath = mActivity.get().getCacheDir().getAbsolutePath() + File.separator + dexFileName; File destFile = new File(mDexFilePath); if (!destFile.exists()) &#123; copyFile(mActivity.get().getApplicationContext(), dexFileName, destFile); &#125; if (!destFile.exists())&#123; Log.d(TAG, "isDexFileExist: copy error!"); return false; &#125; return true; &#125; private void hotFix()&#123; Log.d(TAG, "hotFix: "); try &#123; // 1.1 获取系统加载器 PathClassLoader pcl = (PathClassLoader) mActivity.get().getClassLoader(); // 1.2 使用 DexClassLoader 加载补丁包 DexClassLoader dcl = new DexClassLoader(mDexFilePath, null, null, pcl); // 2.1 获取当前已经加载的 DexPathList Object origDexPathList = getPathList(pcl); // 2.2 获取当前加载器的 Elements 数组 Object origElements = getDexElements(origDexPathList); // 3.1 获取补丁包中的 DexPathList Object patchDexPathList = getPathList(dcl); // 3.2 获取补丁包中的 Elements 数组 Object patchElements = getDexElements(patchDexPathList); // 4 将补丁包插入到当前 Elements 数组前面 Object patchedElements = combineArray(patchElements, origElements); setDexElements(origDexPathList, patchedElements); &#125; catch (...) &#125; private static void setField(Object object, Class&lt;?&gt; clazz, String fieldName, Object value) throws NoSuchFieldException, IllegalAccessException &#123; Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); field.set(object, value); &#125; private static Object getField(Object object, Class&lt;?&gt; clazz, String fieldName) throws NoSuchFieldException, IllegalAccessException &#123; Field field = clazz.getDeclaredField(fieldName); field.setAccessible(true); return field.get(object); &#125; private Object getPathList(ClassLoader cl) throws NoSuchFieldException, IllegalAccessException &#123; return getField(cl, cl.getClass().getSuperclass(), "pathList"); &#125; private Object getDexElements(Object dexPathList) throws NoSuchFieldException, IllegalAccessException &#123; Log.d(TAG, "getDexElements: "); return getField(dexPathList, dexPathList.getClass(), "dexElements"); &#125; private void setDexElements(Object dexPathList, Object elements) throws NoSuchFieldException, IllegalAccessException &#123; Log.d(TAG, "setDexElements: "); setField(dexPathList, dexPathList.getClass(), "dexElements", elements); &#125; private static Object combineArray(Object array1, Object array2) &#123; Log.d(TAG, "combineArray: "); if (array1 == null || !array1.getClass().isArray() || array2 == null || !array2.getClass().isArray()) &#123; Log.d(TAG, "combineArray: array is null."); return null; &#125; Class&lt;?&gt; clazz = array1.getClass().getComponentType(); int length1 = Array.getLength(array1); int length2 = Array.getLength(array2); int length = length1 + length2; Object combineArray = Array.newInstance(clazz, length); System.arraycopy(array1, 0, combineArray, 0, length1); System.arraycopy(array2, 0, combineArray, length1, length2); return combineArray; &#125; ... &#125;&#125; 示例 Log123456789101112131415161718192021222324252627282930* I/mmid: select timeout: wait for receiving msg*/com.*.knowledge D/XMT:HotFixAct: hotFix: */com.*.knowledge E/System: XMT, openDexFile, sourceName = /data/user/0/com.*.knowledge/cache/test.jar, outputName = null, flags = 0, classloader = dalvik.system.DexClassLoader[null]*/com.*.knowledge E/System: java.lang.Exception at dalvik.system.DexFile.openDexFile(DexFile.java:356) at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:100) at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:74) at dalvik.system.DexPathList.loadDexFile(DexPathList.java:374) at dalvik.system.DexPathList.makeDexElements(DexPathList.java:337) at dalvik.system.DexPathList.&lt;init&gt;(DexPathList.java:157) at dalvik.system.BaseDexClassLoader.&lt;init&gt;(BaseDexClassLoader.java:65) at dalvik.system.DexClassLoader.&lt;init&gt;(DexClassLoader.java:54) at com.*.knowledge.classloading.HotFixActivity$HotFixAsyncTask.hotFix(HotFixActivity.java:108) at com.*.knowledge.classloading.HotFixActivity$HotFixAsyncTask.doInBackground(HotFixActivity.java:76) at com.*.knowledge.classloading.HotFixActivity$HotFixAsyncTask.doInBackground(HotFixActivity.java:60) at android.os.AsyncTask$2.call(AsyncTask.java:333) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:245) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636) at java.lang.Thread.run(Thread.java:764)* /com.*.knowledge E/System: XMT, element: null* /com.*.knowledge I/zygote64: The ClassLoaderContext is a special shared library.* /com.*.knowledge D/XMT:HotFixAct: getPathList: * /com.*.knowledge D/XMT:HotFixAct: getDexElements: * /com.*.knowledge D/XMT:HotFixAct: getPathList: * /com.*.knowledge D/XMT:HotFixAct: getDexElements: * /com.*.knowledge D/XMT:HotFixAct: combineArray: * /com.*.knowledge D/XMT:HotFixAct: setDexElements: * /com.*.knowledge D/XMT:HotFixAct: getTestResult: result = Test: from other dex file, classLoader: dalvik.system.PathClassLoader[DexPathList[[zip file "/data/user/0/com.*.knowledge/cache/test.jar", zip file "/data/app/com.*.knowledge-0dRhS8t5SzW66qvx7ecm8w==/base.apk"],nativeLibraryDirectories=[/data/app/com.*.knowledge-0dRhS8t5SzW66qvx7ecm8w==/lib/arm64, /system/lib64, /vendor/lib64]]] 从结果可以看出 Test 类是从补丁包中加载的: 类加载器为系统加载器 PathClassLoader，也就是它的 Elements 数组已经通过反射合入了热补丁 DexPathList 中包含两个文件：补丁包 /data/user/0/com.*.knowledge/cache/test.jar 和原始的 APK: /data/app/com.*.knowledge-0dRhS8t5SzW66qvx7ecm8w==/base.apk 其他dalvikvm类似 PC 端的 java 工具，用来指执行 apk,dex,jar 等 Android 可执行文件的，常用参数为： -cp ：指定可执行文件绝对路径 -verbose:class ：在 logcat 中输出类加载过程 1234567891011xmt@server005:~/$ dalvikvm --helpUnknown argument: --helpdalvikvm: [options] class [argument ...]The following standard options are supported: -classpath classpath (-cp classpath) -Dproperty=value -verbose:tag (&apos;gc&apos;, &apos;jit&apos;, &apos;jni&apos;, or &apos;class&apos;) -showversion -help ... 下面是一个调试过程，可以看到 Android 类加载过程 java 文件编写 123456public class DalvikvmTest &#123; public static void main(String[] args) &#123; System.out.println("This is DalvikvmTest."); &#125;&#125; class 文件生成javac -bootclasspath C:\Users\xmt\sdk\platforms\android-28\android.jar DalvikvmTest.java ，这里可以省略 -bootclasspath ，只有在调用了 android 代码时才需要。 dex, jar 文件生成 1C:\Users\xmt\sdk\build-tools\28.0.3\d8.bat --classpath C:\Users\xmt\sdk\platforms\android-28\android.jar --output=DalvikvmTest.jar DalvikvmTest.class 这里同样可以省略 --classpath 。 push 到手机中，dalvikvm 执行 123adb push DalvikvmTest.jar /storage/emulated/0/testadb shelldalvikvm -verbose:class -cp /storage/emulated/0/test/DalvikvmTest.jar DalvikvmTest 对应 log从 Log 中可以清晰的看到类的加载和类初始化两个过程，默认使用的是 PathClassLoader 类加载器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/? I/dalvikvm: Adding image space took 153.906us/? I/dalvikvm: Adding image space took 57.448us/? I/dalvikvm: Adding image space took 71.718us.../? W/ADebug: Failed to get property persist.sys.media.traces/? I/dalvikvm: Initialized class Landroid/system/OsConstants; from /system/framework/core-libart.jar/? I/dalvikvm: Initialized class Ljava/io/FileDescriptor; from /system/framework/core-oj.jar/? I/dalvikvm: Initialized class Ljava/net/Inet4Address; from /system/framework/core-oj.jar/? I/dalvikvm: Initialized class Ljava/lang/System; from /system/framework/core-oj.jar/? I/dalvikvm: Initialized class Ljava/net/Inet6Address; from /system/framework/core-oj.jar/? I/dalvikvm: Initialized class Ljava/io/UnixFileSystem; from /system/framework/core-oj.jar/? I/dalvikvm: Initialized class Ljava/io/File; from /system/framework/core-oj.jar/? I/dalvikvm: Initialized class Ljava/util/regex/Pattern; from /system/framework/core-oj.jar/? I/dalvikvm: Loaded class [Ljava/lang/ThreadLocal$ThreadLocalMap$Entry;/? E/System: XMT, openDexFile, sourceName = /storage/emulated/0/test/DalvikvmTest.jar, outputName = null, flags = 0, classloader = dalvik.system.PathClassLoader[null]/? E/System: java.lang.Exception at dalvik.system.DexFile.openDexFile(DexFile.java:356) at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:100) at dalvik.system.DexFile.&lt;init&gt;(DexFile.java:74) at dalvik.system.DexPathList.loadDexFile(DexPathList.java:374) at dalvik.system.DexPathList.makeDexElements(DexPathList.java:337) at dalvik.system.DexPathList.&lt;init&gt;(DexPathList.java:157) at dalvik.system.BaseDexClassLoader.&lt;init&gt;(BaseDexClassLoader.java:65) at dalvik.system.PathClassLoader.&lt;init&gt;(PathClassLoader.java:64) at java.lang.ClassLoader.createSystemClassLoader(ClassLoader.java:224) at java.lang.ClassLoader.-wrap0(Unknown Source:0) at java.lang.ClassLoader$SystemClassLoader.&lt;clinit&gt;(ClassLoader.java:183) at java.lang.ClassLoader.getSystemClassLoader(ClassLoader.java:1110)/? E/System: XMT, element: null/? I/dalvikvm: The ClassLoaderContext is a special shared library./? I/dalvikvm: Registering /storage/emulated/0/test/oat/arm64/DalvikvmTest.odex/? I/dalvikvm: Initialized class Ljava/lang/ClassLoader$SystemClassLoader; from /system/framework/core-oj.jar// 加载 DalvikvmTest 类/? I/dalvikvm: Loaded class LDalvikvmTest; from /storage/emulated/0/test/DalvikvmTest.jar/? I/dalvikvm: Beginning verification for class: DalvikvmTest in /storage/emulated/0/test/DalvikvmTest.jar/? I/dalvikvm: Class preverified status for class DalvikvmTest in /storage/emulated/0/test/DalvikvmTest.jar: 1// DalvikvmTest 类初始化/? I/dalvikvm: Initialized class LDalvikvmTest; from /storage/emulated/0/test/DalvikvmTest.jar/? I/dalvikvm: Initialized class Llibcore/icu/NativeConverter; from /system/framework/core-libart.jar/? I/dalvikvm: Initialized class Ljava/nio/charset/StandardCharsets; from /system/framework/core-oj.jar/? I/dalvikvm: Loaded class Ljava/io/BufferedWriter; from /system/framework/core-oj.jar/? I/dalvikvm: Beginning verification for class: java.io.BufferedWriter in /system/framework/core-oj.jar/? I/dalvikvm: Class preverified status for class java.io.BufferedWriter in /system/framework/core-oj.jar: 1/? I/dalvikvm: Initialized class Ljava/io/BufferedWriter; from /system/framework/core-oj.jar AOSP libcore 编译在调试时，希望打出类加载堆栈中调用关系，在 DexFile.java 中增加了一个 Log 打印：System.logE(&quot;XMT, ***&quot; , new Exception()); 。修改完代码后，在 libcore 目录下编译 mm ，但是总是会出错并打印如下信息： 12ninja: error: &apos;out/host/common/obj/JAVA_LIBRARIES/junit-hostdex_intermediates/classes.jack&apos;, needed by &apos;out/host/common/obj/JAVA_LIBRARIES/core-test-rules-hostdex_intermediates/classes.jack&apos;, missing and no known rule to make it11:21:10 ninja failed with: exit status 1 根据错误信息，需要编译 core-test-rules 模块，其实我们并不需要。在 libcore/JavaLibrary.mk 中看到这个模块是宏 LIBCORE_SKIP_TESTS 控制的，我们在 libcore/Android.mk 中注释掉这个宏，export LIBCORE_SKIP_TESTS = false ，重新编译。Java 代码的改动会更新： 1234out/***/system/framework/core-libart.jarout/***/system/framework/boot-core-libart.vdexout/***/system/framework/boot-core-libart.oatout/***/system/framework/boot-core-libart.art 将这几个文件 push 到手机后重启生效。 小结： 打印 log 方式：使用 System.logE() 编译方式：设置 export LIBCORE_SKIP_TESTS = false ，在 libcore/ 目录下 mm 常见问题APK 加载过程应用中的四大组件和自定义类，编译工具会先将 Java 文件生成 .class ，然后合并成 .dex 文件，最终打包成 APK 。Android 启动 APP 时，会加载对应的 APK 文件，并将整个 APK 中相关类信息加载到虚拟机中，参考 APK 加载过程章节中的序列图。 Android 类加载时机APK 加载后，并不会将拥有的类全部加载，只有在类初始化时才会加载，类加载时机参考 Java 类加载机制 ，大概有 5 种情况会触发。 APK 中的四大组件是主动调用 ClassLoader 来加载，通过反射来实例化的 APK 中普通自定义类通过 new 来加载和实例化；这个过程并没有出现 ClassLoader 类加载器相关调用关系，怀疑是虚拟机 ART 中直接实现（没有看虚拟机的实现代码只是猜测） APK 中如果遇到了 framework 中的类，会通过双亲委派模型从系统中 ClassLoader.findLoadedClass 查找已经加载的类 虚拟机 ART 中的底层代码，在加载应用中的类时，会在 Java DexPathList.Elements 数组中查找对应的 apk, dex, jar 等文件，并加载对应类（并没有搞清楚底层代码是怎么实现的，但是从热补丁的测试结果来看是这样的） 打印类加载过程可以通过 dalvikvm -verbose:class 简单了解类加载过程。 几个重要的 native 方法 DexFile.openDexFile -&gt; openDexFileNative DexFile.defineClass -&gt; defineClassNative Class.classForName ClassLoader.findLoadedClass -&gt; VMClassLoader.findLoadedClass 后续 热加载，插件化详细分析 ART 底层代码分析 参考文档 JIT和AOT的比较 JVM解释器 JIT与JVM的三种执行模式 ART、JIT、AOT、Dalvik之间的关系 odex文件在Dalvik和ART中不同的含义 android 文件格式 ELF格式的oat文件图解 ELF文件格式解析 jack：字节码生成工具 API Reference: PathClassLoader API Reference: DexClassLoader API Reference: InMemoryDexClassLoader API Reference: DelegateLastClassLoader API Reference: BaseDexClassLoader Android动态加载Dex过程 热修复——深入浅出原理与实现 ART配置 Android类加载机制的细枝末节 ART运行普通java程序 Android动态加载基础 ClassLoader工作机制 ART系统类的编译解析加载探究 老罗：Android运行时ART简要介绍和学习计划 尼古拉斯_赵四:Android中的动态加载机制 Android自定义ClassLoader耗时问题追查 Android Dalvikvm的使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Shell 命令及相关知识]]></title>
    <url>%2F2018%2F10%2F08%2F0107-linux-shell%2F</url>
    <content type="text"><![CDATA[Linux Shell 小知识汇总。 basename 获取文件名描述：从带路径的字符串中获取文件名称，或者截取字符串。 1234567891011var1=/usr/lib/abcdefg.so.bak var2=/usr/sbin/ifconfiggg all_name=`basename $var1` // 获取文件名称sub_name1=`basename $var1 .bak` // 截取字符串sub_name2=`basename $var2 gg` echo "all_name: $all_name" // all_name: abcdefg.so.bak echo "sub_name1: $sub_name1" // sub_name1: abcdefg.so echo "sub_name2: $sub_name2" // sub_name2: ifconfig screen 的使用作用：后台开启终端，执行各种命令。即使当前终端已经退出，不会影响 screen 的后台终端命令的执行。 新建和连接12screen -dmS back_xmt // 新建screen -r back_xmt // 连接 断开连接断开连接只是回到当前终端，后台 screen 命令会继续执行。 断开连接后，同时按下 ctrl+a 进入，再接着按 d，断开连接。 关闭连接后，同时按下 ctrl+a 进入，再接着按 k，关闭连接。 &amp; 挂后台示例：vi 1.txt &amp; 。查看：jobs 查看挂后台有几个进程。前置切换：fg 1 ，其中 1 表示 jobs 查看到的第一个程序。 管理普通用户创建和删除用户12adduser fcopyuseruserdel fcopyuser 查看用户所在组 groups12root@ubuntu1404:~# groups xmtxmt : xmt 管理用户组 gpasswd 将用户加入管理员组： 12gpasswd -a xmt sudogpasswd -a xmt adm 再次查看，账号已经具有管理员权限： 12root@ubuntu1404:~# groups xmtxmt : xmt adm sudo 将用户移出某个组gpasswd -d xmt rootgroup expect 功能linux shell 命令行自动交互，比如自动登录，或者自动输入密码，可以使用 expect 功能。 安装sudo apt-get install expect 示例自动输入 scp 需要的密码： 1234567891011121314151617181920212223#!/bin/bashCMD_EXPECT=/usr/bin/expectfunction check_cmd_expect()&#123; if [ ! -f $CMD_EXPECT ]; then echo "Please Install expect: sudo apt-get install expect!" exit fi&#125;function scp_source()&#123; $&#123;CMD_EXPECT&#125;&lt;&lt;EOF set timeout 1200; spawn /usr/bin/scp server@10.1.1.138:/home/server/test.tgz ./ expect "*password:" send "server\r" // 自动填入密码 server expect eofEOF&#125;check_cmd_expectscp_source crontab 定时任务格式格式：M H D m d cmd 。其中： M: 分钟（0-59） H：小时（0-23） D：天（1-31） m: 月（1-12） d: 一星期内的天（0~6，0为星期天） cmd 要运行的程序，程序被送入 sh 执行。 该命令中只有 USER, HOME, SHELL 这三个环境变量，如果需要使用其他环境变量，需要在 cmd 中 export 这些变量。 使用方法 crontab –l：查看当前的任务 crontab –e：编辑（新建）任务 crontab –r：删除任务表 sudo service cron restart：重启 crontab 服务 示例定时执行脚本： 1234#定时每天 10 点 21 分执行脚本21 10 * * * /home/xmt/share/Temp/delete/1.sh#定时每隔 2 分钟执行脚本*/2 * * * * /home/fcopyuser/HO9021/daily_build/daily_build.sh TAR 常用命令 压缩：tar zcf dest.tgz source注意：source 不要带路径，否则会将路径目录也压缩进去。如 /home/source，会把 home 这个目录也压缩到包中。压缩命令 z 表示用 gzip 压缩；如果不带 z 表示仅打包。 解压：tar zxf dest.tgz 不解压，直接查看压缩包有哪些文件：tar tvf dest.tgz 分卷压缩tar zcf - test.pdf | split -b 5M - dir/test.tar.gz ，注意两个短横不能漏掉； -b 后面表示每卷最大值。 字符串操作获取字符串中的数字如：echo &quot;ere1j32kk4&quot; | tr -cd &#39;[0-9\n]&#39; #1324 。 当前时间 date命令：date +%Y%m%d%H%M%S # 20141126104053 。格式：Y 年，m 月，d 日，H 小时，M 分，S 秒。 查看服务器上用户登录日志cat /var/log/auth.log 把自己的命令添加到环境变量中 新建 bin 目录：mkdir –p $HOME/bin 新建可执行命令：touch my.sh ;chmod +x my.sh bin 目录加入到环境变量中 123root@ubuntu1404:~# vi ~/.bashrc# add my exec binPATH=$PATH:$HOME/bin 重新加载环境变量：source ~/.bashrc 至此 bin 目录下所有可执行文件都加入到环境变量了 7z 格式文件操作解压缩示例 1 ：当前目录解压：7za x po9041_20141202.7z示例 2 ：解压到指定目录：7za x po9041_20141202.7z -opo9041_20141202其中 -o 后面不能有空格。 压缩使用 du 查看大小并按照大小排序1du -sh `du -s * | sort -rn| awk '&#123;print $2&#125;'` 开机自启动脚本新建脚本创建脚本后，并将脚本拷贝到 /etc/init.d/ 目录下。 1234sudo -stouch new_service.shchmod +x new_service.shmv new_service.sh /etc/init.d/ update-rc.d 命令update-rc.d 命令用来设置开机启动的优先级。 123update-rc.d &lt;basename&gt; start|stop &lt;order&gt; &lt;runlevels&gt;update-rc.d &lt;basename&gt; defaults &lt;order&gt;update-rc.d -f &lt;basename&gt; remove 其中：update-rc.d sample_init_script defaults 命令等效于（中间是一个英文句点符号）：update-rc.d sample_init_script start 20 2 3 4 5 . stop 20 0 1 6 .，表示在 2, 3, 4, 5 这五个运行级别中，由小到大第 20 个开始运行 sample_init_script；在 0 1 6 这 3 个运行级别中，第 20 个关闭 sample_init_script 。这是合并起来的写法，注意它有 2 个点号。比如，我们将 gerrit_start 脚本放在第 99 顺位命令后执行： 1234567891011root@gm-20180529:/etc/init.d# update-rc.d gerrit_start defaults 99update-rc.d: warning: /etc/init.d/gerrit_start missing LSB informationupdate-rc.d: see &lt;http://wiki.debian.org/LSBInitScripts&gt; Adding system startup for /etc/init.d/gerrit_start ... /etc/rc0.d/K99gerrit_start -&gt; ../init.d/gerrit_start /etc/rc1.d/K99gerrit_start -&gt; ../init.d/gerrit_start /etc/rc6.d/K99gerrit_start -&gt; ../init.d/gerrit_start /etc/rc2.d/S99gerrit_start -&gt; ../init.d/gerrit_start /etc/rc3.d/S99gerrit_start -&gt; ../init.d/gerrit_start /etc/rc4.d/S99gerrit_start -&gt; ../init.d/gerrit_start /etc/rc5.d/S99gerrit_start -&gt; ../init.d/gerrit_start sysv-rc-conf 命令sysv-rc-conf 命令可以直观的查看，并勾选运行级别。 安装：apt-get install sysv-rc-conf 查看 1234root@gm-20180529:~# sysv-rc-confx service 1 2 3 4 5 0 6 S x --------------------------------------------------------------------------x gerrit_st$ [ ] [X] [X] [X] [X] [ ] [ ] [ ] grep 常见操作在指定文件类型中搜索比如在 cpp, java, h 文件中搜索字符串 adjustment ，命令如下： 1grep --include=*.&#123;cpp,java,h&#125; -irsn &quot;adjustment&quot; frameworks/ 设置代理在当前用户 shell 环境下设置代理，打开 ~/.bashrc 文件，添加如下代码： 1234# http_proxyexport http_proxy="ip:port"export https_proxy="ip:port"export no_proxy="localhost, 127.0.0.1, *.my.lan" 其中 ip:port 是代理服务器的地址以及开放的端口；重新连接或者执行 source ~/.bashrc 生效！验证结果： 12345678910xmt@server138:~$ wget https://www.google.com--2019-05-17 17:40:28-- https://www.google.com/Connecting to 10.50.100.113:3128... connected.Proxy request sent, awaiting response... 200 OKLength: unspecified [text/html]Saving to: ‘index.html.1’ [ &lt;=&gt; ] 11,889 --.-K/s in 0.02s2019-05-17 17:40:29 (739 KB/s) - ‘index.html.1’ saved [11889] 参考文档 鸟哥的私房菜]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 二叉树]]></title>
    <url>%2F2018%2F09%2F27%2F0106-algorithms-binary-tree%2F</url>
    <content type="text"><![CDATA[介绍树的定义和基本术语；二叉树基础知识、性质；二叉树前中后序遍历，层次遍历；哈夫曼编码等。 树的定义和基本术语树的定义树 Tree 是 n(n≧0) 个结点的有限集合 T，若 n=0 时称为空树，否则： 有且只有一个特殊的称为：树的根 Root 结点 若 n&gt;1 时，其余的结点被分为 m(m&gt;0) 个互不相交的子集 T1, T2, T3, ... , Tm，其中每个子集本身又是一棵树，称其为根的子树 Subtree这是树的递归定义，即用树来定义树，而只有一个结点的树必定仅由根组成。 基本术语 结点 node一个数据元素及其若干指向其子树的分支。 结点的度 degree结点所拥有的子树的棵数称为结点的度。 树的度树中结点度的最大值称为树的度。 叶子 leaf 结点树中度为 0 的结点称为叶子结点或终端结点。 非叶子结点度不为 0 的结点称为非叶子结点，或者非终端结点、分支结点；除根结点外，分支结点又称为内部结点。 孩子结点 child / 双亲结点 parent一个结点的子树的根称为该结点的孩子结点或子节点；该结点是其孩子结点的双亲结点或父结点。 兄弟结点同一双亲结点的所有子结点互称为兄弟结点。 层次规定树中根结点的层次为 1 ，其余结点的层次等于其双亲结点的层次加 1 。 堂兄弟节点双亲结点在同一层上的所有结点互称为堂兄弟结点。 结点的层次路径从根结点开始，到达某结点 p 所经过的所有结点成为结点 p 的层次路径(有且只有一条)。 祖先 ancester / 子孙 descent结点 p 的层次路径上的所有结点（p 除外）称为 p 的祖先；以某一结点为根的子树中的任意结点称为该结点的子孙结点。 树的深度 depth树中结点的最大层次值，又称为树的高度。 森林 forest森林是 m(m≧0) 棵互不相交的树的集合。如果将一棵树的根结点删除，剩余的子树就构成了森林。 二叉树定义二叉树 Binary tree 是 n(n≥0) 个结点的有限集合。若 n=0 时称为空树，否则： 有且只有一个特殊的称为：树的根 Root 结点 若 n&gt;1 时，其余的结点被分成为二个互不相交的子集 T1, T2，分别称之为左子树、右子树，并且左、右子树又都是二叉树由此可知，二叉树的定义是递归的。 满二叉树满二叉树 Full Binary Tree ：一棵深度为 k 且有 2ᵏ-1 个结点的二叉树称为满二叉树。其特点为： 每一层上的结点数总是最大结点数 满二叉树的所有的子结点都有左、右子树 对满二叉树的结点进行连续编号，若规定从根结点开始，可以按“自上而下、自左至右”的原则进行 完全二叉树完全二叉树 Complete Binary Tree：如果深度为 k，有 n 个结点的二叉树，当且仅当其每一个结点都与深度为 k 的满二叉树中编号从 1 到 n 的结点一一对应，该二叉树称为完全二叉树。完全二叉树是满二叉树的一部分，而满二叉树是完全二叉树的特例。其特点为： 若完全二叉树的深度为 k ，则所有的叶子结点都出现在第 k 层或 k-1 层 对于任一结点，如果其右子树的最大层次为 k，则其左子树的最大层次为 k 或 k+1 性质 在非空二叉树中，第 i(i≧1) 层上至多有 2^(i-1) 个结点 深度为 k(k≧1) 的二叉树至多有 2ᵏ-1 个结点 对任何一棵二叉树，若其叶子结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 N 个结点的完全二叉树深度为 |logN| + 1 ；|| 表示向下取整 对一棵有 n 个结点的完全二叉树（深度为 |logN|+1） 的结点，从第 1 层到第 |logN|+1 层，按照层序从左向右进行编号，则对于编号为 i(1≦i≦n) 的结点： 如果 i=1 ，则结点 i 是二叉树的根，无双亲结点；否则如果 i&gt;1 ，则其双亲结点编号是 |i/2| 如果 2i&gt;n ，则结点 i 为叶子结点，无左孩子；否则其左孩子结点编号是 2i 如果 2i+1&gt;n ，则结点 i 无右孩子；否则其右孩子结点编号是 2i+1 二叉树遍历几个简称：节点 N:Node，左子树 L:Left subtree 和右子树 R:Right subtree 。 基本概念 前序遍历前序遍历 Preorder Traversal ，也称为先序遍历、NLR ：先访问根结点，再遍历左子树，然后遍历右子树。 中序遍历中序遍历 Inorder Traversal ，LNR ：先遍历左子树，再访问根，然后遍历右子树。 后序遍历后序遍历 Postorder Traversal ，LRN ：先遍历左子树，再遍历右子树，然后访问根。 层级遍历层次遍历是从根结点开始遍历，按层次次序“自上而下，从左至右”访问树中的各结点。 可以看出：前中后序遍历都是针对根而言的。二叉树也可以按照深度和广度搜索来划分： 深度优先搜索实际就是前序遍历，沿着树的深度遍历树的节点，尽可能深的搜索树的分支；先访问根结点，然后遍历左子树接着是遍历右子树。 广度优先搜索实际就是层级遍历，是从根结点开始沿着树的宽度搜索遍历。 前中后序遍历图解 前中后序遍历递归实现前序遍历算法的递归定义是：若二叉树为空，则遍历结束；否则： 访问根结点 先序遍历左子树(递归调用本算法) 先序遍历右子树(递归调用本算法) 1234567891011121314151617181920212223242526// 前序遍历private void preOrderTraversal(Node node)&#123; if (node != null)&#123; visit(node.value); preOrderTraversal(node.leftChild); preOrderTraversal(node.rightChild); &#125;&#125;// 中序遍历private void inOrderTraversal(Node node)&#123; if (node != null)&#123; inOrderTraversal(node.leftChild); visit(node.value); inOrderTraversal(node.rightChild); &#125;&#125;// 后序遍历private void postOrderTraversal(Node node)&#123; if (node != null)&#123; postOrderTraversal(node.leftChild); postOrderTraversal(node.rightChild); visit(node.value); &#125;&#125; 从递归算法的实现，也可以看出三种算法的区别仅仅是根访问顺序不一样。 前中后序遍历非递归实现因为递归算法默认使用的是系统调用栈，而前中后序遍历非递归实现，主要是定义一个栈来替换系统调用栈。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private void preOrderNonRecur(Node node)&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.empty())&#123; while (node != null)&#123; visit(node.value); stack.push(node); node = node.leftChild; &#125; if (!stack.empty())&#123; node = stack.pop(); node = node.rightChild; &#125; &#125;&#125;private void inOrderNonRecur(Node node)&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while (node != null || !stack.empty())&#123; while (node != null)&#123; stack.push(node); node = node.leftChild; &#125; if (!stack.empty())&#123; node = stack.pop(); visit(node.value); node = node.rightChild; &#125; &#125;&#125;private void postOrderNonRecur(Node node)&#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node lastVisited = null; while (node != null || !stack.empty())&#123; if (node != null)&#123; // 根节点左子节点入栈 stack.push(node); node = node.leftChild; &#125; else &#123; // 取出根节点 node = stack.pop(); // 一个根节点被访问的前提是：无右子树或右子树已被访问过 if (node.rightChild == null || node.rightChild == lastVisited)&#123; visit(node.value); lastVisited = node; // 访问完置空，等待取出栈中下个节点 node = null; &#125; else &#123; // 根节点重新入栈 stack.push(node); // 根节点右子节点入栈 node = node.rightChild; stack.push(node); // 右子节点的左子树 node = node.leftChild; &#125; &#125; &#125;&#125;// 双栈实现，非常简单// 栈 1 入栈顺序为：根-左-右；出栈顺序：根-右-左// 栈 2 入栈顺序为：根-右-左；即为栈 1 的出栈顺序private void postOrderNonRecur2(Node node)&#123; Stack&lt;Node&gt; stack2 = new Stack&lt;&gt;(); stack1.add(node); while (!stack1.isEmpty()) &#123; node = stack1.pop(); stack2.push(node); if (node.leftChild != null) &#123; stack1.push(node.leftChild); &#125; if (node.rightChild != null) &#123; stack1.push(node.rightChild); &#125; &#125; Node n; while (!stack2.empty())&#123; n = stack2.pop(); visit(n.value); &#125;&#125; 前序、中序遍历的非递归实现比较简单；后续遍历因为节点无法获取父节点信息，所以需要做多次判断，并记录上次已经被访问的节点。后序遍历的双栈实现巧妙的利用了两个栈的入出栈顺序，获取最终的根左右遍历结果。非递归算法有多种实现：参考 BinaryTree.Java 层级遍历层次遍历非递归算法是：若二叉树为空，则返回；否则： 访问访问当前节点 如果节点左子树不为空，左子树入队 如果节点右子树不为空，右子结入队 取出队首节点，直到队列为空 1234567891011121314151617private void levelTraversal(Node node)&#123; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); while (node != null || !queue.isEmpty())&#123; visit(node.value); if (node.leftChild != null) &#123; queue.offer(node.leftChild); &#125; if (node.rightChild != null) &#123; queue.offer(node.rightChild); &#125; node = queue.poll(); &#125;&#125; 哈夫曼编码哈夫曼 Huffman 树，又称最优二叉树，是一类带权路径长度最短的二叉树。 基础概念 结点路径从树中一个结点到另一个结点的之间的分支构成这两个结点之间的路径。 路径长度结点路径上的分支数目称为路径长度。 树的路径长度从树根到每一个结点的路径长度之和。 结点的带权路径长度从该结点的到树的根结点之间的路径长度与结点的权值的乘积。权值：各种开销、代价、频度等的抽象称呼。 树的带权路径长度树中所有叶子结点的带权路径长度之和，记做：WPL=W1×L1+W2×L2+...+Wn×ln=ΣWi×Li(i=1,2,...,n) ，其中：n 为叶子结点的个数；Wi 为第 i 个结点的权值；Li 为第 i 个结点的路径长度。 哈夫曼 Huffman 树：具有 n 个叶子结点，每个结点的权值为 Wi 的二叉树不止一棵，但在所有的这些二叉树中，必定存在一棵 WPL 值最小的树，称这棵树为 Huffman 树或称最优树。几个特点： 满二叉树不一定是哈夫曼树 哈夫曼树中权越大的叶子离根越近 具有相同带权结点的哈夫曼树不惟一 哈夫曼树的结点的度数为 0 或 2， 没有度为 1 的结点 包含 n 个叶子结点的哈夫曼树中共有 2n – 1 个结点 包含 n 棵树的森林要经过 n–1 次合并才能形成哈夫曼树，共产生 n–1 个新结点 示例 如图所示：权值分别为 22, 33, 66, 77，具有 4 个叶子结点的二叉树，它们的带权路径长度分别为： a: WPL=2×2+3×2+6×2+7×2=36 b: WPL=2×1+3×2+6×3+7×3=47 c: WPL=7×1+6×2+2×3+3×3=34 其中图 c 的 WPL 值最小，可以证明它就是 Huffman 树。 哈夫曼树的构造根据 n 个权值 {W1, W2, ... , Wn}，构造成 n 棵二叉树的集合 F={T1, T2, ..., Tn}，其中每棵二叉树只有一个权值为 Wi 的根结点，没有左、右子树； 在 F 中选取两棵根结点权值最小的树作为左、右子树构造一棵新的二叉树，且新的二叉树根结点权值为其左、右子树根结点的权值之和 在 F 中删除这两棵树，同时将新得到的树加入 F 中 重复上面两步，直到 F 只含一颗树为止 构造 Huffman 树时为了规范，规定 F={T1, T2, ..., Tn} 中权值小的二叉树作为新构造的二叉树的左子树，权值大的二叉树作为新构造的二叉树的右子树；在取值相等时，深度小的二叉树作为新构造的二叉树的左子树，深度大的二叉树作为新构造的二叉树的右子树。 哈夫曼编码 前缀编码在电报收发等数据通讯中，通常需要将传送的文字转换成由二进制字符 0, 1 组成的字符串来传输。为了使收发的速度提高，就要求电文编码要尽可能地短。此外要设计长短不等的编码，还必须保证任意字符的编码都不是另一个字符编码的前缀，这种编码称为前缀编码。Huffman 树可以用来构造编码长度不等且译码不产生二义性的编码。 哈夫曼编码设电文中的字符集 C={c1, c2, ... , ci, ... , cn}，各个字符出现的次数或频度集 W={W1, w2, ... , wi, ... , Wn} 。以字符集 C 作为叶子结点，次数或频度集 W 作为结点的权值来构造 Huffman 树。规定 Huffman 树中左分支代表 0 ，右分支代表 1 。从根结点到每个叶子结点所经历的路径分支上的 0 或 1 所组成的字符串，为该结点所对应的编码，称之为 Huffman 编码。由于每个字符都是叶子结点，不可能出现在根结点到其它字符结点的路径上，所以一个字符的 Huffman 编码不可能是另一个字符的 Huffman 编码的前缀。 若字符集 C={a, b, c, d, e, f} 所对应的权值集合为 W={8, 3, 4, 6, 5, 5}，如图所示字符 a, b, c, d, e, f 所对应的 Huffman 编码分别是：10, 010, 011, 00, 110, 111。 算法实现根据哈夫曼树构造定义可以看出，每次选取权值最小的树构造一颗新的树。所以使用优先队列来存储权值，小根堆顶即权值最小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Huffman trie nodeprivate static class Node implements Comparable&lt;Node&gt; &#123; private final char ch; // 节点内容 private final int freq; // 节点权值 private final Node left, right; Node(char ch, int freq, Node left, Node right) &#123; this.ch = ch; this.freq = freq; this.left = left; this.right = right; &#125; // is the node a leaf node? private boolean isLeaf() &#123; return (left == null) &amp;&amp; (right == null); &#125; // compare, based on frequency public int compareTo(Node that) &#123; return this.freq - that.freq; &#125;&#125;// build the Huffman trie given frequenciesprivate static Node buildTrie(int[] freq) &#123; // initialze priority queue with singleton trees // 使用优先队列存储权值 MinPQ&lt;Node&gt; pq = new MinPQ&lt;Node&gt;(); for (char i = 0; i &lt; R; i++) if (freq[i] &gt; 0) pq.insert(new Node(i, freq[i], null, null)); // special case in case there is // only one character with a nonzero frequency if (pq.size() == 1) &#123; if (freq['\0'] == 0) pq.insert(new Node('\0', 0, null, null)); else pq.insert(new Node('\1', 0, null, null)); &#125; // merge two smallest trees while (pq.size() &gt; 1) &#123; // 循环取出小根堆顶的权值，构造一个新的节点 Node left = pq.delMin(); Node right = pq.delMin(); Node parent = new Node('\0', left.freq + right.freq, left, right); pq.insert(parent); &#125; // 哈夫曼树的根，小根堆清空 return pq.delMin();&#125; 参考实现：alg4-Huffman 参考文档 数据结构-清华大学严蔚敏 PPT 《数据结构与算法分析：C 语言描述》 第 4 章 wiki: binary tree 浅谈数据结构-二叉树 二叉树的遍历 哈夫曼（huffman）树和哈夫曼编码]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 优先队列 - 斐波那契堆]]></title>
    <url>%2F2018%2F09%2F25%2F0105-algorithms-fibonacci-heap%2F</url>
    <content type="text"><![CDATA[斐波那契堆是优先队列的一种实现。 概念斐波那契堆 Fibonacci Heap ：是一系列具有最小堆序 min-heap ordered 的有根树的集合。也就是说，每棵树都遵循最小堆性质 min-heap property：每个节点的关键字大于或等于它的父节点的关键字。（树是无序的，所以并不需要关心树是怎么排序的） 从图中可以看出，节点的所有孩子节点都被链接成一个环形的双向链表。环形双向链表在斐波那契堆中有两个优点： 可以在 O(1) 时间内从一个环形双向链表的任意位置插入一个节点和删除节点 给定两个这种链表，可以在 O(1) 时间内将他们链接成一个环形双向链表 通常使用最小关键字节点作为整个堆的入口，通过该入口可以遍历所有的堆元素。 可合并堆可合并堆 mergeable heap 是支持以下 5 种操作的数据结构，其中每个元素都有一个关键字： MAKE-HEAP()：创建和返回一个新的不含任何元素的堆 INSERT(H, x)：将一个已填入关键字的元素 x 插入堆 H 中 MINIMUM(H)：返回一个指向堆 H 中具有最小关键字元素的指针 EXTRACT-MIN(H)：从堆 H 中删除最小关键字的元素，并返回指向该元素的指针 UNION(H1，H2)：创建并返回一个包含堆 H1 和堆 H2 中所有元素的新堆。堆 H1 和 H2 被销毁 除了以上可合并堆的操作外，斐波那契堆还支持以下两种操作： DECREASE-KEY(H, x, k)：将堆 H 中元素 x 的关键字赋予新值 k。假定新值 k 不大于当前的关键字 DELETE(H, x)：从堆 H 中删除元素 x 二项堆和斐波那契堆比较 如果没有 UNION 操作，普通的二项堆操作性能已经相当好。所以斐波那契堆的优势在于合并两个堆，并且支持 DECREASE-KEY 和 DELETE 操作。但是对于大多数应用，斐波那契堆的常数因子和编程复杂性使得它比起普通二项（或 k 项）堆并不那么适用。因此，对斐波那契堆的研究主要出于理论兴趣。如果能开发出一个简单得多的数据结构，而且它的摊还时间界与斐波那契堆相同，那么它将非常实用。 可合并堆操作插入节点插入操作不会改变斐波那契堆的结构，直接生成新的根节点，时间复杂度为 O(1) 。 123456789101112131415161718192021public void insert(Key key) &#123; Node x = new Node(); x.key = key; size++; head = insert(x, head); if (min == null) min = head; else min = (greater(min.key, key)) ? head : min;&#125;private Node insert(Node x, Node head) &#123; if (head == null) &#123; x.prev = x; x.next = x; &#125; else &#123; head.prev.next = x; x.next = head; x.prev = head.prev; head.prev = x; &#125; return x;&#125; 本文中的算法，都是参考《算法：第四版》的实现代码。 合并合并操作非常简单，将两个根节点链接并重新确定最小值，摊还时间为 O(1) 。 1234567891011121314151617public FibonacciMinPQ&lt;Key&gt; union(FibonacciMinPQ&lt;Key&gt; that) &#123; this.head = meld(head, that.head); this.min = (greater(this.min.key, that.min.key)) ? that.min : this.min; this.size = this.size+that.size; return this;&#125;//Merges two root lists togetherprivate Node meld(Node x, Node y) &#123; if (x == null) return y; if (y == null) return x; x.prev.next = y.next; y.next.prev = x.prev; x.prev = y; y.next = x; return x;&#125; 取出最小值优先队列的核心功能，就是能快速取出最小值或最大值。斐波那契堆在取出最小值后，会将堆中所有节点进行合并及调整堆的结构，并重新确定最小值。具体实现思路为： 首先将最小节点的孩子节点变为根节点，并从根链表中删掉最小节点。然后通过把具有相同度数的根节点合并的方法来链接成根链表，直到每个度数至多只有一个根在根链表中。 (a) 斐波那契堆 H (b) 从根链表中移除最小值节点，并把它的孩子节点加入根链表中 (c)-(m) 过程是合并根链表，来减少斐波那契堆中树的数目，直到根链表中每一个根都有不同的度数 取出最小值操作的摊还时间为 O(logn) 。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// Deletes the minimum key// Worst case is O(log(n)) (amortized)public Key delMin() &#123; if (isEmpty()) throw new NoSuchElementException("Priority queue is empty"); head = cut(min, head); Node x = min.child; Key key = min.key; min.key = null; if (x != null) &#123; head = meld(head, x); min.child = null; &#125; size--; if (!isEmpty()) consolidate(); else min = null; return key;&#125;//Removes a tree from the list defined by the head pointerprivate Node cut(Node x, Node head) &#123; if (x.next == x) &#123; x.next = null; x.prev = null; return null; &#125; else &#123; x.next.prev = x.prev; x.prev.next = x.next; Node res = x.next; x.next = null; x.prev = null; if (head == x) return res; else return head; &#125;&#125;//Coalesce the roots, thus reshapes the treeprivate void consolidate() &#123; table.clear(); Node x = head; int maxOrder = 0; min = head; Node y = null; Node z = null; do &#123; y = x; x = x.next; z = table.get(y.order); while (z != null) &#123; table.remove(y.order); if (greater(y.key, z.key)) &#123; link(y, z); y = z; &#125; else &#123; link(z, y); &#125; z = table.get(y.order); &#125; table.put(y.order, y); if (y.order &gt; maxOrder) maxOrder = y.order; &#125; while (x != head); head = null; for (Node n : table.values()) &#123; if (n != null) &#123; min = greater(min.key, n.key) ? n : min; head = insert(n, head); &#125; &#125;&#125;//Assuming root1 holds a greater key than root2, //root2 becomes the new rootprivate void link(Node root1, Node root2) &#123; root2.child = insert(root1, root2.child); root2.order++;&#125; 降键值和删除降键值 DECREASE-KEY斐波那契堆中降键值涉及到几个关键点： 被降键值的节点，会被执行切断 cuting 操作，切断该节点和其父节点的链接，使它成为根节点 如果节点的一个孩子节点被切断，它将会被标记；如果失去两个孩子节点，它将被切断。也就是该节点会成为根节点 如果被标记的节点，其父节点也被标记了，当该节点被切断时，父节点将也会被切断，这个过程为级联切断 cascading-cut 也就是被降键值的节点，一定会成为根节点。如果最小值变更，只需要从新在根节点链表中找到最小值就行。 《算法：第四版》中使用的是索引斐波那契堆来实现降键值，因为和斐波那契堆是两个数据结构，暂时不参考该代码实现。 删除删除的思路是： 将该节点降键值到负无穷 删除该最小键值 动画演示 动画中可以看出，为了性能平衡，插入时仅需 O(1) ，直接插入最小值左边，并作为根节点存在。删除最小值时，才会将堆合并。 小结斐波那契堆的降键值功能，可以在一些问题上得到应用：单源最短路径、加权二分图匹配，最小生成树等问题。不过根据我们前面对图相关问题的分析，可以使用索引优先队列二项堆，或者优先队列删除再插入来替代降键值功能。 参考文档 《算法导论：第3版》 第 19 章 usfca: FibonacciHeap 动画 princeton 图解斐波那契堆各种操作 算法4 斐波那契堆 算法4 索引斐波那契堆 FIBONACCI HEAPS 如果天空不死：斐波那契堆(三)之 Java的实现]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 字符串排序算法]]></title>
    <url>%2F2018%2F09%2F20%2F0104-algorithms-strings-sorting%2F</url>
    <content type="text"><![CDATA[介绍字符串的几种排序算法：键索引计数法、低位优先排序、高位优先排序、三向字符串快速排序。 键索引计数法概念键索引计数法：适合小整数键的简单排序。它的实现步骤为如下四步： 频率统计 频率转换为索引 数据分类 回写 算法实现N 个字符串；R 个键值，键值范围 [0, R) 从 0 到 R-1 。 数组 a[]存储待排序元素 item 的数组，长度为 N，item 记录字符串和对应的键值。 整型数组 count[]数组长度为 R+1，为什么要多两个？其中 count[0] 和 count[R] 有特殊作用：在频率统计中，count[r] 记录键 r-1 出现的频率，即从 count[1] 开始记录键值出现的频率。其中：count[0] 无作用，默认设置为 0；count[R] 记录键 R-1 出现的频率。在频率转换为索引中，count[r] 记录键 r 在预期排序结果的起始索引位置；任意给定键 r 的起始索引位置为所有较小键出现频率之和，即 count[r+1] += count[r]。其中：count[0] 记录键 0 的起始索引；count[R] 无实际作用，记录 a[] 的长度。在数据分类中，count[r] 记录了*下一个键 r *的索引位置，即 count[a[i].key()]++ 。正常情况下，分类结束后的 count[r] 和分类前的 count[r+1] 值相等。 辅助数组 aux[]存储排序后的值。 a[i] 元素在 aux[] 中的位置，由 a[i] 的键值 r 在 count[] 中索引值决定，在移动之后 count[] 中对应索引值加 1，确保 count[r] 总是下一个键为 r 的元素在 aux[] 中的索引位置。 12345678910111213141516171819// R 个键值，n 个字符串int[] count = new int[R+1];// 频率统计for (int i = 0; i &lt; n; i++) count[a[i].key() + 1]++;// 频率转换为索引for (int r = 0; r &lt; R; r++) count[r+1] += count[r];// 数据分类for (int i = 0; i &lt; n; i++) // 数据移动时，同步更新 count[] 的索引 aux[count[a[i].key()]++] = a[i];// 回写for (int i = 0; i &lt; n; i++) a[i] = aux[i]; 图解 频率统计 频率转换为索引 数据分类 小结键索引计数法是一种对于小整数键排序非常有效，但容易被忽略的排序算法。被排序字符串时等长字符串，可以在线性时间内完成排序。注意：键索引计数法不会对相同键值的字符串做排序，仅仅按照键值排序排序字符串。 LSD 低位优先字符串排序概念LSD: Least Significant Digit radix sorts，低位优先字符串排序算法，要求字符串时定长的（即所有被排序字符串长度相同），能够稳定地将定长字符串排序。思路：从右向左（即低位优先）依次将字符作为键值排序，通常取扩展 ASCII 码长度作为键的个数（256 个）。定长字符串长度为 W，只需要使用键索引计数法排序 W 遍，就可以得到最终排序结果了。 算法实现123456789101112131415161718192021222324252627282930public static void sort(String[] a, int w) &#123; int n = a.length; int R = 256; // extend ASCII alphabet size String[] aux = new String[n]; // n 个字符串，R 个键值，字符串为定长 W // 低位优先，即从右向左一次将字符作为键值排序 for (int d = w-1; d &gt;= 0; d--) &#123; // 键索引计数法 // sort by key-indexed counting on dth character // compute frequency counts int[] count = new int[R+1]; for (int i = 0; i &lt; n; i++) // chatAt(d) 将字符作为键值 count[a[i].charAt(d) + 1]++; // compute cumulates for (int r = 0; r &lt; R; r++) count[r+1] += count[r]; // move data for (int i = 0; i &lt; n; i++) aux[count[a[i].charAt(d)]++] = a[i]; // copy back for (int i = 0; i &lt; n; i++) a[i] = aux[i]; &#125;&#125; 参考：algs4: lsd 图解 小结对于 N 个定长为 W 的字符串，无论 N 有多大，都只需要遍历 W 次就能实现排序，排序时间也是线性的。 MSD 高位优先字符串排序概念MSD: Most Significant Digit radix sorts，高位优先字符串排序算法，可以实现通用字符串排序（即字符串长度可以不同），从左向右遍历所有字符。思路：首先用键索引计数法将所有字符串按照首字母排序，然后（递归地）再将每个首字母所对应的子数组排序（忽略首字母，因为每一类中的所有字符串首字母是相同的）。和快速排序一样，高位优先字符串排序会将数组切分为能够独立排序的子数组来完成排序任务，但它的切分会为每个首字母得到一个子数组，而不是像快速排序中产生固定的切分。 count[] 数组的含义字符串末尾的约定：对于长度不等的字符串，当到达末尾时，指定位置为 -1，也就是说认为末尾字符为 count[0] 。 小型子数组高位优先字符串排序的基本思想：在一般应用中，只需检查若干个字符就能完成所有字符串的排序。也就是说，这种方法能快速地将需要排序的数组切分为较小的数组。小型子数组对于高位优先的字符串排序性能至关重要。对于小型子数组，需要将排序算法切换为插入排序，减少过多的微型数组排序。 算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class MSD &#123; private static final int R = 256; // extended ASCII alphabet size private static final int CUTOFF = 15; // cutoff to insertion sort // do not instantiate private MSD() &#123; &#125; public static void sort(String[] a) &#123; int n = a.length; String[] aux = new String[n]; sort(a, 0, n-1, 0, aux); &#125; // return dth character of s, -1 if d = length of string // 如果到达字符串末尾，返回 -1 private static int charAt(String s, int d) &#123; assert d &gt;= 0 &amp;&amp; d &lt;= s.length(); if (d == s.length()) return -1; return s.charAt(d); &#125; // sort from a[lo] to a[hi], starting at the dth character private static void sort(String[] a, int lo, int hi, int d, String[] aux) &#123; // cutoff to insertion sort for small subarrays if (hi &lt;= lo + CUTOFF) &#123; // 小型子数组切换为插入排序 insertion(a, lo, hi, d); return; &#125; // 键索引计数法四部曲 // compute frequency counts int[] count = new int[R+2]; for (int i = lo; i &lt;= hi; i++) &#123; int c = charAt(a[i], d); count[c+2]++; &#125; // transform counts to indicies for (int r = 0; r &lt; R+1; r++) count[r+1] += count[r]; // distribute for (int i = lo; i &lt;= hi; i++) &#123; int c = charAt(a[i], d); aux[count[c+1]++] = a[i]; &#125; // copy back for (int i = lo; i &lt;= hi; i++) a[i] = aux[i - lo]; // recursively sort for each character (excludes sentinel -1) // 递归实现 for (int r = 0; r &lt; R; r++) sort(a, lo + count[r], lo + count[r+1] - 1, d+1, aux); &#125; // insertion sort a[lo..hi], starting at dth character // 插入排序 private static void insertion(String[] a, int lo, int hi, int d) &#123; for (int i = lo; i &lt;= hi; i++) for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j-1], d); j--) exch(a, j, j-1); &#125; // exchange a[i] and a[j] private static void exch(String[] a, int i, int j) &#123; String temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; // is v less than w, starting at character d private static boolean less(String v, String w, int d) &#123; // assert v.substring(0, d).equals(w.substring(0, d)); for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) &#123; if (v.charAt(i) &lt; w.charAt(i)) return true; if (v.charAt(i) &gt; w.charAt(i)) return false; &#125; return v.length() &lt; w.length(); &#125;&#125; 参考：algs4: msd 图解 小结高位优先字符串排序不会处理等值键数组。如果相同的子字符串出现过多，也不会切换排序算法，那么递归方法会检查相同键中的每一个字符。总体来讲，高位优先算法能很好的解决随机字符串的排序。 三向字符串快速排序概念三向字符串快速排序 Three-way string quicksort ：根据键的首字母进行三向切分，仅在中间子数组中的下一个字符（因为键的首字母都与切分字符相等）继续递归排序。 小型子数组在所有递归算法中，都可以通过对小型子数组进行特殊处理来提高效率。三向字符串快速排序和高位优先字符串排序一样，对于小型子数组会切换到插入排序算法。 算法实现为了避免数组已经有序或接近有序的最坏情况，排序前先将数组随机打乱或者将第一个元素和一个随机位置的元素交换，以得到一个随机的切分元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Quick3string &#123; private static final int CUTOFF = 15; // cutoff to insertion sort // do not instantiate private Quick3string() &#123; &#125; public static void sort(String[] a) &#123; // 随机打乱数组 StdRandom.shuffle(a); sort(a, 0, a.length-1, 0); &#125; // return the dth character of s, -1 if d = length of s // 如果到达字符串末尾，返回 -1 private static int charAt(String s, int d) &#123; assert d &gt;= 0 &amp;&amp; d &lt;= s.length(); if (d == s.length()) return -1; return s.charAt(d); &#125; // 3-way string quicksort a[lo..hi] starting at dth character private static void sort(String[] a, int lo, int hi, int d) &#123; // cutoff to insertion sort for small subarrays if (hi &lt;= lo + CUTOFF) &#123; // 小型子数组切换为插入排序 insertion(a, lo, hi, d); return; &#125; // 对指定位置字符进行快速排序 int lt = lo, gt = hi; int v = charAt(a[lo], d); int i = lo + 1; while (i &lt;= gt) &#123; int t = charAt(a[i], d); if (t &lt; v) exch(a, lt++, i++); else if (t &gt; v) exch(a, i, gt--); else i++; &#125; // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. // 递归实现 sort(a, lo, lt-1, d); if (v &gt;= 0) sort(a, lt, gt, d+1); sort(a, gt+1, hi, d); &#125; // sort from a[lo] to a[hi], starting at the dth character private static void insertion(String[] a, int lo, int hi, int d) &#123; for (int i = lo; i &lt;= hi; i++) for (int j = i; j &gt; lo &amp;&amp; less(a[j], a[j-1], d); j--) exch(a, j, j-1); &#125; // exchange a[i] and a[j] private static void exch(String[] a, int i, int j) &#123; String temp = a[i]; a[i] = a[j]; a[j] = temp; &#125; // is v less than w, starting at character d private static boolean less(String v, String w, int d) &#123; assert v.substring(0, d).equals(w.substring(0, d)); for (int i = d; i &lt; Math.min(v.length(), w.length()); i++) &#123; if (v.charAt(i) &lt; w.charAt(i)) return true; if (v.charAt(i) &gt; w.charAt(i)) return false; &#125; return v.length() &lt; w.length(); &#125;&#125; 参考：algs4: Quick3string 图解 小结高位优先字符串排序可能会创建大量（空）子数组，而三向字符串快速排序的切分总是只有三个。因此三向字符串快速排序能够很好地处理等值键、有较长公共前缀的键、取值范围较小的键和小数组等，所有高位优先字符串排序算法不擅长的各种情况。和普通快速排序一样，三向字符串快速排序也不需要额外的空间（除了递归所需的隐式栈调用）。 小结各种字符串排序算法的性能特点： 参考文档 《算法：第四版》 第 5 章]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 子字符串匹配 BM 算法]]></title>
    <url>%2F2018%2F09%2F18%2F0103-algorithms-strings-search-bm%2F</url>
    <content type="text"><![CDATA[介绍子字符串匹配算法：从右至左暴力匹配算法，BM 算法。 从右至左暴力匹配算法算法实现使用下标 j 记录文本位置；使用下标 i 记录模式位置。从模式最右边的字符开始比较，从右向左直到整个模式匹配，则返回文本位置。 1234567891011121314151617181920212223private int bruteForce(String pattern, String text)&#123; int m = pattern.length(); int n = text.length(); int j = 0; // 记录文本当前比较位置 int i = m - 1; // 记录模式当前比较位置 while (j &lt;= n - m &amp;&amp; i &gt;= 0)&#123; // 模式从右向左和文本匹配 // 如果匹配，模式向左缩进一位继续比较 if (pattern.charAt(i) == text.charAt(i + j)) &#123; i--; &#125; else &#123; // 如果不匹配，文本向右移动一位 // i 恢复为在模式最右边 j++; i = m - 1; &#125; &#125; if (i &lt; 0) return j; return n;&#125; 时间复杂度暴力匹配算法在长度为 N 的文本中查找长度为 M 的模式，时间复杂度为 O(NM) 。 BM 算法基础概念BM: Boyer-Moore 算法：大部分文本编辑器的查找功能 CTRL+F ，都是使用的该算法。KMP 算法中，模式和文本同时向右移动，文本逐个字符向后移动（不回退），模式从左向右逐个字符去匹配，当出现不匹配时，模式可以利用已知信息向前跳跃式继续匹配。而 BM 算法中，文本跳跃式向后移动，模式从右向左逐个字符匹配（这会变相导致文本出现回退），当出现字符不匹配时，利用模式的已知信息，文本可以直接大范围跳跃式向后移动，这也是算法更高效的原因。BM 算法中计算的是文本的移动距离，它会依据坏字符和好字符规则来决定；而 KMP 算法计算的是模式的移动距离。 坏字符规则坏字符 bad character：模式与文本匹配过程中，文本出现的第一个不匹配字符。也就是坏字符是文本中的字符。 示例中：S 即为坏字符，不匹配的字符。 坏字符规则移动位数 移动位数：坏字符位置 - 模式中上一次出现的位置 位置是从 0 开始编号的；如果坏字符不在模式中，则上次出现位置为 -1 。 坏字符不在模式中文本向右移动位数：坏字符及前面字符串的长度；即坏字符所在位置加上 1 。 坏字符在模式中文本向右移动位数：坏字符位置 - 模式中上一次出现的位置 示例模式从尾部开始和文本比较：文本中 P 与模式最后一个字符 E 不匹配，坏字符 P 的位置为 6 ，而它在模式中上一次出现的位置为 4 ，所以坏字符规则移动位数为：6-4=2 。 好后缀规则好后缀 good suffix：模式与文本匹配过程中，模式已经与文本相匹配了的字符串。也就是模式中所有尾部匹配的字符串。 示例中：模式尾部匹配的字符串为 MPLE, PLE, LE, E，它们都是好后缀，而 MPLE 为最长好后缀。 好后缀规则移动位数好后缀匹配有三种情况： case1 模式串中有子串和最长好后缀完全匹配，则将最靠右的那个子串（最长好后缀在模式中上一次出现位置的子串）移动到好后缀的位置继续进行匹配 case2 如果不存在和最长好后缀完全匹配的子串，则在好后缀中找到 pattern[m-1-s…m-1]=pattern[0…s] 尽量长并匹配的子串，也就是从模式第一个字符开始匹配的子串 case3 如果完全不存在和好后缀匹配的子串，则右移模式长度的距离 移动位数：好后缀位置 - 模式中上一次出现的位置 好后缀的位置以最后一个字符位置为准。也就是说，好后缀位置其实始终为 m-1 ，m 为模式长度。 模式中上一次出现的位置根据上面三种匹配规则：当存在和最长好后缀完全匹配的子串时，上一次出现位置为子串位置；当好后缀只有部分子串匹配时，需要找到从头部开始匹配的尽量长的好后缀子串，上一次出现位置为该子串的位置；如果不存在和好后缀匹配的子串，上一次出现位置为 -1 。因为模式是从右向左匹配的，所以这里说的子串位置，指的是子串最右边字符的位置。 示例上面好后缀规则示例中 MPLE, PLE, LE, E 都是好后缀，以最后一个字符 E 为准，好后缀位置为 6 。因为好后缀只有部分子串匹配，从头部开始匹配尽量长的好后缀子串为 E，它在模式中上一次出现的位置为 0 ，所以好后缀规则移动位数为 6-0=6 。 文本移动位数BM 算法的基本思想，文本的最终移动位置为两个规则移动位数的最大值。 文本移动位数 = Max{坏字符规则移动位数，好后缀规则移动位数} 。 图解示例文本：HERE IS A SIMPLE EXAMPLE；模式 EXAMPLE 。 BM 算法解析坏字符距离数组 bmBc[]数组相关信息： 数组长度通常以 8 位字符也就是 256 位长度来表示所有字符，也就是 ASCII 能表示的字符；如果是模式中存在中文，需要使用 16 为字符也就是 65536 位长度来表示。大部分算法中都取的是 256 （可能因为算法主要针对的是英文吧？）。 下标以字符作为下标，而不是位置。这就是为什么要用 256 来表示数组长度了，数组可以包含所有的 ASCII 字符。 含义bmBc[&#39;v&#39;] 表示字符 v 在模式中最后一次出现的位置，距离模式尾部的长度。 在坏字符规则中，对应两种情况，我们分别计算对应的坏字符数组： 坏字符没有出现在模式中这种情况很简单，坏字符在模式中上一次出现的位置为 -1，所以距离模式尾部为模式的长度：bmBc[&#39;v&#39;] = pattern.length() 。 坏字符出现在模式中如果坏字符上一次出现的位置为 i ，那么坏字符距离模式尾部的距离为：bmBc[&#39;v&#39;] = pattern.length()-i-1 。 坏字符规则移动位数坏字符数组 bmBc[] 表示：坏字符最后一次出现位置距离模式尾部的长度。我们根据这个长度来计算坏字符规则中，模式的移动位数： 模式在第 i 个位置的字符 u，和文本在第 i+j 个位置的字符 v 不匹配，坏字符为 v。坏字符在模式中上一次出现，距离模式尾部的距离为 bmBc[&#39;v&#39;]，所以坏字符在模式中上一次出现的位置为 m-1-bmBc[&#39;v&#39;]。套用公式：模式实际移动位数 = 坏字符位置 - 模式中上一次出现的位置。模式实际移动位数为 i - (m-1-bmBc[&#39;v&#39;])，即 bmBc[&#39;v&#39;]-m+1+i 。 好后缀长度数组 suffix[]好后缀长度数组 suffix[] 长度等于模式的长度，它的下标就是位置。模式以最后一个字符为准，对应的所有后缀中，suffix[i] 表示以 i 位置结束的子串，其所有后缀中和模式所有后缀的最长共有元素长度。根据以上定义，假设模式为 bcababab ，它对应的所有后缀为 bcababab, cababab, ababab, babab, abab, bab, ab, b ，从右向左计算模式的每个子串的所有后缀和模式所有后缀的最长共有元素长度： 模式的子串 子串的所有后缀 最长共有元素 长度 bcababab bcababab, cababab, ababab, babab, abab, bab, ab, b bcababab 8 bcababa bcababa, cababa, ababa, baba, aba, ba, a 无 0 bcabab bcabab, cabab, abab, bab, ab, b abab 4 bcaba bcaba, caba, aba, ba, a 无 0 bcab bcab, cab, ab, b ab 2 bca bca, ca, a 无 0 bc bc, c 无 0 b b b 1 有了以上定义和示例说明，通过算法来计算 suffix[] 数组，假设： i 是当前位置，计算 suffix[i] 的值 f 是上一轮匹配成功的起始位置 g 是上一轮匹配的失配位置 这里的匹配指的是 i 位置的子串与模式后缀的匹配。从右向左扫描模式，也就是从后向前计算 suffix[] 数组： 当 g &lt; i &lt; f 时，必定会有 pattern[i]=pattern[m-1-f+i] ；如果 suffix[m-1-f+i] &lt; i-g ，则必定会有 suffix[i] = suffix[m-1-f+i] ，充分利用已经计算过的 suffix 值。如果是其他情况（即不能利用已知的 suffix 值），也就是说并不是每个位置都能进行成功匹配（实际上能够进行成功匹配的位置并不多）。当在起始位置就不匹配时，可以假定 f=g=i ，直接逐个字符比较计算 suffix 值。 好后缀移位数组 bmGs[]好后缀移位数组 bmGs[] 长度：等于模式的长度，它的下标就是位置，它的计算需要借助好后缀长度数组 suffix[] 。 case1 模式中有子串和最长好后缀完全匹配位置 j 出现不匹配，移动位数为 bmGs[j]=m-1-i，即 bmGs[m-1-suffix[i]]=m-1-i 。 case2 模式中没有最长好后缀的子串，则在好后缀中找到 pattern[m-1-s…m-1]=pattern[0…s] 尽量长并匹配的子串位置 j 出现不匹配，当 0&lt;=j&lt;m-1-i 时，存在 suffix[i]=i+1 ，且移动位数为 bmGs[j]=m-1-i 。 case3 完全不存在和好后缀匹配的子串只要出现不匹配，移动位数为整个模式长度，即 bmGs[i]=m 。 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class BoyerMoore &#123; private final int R; // the radix public BoyerMoore()&#123; this.R = 256; &#125; private int bmBc[]; private int suffix[]; private int bmGs[]; private void preBmBc(String pattern)&#123; // 坏字符距离数组，用 256 来表示数组长度了，包含所有的 ASCII 字符 bmBc = new int[R]; int m = pattern.length(); // 坏字符没有出现在模式中 for (int i = 0; i &lt; R; i++) bmBc[i] = m; // 坏字符存在模式中 for (int i = 0; i &lt; m - 1; i++) bmBc[pattern.charAt(i)] = m - i - 1; &#125; private void preSuffix(String pattern)&#123; int m = pattern.length(); // suffix 数组长度为模式长度 suffix = new int[m]; // 从右向左扫描 int i = m - 1; int f = i, g = i; // 最后一个元素就是模式本身，所以长度为 m suffix[m - 1] = m; // 从倒数第二个字符开始 for (i = m - 2; i &gt;= 0; i--) &#123; // 如果满足假设条件，利用已经计算过的 suffix 值 if (i &gt; g &amp;&amp; suffix[i + m - 1 - f] &lt; i - g) suffix[i] = suffix[i + m - 1 - f]; else &#123; // 否则逐个字符比较 // f 记录上一轮匹配成功的起始位置 f = g = i; // g 在第 i 个位置，从右向左移动，直到出现不匹配 // g 同时记录上一轮匹配失配位置 while (g &gt;= 0 &amp;&amp; pattern.charAt(g) == pattern.charAt(m - 1 - i + g)) g--; // 第 i 个位置的公共好后缀长度为 i - g suffix[i] = i - g; &#125; &#125; &#125; private void preBmGs(String pattern)&#123; preSuffix(pattern); int m = pattern.length(); bmGs = new int[m]; // case3: 模式中完全不存在和好后缀匹配的子串 for (int i = 0; i &lt; m; i++) bmGs[i] = m; // case2：模式中没有最长好后缀的子串，则在好后缀中找到 // pattern[m-1-s…m-1]=pattern[0…s] 尽量长并匹配的子串 for (int i = m - 1; i &gt;= 0; i--) // 满足头部匹配条件 if (suffix[i] == i + 1) for (int j = 0; j &lt; m - 1 - i; j++) if (bmGs[j] == m) bmGs[j] = m - 1 - i; // case1：模式中有子串和最长好后缀完全匹配 for (int i = 0; i &lt;= m - 2; i++) bmGs[m - 1 - suffix[i]] = m - 1 - i; &#125; private int max(int a, int b)&#123; return (a &gt; b) ? a : b; &#125; private int bm(String pattern, String text)&#123; /* Pre-processing */ preBmBc(pattern); preBmGs(pattern); /* Searching */ int m = pattern.length(); int n = text.length(); int j = 0; int i = m -1; while (j &lt;= n - m &amp;&amp; i &gt;= 0) &#123; if (pattern.charAt(i) == text.charAt(i + j)) &#123; i--; &#125; else &#123; j += max(bmGs[i], bmBc[text.charAt(i + j)] - m + 1 + i); // 这里直接恢复为模式的最右边，可能存在重复计算问题 // 如果模式从右向左已经匹配了 x 位，这 x 位会重复和文本作比较 i = m - 1; &#125; &#125; if (i &lt; 0) return j; return n; &#125;&#125; 参考：algs4: bm 。从算法实现也可以看出，BM 算法和从右向左的暴力算法相比，增加预处理阶段，并且文本大范围向后移动，其他思路基本一致。BM 算法主要是改进了暴力匹配算法中，文本移动的位置；而模式中已经匹配成功的，并没有特别处理，也就是可能出现冗余的匹配计算。 时间复杂度BM 算法在最坏情况下，和暴力匹配算法一致，时间复杂度为 O(MN)；但实际中通常情况下时间复杂度仅需 O(N/M) 。 参考文档 《算法：第四版》 第 5 章 阮一峰：字符串匹配的Boyer-Moore算法 grep之字符串搜索算法Boyer-Moore由浅入深 Boyer-Moore algorithm Moore 官网 百科：Boyer-Moore 算法 更快的Boyer-Moore算法 Boyer-Moore算法学习 Boyer-Moore 算法]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 子字符串匹配 KMP 算法]]></title>
    <url>%2F2018%2F09%2F12%2F0102-algorithms-strings-search-kmp%2F</url>
    <content type="text"><![CDATA[介绍子字符串匹配算法：暴力匹配算法，KMP 算法。 概念定义字符串匹配问题的形式定义： 文本 Text 是一个长度为 n 的数组 T[1..n] 模式 Pattern 是一个长度为 m 且 m≤n 的数组 P[1..m] T 和 P 中的元素都属于有限的字母表 Σ 表的字符；比如：Σ={0,1} 或者 Σ={a,b,...,z}。P, T 通常称为字符串 如果 0≤s≤n-m，并且 T[s+1..s+m] = P[1..m]，即对 1≤j≤m，有 T[s+j] = P[j]，那么称模式 P 在文本 T 中出现，且位移为 s。称 s 是一个有效偏移；如果 s 不出现则称它为无效偏移。 时间复杂度字符串匹配算法通常分为两个步骤：预处理 Preprocessing 和匹配 Matching 。算法的总运行时间为预处理和匹配两个阶段所耗时间的总和。 暴力匹配算法朴素的字符串匹配算法 Naive String Matching Algorithm ，又称为暴力匹配算法 Brute Force Algorithm 。 算法实现使用下标 i 记录文本位置；使用下标 j 记录模式位置。从文本和模式的首字母开始比较，直到整个模式匹配，则返回文本位置。 123456789101112131415161718public static int search(String pat, String txt)&#123; int M = pat.length(); int N = txt.length(); int i =0, j = 0; while(i &lt; N &amp;&amp; j &lt; M)&#123; if (txt.charAt(i) == pat.charAt(j)) &#123; i++; j++; &#125; else &#123; i = i - j + 1; j = 0; &#125; &#125; if (j == M) return i - j; // 找到匹配 else return -1; // 未找到匹配&#125; 时间复杂度暴力匹配算法没有预处理步骤，在最坏情况下，在长度为 N 的文本中查找长度为 M 的模式，时间复杂度为 O(NM) 。 KMP 算法基础概念KMP: Knuth-Morris-Pratt 子字符串查找算法的基本思想是：当出现不匹配时，已经能知晓一部分文本内容（因为在匹配失败前这部分文本内容已经和模式相匹配），利用这些信息避免将下标回退到这些已知字符之前。 《算法 4》中的 KMP 算法使用了有限状态机 DFA[][] 来计算下标回退的位置。我们这里参考《算法导论 3》中更通用的算法，使用模式的前后缀来计算下标。 伪代码《算法导论》中的伪代码，其中当出现不匹配时， π 数组记录了不匹配字符对应的移动距离，这个值是模式向右移动的距离。 1234567891011121314151617181920212223242526KMP-MATCHER(T,P) n=T.length // 文本长度 m=P.length // 模式长度 π=COMPUTE-PREFIX-FUNCTION(P) q=0 // 字符串匹配个数 for i=1 to n // 从左往右扫描文本 while q&gt;0 and P[q+1]≠T[i] q=π[q] // 下个字符不匹配 if P[q+1] == T[i] q=q+1 // 下个字符匹配 if q == m // 模式完全匹配？ print &quot;Pattern occurs with shift&quot; i-m q=π[q] // 从下一个位置开始查找COMPUTE-PREFIX-FUNCTION(P) m=P.length let π[1..m] be a new array π[1]=0 k=0 for q=2 to m while k&gt;0 and P[k+1]≠P[q] k=π[k] if P[k+1] == P[q] k=k+1 π[q]=k return π next 数组先了解两个定义： 前缀：字符串中去掉最后一个字符后，全部头部字符串组合 后缀：字符串中去掉第一个字符，全部尾部字符串组合 比如：字符串 bread，其前缀和后缀分别为： 前缀：b, br, bre, brea 后缀：read, ead, ad, d 根据以上定义，我们计算模式 ABCDABD 中，每个子串前后缀的最长共有元素长度： 模式的子串 前缀 后缀 最长共有元素 长度 A 空集 空集 无 0 AB A B 无 0 ABC A, AB BC, C 无 0 ABCD A, AB, ABC BCD, BC, D 无 0 ABCDA A, AB, ABC, ABCD BCDA, CDA, CD, A A 1 ABCDAB A, AB, ABC, ABCD, ABCDA BCDAB, CDAB, DAB, AB, B AB 2 ABCDABD A, AB, ABC, ABCD, ABCDA, ABCDAB BCDABD, CDABD, DABD, ABD, BD, D 无 0 最长共有元素长度，表示有相同前后缀的长度。这也是 KMP 算法的核心，当出现不匹配字符时，利用前面已知的已经匹配的字符，不需要把文本字符串下标回退，而是利用具有相同前后缀信息，直接将模式向后移动。 next 数组：记录了每个元素前的子串前后缀最长共有元素长度，其中 next 数组第一位默认为 -1 。（而模式本身对应的最长共有元素长度舍弃掉） 模式移动位数 移动位数 = 失配字符所在位置 - 失配字符对应的 next 值。（字符位置从 0 开始计数） 使用下标 j 记录模式中不匹配字符所在位置，该位置对应的 next[j]=k ，即前后缀最长共有元素长度为 k。那么移动位数为：j - next[j] 。我们用下图来表示： 模式在 Pj 和文本 Si 位置匹配失败，此时模式的前缀和后缀共有元素为 P0 P1 ... Pk-1 = Pj-k Pj-k+1 ... Pj-1，即有 k 个最长共有元素 next[j] = k 。模式向后移动位数为 j - next[j] ，让模式的 Pk 位置字符和文本 Si 位置字符继续匹配。也就是说：模式的下个比较的位置为 j=k=next[j] 。 next[j] 的实际意义为：模式匹配过程中，如果该位置字符不匹配，模式从 next[j] 位置开始和文本的第 i 个位置继续比较。也就是说 KMP 算法中，为确保文本不用回退，模式整体向后移动 j-next[j] 位。 图解文本：BBC ABCDAB ABCDABCDABDE ；模式：ABCDABD 。 子字符串匹配从文本和模式的第一个字符开始比较，直到出现不匹配字符 如果是暴力匹配算法，存在文本下标回退 KMP 算法，仅将模式向后移动模式在第 6 位字符 D 出现不匹配，对应的 next 值为 2，所以模式移动位数为 6-2=4 ；模式向后移动 4 位，继续匹配。 继续比较中，模式中字符 C 与文本的空格不匹配模式在第 2 位字符 C 出现不匹配，对应的 next 值为 0，所以模式移动位数为 2-0=2 ；模式向后移动 2 位，继续匹配。 继续比较中，模式中字符 A 与文本的空格不匹配此次比较模式的第一个字符就不匹配，模式和文本同时向后移动一位，继续比较。 继续比较中，直到出现不匹配字符模式在第 6 位字符 D 和文本中的字符 C 不匹配，对应的 next 值为 2，模式向后移动 4 位，继续匹配。 模式向后移动 4 位后，匹配成功 KMP 算法解析next 数组计算next 数组第一位默认为 -1，假设已知 0...j 个字符对应的 next 数组值，其中第 j 个字符前的子串，其前后缀最长共有元素长度为 k ， 即 next[j]=k。那么：如何计算第 j+1 个字符串的 next ？ P[k] == P[j] 当 P[k] == P[j] 时，意味着第 j+1 个字符前的子串，其前后缀最长共有元素多了一位，即 next[j+1] = next[j]+1 = k+1 。 P[k] ≠ P[j] 因为前 k-1 个字符是相同的，而第 k 位和 j 位字符不匹配。我们换个思路来看待这个问题：将模式的前 k+1 个字符比作新的模式，原模式去掉新模式后剩余字符串比作新的文本。这样类比后，可以看作一个新的模式和文本匹配问题了。 而 next[0...k] 是已知的，根据 KMP 算法，第 k 个元素出现不匹配，将新的模式整体向后移动，即新模式从 k=next[k] 的位置重新和 j 比较。这是一个递归过程，直到出现 P[k] == P[j] 或者 k=-1 为止。其中：如果 P[k] == P[j] ， 则 next[j+1]=next[k]+1=k+1；如果 k=-1 ，则表示新模式的第一个字符就和新文本的第 j 位不相等，匹配结束没有共有元素，next[j+1]=0=k+1。 next 数组计算分为两种情况：k=-1 或者 P[k] == P[j] 时，next[j+1]=k+1；其他情况即出现不匹配时，使用最大子串 k=next[k] 继续比较，即从第 next[k] 处开始继续比较。 k=next[k] 的意义：表示 k 个字符串内部前后缀最大共有元素长度，使用该子串继续去匹配： 算法实现算法分为两部分：预处理和匹配搜索。预处理步骤用来计算 next 数组；匹配步骤用来从文本中搜索模式字符串。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private int next[];// 计算 next 数组private void KMPCLRNext(String pattern) &#123; int m = pattern.length(); next = new int[m]; next[0] = -1; int j = 0, k = -1; while (j &lt; m - 1) &#123; // k 为 -1，表示不匹配，没有共有元素 // 或者第 k 个位置的字符和第 j 个位置字符相等时 // next[j+1]=k+1 if (k == -1 || pattern.charAt(j) == pattern.charAt(k)) &#123; next[++j] = ++k; &#125; else &#123; // 如果出现不匹配，从第 next[k] 位置继续匹配 k = next[k]; &#125; &#125;&#125;// 文本中搜索模式字符串private int KMPCLRSearch(String text, String pattern) &#123; KMPCLRNext(pattern); int n = text.length(); int m = pattern.length(); int i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; m) &#123; // j 为 -1 时，表示模式的第一个字符和文本当前位置不匹配 // 或者文本第 i 个位置字符和模式第 j 个位置字符匹配 // 这两种情况：文本和模式都同时向后移动一位 if (j == -1 || text.charAt(i) == pattern.charAt(j)) &#123; i++; j++; &#125; else &#123; // 如果模式不是在第一个字符出现的不匹配，模式向后移动 j-next[j] 位 // 即模式从第 next[j] 位置处和文本第 i 个位置字符继续匹配 j = next[j]; &#125; &#125; // 匹配成功 if (j == m) return i - j; else return -1;&#125; 参考：algs4:kmp 时间复杂度KMP 算法预处理步骤，需要遍历模式所有字符串（长度为 m），时间复杂度为 O(m)；搜索匹配阶段，需要遍历文本所有字符串（长度为 n），时间复杂度为 O(n)。所以整个算法时间复杂度为 O(n+m) 。 JDK 中 String.indexOf 算法12345678910111213141516171819202122232425262728293031323334353637static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1;&#125; 从算法实现可以看出：indexOf 使用了暴力匹配算法。 参考文档 《算法：第四版》 第 5 章 《算法导论：第三版》 第 32 章 Wiki-string search 从头到尾彻底理解KMP 阮一峰：字符串匹配的KMP算法 KMP算法 字符串匹配算法 字符串匹配KMP算法详解 详解KMP算法 next 数组 KMP算法的Next数组详解 KMP 算法视频 stackoverflow: indexof 时间复杂度 stackoverflow: indexof 为什么不使用 kmp]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 最短路径应用场景]]></title>
    <url>%2F2018%2F09%2F11%2F0101-algorithms-spt-samples%2F</url>
    <content type="text"><![CDATA[最短路径常见应用场景：加权无向图最短路径、给定两点的最短路径、加权有向无环图的最长路径、并行任务调度、负权重环检测、套汇等等。 加权无向图最短路径将无向图看成有向图，利用有向图的算法来计算最短路径。 转换给定的加权无向图，创建一幅由相同顶点构成的加权有向图，且对于无向图中的每条边，相应地创建两条（方向不同）有向边。有向图中的路径和无向图中的路径存在一一对应的关系，路径的权重也是相同的；所以最短路径问题是等价的。 特点权值不能为负值，否则在创建对应有向图时，每两个顶点间都存在一个负权重环。 给定两点的最短路径给定一幅加权有向图，以及一个起点 s 和一个终点 t ，找到 s 到 t 的最短路径。如果不包含负权重，可以在 Dijkstra 算法中，从优先队列取出目标顶点 t 之后终止搜索，而 distTo[t] 则为最短路径值。 123456789101112131415public DijkstraSP(EdgeWeightedDigraph G, int s) &#123; ... // relax vertices in order of distance from s pq = new IndexMinPQ&lt;Double&gt;(G.V()); pq.insert(s, distTo[s]); while (!pq.isEmpty()) &#123; int v = pq.delMin(); // 如果 v 为终点，则跳出循环，计算结束 if (v == endVertex) break; for (DirectedEdge e : G.adj(v)) relax(e); &#125; ...&#125; 加权有向无环图的最长路径给定一幅无环加权有向图和起点 s，是否存在一条 s 到给定顶点 v 的路径？找出最长（总权重最大）的路径。 算法一：转换为最短路径复制原始无环加权有向图得到一个副本，并将副本中所有边的权重变为负值。计算副本中的最短路径，即为原图中的最长路径。 算法二：修改最短路径判断条件修改最短路径算法，初始化时将 distTo[] 为负无穷，放松边时判断 distTo[w] &lt; distTo[v] + e.weight() ，这样就称为最长路径算法了。 123456789101112131415161718192021222324252627282930public AcyclicLP(EdgeWeightedDigraph G, int s) &#123; distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; validateVertex(s); // 初始化为负无穷 for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.NEGATIVE_INFINITY; distTo[s] = 0.0; // relax vertices in topological order Topological topological = new Topological(G); if (!topological.hasOrder()) throw new IllegalArgumentException("Digraph is not acyclic."); for (int v : topological.order()) &#123; for (DirectedEdge e : G.adj(v)) relax(e); &#125;&#125;// relax edge e, but update if you find a *longer* pathprivate void relax(DirectedEdge e) &#123; int v = e.from(), w = e.to(); // 放松时，改为小于 if (distTo[w] &lt; distTo[v] + e.weight()) &#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125; &#125; 并行任务调度优先级限制下的并行任务调度：给定一组需要完成的特定任务，以及一组关于任务完成的先后次序的优先级限制！在满足限制条件的前提下，应该如何在若干相同处理器上安排任务，并在最短时间内完成所有任务？关键路径：并行任务序列中，耗时最长路径即为关键路径。可以证明：关键路径和无环加权有向图的最长路径问题是等价的。 解决关键路径步骤解决并行任务调度的关键路径的方法步骤如下： 创建一幅无环加权有向图，其中包含起点 s 和终点 t，并且每个任务都对应两个顶点（任务起始顶点和任务结束顶点）。也就是说 N 个任务的无环加权有向图中，一共有 2*N+2 个顶点。其中 2*N 表示为图的起点，2*N+1 为图的终点，i 为任务起始顶点，i+N 为任务的结束顶点 每个任务都有一条从它的起始顶点到结束顶点的边，边的权重即为任务所需时间 对于每条优先级限制 v-w，添加一条从 v 的结束顶点指向 w 的起始顶点的边，并设定权重为零 为每个任务添加一条从图的起点 s 指向任务的起始顶点的边，并设定权重为零 为每个任务添加一条从任务的结束顶点指向图的终点 t 的边，并设定权重为零 这样每个任务预计的开始时间：为图的起点 s 到任务的起始顶点的最长距离 并行任务调度的关键路径为：图的起点 s 到图的终点 t 的最长距离 并行任务调度转换为：无环加权有向图的最长路径。 测试数据并行任务调度数据： 12345678910111213$ more jobPC.txt10//耗时 共有几个前置任务 前置任务列表41.0 3 1 7 951.0 1 250.0 036.0 038.0 045.0 021.0 2 3 832.0 2 3 832.0 1 229.0 2 4 6 测试数据共有 10 个任务，其中第七行数据 21.0 2 3 8 表示：任务 7 的耗时为 21.0，有 2 个前置任务；任务 7 必须在任务 3,8 两个前置任务之前完成。数据对应的是上面的示例图。 算法分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class CPM &#123; // this class cannot be instantiated private CPM() &#123; &#125; public static void main(String[] args) &#123; // 给定任务数 int n = StdIn.readInt(); // 图的起点 s，终点 t int s = 2*n; int t = 2*n + 1; // 创建无环加权有向图，顶点供 2*n+2 个 EdgeWeightedDigraph G = new EdgeWeightedDigraph(2*n + 2); for (int i = 0; i &lt; n; i++) &#123; // 任务耗时 double duration = StdIn.readDouble(); // 为每个任务添加一条从图的起点 s 指向任务的起始顶点的边 // 并设定权重为零 G.addEdge(new DirectedEdge(s, i, 0.0)); // 为每个任务添加一条从任务的结束顶点指向图的终点 t 的边 // 并设定权重为零 G.addEdge(new DirectedEdge(i+n, t, 0.0)); // 每个任务都有一条从它的起始顶点到结束顶点的边 // 边的权重即为任务所需时间 // 其中 i 为任务的起始顶点，i+n 为任务的结束顶点 G.addEdge(new DirectedEdge(i, i+n, duration)); // precedence constraints // 前置任务个数 int m = StdIn.readInt(); for (int j = 0; j &lt; m; j++) &#123; // 前置任务，对于每条优先级限制 v-w， // 添加一条从 v 的结束顶点指向 w 的起始顶点的边，并设定权重为零 int precedent = StdIn.readInt(); G.addEdge(new DirectedEdge(n+i, precedent, 0.0)); &#125; &#125; // compute longest path // 计算加权有向无环图的最长路径 AcyclicLP lp = new AcyclicLP(G, s); // print results StdOut.println(" job start finish"); StdOut.println("--------------------"); for (int i = 0; i &lt; n; i++) &#123; StdOut.printf("%4d %7.1f %7.1f\n", i, lp.distTo(i), lp.distTo(i+n)); &#125; StdOut.printf("Finish time: %7.1f\n", lp.distTo(sink)); &#125;&#125; 测试结果1234567891011121314% java CPM &lt; jobsPC.txt job start finish-------------------- 0 0.0 41.0 1 41.0 92.0 2 123.0 173.0 3 91.0 127.0 4 70.0 108.0 5 0.0 45.0 6 70.0 91.0 7 41.0 73.0 8 91.0 123.0 9 41.0 70.0Finish time: 173.0 负权重环检测Bellman-Ford 算法包含了负权重环的检测，可以使用该算法来计算最短路径并判断是否存在负权重环。 套汇套汇问题等价于加权有向图中的负权重环的检测问题。 转换步骤取每条边权重的自然对数并取反，这样套汇问题中的权重之积的计算转换为新图中的所有边权重之和的计算。任意权重之积 w1*w2*...wk 即对应 -lnw1-lnw2...-lnwk 之和。转换后边的权重可能为正也可能为负，一条从 v 到 w 的路径表示将货币 v 兑换为货币 w，任意负权重环都是一次套汇机会。 测试数据套汇测试数据各种货币汇率： 1234567% more rates.txt5USD 1 0.741 0.657 1.061 1.005EUR 1.349 1 0.888 1.433 1.366GBP 1.521 1.126 1 1.614 1.538CHF 0.942 0.698 0.619 1 0.953CAD 0.995 0.732 0.650 1.049 1 第一行数据 USD 1 0.741 0.657 1.061 1.005 表示：当前顶点代表美元 USD ，兑换其他四种货币的汇率分别为 0.741 0.657 1.061 1.005 。 算法解析1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Arbitrage &#123; // this class cannot be instantiated private Arbitrage() &#123; &#125; public static void main(String[] args) &#123; // V currencies // 读取一共有几种货币 int V = StdIn.readInt(); String[] name = new String[V]; // create complete network // 创建加权有向图 EdgeWeightedDigraph G = new EdgeWeightedDigraph(V); for (int v = 0; v &lt; V; v++) &#123; // 货币名称 name[v] = StdIn.readString(); for (int w = 0; w &lt; V; w++) &#123; // 兑换其他货币汇率 double rate = StdIn.readDouble(); DirectedEdge e = new DirectedEdge(v, w, -Math.log(rate)); G.addEdge(e); &#125; &#125; // find negative cycle // 使用 Bellman-Ford 算法，判断是否存在负权重环 BellmanFordSP spt = new BellmanFordSP(G, 0); if (spt.hasNegativeCycle()) &#123; double stake = 1000.0; // 如果存在，找出负权重环路径 for (DirectedEdge e : spt.negativeCycle()) &#123; StdOut.printf("%10.5f %s ", stake, name[e.from()]); stake *= Math.exp(-e.weight()); StdOut.printf("= %10.5f %s\n", stake, name[e.to()]); &#125; &#125; else &#123; StdOut.println("No arbitrage opportunity"); &#125; &#125;&#125; 测试结果1234% java Arbitrage &lt; rates.txt1000.00000 USD = 741.00000 EUR 741.00000 EUR = 1012.20600 CAD1012.20600 CAD = 1007.14497 USD 表示存在负权重环，有套现机会。套现路径为：USD -&gt; EUR -&gt; CAD -&gt; USD，即 1000 美元经过套汇后，能获取 1007 美元。 参考文档 《算法：第四版》 第 4 章]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 最短路径：有向无环图]]></title>
    <url>%2F2018%2F09%2F10%2F0100-algorithms-spt-dag%2F</url>
    <content type="text"><![CDATA[在计算最短路径时，Dijkstra 算法和 Bellman-Ford 算法都可以包含环，但是时间复杂度都较高。而有向无环图中，使用拓扑顺序放松边，能非常高效解决单点路径问题。 概念加权有向无环图最短路径算法： 能够在线性时间内解决单点路径问题 能够处理负权重的边 能够解决相关问题，例如找到最长的路径 其特点是：无环，权重可正可负，但是不能包含环。 算法定义首先将 distTo[s] 初始化为 0，其他 distTo[] 元素初始化为无穷大，然后一个一个地按照拓扑顺序放松所有顶点。 按照拓扑排序放松所有顶点，能在和 E+V 成正比的时间内解决无环加权有向图的单点路径问题。 动画演示 算法解析 double[] distTo 数组记录起点到当前顶点的，最短路径估计长度。 DirectedEdge[] edgeTo 数组记录起点到当前顶点最短路径上，最后一条边。也就是说前驱顶点到当前顶点的边。 12345678910111213141516171819202122232425262728293031323334353637public class AcyclicSP &#123; private double[] distTo; private DirectedEdge[] edgeTo; public AcyclicSP(EdgeWeightedDigraph G, int s) &#123; distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; //validateVertex(s); // 初始化 for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; // visit vertices in topological order // 拓扑排序顶点，并判断是否有环 Topological topological = new Topological(G); if (!topological.hasOrder()) throw new IllegalArgumentException("Digraph is not acyclic."); // 按照拓扑顺序取出顶点 for (int v : topological.order()) &#123; for (DirectedEdge e : G.adj(v)) relax(e); &#125; &#125; // relax edge e private void relax(DirectedEdge e) &#123; int v = e.from(), w = e.to(); if (distTo[w] &gt; distTo[v] + e.weight()) &#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125; &#125;&#125; 小结 权重边的权重可正可负，有向图不能包含环。 边的放松顺序按照顶点的拓扑顺序，放松所有的边；且所有的边只会被放松一次。 时间复杂度V 个顶点，E 条边的有向无环图，拓扑排序时间复杂度为 O(E+V)；而根据拓扑顺序放松所有的边为 O(E)；所以总的时间复杂度为 O(E+V) 。 最短路径算法对比Dijkstra 算法 特点：支持环，仅能处理权重全为正的有向图 时间复杂度为 O(ElogV) 边的放松顺序小根堆取出距离起点距离最近的顶点，依次放松该顶点指向邻接点的边；且每条边只会被放松一次。 Bellman-Ford 算法 特点：支持环，权重正或负都能处理，但有向图中不能存在负权重环（如果存在，最短路径树的计算会被无限循环放松） 时间复杂度为 O(EV) 边的放松顺序原始 Bellman-Ford 算法：以任意顺序放松边，放松 V 轮；SPFA 基于队列改进型算法：当 distTo[w] 值发生变化的顶点进入队列，以 FIFO 的方式放松该顶点指向邻接点的边。 DAG 有向无环图算法 特点：不支持环，权重正或负都能处理 时间复杂度为 O(E+V) 边的放松顺序按照顶点的拓扑顺序，放松所有的边；且所有的边只会被放松一次。 支持环：仅仅表示有向图中可以有环存在；但最短路径树中是不可能存在环的（不管是正权重环还是负权重环）。三个算法的主要区别在于边的放松顺序不同。 参考文档 《算法：第四版》 第 4 章 algs4: sp visualgo动画-Dynamic Programming]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 最短路径树 Bellman-Ford 算法]]></title>
    <url>%2F2018%2F09%2F10%2F0099-algorithms-spt-bellman-ford%2F</url>
    <content type="text"><![CDATA[Bellman-Ford 贝尔曼-福特算法，是求含负权图的单源最短路径的一种算法。特点：支持有环，负权重，但不能存在负权重环。 最短路径树及边的松弛，相关概念见《算法 - 最短路径树以及 Dijkstra 算法》。 算法定义Bellman-Ford 算法：在任意含有 V 个顶点的加权有向图中给定起点 s，从 s 无法到达任何负权重环，以下算法能够解决其中的单点最短路径问题：将 distTo[s] 初始化为 0，其他 distTo[] 元素初始化为无穷大，以任意顺序放松有向图的所有边，重复 V 轮。算法证明如下： 算法实现123456// 重复 V 轮for(int pass = 0; pass &lt; G.V(); pass++) // 两个 for 找出 E 条边 for (v = 0; v &lt; G.V(); v++) for (DirectedEdge e : G.adj(v)) relax(e); 根据算法定义和实现可以看出，Bellman-Ford 算法需要重复 V 轮，每一轮都会对所有边（E 条边）进行放松，时间复杂度总是为 O(EV) 。具体步骤看下面动画： 动画演示 负权重边 负权重环 基于队列对算法改进在 Bellman-Ford 算法的执行过程中，很容易发现任意一轮中，很多边的放松都不成功：只有上一轮中的 distTo[] 值发生变化的顶点指出的边，才能改变其他 distTo[] 元素的值（可以参考负权重环算法执行动画）。SPFA: Shortest Path Faster Algorithm 是 Bellman-Ford 算法的一种队列优化。使用一条 FIFO 队列记录这样的顶点：放松边的顺序是出队顺序；当 distTo[w] 值发生变化的顶点进入队列，即放松生效时的顶点入队。 算法轨迹 算法实现 Queue&lt;Integer&gt; queue 队列一条保存即将被放松的顶点的队列。 boolean[] onQueue 数组用来指示顶点是否已经在队列中存在，防止将顶点重复插入队列。 double[] distTo 数组记录起点到当前顶点的，最短路径估计长度。 DirectedEdge[] edgeTo 数组记录起点到当前顶点最短路径上，最后一条边。也就是说前驱顶点到当前顶点的边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public BellmanFordSP(EdgeWeightedDigraph G, int s) &#123; distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; onQueue = new boolean[G.V()]; // 初始化 for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; // Bellman-Ford algorithm queue = new Queue&lt;Integer&gt;(); queue.enqueue(s); onQueue[s] = true; while (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) &#123; int v = queue.dequeue(); onQueue[v] = false; relax(G, v); &#125;&#125;private void relax(EdgeWeightedDigraph G, int v) &#123; for (DirectedEdge e : G.adj(v)) &#123; int w = e.to(); if (distTo[w] &gt; distTo[v] + e.weight()) &#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; // distTo[w] 发生变化，将对应顶点入队 // 入队前先判断是否已经在队列中存在 if (!onQueue[w]) &#123; queue.enqueue(w); onQueue[w] = true; &#125; &#125; // 放松 V 轮后，检测是否存在环 // 如果存在，则一定是负权重环 if (cost++ % G.V() == 0) &#123; findNegativeCycle(); if (hasNegativeCycle()) return; // found a negative cycle &#125; &#125;&#125;// by finding a cycle in predecessor graphprivate void findNegativeCycle() &#123; int V = edgeTo.length; EdgeWeightedDigraph spt = new EdgeWeightedDigraph(V); // 边构造的有向图，环检测 for (int v = 0; v &lt; V; v++) if (edgeTo[v] != null) spt.addEdge(edgeTo[v]); EdgeWeightedDirectedCycle finder = new EdgeWeightedDirectedCycle(spt); cycle = finder.cycle();&#125; 根据算法分析，每个顶点都会至少入队一次，即会放松 E 条边；但是每个顶点在出队被放松后，会存在重复入队的情况（这正是和广度优先搜索最大的区别，广度优先搜索每个顶点只入队一次）；也就是说在最坏情况下可能会重复入队 V 次，所以最坏时间复杂度还是 O(EV)。通常情况下，SPFA 算法效率会比常规的 Bellman-Ford 算法快。 负权重环转换Bellman-Ford 算法对负权重环检测，转换为仅仅需要检测是否存在环的原理：将所有边放松 V 轮后，当且仅当队列非空时，有向图中才存在从起点可达的负权重环，因此 edgeTo[] 数组所表示的子图中必然含有这个负权重环。所以负权重环的检测，可以转化为 edgeTo[] 中的边构造的有向图，并检测该图是否存在环。 小结 权重边的权重可以为负值，但不能包含负权重环，有向图中可以有环。 边的放松顺序原始 Bellman-Ford 算法：以任意顺序放松边，放松 V 轮；SPFA 基于队列改进型算法：当 distTo[w] 值发生变化的顶点进入队列，以 FIFO 的方式放松该顶点指向邻接点的边。 时间复杂度不管是 Bellman-Ford 算法，还是基于队列改进后的算法 SPFA，最坏情况下的时间复杂度都是 O(EV) 。 参考文档 《算法：第四版》 第 4 章 algs4: sp visualgo动画-Bellman-Ford实现 Bellman-Ford的队列优化]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 最短路径树基础以及 Dijkstra 算法]]></title>
    <url>%2F2018%2F09%2F05%2F0098-algorithms-spt-dijkstra%2F</url>
    <content type="text"><![CDATA[介绍最短路径基础概念；以及 Dijkstra 算法 - 迪科斯彻算法：解决边权重非负的加权有向图的单点最短路径问题。 最短路径基础概念名词 最短路径在一幅加权有向图中，从顶点 s 到顶点 v 的最短路径是所有从 s 到 v 的路径中的权重最小者。 最短路径树SPT: Shortest Path Tree，给定一幅加权有向图和顶点 s，以 s 为起点的一颗最短路径树是图的一幅子图，它包含 s 和从 s 可达的所有顶点。这颗有向树的根顶点为 s，树的每条路径都是有向图中的一条最短路径。 边的松弛松弛 relaxation ，对于每个顶点 v 来说： v.d假设 v.d 用来记录从起点 s 到达顶点 v 的最短路径权重的上界。我们称 v.d 为 s 到 v 的最短路径估计。 v.π假设 v.π 表示顶点 v 的前驱顶点。 松弛过程：将从起点 s 到顶点 u 之间的最短路径距离加上顶点 u 与 v 之间的边权重，并与当前 s 到 v 的最短路径估计进行比较，如果前者更小，则对 v.d, v.π 进行更新。 1234567891011121314// 初始化所有顶点// 每个顶点最短路径估计为无穷大，前驱顶点为空INITIALIZE-SINGLE-SOURCE(G, s) for each vertex v ∈ G.V v.d = ∞ v.π = NIL s.d=0// 松弛，并更新 v 的前驱顶点为 u// w 表示权重RELAX(u,v,w) if v.d &gt; u.d + w(u,v) v.d = u.d + w(u,v) v.π = u 松弛操作的时间复杂度为 O(1) 。 最短路径的最优性条件最优性条件：G 是一幅加权有向图，顶点 s 是 G 的起点，distTo[] 是一个由顶点索引的数组，保存的是 G 中路径的长度。对于从 s 可达的所有顶点 v，distTo[v] 的值是从 s 到 v 的某条路径的长度，对于从 s 不可达的所有顶点 v，该值为无穷大。当且仅当对于从 v 到 w 的任意一条边 e，这些值都满足 distTo[w] &lt;= distTo[v] + e.weight() 时（换句话说，不存在有效边时），它们是最短路径长度。 边的松弛实现：放松边 v-w 意味着检查从 s 到 w 的最短路径是否先从 s 到 v，然后再由 v 到 w。如果是，则比较 distTo[w] 和 distTo[v] + e.weight() 的大小。如果 distTo[w] 小，则 v-w 这条边失效了；否则将 distTo[w] 更新为较小值。distTo[] 记录顶点到该点的最短路径。 1234567private void relax(DirectedEdge e)&#123; int v = e.from(), w = e.to(); if(distTo[w] &gt; distTo[v] + e.weight())&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125;&#125; 最优性条件是所有最短路径算法证明的基础，即只要满足不等式 distTo[w] &lt;= distTo[v] + e.weight() ，则这条路径必为最短路径。 通用最短路径算法一个定义明确且可以解决的加权有向图最短路径问题的算法： 对于起点不可达的顶点，最短路径为正无穷 对于起点可达但路径上某个顶点属于一个负权重环的顶点，最短路径为负无穷 对于所有其他顶点，计算最短路径及最短路径树 将 distTo[s] 初始化为 0 ，其他 distTo[] 元素初始化为无穷大，继续如下操作：放松 G 中的任意边，直到不存在有效边为止。对于任意从 s 可达的顶点 w ，在进行这些操作之后，distTo[w] 的值即为从 s 到 w 的最短路径的长度（且 edgeTo[w] 的值即为该路径上的最后一条边）。 最优性条件和通用算法，给出了计算最短路径的思路，但是没有指定边的放松顺序。接下来学的 Dijkstra 算法、Bellman-Ford 算法和 DAG 有向无环图算法，主要区别在于：边的放松顺序不一样。 特点 环路最短路径不能包含环路，不管是负值环还是正值环。 唯一性最短路径并不是唯一的，最短路径树也不是唯一的。 Dijkstra 算法定义Dijkstra 算法类似 Prim 算法：构造的每一步都想这棵树中添加一条新的边。首先将 distTo[s] 初始化为 0，distTo[] 其他元素初始化为正无穷。然后将 distTo[] 最小的非树顶点放松并加入树中，直到所有顶点都在树中或者所有的非树顶点的 distTo[] 值均为无穷大。 Dijkstra 算法能够解决边权重非负的加权有向图的单起点最短路径问题。边的放松顺序为：距离起点路径最短的顶点，该顶点指向邻接点的边。且整个算法过程中，每条边会被放松一次。 正确性证明 Dijkstra 算法每条边的放松，都是基于前驱顶点最短路径已经确定的前提下进行的。 不能处理负权重边的原因Dijkstra 算法属于贪心算法，每次选的是当前能连到的边中权值最小的，并没有考虑到远处的边。在正权重图中这种贪心是对的，但是在负权重图中，远处的负权重边会影响当前能连到的权值最小值并不是最优解。从上面的正确性证明中也可看出，每条边的放松，前驱顶点的最短路径必须是已经确定了的。但是如果存在负权重边，前驱顶点的最短距离将会可能会被后续的负权重边修改。 从示例中可以看出，根据 Dijkstra 算法，顶点 0 到顶点 2 的最短路径为：0 -&gt; 1 -&gt; 2，最短距离为 5。但是实际上，最短路径应该为 0 -&gt; 3 -&gt; 1 -&gt; 2，因为存在负权重边，这条路径最短距离为 4. 所以存在负权重边的有向图， Dijkstra 算法计算出的最短路径并不准确。 疑问：在《算法 4》中给出的 DijkstraSP 实现中，只要去掉负权重边的判断，上图测试数据，算法最终还是可以准确计算出最短路径的。只是顶点 1 会两次入队，并更新顶点 1 和顶点 2 的最终最短路径。 动画演示 算法解析 distTo[] 数组记录起点到当前顶点的，最短路径估计长度。 edgeTo[] 数组记录起点到当前顶点最短路径上，最后一条边。也就是说前驱顶点到当前顶点的边。 IndexMinPQ&lt;Double&gt; pq 索引最小优先队列索引为当前顶点，记录对应的最短路径估计（distTo）。使用索引最小优先队列的目的是，在边的松弛时，方便更新（降低）键值；最小值为距离起点路径最短的顶点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class DijkstraSP &#123; private double[] distTo; private DirectedEdge[] edgeTo; private IndexMinPQ&lt;Double&gt; pq; public DijkstraSP(EdgeWeightedDigraph G, int s) &#123; //疑问：如果去掉负权重边的判断，自测的几组包含负权重边的有向图 // 是可以正确计算最短路径的，只是负权重边的顶点会重复入队 for (DirectedEdge e : G.edges()) &#123; if (e.weight() &lt; 0) throw new IllegalArgumentException( "edge " + e + " has negative weight"); &#125; distTo = new double[G.V()]; edgeTo = new DirectedEdge[G.V()]; //validateVertex(s); // 初始化所有顶点 for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; distTo[s] = 0.0; // relax vertices in order of distance from s pq = new IndexMinPQ&lt;Double&gt;(G.V()); pq.insert(s, distTo[s]); // 放松所有的边 while (!pq.isEmpty()) &#123; // 放松顺序：距离起点路径最短的顶点，该顶点指向邻接点的边 int v = pq.delMin(); for (DirectedEdge e : G.adj(v)) relax(e); &#125; &#125; // relax edge e and update pq if changed private void relax(DirectedEdge e) &#123; int v = e.from(), w = e.to(); // 边的放松 if (distTo[w] &gt; distTo[v] + e.weight()) &#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; // 索引优先队列降键值 if (pq.contains(w)) pq.decreaseKey(w, distTo[w]); else pq.insert(w, distTo[w]); &#125; &#125;&#125; 小结 权重Dijkstra 算法要求所有边的权重为非负值，但是可以包含有向环。 边的放松顺序放松顺序为：距离起点路径最短的顶点，该顶点指向邻接点的边。且整个算法过程中，每条边会被放松一次。 时间复杂度边的放松过程：优先队列的大小为 V 个顶点，插入或者降键值需要 logV ，需要放松所有的边即 E 条边。所以 Dijkstra 算法的时间复杂度为 O(ElogV) 。 参考文档 《算法：第四版》 第 4 章 algs4: sp visualgo动画-Dijkstra实现]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 最小生成树 Kruskal 算法]]></title>
    <url>%2F2018%2F08%2F30%2F0097-algorithms-mst-kruskal%2F</url>
    <content type="text"><![CDATA[Kruskal 算法 - 克鲁斯卡尔算法，是一种用来寻找最小生成树的算法。在剩下的所有未选取的边中，找最小边；如果和已选取的边构成回路，则放弃选取次小边。 概念最小生成树 MST: Minimum Spanning Tree ：也是最小权重生成树的简称。一幅加权无向图，包含所有顶点的无环连通子图，该子图中所有边（ V-1 条边）的权值之和最小。 算法定义Kruskal 算法的主要思想是按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，直到树中含有 V-1 条边为止。 动画演示 算法解析 weight记录最小生成树的总权重。 Queue&lt;Edge&gt; mst 队列记录最小生成树中所有的边。 MinPQ&lt;Edge&gt; pq 最小优先队列小根堆，加入所有边，堆顶为权重最小的边。 UF uf 并查集判断无向图中两个顶点的连通性。 算法实现非常简单： 将所有边加入最小优先队列，确保堆顶都是最小权重边 根据顶点个数建立并查集 小根堆取出堆顶元素，如果边两端的顶点不连通，根据 Kruskal 算法定义，将边加入最小生成树 mst 队列中；如果两个顶点连通，则忽略这条边 直到小根堆所有边取出或者达到 V-1 条边，最小生成树完成 12345678910111213141516171819202122232425public class KruskalMST &#123; private double weight; // weight of MST private Queue&lt;Edge&gt; mst = new Queue&lt;Edge&gt;(); // edges in MST public KruskalMST(EdgeWeightedGraph G) &#123; // more efficient to build heap by passing array of edges MinPQ&lt;Edge&gt; pq = new MinPQ&lt;Edge&gt;(); for (Edge e : G.edges()) &#123; pq.insert(e); &#125; // run greedy algorithm UF uf = new UF(G.V()); while (!pq.isEmpty() &amp;&amp; mst.size() &lt; G.V() - 1) &#123; Edge e = pq.delMin(); int v = e.either(); int w = e.other(v); if (!uf.connected(v, w)) &#123; // v-w does not create a cycle uf.union(v, w); // merge v and w components mst.enqueue(e); // add edge e to mst weight += e.weight(); &#125; &#125; &#125;&#125; 小结 时间复杂度使用优先队列和并查集，优先对列长度为 E，取出最小边时间复杂度为 logE，而并查集接近常数，所以总的时间复杂度为 O(ElogE) 。 参考文档 《算法：第四版》 第 4 章 algs4: mst visualgo动画-Kruskal实现]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 最小生成树以及 Prim 算法]]></title>
    <url>%2F2018%2F08%2F27%2F0096-algorithms-mst-prim%2F</url>
    <content type="text"><![CDATA[Prim 算法 - 普里姆算法，用来计算加权无向图的最小生成树。又被称为 DJP 算法、亚尔尼克算法、普里姆－亚尔尼克算法。 概念基础概念无向图的连通图：从任意一个顶点都存在一条路径到达另外任意一个顶点，则这幅图是连通图。生成树：包含所有顶点的无环连通子图，称为生成树。最小生成树 MST: Minimum Spanning Tree ：也是最小权重生成树的简称。一幅加权无向图，对应的生成树中，树中所有边的权值之和最小。 最小生成树的目的是：在加权无向图中，找出 V-1 条边，且它们的顶点构成无环连通子图，并且这些边的权值之和最小。 最小生成树 切分：将图的所有顶点分为两个非空且不重复的两个集合；切分就是将图分成二分图 横切边：是一条连接两个属于不同集合的顶点的边 切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树；是最小生成树算法的基本定理 算法定义Prim 算法的每一步都会为一颗生长中的数添加一条边：最开始这颗树只有一个顶点（起点），然后向它添加 V-1 条边，每次总是将下一条连接树中顶点与不在树中的顶点且权重最小的边（也就是横切边权重最小者），加入到树中。 选取任意顶点作为起点，则该顶点为树中顶点 从非树顶点集合中，找出横切边权重最小者，根据切分定理，这条边必然属于最小生成树；则边的另一个顶点也成为树中顶点 循环选取横切边，直到找到 V-1 条边（所有顶点都加入到树中），这些边构成最小生成树 应用场景如：电路图中，连接多个组件的针脚，使用最小生成树，来确保连接最短。 Prim 延时实现动画演示 算法解析 marked[] 数组记录当前顶点是否被扫描过。 Queue&lt;Edge&gt; mst 对列Edge 表示图中的边，mst 记录最小生成树所有的边，长度为 V-1 。 weight最小生成树的总权重。 MinPQ&lt;Edge&gt; pq 优先队列小根堆，记录图中所有的边。 G.adj(v)顶点 v 所有邻接点对应的边。 切分：也就是 marked 数组，如果顶点已经被扫描，则为 true。所以 marked 数组将所有顶点分成了两个非空且不重复的集合：{扫描过，未被扫描过} 。横切边：一条边的两个顶点 v-w，其中顶点 v 已经被扫描，顶点 w 未被扫描，即 v, w 属于两个不同集合，而这条边就是横切边。如下算法实现中，始终取出小根堆中最小权重的边，当判断这条边是横切边时，则这条边属于最小生成树。 算法核心思路： 每个顶点都会有一条最小权重的横切边，逐个扫描顶点找出这条横切边 扫描顶点 v 时，该顶点的所有边中，如果另一个顶点没有被扫描过，则将边压入小根堆；也就是小根堆存储了图中所有的边 循环取出小根堆中最小的边，判断边两端顶点是否被扫描过（如果有一个顶点没有被扫描，说明这条边是横切边，且权重最小），即判断是否为横切边 将权重最小的横切边加入最小生成树队列中；继续扫描横切边中未被扫描的顶点，并将该顶点的边加入优先队列 优先队列循环出队，直到队列为空，或者最小生成树队列中有 V-1 条边 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class LazyPrimMST &#123; private double weight; private Queue&lt;Edge&gt; mst; private boolean[] marked; private MinPQ&lt;Edge&gt; pq; public LazyPrimMST(EdgeWeightedGraph G) &#123; mst = new Queue&lt;Edge&gt;(); pq = new MinPQ&lt;Edge&gt;(); marked = new boolean[G.V()]; // 逐个顶点扫描，找出权重最小横切边 for (int v = 0; v &lt; G.V(); v++) if (!marked[v]) prim(G, v); &#125; // run Prim's algorithm private void prim(EdgeWeightedGraph G, int s) &#123; scan(G, s); // better to stop when mst has V-1 edges while (!pq.isEmpty()) &#123; // 取出权重最小的边 Edge e = pq.delMin(); int v = e.either(), w = e.other(v); assert marked[v] || marked[w]; // 如果边的两个顶点都被扫描过，则继续出队 if (marked[v] &amp;&amp; marked[w]) continue; // 否则这条边为横切边，且权重最小 // 将这条最小权重横切边，加入到最小生成树中 mst.enqueue(e); weight += e.weight(); // 沿着边的两端继续扫描 if (!marked[v]) scan(G, v); if (!marked[w]) scan(G, w); &#125; &#125; // add all edges e incident to v onto pq // if the other endpoint has not yet been scanned private void scan(EdgeWeightedGraph G, int v) &#123; // 扫描顶点 v marked[v] = true; for (Edge e : G.adj(v)) if (!marked[e.other(v)]) pq.insert(e); &#125;&#125; 参考代码：LazyPrimMST 特点优先队列存储所有的边，逐个取出时再判断是否为横切边（延时判断）。 Prim 即时实现即时实现主要区别在于：优先队列中始终存储的是非树顶点到树中的最小权重横切边。 失效边 优先队列从图解中看到四条边：7-2, 7-4, 0-4, 0-2 都是横切边，而 7-2 和 7-4 已经失效，因为 0-4 和 0-2 权重更小；对于优先队列始终只存储非树顶点 2, 4 到树中 0, 7 的最小权重横切边，即只存储 0-4, 0-2 。 图解 动画演示这段动画更适合在网站上逐步显示，更便于理解动画算法步骤。 算法实现 marked[] 数组记录当前顶点是否被扫描过。 weight最小生成树的总权重。 edgeTo[] 数组和 distTo[] 数组如果顶点 v 不在树中，但至少还有一条边和树相连。则 edgeTo[v] 是将顶点 v 与树相连的最短边，distTo[v] 为这条边的权重。 PriorityQueue&lt;Edge&gt; pq 优先队列小根堆，记录图中非树顶点到树中的最小权重横切边，堆顶的最小权重横切边满足切分定理，而这条边的非树顶点就是下一个被添加到树中的顶点；该优先队列长度不会超过顶点数。 G.adj(v)顶点 v 所有邻接点对应的边。 算法核心思路： 将 distTo[] 数组初始化为无限大，即所有边都不属于树 从加权无向图中任意指定起点 s，扫描该顶点及其对应的邻接边 如果邻接边的顶点被扫描过，则继续遍历其他邻接边顶点；如果没有被扫描过，则判断这条边是否比记录的小 如果这条边为权重更小，则更新 distTo[] 权重；将失效的边从优先队列中删除，并添加这条有效横切边到优先队列中 循环从优先队列中取出最小键（即满足切分定理的最小权重横切边），而和它关联的顶点 w 就是下一个被添加到树中的顶点；直到优先队列中所有的横切边都被取出，最小生成树生长完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class PrimMST &#123; private Edge[] edgeTo; private double[] distTo; private boolean[] marked; private PriorityQueue&lt;Edge&gt; pq; private Double weight; public PrimMST(EdgeWeightedGraph G) &#123; edgeTo = new Edge[G.V()]; distTo = new double[G.V()]; marked = new boolean[G.V()]; pq = new PriorityQueue&lt;&gt;(); weight = 0.0; // 初始化所有权重为无限大 for (int v = 0; v &lt; G.V(); v++) distTo[v] = Double.POSITIVE_INFINITY; // 逐个顶点扫描，计算最小生成树 for (int v = 0; v &lt; G.V(); v++) if (!marked[v]) prim(G, v); &#125; private void prim(EdgeWeightedGraph G, int s)&#123; distTo[s] = 0.0; // 扫描顶点 scan(G, s); while (!pq.isEmpty())&#123; // 循环取出最小键，即权重最小的横切边， // 这条边一定属于最小生成树 Edge e = pq.poll(); int v = e.either(), w = e.other(v); weight += e.weight(); // 扫描横切边的另外一个顶点 if (marked[v]) scan(G, w); else scan(G, v); &#125; &#125; private void scan(EdgeWeightedGraph G, int v) &#123; // 标记当前顶点为已扫描 marked[v] = true; // 遍历邻接边，找出最小权重横切边 for (Edge e : G.adj(v)) &#123; int w = e.other(v); // 如果已经扫描过，则继续遍历其他邻接点 if (marked[w]) continue; // 如果当前横切边比记录的横切边权重小 // 则更新横切边及其权重 if (e.weight() &lt; distTo[w]) &#123; // 更新权重 distTo[w] = e.weight(); // 如果优先队列中包含失效边，则删除 if (pq.contains(edgeTo[w]))&#123; pq.remove(edgeTo[w]); &#125; // 更新横切边 edgeTo[w] = e; // 这条横切边加入优先队列 pq.offer(edgeTo[w]); &#125; &#125; &#125;&#125; 参考代码：PrimMST 特点优先队列记录非树顶点到树中的最小权重横切边，堆顶的最小权重横切边满足切分定理，而这条边的非树顶点就是下一个被添加到树中的顶点。 延时实现和即时实现差别延时实现 优先队列优先队列中存储了图中所有的边！取出权值最小的边，再判断是否为横切边（即边的两个顶点只有一个被扫描过）。 时间复杂度优先队列存储了所有边即 E 条边，插入和删除的时间复杂度都为 logE，而 while 循环中遍历这 E 条边，所以总的复杂度为 O(ElogE) 。 即时实现 优先队列优先队列中只存储非树顶点到树中的最小权重横切边！堆顶的最小权重横切边满足切分定理，也就是这条边必然属于最小生成树。 时间复杂度优先队列始终最多存储了 V 个顶点最小生成树的边，即 V 条边。插入和删除的时间复杂度都为 logV，遍历 E 条边，所以总的复杂度为 O(ElogV) 。 小结 两种实现都没有考虑图的连通性。如果为非连通图，会输出所有的极大连通子图的最小生成树 参考文档 《算法：第四版》 第 4 章 algs4: mst 百科：Prim 算法 visualgo动画-Prim延时实现 usfca动画-Prim即时实现 Prim算法详解]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 并查集]]></title>
    <url>%2F2018%2F08%2F26%2F0095-algorithms-union-find-set%2F</url>
    <content type="text"><![CDATA[并查集 Union-Find ，也称为不相交集。 概念不相交集合数据结构一个不相交集合数据结构 disjoint-set data structure 维护了一个不相交动态集的集合 S={S1, S2, S3, ..., Sk}。我们用一个代表 representative 来标识这个集合，它是这个集合的某个成员。这个数据结构支持下面三个操作： MAKE-SET(x) ：集建立一个新的集合，它的唯一成员（因而为代表）是 x。因为各个集合是不相交的，故 x 不会出现在别的某个集合中。 UNION(x, y) ：并将包含 x 和 y 的两个动态集合（表示为 Sx, Sy）合并为一个新的集合，即这两个集合的并集。假定在操作之前这两个集合是不相交的。虽然 UNION 的很多实现中特别地选择 Sx 或 Sy 的代表作为新的代表，然而结果集的代表可以是 Sx U Sy 的任何成员。 FIND-SET(x) ：查返回包含 x 的（唯一）集合的代表。也就是代表 x 所在集合的元素。 这种数据结构也称为并查集。可以使用链表结构实现，但是更多采用的是堆存储结构（即用数组表示一棵树）。 不相交集合森林在一个不相交集合更快的实现中，我们使用有根树来表示集合，树中每个节点包含一个成员，每棵树代表一个集合。在一个不相交集合森林 disjoint-set forest 中，每个成员仅指向它的父节点。每棵树的根包含集合的代表，并且是其自己的父节点。 应用场景 确定无向图的连通分量（但并不需要知道连通路径） 确定无向图中，两个顶点是否是连通的 并查集的特点有点像优先队列：只需要知道最小值，但并不需要完全排序。而并查集只需要知道两个顶点是否连接，但并不要这两个顶点的路径。 秩 rank秩：记录树高度的一个上界（这颗树曾经达到过的最高树高），是树高的一个估计值，并不准确。常见错误理解：秩为当前节点为根的树，该树的树高；秩为当前节点所在树中，根节点的树高。这些说法都不正确，因为秩是一个估计值，所以并不能准备代表任何节点，任何数的树高，仅仅是一个估计值，而且是曾经的上界。 算法定义按秩合并按秩合并 union by rank：让具有较小秩的根，指向具有较大秩的根。这样两个根的秩都不会变化。 路径压缩路径压缩 path compression：使查找路径上的每个节点都指向根。路径压缩并不改变任何节点的秩！这里非常容易理解错误，因为路径压缩实际上压缩了树高，为什么却没有改变秩呢？我们来看《数据结构与算法分析–C语言描述》这本书中的解释： 路径压缩与“按大小求并”完全兼容，但不完全与“按高度合并”兼容，因为路径压缩可以改变树的高度。我们根本不清楚如何有效地重新计算它们（树高）。答案是不去计算！！此时，对于每棵树存储的高度是估计的高度（有时称为秩 rank）。但实际上“按秩合并”理论上和“按大小合并”效率上是一样的。不仅如此，高度的更新也不如大小的更新频繁。（第八章：不相交集 ADT - 路径压缩） 也就是说：因为秩的定义是树曾经的最高值，所以路径压缩时即使减小了树高，也不用去改变秩，并且实际上也无法计算树的准确高度。 动画演示按秩合并 从图中可以看到： 合并顶点 5 和顶点 6，先查找两个顶点的根，并将较小秩的树并到较大秩的树中 合并两棵树后，整棵树高度增长，顶点 10 的秩增加 1 路径压缩 从图中可以看到： 查找顶点 15 时，查找路径上的所有节点的父节点都设置为根节点 顶点 7 的树高实际减小了一层，但是秩 rank 并没有改变 算法解析标准实现两个关键数组： parent[] 数组记录当前位置节点的父节点。 rank[] 数组以当前位置节点为根的树，记录它的秩。对秩的理解很大程度的影响了对算法的理解，因为是估计值，所以在 find 时，即使压缩了树高，也并没有更新 rank 的值（同时也无法准确计算它的值）。 count记录有多少个连通分量，或者说有多少棵树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class UF &#123; // parent[i] = parent of i private int[] parent; // rank[i] = rank of subtree rooted at i (never more than 31) private byte[] rank; private int count; // MAKE-SET public UF(int n) &#123; if (n &lt; 0) throw new IllegalArgumentException(); count = n; parent = new int[n]; rank = new byte[n]; // 建立并查集时，每个顶点的父节点都是自己 // 每个顶点的秩都是 0 for (int i = 0; i &lt; n; i++) &#123; parent[i] = i; rank[i] = 0; &#125; &#125; // FIND-SET(x) public int find(int p) &#123; int r = p, t; // r: root node. // 查找到根节点 while (parent[r] != r) r = parent[r]; // path compression // 将查找路径上所有节点的父节点都设置为根 while (parent[p] != r) &#123; t = parent[p]; parent[p] = r; p = t; &#125; return r; &#125; // 判断两个顶点是否连通 public boolean connected(int p, int q) &#123; return find(p) == find(q); &#125; // UNION public void union(int p, int q) &#123; int rootP = find(p); int rootQ = find(q); // 如果两个顶点在同一棵树中，不需要合并 if (rootP == rootQ) return; // make root of smaller rank point to root of larger rank // 较小秩的根，其父节点设置为较大秩的根 if (rank[rootP] &lt; rank[rootQ]) parent[rootP] = rootQ; else if (rank[rootP] &gt; rank[rootQ]) parent[rootQ] = rootP; else &#123; parent[rootQ] = rootP; // 树的高度增加一层 rank[rootP]++; &#125; count--; &#125;&#125; 代码参考：算法4 UF.java 路径压缩的其他实现 递归实现 123456public int find(int p)&#123; if (p != parent[p])&#123; parent[p] = find(parent[p]); &#125; return parent[p];&#125; 减半压缩《算法4》中使用的 find 算法就是这种减半压缩，只将当前节点链接到爷爷节点，下次再从爷爷节点链接到爷爷的爷爷节点，如此反复直到根节点。也就是说，当前节点的父节点并没有直接链接到根节点，以及爷爷的父节点也没有链接到根节点。只需要循环遍历一次，就实现了路径压缩同时查找到根节点。 12345678public int find(int p) &#123; validate(p); while (p != parent[p]) &#123; parent[p] = parent[parent[p]]; // path compression by halving p = parent[p]; &#125; return p;&#125; 测试数据parent 指的是父节点相同的节点个数，指向根节点或者没有被路径压缩到根节点的节点。 实现方式 数据大小 rank parent 连通分量 路径全压缩 100000 9 41650 6 路径减半压缩 100000 9 48023 6 路径全压缩 625 5 83 2 路径减半压缩 625 5 88 2 小结 动态性并查集连通性是动态的，并不需要先将完整的关系导入，可以边合并边来查找。 扁平型并查集生成的森林中，每棵树都接近扁平，参考测试数据，百万数据的秩也是个位数，实际树高更低。 时间复杂度除了构造并查集时，时间复杂度为 N；按秩合并和路径压缩查找的时间复杂度基本能达到常数级别，效率非常高。 参考文档 《算法：第四版》 第 1 章 《算法导论》第 21 章：用于不相交集合的数据结构 《数据结构与算法分析–C语言描述》第 8 章：不相交集 ADT visualgo动画-并查集 并查集（有趣篇） 超有爱的并查集 算法4并查集读后感]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 强连通分量 Tarjan 算法]]></title>
    <url>%2F2018%2F08%2F23%2F0094-algorithms-scc-tarjan%2F</url>
    <content type="text"><![CDATA[Tarjan 算法是 Robert Tarjan （罗伯特·塔扬）发明的，只通过一次深度优先搜索就能计算出有向图的强连通分量，而 Kosaraju 算法需要做两次 DFS 加上计算图的反向图。 算法定义Tarjan 算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。搜索时把当前搜索树中未处理的节点加入一个堆栈，回溯时可以判断栈顶到栈中的节点是否为一个强连通分量。定义两个重要数组： dfn(v) 为顶点 v 被搜索的次序号 low(v) 为顶点 v 被搜索的次序号，或者** v 的子树能够追溯到的最早的栈中顶点的次序号**（这句话非常费解，没弄明白！） 本文算法实现及分析的有向图： 动画演示 visualgo 上动画演示的伪代码是错误的！但是动画实际执行的结果是对的。 算法解析算法中的几个重要的变量： marked[] 数组记录当前顶点是否被访问过。 stack 栈辅助变量：记录同一个强连通分量中的所有顶点。当 DFS 第一次访问顶点时，该顶点入栈；当顶点 v 的强连通分量条件满足时，栈中顶点逐个出栈，直到顶点 v 也出栈。 onStack[] 数组记录当前顶点是否在栈中。 dfn[] 数组记录顶点被访问的次序号，dfn[v]=5 表示顶点 v 是第 5 个被访问的顶点。 low[] 数组low[v] 值的计算很复杂，搜索时从顶点 v 访问顶点 w 则 low[v]=min{low[v], dfn[w]} ；回溯时顶点 v 从顶点 w 回溯，则 low[v]=min{low[v], low[w]}。可能帮助理解的概念：横插边：连接到已经出栈的节点的边；后向边：连接到已在栈中节点的边；树枝边：在搜索树中的边。 count强连通分量的个数。 Tarjan 算法涉及到深度优先搜索 DFS 的两个过程：搜索过程和回溯过程。 DFS 遍历有向图中所有的顶点，并将顶点压入栈 DFS 搜索过程中，对于从顶点 v 访问顶点 w ：如果顶点 w 没有被访问过，对 w 进行 DFS 遍历；如果 w 被访问过且 w 在栈中，更新 low[v] 的值：low[v]=min{low[v], dfn[w]} DFS 回溯过程中，对于顶点 v 从顶点 w 回溯，更新 low[v] 的值：low[v]=min{low[v], low[w]} 不管是搜索过程还是回溯过程，如果顶点 v 满足 dfn[v] == low[v]，则栈中顶点 v 之上的顶点是一个强连通分量！栈中元素逐个出栈，直到顶点 v 出栈 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class TarjanSCC &#123; private boolean[] marked; private int[] dfn; private int[] low; // low[v] = low number of v private int pre; // preorder number counter private Stack&lt;Integer&gt; stack; private boolean[] onStack; private int count; public TarjanSCC(Digraph G) &#123; marked = new boolean[G.V()]; stack = new Stack&lt;Integer&gt;(); low = new int[G.V()]; dfn = new int[G.V()]; onStack = new boolean[G.V()]; // 深度优先搜索 for (int v = 0; v &lt; G.V(); v++) &#123; if (!marked[v]) tarjan(G, v); &#125; &#125; private void tarjan(Digraph G, int v)&#123; marked[v] = true; // 记录顶点被访问的次序号 dfn[v] = low[v] = pre++; stack.push(v); onStack[v] = true; for (int w : G.adj(v))&#123; if (!marked[w]) &#123; // 递归深度优先搜索 tarjan(G, w); if (low[v] &gt; low[w]) low[v] = low[w]; &#125; else if (onStack[w] &amp;&amp; low[v] &gt; dfn[w])&#123; low[v] = dfn[w]; &#125; &#125; // 顶点 v 满足强连通分量条件 // 栈中顶点 v 之上的所有顶点都在同一个强连通分量中 // 栈中顶点出栈，直到顶点 v 出栈 if (dfn[v] == low[v])&#123; int w; do &#123; w = stack.pop(); onStack[w] = false; id[w] = count; &#125; while (w != v); count++; &#125; &#125;&#125; 《算法 4》的作者将 low[] 数组做了简化：low[v]=min{low[v], low[u]} ，也没有使用 dfn[] 数组。这样得出的 low[] 结果：同一个强连通分量中所有顶点的 low[] 值相同。本文参考的是 wiki: Tarjan Algorithms 的伪代码，网上大部分实现都是基于这份伪代码。参考：github tarjanscc 代码 图解Tarjan 算法的 dfn[] 值很好理解，但是 low[] 并不好理解，特别是代表的含义，本文也没弄明白！！现在通过代码来图解分析 low[v] 的值。深度优先搜索顺序为：0, 1, 3, 5, 2, 4 ，重点分析三个顶点 3, 1, 2。 顶点 3 顶点 3 的 low 值是在搜索时变化的，回溯没有更新。DFS 搜索过程中，从顶点 3 访问顶点 0，而顶点 0 已经在栈中：如果 dfn[0] &lt; low[3]，则更新 low[3] = dfn[0]，所以 low[3]=0 。 顶点 1 顶点 1 的 low 值是在回溯时更新的，搜索时因为是第一次访问直接赋值次序号。DFS 回溯过程中，顶点 1 从顶点 3 回溯：如果 low[3] &lt; low[1]，则更新 low[1] = low[3]，所以 low[1]=0 。 顶点 2 顶点 2 的 low 值是在搜索时变化的，回溯没有更新。DFS 搜索过程中，从顶点 2 访问顶点 3，而顶点 3 已经在栈中：如果 dfn[3] &lt; low[2]，则更新 low[2] = dfn[3]，所以 low[2]=2。low[2] 的值如果按照定义：最早栈中顶点次序号，应该为 0？但是根据算法实现思路推算，以及实际调试的结果： low[2]=2 。这也是为什么没弄明白 low 值含义的原因！ 小结 复杂度Tarjan 算法的时间复杂度也为 O(V+E)，虽然比 Kosaraju 算法计算量小，但是并没有 Kosaraju 算法容易理解。 强连通示例中顶点 1 3 4 和 顶点 1 2 4 都是强连通图，但是只有 1 2 3 4 才是强连通分量（相互连通顶点的最大子集）。 参考文档 wiki: Tarjan’s strongly connected components algorithm 百科：tarjan 算法 有向图强连通分量的Tarjan算法 Tarjan 算法 强连通分量-Tarjan算法动画 Tarjan知识点讲解 图解-画图工具]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 强连通分量 Kosaraju 算法]]></title>
    <url>%2F2018%2F08%2F22%2F0093-algorithms-scc-kosaraju%2F</url>
    <content type="text"><![CDATA[Kosaraju 算法，也称为 Kosaraju-Sharir 算法：在线性时间内找到有向图的强连通分量。 强连通分量如果两个顶点 v 和 w 是相互可达的，则称为它们为强连通的。强连通性将所有顶点分为一些平等的部分，每个部分都是由相互均为强连通的顶点的最大子集组成的；我们称这些最大子集为强连通分量。强连通分量是基于顶点而不是边的，可以认为 V 个顶点的有向图，可能含有 1 ~ V 个强连通分量。一个强连通图，只含有一个强连通分量；一个有向无环图则含有 V 个强连通分量。 强连通分量，必定存在环中。 算法定义强连通分量的 Kosaraju 算法，使用深度优先 DFS 实现： 在给定的有向图 G 中，计算反向图的顶点逆后序排序 按照上一步逆后序中顶点的顺序，在 G 中按照深度优先搜索访问未被标记的顶点 所有在同一个递归 DFS 调用中被访问到的顶点都在同一个强连通分量中 这里逆后序排序，不是拓扑排序，虽然算法类似，但是拓扑排序针对的是有向无环图，DFS 中会判断是否存在环，检测到环直接退出；而逆后序不检测环，会遍历所有顶点。 动画演示 动画演示和标准的 Kosaraju 算法有点不一样：它是先 DFS 遍历顶点得到逆后序排序，然后再将有向图置为反向图，按照逆后序排序取出顶点，深度优先搜索反向图。结果和 Kosaraju 算法一致。 算法实现算法解析： marked[] 数组记录当前顶点是否被访问过。 count记录有多少个强连通分量。 id[] 数组记录当前顶点属于第几个强连通分量。 G.reverse()有向图 G 的反向图：即将所有边的指向全部反过来。 ReversePostSort.getSort使用深度优先搜索获取顶点的逆后序排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// Kosaraju-Sharir 强连通分量算法public class KosarajuSharirSCC &#123; private boolean[] marked; private int[] id; private int count; public KosarajuSharirSCC(Digraph G) &#123; marked = new boolean[G.V()]; id = new int[G.V()]; ReversePostSort reverse = new ReversePostSort(G.reverse()); for (int v : reverse.getSort()) &#123; if (!marked[v]) &#123; dfs(G, v); count++; &#125; &#125; &#125; private void dfs(Digraph G, int v) &#123; marked[v] = true; id[v] = count; for (int w : G.adj(v)) &#123; if (!marked[w])&#123; dfs(G, w); &#125; &#125; &#125;&#125;// 深度优先搜索，得到顶点的逆后序排序public class ReversePostSort&#123; private boolean[] marked; private Stack&lt;Integer&gt; reversePostOrder; public ReversePostSort(Digraph G) &#123; reversePostOrder = new Stack&lt;Integer&gt;(); marked = new boolean[G.V()]; for (int v = 0; v &lt; G.V(); v++) if (!marked[v]) dfs(G, v); &#125; private void dfs(Digraph G, int v) &#123; marked[v] = true; for (int w : G.adj(v)) &#123; if (!marked[w]) &#123; dfs(G, w); &#125; &#125; // 递归后顶点入栈 reversePostOrder.push(v); &#125; // 获取有向无环图的拓扑排序 public Iterable&lt;Integer&gt; getSort()&#123; return reversePostOrder; &#125;&#125; 小结 时间复杂度时间复杂度为 O(V+E) 。 参考文档 《算法：第四版》 第 4 章 强连通分量-Kosaraju算法动画 强连通分支算法–Kosaraju算法、Tarjan算法和Gabow算法 求解强连通分量算法之—Kosaraju算法]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 拓扑排序]]></title>
    <url>%2F2018%2F08%2F22%2F0092-algorithms-topological-sorting%2F</url>
    <content type="text"><![CDATA[拓扑排序：针对有向无环图来排序。 概念定义对一个有向无环图 DAG: Directed Acyclic Graph 进行拓扑排序，是将图 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边 (u,v)∈E(G)，则 u 在线性序列中出现在 v 之前。通常这样的线性序列称为满足 拓扑次序 Topological Order 的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。当且仅当一幅图为有向无环图时才能进行拓扑排序。 AOV 网有向图中若以顶点表示活动，有向边表示活动之间的先后关系，这样的图简称为 AOV 网 Activity On Vertex Network 。如下图是计算机专业课程之间的先后关系： AOV 网：是一个有向无环图，通常用来表示： 课程先后关系哪个课程必须先修，修某个课程前必须修完哪些指定课程等。 工程先后关系哪些子工程必须先做完，做某个工程前必须将哪些工程先做完。 所以 AOV 网在实际中非常实用，可以通过拓扑排序来找出这些活动的先后关系序列。 排序思路拓扑排序在 AOV 网中排序方法如下： 在网中选择一个入度为 0（没有前驱）的顶点输出 在网中删除该顶点及与该顶点有关的所有边 重复上述两步，直到网中不存在入度为 0 的顶点 如果所有顶点输出则拓扑排序完成，否则表示网中存在回路。从上面算法思路中可以看出，拓扑排序和选择顶点的顺序有很大关系，所以拓扑排序输出顺序不是唯一的。 深度优先搜索递归实现前序/后序/逆后序深度优先搜索在遍历图的过程中，可以记录如下顺序： 前序即在递归调用之前将顶点加入队列；意义：代表深度优先搜索访问顶点的顺序。 后序即在递归调用之后将顶点加入队列；意义：代表深度优先搜索顶点遍历完成的顺序。 逆后序即在递归调用之后将顶点压入栈；意义：代表着顶点的拓扑排序。 一幅有向无环图的拓扑排序即为所有顶点的逆后序排列。 动图演示 算法解析 marked 数组记录当前顶点是否被访问过。 onStack 数组记录同一次深度优先搜索时，当前顶点是否被访问过。如果在同一次深度优先搜索中，已经被访问过，再次访问则说明存在有向环。 hasCycle如果为 true 表示存在环。 preorder 队列记录顶点前序，顶点在递归前入队。 postorder 队列记录顶点后序，顶点在递归后入队。 reverse 栈记录顶点逆后序，即拓扑排序；顶点在递归后入栈。 G 图有向无环图。 G.adj(v)顶点 v 所有邻接点序列。 参考：算法 4 的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445private boolean[] marked;private boolean[] onStack[];private boolean hasCycle = false;private Queue&lt;Integer&gt; preorder;private Queue&lt;Integer&gt; postorder;private Stack&lt;Integer&gt; reverse;public TopologicalSorting(Digraph G) &#123; preorder = new Queue&lt;Integer&gt;(); postorder = new Queue&lt;Integer&gt;(); reverse = new Stack&lt;Integer&gt;(); marked = new boolean[G.V()]; onStack = new boolean[G.V()]; for (int v = 0; v &lt; G.V(); v++) if (!marked[v] &amp;&amp; !hasCycle) dfs(G, v); if (hasCycle) reverse = null;&#125;private void dfs(Digraph G, int v) &#123; marked[v] = true; onStack[v] = true; // 递归前顶点入队 preorder.enqueue(v); for (int w : G.adj(v)) &#123; if (hasCycle) return; else if (!marked[w]) &#123; dfs(G, w); &#125;else if (onStack[w])&#123; hasCycle = true; return; &#125; &#125; // 递归后顶点入队和入栈 postorder.enqueue(v); reverse.push(v); onStack[v] = false;&#125;// 获取有向无环图的拓扑排序public Iterable&lt;Integer&gt; getTopologicalSort()&#123; return reverse;&#125; 使用递归实现的拓扑排序，有深度优先搜索特性，所有排序结果是按照一条纵深线来排序的。 有向环检测上述算法中，有向环的检测核心在同一次深度优先搜索 dfs 中，顶点 v 在遍历邻接点 w 时，如果再次访问到 广度优先搜索非递归实现根据拓扑排序思路，使用入度数组来记录每个顶点的入度，入度为 0 时，顶点即为拓扑排序顺序。这种基于入度的拓扑排序，也称为 Kahn&#39;s algorithm 。 动图演示 算法解析 indegree[] 数组记录各个顶点当前入度，也是算法实现的核心数组。 zeroInDegreeQueue 队列辅助队列：记录入度为 0 的顶点入队顺序。循环取出顶点并访问其邻接点。 order 队列拓扑队列：记录入度为 0 的顶点入队顺序，也就是拓扑排序结果。如果 G 图有向无环图。 G.adj(v)顶点 v 所有邻接点序列。 G.indegree(v)顶点 v 的入度。 参考：算法 4 的实现 1234567891011121314151617181920212223242526272829303132333435private int[] inDegree;private Queue&lt;Integer&gt; zeroInDegreeQueue;private Queue&lt;Integer&gt; order;private void topologicalSort(Digraph G)&#123; inDegree = new int[G.V()]; zeroInDegreeQueue = new LinkedList&lt;&gt;(); order = new LinkedList&lt;&gt;(); // 初始化入度数组，并将入度为 0 的顶点加入队列 for (int v = 0; v &lt; G.V(); v++)&#123; inDegree[v] = G.indegree(v); if (inDegree[v] == 0)&#123; zeroInDegreeQueue.offer(v); &#125; &#125; // 循环取出入度为 0 的顶点排序 while (!zeroInDegreeQueue.isEmpty())&#123; int node = zeroInDegreeQueue.poll(); // 记录拓扑排序结果，即入度为 0 的顶点 order.offer(node); for (int v : G.adj(node)) &#123; inDegree[v]--; if (inDegree[v] == 0) &#123; zeroInDegreeQueue.offer(v); &#125; &#125; &#125; // 如果队列长度和顶点总数不等，表示有向图存在环 if (order.size() != G.V())&#123; order = null; &#125;&#125; 使用入度数组的拓扑排序，有广度优先搜索的特性，所有排序结果是一层层的排出来的。 应用场景 任务优先级排序 任务调度 小结环检测不管是广度还是深度优先搜索，拓扑排序针对的是有向无环图。即使有向图中存在环，广度和深度优先搜索算法本身并不会报错或者无法执行，所以拓扑排序前后，需要判定有向图是否存在环！如果存在环，则排序结果是错误的，拓扑排序不存在。存在环的排序结果： 深度优先搜索能得到所有顶点顺序，但是并没有体现拓扑排序的特点：图中任意一对顶点 u 和 v，若边 (u,v)∈E(G)，则 u 在线性序列中出现在 v 之前。也就是这个结果是错误的。 广度优先搜索无法得到所有顶点顺序，在环里面的顶点输出不全。广度优先搜索使用的是入度数组来排序的，但是环中顶点入度将始终不会为 0，导致环中顶点不参与排序。 两种实现方式结果对比 深度优先搜索拓扑排序结果：6, 7, 0, 2, 1, 8, 9, 12, 10, 11, 5, 3, 4 ，体现了排序纵深特性。 广度优先搜索拓扑排序结果：0, 6, 1, 2, 7, 5, 3, 8, 9, 4, 10, 12, 11 ，体现了排序分层特性。 时间复杂度不管是广度还是深度优先，实现拓扑排序的时间复杂度都为 O(V+E) 。 参考文档 《算法：第四版》 第 4 章 拓扑排序-索引 拓扑排序-深度优先搜索 拓扑排序-广度和深度优先搜索]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 图的搜索]]></title>
    <url>%2F2018%2F08%2F20%2F0091-algorithms-dfs-bfs%2F</url>
    <content type="text"><![CDATA[算法图的搜索和遍历：广度优先搜索和深度优先搜索。 深度优先搜索定义深度优先搜索 DFS: Depth First Search ，基本思路：假设初始状态是图中所有顶点均未被访问，从图中某顶点 v 出发： 首先访问该顶点 v，并标记为已访问 依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止 图解图解中有两个数组：Visited[] 表示是否已被访问；Parent[] 记录图遍历过程父顶点。 无向图深度优先搜索 有向图深度优先搜索 递归实现从深度优先搜索的定义可以看出，它是一个标准的递归算法，其算法解析： marked[] 数组记录当前顶点是否被访问过。 parent[] 数组记录当前顶点，在遍历过程中的父节点。 G 图代表无向图或者有向图。 v 顶点指定深度优先搜索从该顶点触发。 G.adj[v] 邻接点顶点 v 的所有邻接点。 参考：算法 4 的实现 12345678910111213141516171819private boolean[] marked; private int[] parent;public DepthFirstSearch(Graph G, int s) &#123; marked = new boolean[G.V()]; parent = new int[G.V()]; dfs(G, s);&#125;private void dfs(Graph G, int v) &#123; marked[v] = true; for (int w : G.adj(v)) &#123; // 如果没有被访问过，递归深度优先搜索 if (!marked[w]) &#123; parent[w] = v; dfs(G, w); &#125; &#125;&#125; 非递归实现 adj[] 数组记录每个顶点，对应邻接点的列表。也可以认为它是一个二维数组。 stack 栈后进先出，一次记录被访问的轨迹。 参考：算法 4 的实现 1234567891011121314151617181920212223242526private void dfs_non_recur(Graph G, int v)&#123; Iterator&lt;Integer&gt;[] adj = (Iterator&lt;Integer&gt;[]) new Iterator[G.V()]; for (int i = 0; i &lt; G.V(); i++) adj[i] = G.adj(i).iterator(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); marked[v] = true; stack.push(v); while (!stack.isEmpty()) &#123; int node = stack.peek(); if (adj[node].hasNext()) &#123; int w = adj[node].next(); if (!marked[w]) &#123; // discovered vertex w for the first time marked[w] = true; parent[w] = node; stack.push(w); StdOut.printf("dfs(%d)\n", w); &#125; &#125; else &#123; StdOut.printf("%d done\n", node); stack.pop(); &#125; &#125;&#125; 应用场景 连通性：给定两个顶点是否连通 单点路径：两个给定的顶点是否存在路径 检测环：判断图中是否存在环 二分图或者双色问题，是否能用两种颜色将图着色？使得任意一条边的两端都是不同的颜色（即是否为二分图）。 单点可达性：有向图中，给定顶点 s 到给定顶点 v 是否可达 多点可达性给定一幅有向图中和顶点集合，是否存在一条从集合中的任意顶点到达给定顶点 v 的有向路径。多点可达性的一个重要应用场景就是 Java 垃圾回收中的：标记-清除算法。每个顶点表示一个对象，每条边表示对另一个对象的引用。 调度问题有向图中有优先级限制的调度问题。 拓扑排序 强连通性有向图中给定两个顶点是否是强连通的？这幅有向图中有多少个强连通分量？ 小结 深度优先搜索算法，递归实现简单清晰；在非递归实现中，使用栈来记录访问的节点，后进先出，确保按照深度来搜索 算法时间复杂度 O(V+E) ，其中 V 是顶点数，E 是边数 广度优先搜索定义广度优先搜索 BFS: Breadth First Search ，也称为宽度优先搜索；基本思路：假设初始状态是图中所有顶点均未被访问，从图中某顶点 v 出发： 首先访问该顶点 v ，并标记为已访问 依次访问顶点 v 的邻接点，并将未被访问的顶点加入队列 依次从队列中取出顶点，并按照上一步访问其邻接点，直至队列为空。即先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直到所有已被访问的顶点的邻接点都被访问到 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止 图解图解中有两个数组：Visited[] 表示是否已被访问；Parent[] 记录图遍历过程父顶点。 无向图广度优先搜索 有向图广度优先搜索 非递归实现从广度优先搜索的定义可以看出，算法更适合非递归来实现，其算法解析： marked[] 数组记录当前顶点是否被访问过。 parent[] 数组记录当前顶点，在遍历过程中的父节点。 G 图代表无向图或者有向图。 v 顶点指定深度优先搜索从该顶点触发。 G.adj[v] 邻接点顶点 v 的所有邻接点。 参考：算法 4 的实现 123456789101112131415161718192021222324private boolean[] marked;private int[] parent;public BreadthFirstSearch(Digraph G, int s) &#123; marked = new boolean[G.V()]; parent = new int[G.V()]; bfs(G, s);&#125;private void bfs(Digraph G, int s) &#123; Queue&lt;Integer&gt; q = new Queue&lt;Integer&gt;(); marked[s] = true; q.enqueue(s); while (!q.isEmpty()) &#123; int v = q.dequeue(); for (int w : G.adj(v)) &#123; if (!marked[w]) &#123; parent[w] = v; marked[w] = true; q.enqueue(w); &#125; &#125; &#125;&#125; 应用场景广度优先搜索是分层次搜索， 单点最短路径：找到给定两个顶点之间的最短路径 间隔度数找到社交网络中间隔度数（或者说熟悉度，几度人脉等）。其实仍然是最短路径问题，计算路径长度。 小结 广度优先搜索通常使用非递归实现 算法时间复杂度 O(V+E) ，其中 V 是顶点数，E 是边数 总结 深度优先搜索有递归和非递归两种实现方式，广度优先搜索采用非递归实现 两种算法的非递归实现中，深度优先搜索使用栈实现，下一个节点从栈顶取出，即最后一个入栈节点；广度优先搜索使用队列实现，下一个节点从队列取出，即第一个入队列节点 两种算法时间复杂度相同，都是 O(V+E) 参考文档 《算法：第四版》 第 4 章 广度优先搜索动画 深度优先搜索动画 图的遍历动画 图的遍历-深度优先搜索和广度优先搜索]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 图的基础概念]]></title>
    <url>%2F2018%2F08%2F17%2F0090-algorithms-graph%2F</url>
    <content type="text"><![CDATA[算法：图的基础概念。 图是一组顶点和一组能够将两个顶点相连的边组成的。四种重要的图模型： 无向图简单连接。无向图是由一组顶点和一组能够将两个顶点相连的边组成的。 有向图连接有方向性。有向图由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。 加权图无向图无向图的每条边，连接带有权值。 加权有向图有向图的每条边，连接既有方向性又带有权值。 无向图本章会介绍图的一些基本概念，这些概念并不是无向图特有的，有些是图的公共特性。 特殊的图有两种简单而特殊的情况： 自环一条连接一个顶点和其自身的边，即自己连接自己的环图。 平行边连接同一对顶点的两条边。 通常含有平行边的图称为多重图，没有平行边或者自环的图称为简单图。 术语表 相邻的顶点/邻接点：当两个顶点通过一条边相连时，我们称这两个顶点是相邻的；也称这两个点互为邻接点 依附：称这条边（该连接）依附于这两个顶点 度数：依附一个顶点的边的总数数学特性：所有顶点度数的和 = 2 * 所有的边数。 子图：一幅图所有边的子集（以及它们所依附的顶点）组成的图图论中很多问题需要识别各种类型的子图，特别是能顺序连接一系列顶点的边所组成的子图。 路径：由边顺序连接的一系列顶点 简单路径：一条没有重复顶点的路径 环：一条至少含有一条边且起点和终点相同的路径 简单环：除了顶点和终点相同外的，一条不含有重复顶点和边的环我们通常研究的路径和环，如果不做特别说明，都是简单路径和简单环。 长度：路径或环的长度为其中所包含的边数 连通的：当两个顶点之间存在一条连接双方的路径时，称一个顶点和另一个顶点是连通的 连通图：如果从任意一个顶点都存在一条路径到达另外任意一个顶点，称这幅图是连通图 极大连通子图：一幅非连通的图由若干连通的部分组成，他们都是极大连通子图。也就是说一个非连通的图由几个极大连通子图组成 极小连通子图：也就是生成树 无环图：一种不包含环的图图论中有很多算法，用来找出一幅图中满足一定条件的无环子图。 树：一幅无环连通图 森林：互不相连的数组成的集合称为森林 生成树：连通图的子图，包含图中所有顶点的一颗树；也就是极小连通子图 生成树森林：所有连通子图的生成树的集合 最小生成树：MST: Minimum Spanning Tree ，一幅加权无向图的最小生成树是它的一颗权值（树中所有边的权值之和）最小的生成树 最小生成森林：一幅非连通图中，计算所有连通分量的最小生成树，合并在一起则为最小生成森林 密度：已经连接的顶点对占所有可能被连接的顶点对的比例 稀疏图：被连接的顶点对很少 稠密图：只有少部分顶点对之间没有没有边连接 二分图：能够将所有节点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分 对于 V 个顶点的图，索引值是以 0 开始，到最后一个 V-1 个顶点： v-w使用 v-w 的记法来表示连接 v 和 w 的边。 u-v-w-x使用 u-v-w-x 的记法来表示 u 到 x 的一条路径。 u-v-w-x-u使用 u-v-w-x-u 的记法来表示从起点为 u 的简单环，以及环经过的顶点。 树的性质和特点树的性质： 用一条边连接树中的任意两个顶点都会产生一个新的环 从树中删除一条边将会得到两颗独立的树 树的特点：当且仅当一幅含有 V 个节点的图 G 满足下列 5 个条件之一时，它就是一颗树： G 有 V-1 条边且不含有环 G 有 V-1 条边且是连通的 G 是连通的，但删除任一条边都会使它不再连通 G 是无环图，但添加任一条边都会产生一条环 G 中的任意一对顶点之间仅存在一条简单路径 图的存储结构常用存储结构常用来表示图的数据结构： 邻接矩阵 Adjacency Matrix使用一个 V*V 的布尔矩阵，当 v 和 w 有相邻边时设置为 true，否则为 false。需要 V*V 个布尔值空间，空间占用太大。因为研究的大部分图为稀疏图，所以邻接矩阵往往对应为稀疏矩阵；无向图是对称矩阵。邻接矩阵有时也用整型数组表示，每个元素可以表示是否连通，或者边上的权值。 边的数组 Edge List数组中存储 Edge 元素，每个表示一条边。而 Edge 中包含两个整型变量，分别表示这条边的两个顶点。 邻接表数组 Adjacency List使用一个以顶点为索引的列表数组，其中每个元素都是和该顶点相邻的顶点列表，以一条链表表示经过顶点的路径。 图存储结构更多的示例可以参考：图存储结构图形化 特点 邻接矩阵由于没有相连的边也占有空间，因此存在浪费空间的问题，而邻接链表则比较合理地利用空间。 邻接链表比较耗时，牺牲很大的时间来查找，因此比较耗时，而邻接矩阵法相比邻接链表法来说，时间复杂度低。 有向图在有向图中，边是单向的：每条边所连接的两个顶点都是一个有序堆，它们的领接性是单向的。有向图由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。 术语表 出度：该顶点指出的边的总数 入度：指向该顶点的边的总数 头：一条有向边的第一个顶点 尾：一条有向边的第二个顶点 有向路径：由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列中的下一个顶点 有向环：一条至少含有一条边且起点和终点相同的有向路径 简单有向环：（除了起点和终点外）一条不含有重复顶点和边的环 长度：路径或环中包含的边数 可达性：存在顶点 v 到 w 的路径时，则称 v 能到达 w约定：每个顶点都能到达自己。有向图中 v 能到达 w，并不意味着 w 能到达 v，需要考虑到方向性。 有向无环图：DAG: Directed Acyclic Graph 一幅不含有环的有向图 强连通的：如果两个顶点 v 和 w 是相互可达的，则称为它们为强连通的两个顶点是强连通的当且仅当它们都在一个普通的环中，也就是说强连通只能出现在环中。 强连通图：有向图中任意两个顶点都是强连通的 强连通分量：强连通性将所有顶点分为一些平等的部分，每个部分都是由相互均为强连通的顶点的最大子集组成的；我们称这些最大子集为强连通分量强连通分量是基于顶点而不是边的，可以认为 V 个顶点的有向图，可能含有 1 ~ V 个强连通分量。一个强连通图，只含有一个强连通分量；一个有向无环图则含有 V 个强连通分量。 强连通性的性质 自反性任意顶点 v 和自己都是强连通的。 对称性如果 v 和 w 是强连通的，那么 w 和 v 也是强连通的。 传递性如果 v 和 w 是强连通的且 w 和 x 也是强连通的，那么 v 和 x 也是强连通的。 加权无向图和加权有向图 加权图加权图是一种为每条边关联一个权值或是成本的图模型。也就是说：图的每条边，连接带有权值。权重可能是距离、时间、费用等，也可以为 0 或者负数。 加权无向图加权无向图经常需要解决的问题是最小生成树问题。 加权有向图加权有向图经常需要解决的问题是最短路径等。 最小生成树 最小生成树：MST: Minimum Spanning Tree ，一幅加权无向图的最小生成树是它的一颗权值（树中所有边的权值之和）最小的生成树 切分：将图的所有顶点分为两个非空且不重复的两个集合；切分就是将图分成二分图 横切边：是一条连接两个属于不同集合的顶点的边 切分定理：在一幅加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图的最小生成树；是最小生成树算法的基本定理 最短路径 最短路径：在一幅加权有向图中，从顶点 s 到顶点 t 的最短路径是所有从 s 到 t 的路径中的权重最小者 最短路径树：SPT: Shortest Path Tree，给定一幅加权有向图和顶点 s，以 s 为起点的一颗最短路径树是图的一幅子图，它包含 s 和从 s 可达的所有顶点。这颗有向树的根节点为 s，树的每条路径都是有向图中的一条最短路径。 边的松弛：放松边 v-w 意味着检查从 s 到 w 的最短路径是否先从 s 到 v，然后再由 v 到 w。如果是，则比较 distTo[w] 和 distTo[v] + e.weight() 的大小。如果 distTo[w] 小，则 v-w 这条边失效了；否则将 distTo[w] 更新为较小值。distTo[] 记录顶点到该点的最短路径。 1234567private void relax(DirectedEdge e)&#123; int v = e.from(), w = e.to(); if(distTo[w] &gt; distTo[v] + e.weight())&#123; distTo[w] = distTo[v] + e.weight(); edgeTo[w] = e; &#125;&#125; 最短路径的最优性条件G 是一幅加权有向图，顶点 s 是 G 的起点，distTo[] 是一个由顶点索引的数组，保存的是 G 中路径的长度。对于从 s 可达的所有顶点 v，distTo[v] 的值是从 s 到 v 的某条路径的长度，对于从 s 不可达的所有顶点 v，该值为无穷大。当且仅当对于从 v 到 w 的任意一条边 e，这些值都满足 distTo[w] &lt;= distTo[v] + e.weight() 时（换句话说，不存在有效边时），它们是最短路径长度。 负权重环负权重环：加权有向图的负权重环是一个总权重（环上所有边的权重之和）为负的有向环。负权重环的所有边不一定都要求为负的，只要权重之和为负就行。假设：从起点 s 到可达顶点 v 的路径上，有某个顶点在一个负权重环上，这种情况下从 s 到 v 是不存在最短路径的。因为负权重环可以构造权重任意小的路径（在负权重环上循环 n 圈）。结论：当且仅当加权有向图中，至少存在一条从 s 到 v 的有向路径，并且这条有向路径上的任意顶点都不在任意负权重环中时， s 到 v 的最短路径才是存在的。 图常见问题 是否连通 有向图可达性 是否存在路径 最短路径 是否存在环 判断有向无环图 有向图调度问题 有向图拓扑排序 是否为二分图 社交网络间隔度数/影视作品演员间间隔 强连通分量 最小生成树 负权重环检测 这些问题在图的搜索 中，可以看到图的深度搜索和广度搜索能解决大部分问题。比较难解决的，会单独列出文章分析。 小结图论的缺点是缺乏单独定义，这就是为什么无法在 jdk, std 等库中找到对应源码。 参考文档 《算法：第四版》 第 4 章 图存储结构图形化 算法-图论 算法4-图详解]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 红黑树]]></title>
    <url>%2F2018%2F08%2F08%2F0089-algorithms-red-black-tree%2F</url>
    <content type="text"><![CDATA[算法：2-3 查找树，红黑树，JDK 中 TreeMap 源码分析。其中 2-3 查找树，红黑树基本定义参考《算法 4》，TreeMap 源码解析参考《算法导论》中红黑树的分析。 2-3 查找树定义2-3 查找树的定义：一颗 2-3 查找树或为一颗空树，或由以下节点组成： 2 节点：含有一个键（及其对应的值）和两条链接，左链接指向的 2-3 树中的键都小于该节点，右链接指向的 2-3 树中的键都大于该节点 3 节点：含有两个键（及其对应的值）和三条链接，左链接指向的 2-3 树中的键都小于该节点，中链接指向的 2-3 树中的键都位于该节点的两个键之间，右链接指向的 2-3 树中的键都大于该节点 空链接：指向一颗空树的链接 一颗完美平衡的 2-3 查找树中，所有的空链接到根节点的距离都是相同的。通常我们在操作（构造、插入、删除）时，都会刻意保持 2-3 树的平衡性，有序性。 查找2-3 树的查找算法和二叉查找树算法类似：先从根节点比较，递归向下查找；如果相等则命中，否则根据比较结果指向相应的链接递归查找；如果是空链接表示查找未命中。 插入2-3 树中的插入操作非常复杂，细分为如下几种情形： 向 2 节点中插入新键 向 3 节点中插入新键，整棵树只包含这个 3 节点 向 3 节点中插入新键，其父节点为 2 节点 向 3 节点中插入新键，其父节点为 3 节点 参考 2、3 节点的定义，引入 4 节点。所有 3 节点的插入操作，会涉及到 4 节点及对应转换。插入新键后，需要保持 2-3 查找树的平衡性、有序性，针对以上情形逐个分析： 向 2 节点中插入新键查找到合适位置后，将新键直接加入 2 节点，使其成为一个 3 节点，完全不影响平衡性。 向 3 节点中插入新键，整棵树只包含这个 3 节点先将新键存入 3 节点使其变为一个 4 节点，而 4 节点很容易分解为一颗由 3 个 2 节点组成的 2-3 树。此时这棵树既是一颗二叉查找树，同时也是一颗完美平衡的 2-3 树。这个场景插入新键前树高为 0，插入后高度增长为 1 。 向 3 节点中插入新键，其父节点为 2 节点先将新键存入 3 节点使其变为一个 4 节点，为了避免破坏平衡性，此时并不能直接将中键创建新节点，而是要将其移动到原来的父节点中。使父节点由 2 节点变为 3 节点。这次转换保持了树的平衡性和有序性。 向 3 节点中插入新键，其父节点为 3 节点先将新键存入 3 节点使其变为一个 4 节点，分解中键插入到父节点中，而父节点也是一个 3 节点。同理递归向上分解中键，直到不需要分解或者到达根节点。如果递归分解中键到根节点，此时根节点是一个 4 节点，参考第二种情形，直接将该节点分解为 3 个 2 节点，使得树高加 1 。此时树仍然是平衡、有序的。 4 节点分解及其性质4 节点分解为 2-3 树一共包含 6 中情况。4 节点的分解变换都是局部的：除了相关的节点和链接之外不必修改或者检查树的其他部分。这些局部变换也不会影响树的全局有序性和平衡性：任意空链接到根节点的路径长度都是相等的。 2-3 树构造2-3 树构造过程是由下向上的，总是会经历 2 节点、 3 节点、 4 节点的转换。 小结 2-3 查找树中，插入和查找的时间复杂度必然不超过 logN，即使在最坏情况下，也能保持良好的平衡性 2-3 查找树因为涉及到多种节点，及类型转换，实现复杂 红黑树定义由于 2-3 树难于实现，所以使用一种名为红黑树的新数据结构来实现它。红黑树首先是一颗二叉查找树，它同时满足 5 条性质： 每个节点要么是红色要么就是黑色 根节点必须是黑色 每个空（NIL）节点必须是黑色 如果节点是红色，它的两个子节点必须是黑色 树是完美黑色平衡的：即任意空 NIL 节点到根节点路径上包含相同数量的黑色节点 红黑树实现有多种表达方式，但必须满足上面 5 条性质。红黑树目的是用标准的二叉查找树和红黑两种颜色来实现。《算法 4》中的实现有如下特点： 红链接：红色左链接连接的两个 2 节点，表示 2-3 树的 3 节点。其特点是：必须为左链接，且不能出现两条连续的红链接。 黑链接：表示 2-3 树中的 2 节点 我们将红黑树中的红链接画平，那么所有空节点到根节点的距离都是相同的（黑色平衡），我们将红链接节点合并，即为一颗 2-3 树。相反，如果将 2-3 树的 3 节点画成由红色左链接相连的两个 2 节点，即转换为一颗红黑树。所以可以认为红黑树既是一颗二叉查找树，又是一颗 2-3 树。 红黑树节点比二叉查找树多了一个字段 color ，用来表示和其父节点链接的颜色。 1234567891011121314private class Node &#123; private Key key; // key private Value val; // associated data private Node left, right; // links to left and right subtrees private boolean color; // color of parent link private int size; // subtree count public Node(Key key, Value val, boolean color, int size) &#123; this.key = key; this.val = val; this.color = color; this.size = size; &#125;&#125; 红黑树中红节点有多种表示方法，《算法 4》中采取的是 2-3 树表示法，也就是只有左红链接。而各种语言自带的 SDK 中红黑树通常是使用 2-3-4 树表示法，这种表示法中红节点可以是左链接、也可以是右链接。还有些算法论文中红黑树使用 2-3-4 树表示时，使用两个连续的左红链接来表示 4 节点。使用不同表示法，插入、删除、修复等算法实现会有较大差异。《算法 4 》使用的是 2-3 树，而《算法导论》则使用的是 2-3-4 树；不管使用哪种树，红黑树的 5 条基本性质不变。 旋转以《算法 4》中，使用左红链接表示 3 节点，来解释红黑树的旋转。在插入或删除等操作后，可能会出现红色右链接或者两条连续的红链接，出现这些情况时需要旋转红链接并修复。 左旋转红色右链接旋转为左链接。实现思路是将两个节点中，较大的作为根节点。 右旋转红色左链接旋转为右链接。实现思路是将两个节点中，较小的作为根节点。 不管是左旋转还是右旋转，我们都不会改变其在父节点链接的颜色。这条链接可能是红色，也可能是黑色，总之旋转不会破坏节点和父节点链接的颜色。如果出现两条连续的红链接，需要递归旋转，直到根节点。 1234567891011121314151617181920212223242526// 左旋转// make a right-leaning link lean to the leftprivate Node rotateLeft(Node h) &#123; // assert (h != null) &amp;&amp; isRed(h.right); Node x = h.right; h.right = x.left; x.left = h; x.color = x.left.color; x.left.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x;&#125;// 右旋转private Node rotateRight(Node h) &#123; // assert (h != null) &amp;&amp; isRed(h.left); Node x = h.left; h.left = x.right; x.right = h; x.color = x.right.color; x.right.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x;&#125; 颜色转换如果一个节点的两个子节点都为红色（可以理解为 2-3 树中的 4 节点），需要对这三个节点做颜色转换：两个子节点的颜色由红变黑，当前节点的颜色要由黑变红。相当于 4 节点的中键建立新键，插入到父节点中，使父节点变为 3 节点。根节点：颜色旋转可能会将根节点变为红色，违背了红黑树的定义。因此每次插入节点时，都会将根节点设置为黑色。颜色转换和旋转操作一样，都属于局部转换，不会破坏整棵树的黑色平衡性。 12345678910// flip the colors of a node and its two childrenprivate void flipColors(Node h) &#123; // h must have opposite color of its two children // assert (h != null) &amp;&amp; (h.left != null) &amp;&amp; (h.right != null); // assert (!isRed(h) &amp;&amp; isRed(h.left) &amp;&amp; isRed(h.right)) // || (isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.right)); h.color = !h.color; h.left.color = !h.left.color; h.right.color = !h.right.color;&#125; 插入《算法 4》的插入分析：2-3 树的插入复杂且情形很多，每次插入新键都会形成 3 节点或者 4 节点，需要逐一对应分析： 向 2 节点插入新键插入新键时，总是用红链接将新节点和它的父节点相连（即产生一个 3 节点）。如果新节点是父节点的左链接，则直接形成 3 节点；如果新节点是父节点的右链接，形成的 3 节点颜色不对，需要左旋转修复。 向 3 节点插入新键，整棵树只包含这个 3 节点3 节点中插入新键时，会产生 4 节点，此时必然涉及到 4 节点的分解，即颜色转换。向 3 节点中插入新键时有三种情况：新键小于树中的两个键，在两个键之间，或者大于两个键。插入后会出现红色右链接、连续两个红链接、两个子节点都为红链接的情形，需要对应做左右旋转及颜色转换。 向 3 节点插入新键，3 节点位于树中或底部操作方式和整个树为 3 节点类似，但是会使得红链接在树中向上传递。使用递归的方式处理这条红链接，直到遇到 2 节点或者根节点。 根据以上分析，插入新键小结如下： 新键节点总是红色 如果右子节点是红色而左子节点是黑色，则将该节点左旋转 如果左子节点是红色，且它的左子节点也是红色，即连续两条红链接，则将该节点右旋转 如果左右两个子节点都是红色，进行颜色转换 不管是那种情形的插入，插入新节点后，必须将根节点置为黑色 123456789101112131415161718192021222324252627282930313233343536373839public void put(Key key, Value val) &#123; if (key == null) throw new IllegalArgumentException(&quot;key is null&quot;); if (val == null) &#123; delete(key); return; &#125; root = put(root, key, val); // 每次插入新键，必须将根节点设置为黑色 root.color = BLACK; // assert check();&#125;// insert the key-value pair in the subtree rooted at hprivate Node put(Node h, Key key, Value val) &#123; // 如果没有找到，新键一个节点 // 新键默认为红色，即新插入节点会形成 3 节点或 4 节点 if (h == null) return new Node(key, val, RED, 1); // 递归查找，新键插入到左子树还是右子树 int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; // fix-up any right-leaning links // 如果右子节点是红色而左子节点是黑色，则将该节点左旋转 if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); // 如果左子节点是红色，且它的左子节点也是红色 // 即连续两条红链接，则将该节点右旋转 if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); // 如果左右两个子节点都是红色，进行颜色转换 if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); // 递归更新节点数 h.size = size(h.left) + size(h.right) + 1; return h;&#125; 构造轨迹根据上面插入新键的思路，得到的红黑树是一颗接近完美平衡的二叉查找树。如下示例为同一组键值对，按照不同顺序构建的红黑树。 查找红黑树的查找算法和二叉查找树算法完全一致。 12345678910111213141516public Value get(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument is null"); return get(root, key);&#125;// value associated with the given key in subtree rooted at x; // null if no such keyprivate Value get(Node x, Key key) &#123; while (x != null) &#123; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x = x.left; else if (cmp &gt; 0) x = x.right; else return x.val; &#125; return null;&#125; 删除及有序性《算法 4》中并没有详细分析红黑树的删除，删除这个过程非常复杂，本文在 TreeMap 源码分析中详细介绍删除过程。 JDK 中的红黑树 TreeMapjava.util.TreeMap.java 是 JDK 中红黑树的实现，并且 java.util.HashMap.java 使用拉链法解决冲突时，链表个数超过 8 个会自动转换为红黑树。 节点TreeMap 是使用 2-3-4 树的思路来实现红黑树的，参考了《算法导论》的伪代码来实现。如下示例将红节点“拉平”后，为一颗完美平衡的 2-3-4 树。 新建节点默认为黑色（但是插入修复时，总是会先将新节点设置为红色），节点中有三条链接分别指向：左子树、右子树、父节点。 123456789101112131415161718192021222324private static final boolean RED = false;private static final boolean BLACK = true;static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; // 默认为黑色节点 boolean color = BLACK; Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; public K getKey() &#123;return key;&#125; public V getValue() &#123;return value;&#125; public V setValue(V value) &#123;...&#125; public boolean equals(Object o) &#123;...&#125; public int hashCode() &#123;...&#125; public String toString() &#123;...&#125;&#125; 旋转2-3 树和 2-3-4 树旋转的概念是一样的，都是红色节点的左右旋。 123456789101112131415161718192021222324252627282930313233private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125;private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 前驱和后继 前驱：小于当前节点的最大节点 后继：大于当前节点的最小节点 换句话说，在红黑树排序中，前驱为当前节点的前一个，后继为当前节点的后一个。如下为后继节点图示： 在看红黑树的文章时，网上经常出现一个结论：前驱或者后继节点最多包含一个子节点。这个结论并不准确！比如：当前节点为叶子节点或者只包含一个子节点时，则其前驱或者后继最多能包含两个节点。示例：当前节点为叶子节点 30 ，其前驱为 21 包含一个子节点，后继为 35 包含两个子节点；当前节点为 45 ，只包含一个子节点，其前驱为 35 包含两个子节点，后继为 50 不包含子节点。所以这个结论需要有一个前提条件才是正确的：当前节点有两个子节点时，其前驱或者后继最多只有一个子节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Returns the successor of the specified Entry, or null if no such. */static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; // t 的右子树不空，则 t 的后继是其右子树中最小的那个元素 else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; // t 的右子树为空，则 t 的后继是其第一个向左走的祖先 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125;/** * Returns the predecessor of the specified Entry, or null if no such. */static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.left != null) &#123; Entry&lt;K,V&gt; p = t.left; while (p.right != null) p = p.right; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.left) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; 插入先循环查找新键插入的合适位置，插入后修复整棵树的平衡性。哪些节点需要修复？同时满足下面两条： 当前节点为红节点（修复时，新插入的节点总是设置为红色，也就是实际上新建节点默认是红色） 当前节点的父节点也为红节点 也就是说：如果出现上下连续两个红节点，则需要修复。修复分为三种情况： 叔叔结点（祖父结点的另一个子结点）是红色修复方案：颜色转换，红色上移！父节点和叔叔节点变黑，祖父节点变为红色。祖父节点作为当前节点循环修复！颜色：父节点和叔叔节点变黑，祖父节点变为红色。旋转：不做旋转。 叔叔节点是黑色，当前结点是其父结点的右子修复方案：父节点作为当前节点左旋。颜色：不改变颜色。旋转：父节点变成兄弟节点。 叔叔节点是黑色，当前结点是其父结点的左子也就是：当前节点，父节点，祖父节点同为左边一条线或者右边一条线修复方案：父节点变为黑色，祖父节点变为红色，并且祖父节点右旋。颜色：父节点变为黑色，祖父节点变为红色。旋转：祖父节点变为叔叔节点。图示中：N 表示新建节点或当前节点；P 表示父节点；G 表示祖父节点。 小结： 插入修复，主要参考的是父节点和叔叔节点的颜色 情形一祖父节点循环修复；情形二和情形三顺序执行后退出 修复的最后一步是确保根节点为黑色 上面三种情况都会有对称情形，请看下面代码。也就说实际上是有 6 中情形，因为对称只需要分析三种情形 修复所做的旋转不会超过 2 次 如下为红黑树插入动态图，动图生成网址， 插入顺序为 12, 1, 9, 2, 0, 11, 7, 19, 4, 15, 18, 5, 14, 13, 10, 16, 6, 3, 8, 17 ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 循环遍历找到新键插入的合适位置public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths // 指定比较器 Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 没有指定比较器，直接比较 else &#123;...&#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;&#125;// 插入后修复新键及整颗树的平衡性private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; // 修复的条件：上下连续两个红节点 x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; // 父节点为左子树 if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; // 获取叔叔节点 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); // 情形 1：叔叔节点为红色 if (colorOf(y) == RED) &#123; // 修复方案：颜色转换，红色上移！ // 父节点和叔叔节点变黑，祖父节点变为红色 // 祖父节点作为当前节点循环修复 setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; // 情形 2：叔叔节点是黑色，当前结点是其父结点的右子 // 修复方案：父节点作为当前节点左旋 if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; // 当前节点左旋后，自动进入情形 3 （满足左子条件） // 情形 3：叔叔节点是黑色，当前结点是其父结点的左子 // 修复方案：父节点变为黑色，祖父节点变为红色，并且祖父节点右旋 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; // 父节点为右子树，获取叔叔节点 Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; // 修复完后，根节点必须设置为黑色 root.color = BLACK;&#125; 删除节点大致思路：找到被删节点 –&gt; 找到替换节点 –&gt; 删除或者修复 找被删节点：如果被删节点有两个子节点，复制后继节点（或者前驱）到被删节点（仅拷贝键值对，被删节点的三条链接和颜色保持不变），并使用其后继节点（或者前驱）作为新的被删节点 找替换节点：如果被删节点左子节点不为空，则用左子节点作为替换节点；否则用右子节点作为替换节点 如果替换节点不为空，则先删除再修复替换节点；如果替换节点为空（即被删节点为叶子节点），则先修复被删节点，再删除被删节点： 删除：被删除节点的左右父三条链接都置空，使用替换节点替换到被删节点的位置。除了修改替换节点的父链接，替换节点的颜色等其他信息全部保留 修复：被修复节点如果是黑色且不为根节点，需要变色和旋转；否则直接将被修复节点置黑结束修复。修复节点可能是替换节点（删除节点和替换节点都为黑色时，即连续两个黑色节点），也可能是被删节点（被删节点为黑色叶子节点，即黑叶子）。 被删节点的特点： 被删节点最多只包含一个子节点分析如下：因为是二叉查找树，所以被删节点可能为叶子节点、只包含一个子节点、有两个子节点。而当被删节点有两个子节点时，需要使用前驱或者后继复制到被删节点位置，并将前驱或者后继作为新的被删节点。而被删节点有两个子节点时，其前驱或者后继（在其左右子树中）必定最多只会包含一个子节点。替换节点则为这个唯一的子节点或者为空节点。 被删节点为黑色才进入修复如果被删节点是红色（表示是 3 节点或 4 节点），则直接删除该节点，并用替换节点替换后结束。如果被删节点是黑色（表示是 2 节点），删除后会导致左右不平衡，则进入修复流程。被修复节点可能是被删节点或者替换节点。 被修复节点的特点： 可能是被删节点或替换节点 颜色可红可黑：如果是被删节点必为黑色；如果是替换节点，可红可黑 修复节点节点的假设：被删除的节点为 X，其替换节点（孩子节点）为 N，大部分学习资料上，在讲删除后修复时，都是将 X 节点省略掉了，直接使用 N 节点替代了 X 节点的位置。不管是修复被删节点还是修复替换节点，本文使用 R 表示被修复节点。而修复时，被修复节点 R 的父节点为 P，兄弟节点为 S；S 的左子节点为 SL，右子节点为 SR。 修复中需要变色和旋转的四种情形细分，图示中白色表示任意颜色，黑色表示黑节点，红色表示红节点： 情形一：兄弟节点是红色的修复方案：父节点和兄弟节点颜色互换，父节点旋转。颜色：父节点变为红色，兄弟节点变为黑色。旋转：向左或者向右旋转父节点，将兄弟节点旋转成祖父节点。 情形二：兄弟节点是黑色的，而且其两个子节点也是黑色的修复方案：兄弟节点设置为红色，并将父节点作为被修复节点从情形一开始循环修复。颜色：仅改变兄弟节点颜色，设置为红色。旋转：不做任何旋转。 情形三：兄弟节点是黑色的，其左子节点是红色的，右子节点是黑色的修复方案：兄弟节点和兄左子节点颜色互换，兄弟节点右旋。颜色：兄弟节点变为红色，兄弟子节点由红变黑。旋转：向右旋转兄弟节点，也就是将兄子节点旋转成兄弟节点。 情形四：兄弟节点是黑色的，其右子节点是红色的修复方案：兄弟节点的右子节点设置为黑色，兄弟节点和父节点颜色互换，父节点左旋。颜色：兄子节点由红变黑，父节点不管是什么颜色都和兄弟节点颜色互换，父节点变成黑色。旋转：父节点旋转，也就是将兄弟节点旋转成父节点。 小结： 不管修复前节点是什么颜色，修复完后必须将被修复节点设置为黑色 上面四种情形顺序执行，只有情形二结束时从父节点开始重新循环修复，情形四结束时退出循环 上面的左右旋转、兄弟左右子节点颜色，因为存在对称关系，所以实际存在 8 种情形 修复所做的旋转不会超过 3 次 如下为红黑树删除动态图，动图生成网址，删除顺序为 12, 1, 9, 2, 0, 11, 7, 19, 4, 15, 18, 5, 14, 13, 10, 16, 6, 3, 8, 17，删除后使用前驱作为替换节点： 删除和修复源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130private void deleteEntry(Entry&lt;K,V&gt; p) &#123; // 1. 找被删节点：p 为被删节点 modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. // 如果被删节点的两个子节点不为空 if (p.left != null &amp;&amp; p.right != null) &#123; // 找到后继节点，并将键值对复制给被删节点 Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; // 被删节点指向后继节点；即后继节点作为新的被删节点 p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. // 2. 找替换节点：替换节点为被删节点子节点 // 默认左子节点，如果左子节点为空，则替换节点为右子节点 Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // 替换节点不为空，先删除再修复 // Link replacement to parent // 替换节点替换被删节点 replacement.parent = p.parent; // 父节点为根节点 if (p.parent == null) root = replacement; // 父节点为左节点 else if (p == p.parent.left) p.parent.left = replacement; // 父节点为右节点 else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. // 被删节点三条链接置空 p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. // 替换节点为空，则先修复再删除 if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125;/** From CLR */private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; // 被修复节点不为根节点并且为黑色时，才需要修复 while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; // 兄弟节点 Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); // 情形一：兄弟节点是红色的 if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; // 情形二：兄弟节点是黑色的，而且其两个子节点也是黑色的 if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; // 情形三：兄弟节点是黑色的，其左子节点是红色的，右子节点是黑色的 if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; // 情形四：兄弟节点是黑色的，其右子节点是红色的 setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; // 被修复节点最终都会被置为黑色 setColor(x, BLACK);&#125; 小结红黑树的插入、删除等算法都比较复杂，但是其带有的优点足以学习并使用它： 红黑树是接近完美平衡的二叉查找树 红黑树的查找，插入，删除等操作，最坏情况下的时间复杂度都能达到 O(logN) 其他 v_JULY_v: 红黑树插入删除全图解 这篇文章在“删除”图示中，删除 12，1 两个节点使用的是前驱作为替换节点，而其他节点使用后继作为替换节点 红黑树的删除依然是使用 case N 大法来分析的，很容易忘记。后期需要找到一种更好的理解方式来学习删除 参考文档 《算法：第四版》 第 3 章 《算法导论》 第 13 章：红黑树 红黑树动画演示 wiki 红黑树 Left-Leaning Red-Black Trees, Dagstuhl Workshop on Data Structures, Wadern, Germany, February, 2008. v_JULY_v: 彻底明白红黑树 v_JULY_v: 教你透彻了解红黑树 v_JULY_v: 红黑树插入删除全图解 平衡查找树之红黑树 CLR: Introduction to Algorithms 算法导论 红黑树画图工具 红黑树详细分析 TreeMap 源码分析 从2-3-4树到红黑树 通过2-3-4树理解红黑树 史上最清晰的红黑树讲解]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 二叉查找树]]></title>
    <url>%2F2018%2F08%2F06%2F0088-algorithms-binary-search-tree%2F</url>
    <content type="text"><![CDATA[算法：二叉查找树。 二叉查找树定义二叉查找树 Binary Search Tree，又称二叉排序树 BST: Binary Sort Tree 、二叉搜索树。二叉查找树：是一颗二叉树，其中每个节点都含有一个 Comparable 的键（以及相关联的值），其中每个节点的键都大于左子树中的任意节点的键，并且小于右子树中的任意节点的键。 数据表示一颗二叉查找树代表了一组键值的集合，而同一个集合可以有多颗不同的二叉查找树表示。但这些二叉查找树在垂直方向上的投影：都是固定顺序的，由小到大的排序顺序。 数据结构解析节点123456789101112private class Node &#123; private Key key; // sorted by key private Value val; // associated data private Node left, right; // left and right subtrees private int size; // number of nodes in subtree public Node(Key key, Value val, int size) &#123; this.key = key; this.val = val; this.size = size; &#125;&#125; 插入 insert插入操作用来构造一颗二叉查找树。 123456789101112131415161718192021public void insert(Key key, Value val)&#123; if(key == null || val == null) return; root = insert(root, key, val);&#125;// 递归算法private Node insert(Node x, Key key, Value val) &#123; // 如果没有查找到 key，则新建节点 if (x == null) return new Node(key, val, 1); // key 和当前节点比较：小则插入左子树，大则插入右子树 // 相等则更新 key 对应的 value int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = insert(x.left, key, val); else if (cmp &gt; 0) x.right = insert(x.right, key, val); else x.val = val; // 更新子树节点数量 x.size = 1 + size(x.left) + size(x.right); return x;&#125; 插入示意图： 查找 find在二叉查找树中，查找指定的关键字。 123456789101112131415public Value find(Key key)&#123; return find(root, key);&#125;// 递归算法private Value find(Node x, Key key) &#123; if (key == null || x == null) return null; // key 和当前节点比较：小则查找左子树，大则查找右子树 // 相等表示查找到 key 对应的 value int cmp = key.compareTo(x.key); if (cmp &lt; 0) return find(x.left, key); else if (cmp &gt; 0) return find(x.right, key); else return x.val;&#125; 查找示意图： 性能分析二叉查找树的算法性能取决于二叉树的形状，而二叉查找树的形状取决于键被插入的先后顺序。最好情况下是完全平衡的二叉树，N 个节点查找的时间复杂度为 logN；最坏情况下时间复杂度会达到 N 。 有序性二叉查找树得到广泛应用的一个重要原因是：始终能保持键的有序性，不管是插入、删除等操作，二叉查找树始终是一个排好序的数据结构。 最大值和最小值 最大值始终在右子树 最小值始终在左子树 123456789101112131415161718192021// 最小值 public Key min() &#123; if (isEmpty()) throw new NoSuchElementException("empty symbol table"); return min(root).key;&#125; private Node min(Node x) &#123; if (x.left == null) return x; else return min(x.left); &#125;// 最大值 public Key max() &#123; if (isEmpty()) throw new NoSuchElementException("empty symbol table"); return max(root).key;&#125; private Node max(Node x) &#123; if (x.right == null) return x; else return max(x.right); &#125; 向上取整和向下取整 向上取整：找到大于等于指定 key 的最小 key 向下取整：找到小于等于指定 key 的最大 key 1234567891011121314151617181920212223242526272829303132333435// 向上取整public Key ceiling(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument is null"); if (isEmpty()) throw new NoSuchElementException("empty symbol table"); Node x = ceiling(root, key); if (x == null) return null; else return x.key;&#125;private Node ceiling(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp == 0) return x; if (cmp &lt; 0) &#123; Node t = ceiling(x.left, key); if (t != null) return t; else return x; &#125; return ceiling(x.right, key); &#125;// 向下取整public Key floor2(Key key) &#123; return floor2(root, key, null);&#125;private Key floor2(Node x, Key key, Key best) &#123; if (x == null) return best; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return floor2(x.left, key, best); else if (cmp &gt; 0) return floor2(x.right, key, x.key); else return x.key;&#125; 向下取整搜索示意图： 选择和排名 选择：找出第 k 个排序位置的键值 排名：给定键值 key 的排序位置 二叉查找树的节点中 size 保存了以该节点为根的子树，一共包含多少子节点（包含自己），计算方式为：size(r) = size(r.left) + size(r.right) + 1;。不管是选择还是排名，都和位置有关系，也就是和节点数有关。所以计算位置时，直接以节点数来判断。 12345678910111213141516171819202122232425262728293031323334353637// 选择 public Key select(int k) &#123; if (k &lt; 0 || k &gt;= size()) &#123; throw new IllegalArgumentException("argument is invalid: " + k); &#125; Node x = select(root, k); return x.key;&#125;// Return key of rank k. private Node select(Node x, int k) &#123; if (x == null) return null; int t = size(x.left); if (t &gt; k) return select(x.left, k); // 选择右子树时，需要扣除左子树中的节点总数 else if (t &lt; k) return select(x.right, k-t-1); else return x; &#125;// 排名 public int rank(Key key) &#123; if (key == null) throw new IllegalArgumentException("argument is null"); return rank(key, root);&#125; // Number of keys in the subtree less than key.private int rank(Key key, Node x) &#123; if (x == null) return 0; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return rank(key, x.left); // 排名右子树时，需要加上左子树的节点总数 else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right); else return size(x.left); &#125; 选择示意图： 删除最大键和最小键 删除最小键最小键的左子树一定为空，右子树可以为空或者非空；删除时将右子树赋给父节点左子树。 删除最大键最大键的右子树一定为空，左子树可以为空或者非空；删除时将左子树赋给父节点右子树。 更新节点数删除键值时，需要注意更新所在子树中每个节点的 size 值。 123456789101112131415161718192021222324252627282930313233// 删除最小值public void deleteMin() &#123; if (isEmpty()) throw new NoSuchElementException("Symbol table null"); root = deleteMin(root);&#125;private Node deleteMin(Node x) &#123; // 如果左子树为空，x 即为最小值，返回其右子树 if (x.left == null) return x.right; // 最小值始终在左子树 // 将找到的最小值节点的右子树赋给父节点左子树 x.left = deleteMin(x.left); // 递归更新节点数 x.size = size(x.left) + size(x.right) + 1; return x;&#125;// 删除最大值public void deleteMax() &#123; if (isEmpty()) throw new NoSuchElementException("Symbol table null"); root = deleteMax(root);&#125;private Node deleteMax(Node x) &#123; // 如果右子树为空，x 即为最大值，返回其左子树 if (x.right == null) return x.left; // 最大值始终在右子树 // 将找到的最大值节点的左子树，赋给父节点右子树 x.right = deleteMax(x.right); // 递归更新节点数 x.size = size(x.left) + size(x.right) + 1; return x;&#125; 删除最小值示意图： 删除指定键值删除最小值或最大值的方法，只适合删除包含一个子节点或没有子节点的节点。但如果一个节点拥有两个子节点，该如何删除？T.Hibbard 在 1962 年提出了解决方案：删除一个节点时，使用其后继节点来填补它的位置。后继节点为其右子树中的最小节点（当然也可以取左子树的最大节点），这样替换后仍能保持二叉查找树的有序性。详细步骤如下： 被删除的节点 x 保存为 t 将 x 赋值为后继节点，即 min(t.right) x 的右子树删除最小值，并更新 x 右子树 x 的左子树保持不变 递归更新子树所有节点数 123456789101112131415161718192021222324252627public void delete(Key key) &#123; if (key == null) throw new IllegalArgumentException("null key"); root = delete(root, key);&#125;private Node delete(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = delete(x.left, key); else if (cmp &gt; 0) x.right = delete(x.right, key); else &#123; if (x.right == null) return x.left; if (x.left == null) return x.right; // 被删除节点保存为 t Node t = x; // 更新值为后继节点 x = min(t.right); // 右子树删除最小值并更新 x.right = deleteMin(t.right); // 左子树保持不变 x.left = t.left; &#125; // 递归更新节点数 x.size = size(x.left) + size(x.right) + 1; return x;&#125; 删除指定键值示意图： 范围查找使用队列保存指定范围内查找到的键值。 123456789101112131415161718192021222324252627// 输出所有键值public Iterable&lt;Key&gt; keys() &#123; if (isEmpty()) return new Queue&lt;Key&gt;(); return keys(min(), max());&#125;// 输出指定范围键值public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123; if (lo == null || hi == null) throw new IllegalArgumentException("key is null"); Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); keys(root, queue, lo, hi); return queue;&#125; private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123; if (x == null) return; int cmplo = lo.compareTo(x.key); int cmphi = hi.compareTo(x.key); // 如果下界比键值小，遍历左子树 if (cmplo &lt; 0) keys(x.left, queue, lo, hi); // 如果键值落入范围，入队 if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.enqueue(x.key); // 如果上界比键值大，遍历右子树 if (cmphi &gt; 0) keys(x.right, queue, lo, hi); &#125; 小结二叉查找树的几个特点： 性能和输入序列顺序高度相关 插入和查找的平均时间复杂度都为 logN 插入、删除等操作，始终能保持键的有序性 参考文档 《算法：第四版》 第 3 章 二叉查找树动画演示]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 优先队列 - 二叉堆]]></title>
    <url>%2F2018%2F08%2F01%2F0087-algorithms-binary-heap%2F</url>
    <content type="text"><![CDATA[算法：优先队列、堆、二叉堆、索引优先队列、堆排序等相关介绍。 基本概念定义优先队列 Priority queue ：是这样一种数据结构，支持删除优先级最高元素和插入元素。通常有两种实现方式： 最大优先队列：支持删除最大元素 最小优先队列：支持删除最小元素 通用 API123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MaxPQ&lt;Key&gt; implements Iterable&lt;Key&gt; &#123; // 存储优先队列的元素 private Key[] pq; // store items at indices 1 to n // 优先队列长度 private int n; // number of items on priority queue // 各种构造方法 public MaxPQ(int initCapacity) &#123;...&#125; public MaxPQ() &#123;...&#125; public MaxPQ(int initCapacity, Comparator&lt;Key&gt; comparator) &#123;...&#125; public MaxPQ(Comparator&lt;Key&gt; comparator) &#123;...&#125; public MaxPQ(Key[] keys) &#123;...&#125; public boolean isEmpty() &#123;...&#125; public int size() &#123;...&#125; // 返回最大元素 public Key max() &#123;...&#125; // 动态调整优先队列数组大小，以 2 的倍数调整 private void resize(int capacity) &#123;...&#125; // 插入元素 public void insert(Key x) &#123;...&#125; // 删除最大元素，并返回最大值 public Key delMax() &#123;...&#125; // 上浮 private void swim(int k) &#123;...&#125; // 下沉 private void sink(int k) &#123;...&#125; /******************************************************************** * Helper functions for compares and swaps. ********************************************************************/ // 最大优先队列和最小优先队列，主要是在比较上返回值相反 private boolean less(int i, int j) &#123; if (comparator == null) &#123; return ((Comparable&lt;Key&gt;) pq[i]).compareTo(pq[j]) &lt; 0; &#125; else &#123; return comparator.compare(pq[i], pq[j]) &lt; 0; &#125; &#125; private void exch(int i, int j) &#123; Key swap = pq[i]; pq[i] = pq[j]; pq[j] = swap; &#125;&#125; 优先队列的初级实现 数组实现无序插入元素：直接插入到数组最后一列；删除最大元素：遍历数组找到最大元素，和最后一列交换后删除它。 数组实现有序插入元素：类似插入排序，将所有较大元素向右移动一格使数组保持有序；删除元素：最大元素总是在数组最右边，直接删除。 链表实现可以基于链表模拟栈操作，pop 找到并返回最大元素并删除；push 保证元素为逆序。 二叉堆堆堆 Heap 是一类特殊的数据结构的统称，堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值 堆总是一棵完全二叉树 堆的定义如下：n 个元素的序列 {K1,K2,Ki,…,Kn} 当且仅当满足下关系时，称之为堆： (Ki &lt;= K2i,ki &lt;= K2i+1) 或者 (Ki &gt;= K2i,Ki &gt;= K2i+1), (i = 1,2,3,4...n/2) 若将和此次序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明：完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列 {K1,K2,…,Kn} 是堆，则堆顶元素（或完全二叉树的根）必为序列中 n 个元素的最小值（或最大值） 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。堆有序：当一颗二叉树的每个节点都大于等于它的两个子节点时，称为堆有序。常见的堆有：二叉堆、二项堆、斐波那契堆。本文重点介绍二叉堆。 二叉堆二叉堆 binary heap 是一种特殊的堆。二叉堆是：完全二叉树或者是近似完全二叉树。二叉堆有两种： 最大堆父结点的键值总是大于或等于任何一个子节点的键值。 最小堆父结点的键值总是小于或等于任何一个子节点的键值。 二叉堆定义：一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组的第一个位置）。二叉堆在数组中的数学性质： 位置为 k 的节点，其父节点位置为向下取整 [k/2] ，其两个子节点位置为 2k,2k+1 位置为 k 的节点，在数组中向上移动一层时，则令 k=2/k；向下移动一层，则令 k=2k 或者 k=2k+1 本文中，默认堆数组的第 0 个元素不保留任何信息，从第 1 个元素开始存储堆元素。 二叉堆有序化二叉堆的插入和删除操作会打破堆的状态，需要遍历整个堆并按照要求将堆的状态恢复，称为堆的有序化。 上浮上浮 swim ：由下至上的堆有序化。如果堆的有序状态因为某个节点变得比它的父节点更大而打破，那么需要交换它和它的父节点来修复堆。但是交换后，该节点可能仍然比父节点大，因此需要重复比较，将这个节点不断的上移，直到找到更大的父节点。这个节点每次都需要上浮到堆的上一层，直到堆恢复有序状态。 123456private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123; exch(k, k/2); k = k/2; &#125;&#125; 下沉下沉 sink ：由上至下的堆有序化。如果堆的有序状态因为某个节点变得比它的两个子节点或者其中一个子节点更小而打破，那么需要交换它和较大子节点来修复堆。同样，交换后该节点可能仍然比子节点或者其中一个子节点小，因此需要重复比较，将这个节点不断的下移，直到找到它的子节点都比它小或者堆的底部。这个节点每次都需要下沉到堆的下一层，直到堆恢复有序状态。 123456789101112private void sink(int k) &#123; while (2*k &lt;= n) &#123; // 找出较大的子节点 int j = 2*k; if (j &lt; n &amp;&amp; less(j, j+1)) j++; // 比较如果节点比较大子节点大，下沉结束 if (!less(k, j)) break; // 否则和较大子节点交换 exch(k, j); k = j; &#125;&#125; 插入和删除最大元素 插入元素将新元素加入到数组末尾，并让这个新元素上浮到合适位置。 删除最大元素从数组顶端删除最大元素（根元素），将数组的最后一个元素放到顶端，并将这个元素下沉到合适位置。 12345678910111213141516171819202122232425262728293031public void insert(Key x) &#123; // double size of array if necessary // 检查优先队列大小，是否需要扩容 if (n == pq.length - 1) resize(2 * pq.length); // add x, and percolate it up to maintain heap invariant // 将新元素加入到数组末尾 pq[++n] = x; // 将新元素上浮到合适位置 swim(n);&#125;public Key delMax() &#123; // 判断优先队列是否为空 if (isEmpty()) throw new NoSuchElementException("Priority queue underflow"); // 删除优先队列顶端元素，并将最后一个元素交换到顶端 Key max = pq[1]; exch(1, n); pq[n] = null; // to avoid loiterig and help with garbage collection // 将顶端元素下沉到合适位置 sink(1); // 调整优先队列大小 if ((n &gt; 0) &amp;&amp; (n == (pq.length - 1) / 4)) resize(pq.length / 2); return max;&#125; 根据上面算法的估算，插入和删除最大元素的时间复杂度都是 O(logN)。 二叉堆构造过程二叉堆的构造过程：逐个插入元素，保持堆的有序状态。 小结可以看出，优先队列在插入元素的过程中，堆始终保持有序状态；删除最大值（最小值），堆仍然有序。优先队列的特点，不需要事先将所有元素读入内存，可以一边读入，一边保持堆有序状态。 索引优先队列意义索引优先队列，首先是一个优先队列，但是又带有索引。索引是用来干什么的呢？我们先回顾下上面介绍的优先队列中，Key[] pq 保存了所有元素，并构成二叉堆，并不方便查找指定元素的位置，或者在指定位置更新元素。索引优先队列，使用数组 Key[] keys 存储元素信息（或其他重要信息），增加一个整型数组 int[] pq 来保存元素下标（即索引），使用索引数组构成二叉堆。这样二叉堆在插入，删除，修改时，仅仅改变的是索引数组，而元素数组并不需要变化（删除元素时置空）。通过索引可以找到元素在堆中的下标，再用这个下标就能访问到元素。 通用 API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class IndexMinPQ&lt;Key extends Comparable&lt;Key&gt;&gt; implements Iterable&lt;Integer&gt; &#123; private int maxN; // maximum number of elements on PQ private int n; // number of elements on PQ // pq 存储元素在 keys 中的下标（即索引），并构成二叉树 private int[] pq; // binary heap using 1-based indexing // qp 存储索引在 pq 中的下标，主要是方便检索 pq。换句话说 // 元素在 keys 中的下标保存在 pq 中 // 元素在 keys 中的下标，在 pq 中的下标，保存在 qp 中 // 某个元素索引满足等式：qp[pq[i]] = pq[qp[i]] = i private int[] qp; // inverse of pq - qp[pq[i]] = pq[qp[i]] = i // Key 可以包含很多信息，可以是自定义类 // 只需要指定排序方式（指定某个属性为优先级，用于排序） // 索引优先队列中 Key[] 并不需要交换，也不会移动数据，只需要比较就行 // 二叉堆建立、插入、删除，都基于索引数组 pq, qp private Key[] keys; // keys[i] = priority of i public IndexMinPQ(int maxN) &#123;...&#125; public boolean isEmpty()&#123;...&#125; public int size() &#123;...&#125; // 索引优先队列，指定索引位置插入元素 public void insert(int i, Key key) &#123;...&#125; // 最小值的索引 public int minIndex() &#123;... return pq[1];&#125; // 最小值元素 public Key minKey() &#123;... return keys[pq[1]];&#125; // 删除最小值 public int delMin() &#123;...&#125; public boolean contains(int i) &#123;...&#125; public Key keyOf(int i) &#123;... return keys[i];&#125; // 指定索引位置，修改元素值 public void changeKey(int i, Key key) &#123;...&#125; public void decreaseKey(int i, Key key) &#123;...&#125; public void increaseKey(int i, Key key) &#123;...&#125; public void delete(int i) &#123;...&#125; /************************************************************* * General helper functions. **************************************************************/ // 本示例介绍的是：索引最小优先队列，所以根存放的是最小值 private boolean greater(int i, int j) &#123; return keys[pq[i]].compareTo(keys[pq[j]]) &gt; 0; &#125; // 仅仅改变索引数组和反向数组 private void exch(int i, int j) &#123; int swap = pq[i]; pq[i] = pq[j]; pq[j] = swap; qp[pq[i]] = i; qp[pq[j]] = j; &#125; /************************************************************** * Heap helper functions. **************************************************************/ // 越小越上浮 private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; greater(k/2, k)) &#123; exch(k, k/2); k = k/2; &#125; &#125; // 越大越下沉 private void sink(int k) &#123; while (2*k &lt;= n) &#123; int j = 2*k; if (j &lt; n &amp;&amp; greater(j, j+1)) j++; if (!greater(k, j)) break; exch(k, j); k = j; &#125; &#125;&#125; 关键算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 插入元素public void insert(int i, Key key) &#123; ... n++; // 反向数组，记录索引在二叉堆的位置 qp[i] = n; // 索引始终加入到二叉堆最后一列 pq[n] = i; // 在指定索引位置添加元素 keys[i] = key; // 上浮到合适位置 swim(n);&#125;// 删除最小值public int delMin() &#123; ... // 最小值始终在二叉堆第一个有效位置 int min = pq[1]; // 二叉堆中最小值和最后一个元素交换 exch(1, n--); // 将交换过来的索引下沉到合适位置 sink(1); assert min == pq[n+1]; // 反向数组，元素数组，对应索引位置置空 qp[min] = -1; // delete keys[min] = null; // to help with garbage collection pq[n+1] = -1; // not needed return min;&#125;// 修改指定索引位置的元素public void changeKey(int i, Key key) &#123; ... // 修改元素值 keys[i] = key; // 这里是否可以优化，先比较 key 是变大还是变小了 // 再来决定是上浮还是下沉 swim(qp[i]); sink(qp[i]);&#125;public void delete(int i) &#123; ... int index = qp[i]; exch(index, n--); swim(index); sink(index); keys[i] = null; qp[i] = -1;&#125; 小结 时间复杂度索引优先队列，不管是插入、删除、修改等，时间复杂度都能控制在 logN，但是需要辅助数组来快速实现。 优点除了能多保存元素信息，索引优先队列还可以更新指定索引的 key 值，这个是普通优先队列无法做到的。通常普通优先队列，对外 API 只包含队列的基本操作，只是在取出元素时，确保每次都是取出的最小值或者最大值。 堆排序定义堆排序 Heap sort：使用堆数据结构设计的一种排序算法，它是选择排序的一种。利用小根堆或者大根堆的特性，每次选出最小值或者最大值来完成排序。堆排序有两个阶段： 堆构造阶段将数据读入后，构造一个堆。堆的特点是，不管什么时候加入新数据，堆都是有序的。 堆下沉阶段（大根堆，由大到小排序）始终从堆中取出最大元素，并得到排序结果。取出最大元素后，堆最后一列元素交换到堆顶，并下沉到合适位置，确保堆保持有序。 动图演示 堆构造-插入法向优先队列一样，逐个插入新元素来构造堆，这个过程时间复杂度为 NlogN 。 堆构造-原地构造（经典算法）现有数组为元素读入顺序，直接在这个数组上构造堆。具体方法：从数组中间位置，从右向左逐个元素 sink 来构造堆，时间复杂度为 N。 堆取出最大值优先队列，逐个取出最大值，实现排序效果。 堆排序经典算法代码示例我们可以使用优先队列，插入元素方法构造堆，删除最大元素方法来实现堆排序。但是我们接下来介绍的是，使用 sink 下沉方法，来原地构造堆和排序，这种算法就是经典的堆排序算法，由 J.W.Williams 发明，并由 R.W.Floyd 在 1964 年改进。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void sort(Comparable[] a) &#123; int n = a.length; // 堆构造 // 核心思路：从数组中间位置，从右向左逐个将元素 sink 来构造堆 // 也就是从最后一个子堆开始，逐个将子堆有序化 // 当到最后一个子堆时，也就是整个堆，下沉第一个元素，确保整个堆有序化 for (int k = n/2; k &gt;= 1; k--) sink(a, k, n); // 堆排序 while (n &gt; 1) &#123; // 核心思路：将最大值交换到数组最后一列 // 将交换到第一个的元素，在剩下的 n-1 个元素中做下沉 // 使得 n-1 个元素的堆恢复到有序状态，即始终确保堆第一个元素为最大值 // 如此反复，直到只剩下第一个元素 // 整个数组变成有序状态 exch(a, 1, n--); sink(a, 1, n); &#125;&#125;private static void sink(Comparable[] a, int k, int n) &#123; while (2*k &lt;= n) &#123; // 找出较大的子节点 int j = 2*k; if (j &lt; n &amp;&amp; less(a, j, j+1)) j++; // 如果比子节点大，跳出 if (!less(a, k, j)) break; // 交换，并循环下沉到合适位置 exch(a, k, j); k = j; &#125;&#125;// 数组从 a[1] 开始为有效元素private static boolean less(Comparable[] a, int i, int j) &#123; return a[i].compareTo(a[j]) &lt; 0;&#125;private static void exch(Object[] a, int i, int j) &#123; Object swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 堆排序静态分解图 堆形态分解轨迹 数组形态分解轨迹 特点经典堆排序算法中： 堆构造只需少于 2N 次比较和 N 次交换 堆排序只需要 2NlogN 次比较和 NlogN 次交换 整个堆排序过程为上述之和 JDK 中的优先队列JDK 中的优先队列源码为 java.util.PriorityQueue.java，默认是最小优先队列（小根堆），如果需要实现最大优先队列，在构造时传入自定义 Comparator 实现大根堆的比较就可以了。 类图结构 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123; private static final int DEFAULT_INITIAL_CAPACITY = 11; // 存储元素数组 transient Object[] queue; // non-private to simplify nested class access // 元素个数 private int size = 0; private final Comparator&lt;? super E&gt; comparator; // 构造方法 public PriorityQueue() &#123;...&#125; public PriorityQueue(int initialCapacity) &#123;...&#125; public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123;...&#125; public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123;...&#125; public PriorityQueue(Collection&lt;? extends E&gt; c) &#123;...&#125; public PriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123;...&#125; public PriorityQueue(SortedSet&lt;? extends E&gt; c) &#123;...&#125; // 优先队列中增加一个元素 public boolean add(E e) &#123;return offer(e);&#125; // 数组最后一列加入新元素，并将新元素上浮到合适位置 public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else siftUp(i, e); return true; &#125; // 取出最小值 public E peek() &#123;return (size == 0) ? null : (E) queue[0];&#125; public boolean remove(Object o) &#123;...&#125; public boolean contains(Object o) &#123;...&#125; public int size() &#123;...&#125; public void clear() &#123;...&#125; // 取出最小值后，将最后一列元素交换并下沉到合适位置 public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result; &#125; private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x); &#125; @SuppressWarnings("unchecked") // 上浮 private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key; &#125; @SuppressWarnings("unchecked") private void siftUpUsingComparator(int k, E x) &#123;...&#125; private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x); &#125; @SuppressWarnings("unchecked") // 下沉 private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = key; &#125; @SuppressWarnings("unchecked") private void siftDownUsingComparator(int k, E x) &#123;...&#125;&#125; 小结PriorityQueue 所有公共接口，几乎和队列保持一致。所以可以参考队列的使用方式，但实际的存储是以堆的形式存在的。 参考文档 《算法：第四版》 第 2 章 visualgo:排序动态演示 usfca:数组原地堆构造 堆的基本概念及操作 索引优先队列的工作原理与简易实现 索引优先队列的原理及实现 Java堆结构PriorityQueue完全解析]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 排序]]></title>
    <url>%2F2018%2F07%2F26%2F0086-algorithms-sorting%2F</url>
    <content type="text"><![CDATA[经典排序算法：选择排序、插入排序、希尔排序、归并排序、冒泡排序、快速排序和堆排序。 通用 API排序算法中的通用 API ： 1234567891011121314151617// 比较并返回较小值private static boolean less(Comparable v, Comparable w) &#123; return v.compareTo(w) &lt; 0;&#125;// is v &lt; w ?private static boolean less(Object v, Object w, Comparator comparator) &#123; return comparator.compare(v, w) &lt; 0;&#125;// 交换数组中第 i 和 j 中的元素// exchange a[i] and a[j]private static void exch(Object[] a, int i, int j) &#123; Object swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 选择排序定义选择排序 Selection sort：遍历数组找到数组中的最小元素，将它和数组中的第一个元素交换位置；其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置；如此反复直到整个数组排完序。核心思路：不断的在数组的剩余元素中找出最小的，所以称为选择排序。 动图演示 代码示例12345678910public static void selection_sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min])) min = j; &#125; exch(a, i, min); &#125;&#125; 特点 时间复杂度根据估算法则，两个嵌套 for 循环，时间复杂度为 O(N²) 。 运行时间和输入无关为了找出最小元素扫描一遍数组并不能为下一次扫描提供任何帮助信息，所以和输入数据的初始状态无关。 数据移动最少在比较时，如果第一个元素就是最小元素也会和自己交换，所以数组中每个元素都会发生一次交换，整个算法交换次数为 N 。 插入排序定义插入排序 Insertion sort：一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序。通常说的插入排序为直接插入排序，其核心思想为：将数组分为两部分，第一个为第一部分，将数组剩余元素划为第二部分。将第二部分中的第一个元素取出，和已经排好序的第一部分比较，插入合适的位置。以此类推，直到最后一个元素插入前面已经排好序的数组中。 动图演示 代码示例12345678public static void insertion_sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) &#123; exch(a, j, j-1); &#125; &#125;&#125; 特点 时间复杂度根据估算法则，两个嵌套 for 循环，时间复杂度为 O(N²) 。 和输入序列高度相关如果输入序列是有序的，或者部分有序的，插入排序将会减少很多次比较和交换。最好情况的完全有序，只需要比较 N-1 次。 排序方式排序通常是从后向前比较，方便数组移动。 适用范围部分有序数组、小规模数组。 希尔排序定义希尔排序 Shell sort：是插入排序的一种，又称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位 希尔排序核心思想：使数组中任意间隔为 h 的元素是有序的，这样的数组称为：h 有序数组。对于任意以 1 结尾的 h 序列，我们都能将数组排序。其中 h 序列的典型序列满足：h=3h+1 (h&lt;n/3)，如：1, 4, 13, 40, 121, 364, 1093, …按照不同步长对元素进行插入排序：当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。下图为 h 序列展示，希尔排序会对每个 h 序列单独排序，直到 h=1。 动图演示 代码示例1234567891011121314151617public static void shell_sort(Comparable[] a) &#123; int n = a.length; // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093, ... int h = 1; while (h &lt; n/3) h = 3*h + 1; while (h &gt;= 1) &#123; // h-sort the array for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125;&#125; 特点 时间复杂度按照 3x+1 递增序列，希尔排序的复杂度能达如下量级。希尔排序比选择排序、插入排序速度快得多，数组越大优势越明显。 适用范围无序数组、中等规模数组。 归并排序定义归并排序 Merge sort：该算法是采用分治法 Divide and Conquer 的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。其递归思路：一个数组可以递归地将它分为两半分别排序，然后将结果归并起来。 动图演示 图解 代码示例有两种实现方式：递归，自顶向下；非递归，自底向上。 自顶向下，递归方法 123456789101112131415161718192021222324252627282930313233343536373839/** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */public static void sort(Comparable[] a) &#123; Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length-1);&#125;// mergesort a[lo..hi] using auxiliary array aux[lo..hi]private static void sort(Comparable[] a,Comparable[] aux,int lo,int hi)&#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; // 递归排序左半部分 sort(a, aux, lo, mid); // 递归排序右半部分 sort(a, aux, mid + 1, hi); // 归并 merge(a, aux, lo, mid, hi);&#125;// 归并过程 private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // copy to aux[] // 辅助数组 for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; // merge back to a[] int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125;&#125; 自底向上，非递归 123456789101112131415161718192021222324252627282930313233/** * Rearranges the array in ascending order, using the natural order. * @param a the array to be sorted */public static void sort(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; for (int len = 1; len &lt; n; len *= 2) &#123; for (int lo = 0; lo &lt; n-len; lo += len+len) &#123; int mid = lo+len-1; int hi = Math.min(lo+len+len-1, n-1); merge(a, aux, lo, mid, hi); &#125; &#125;&#125;private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // copy to aux[] for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; // merge back to a[] int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125;&#125; 特点 时间复杂度根据归并排序的静态分解图可知，归并排序的结构类似一个二叉树，树的高度就是拆分比较的次数 LogN，而归并比较需要 N 次，所以归并排序的时间复杂度为 O(NlogN) 。 冒泡排序定义冒泡排序 Bubble sort：它重复地走访过要排序的元素列，一次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来，重复地进行直到没有相邻元素需要交换。核心思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。 动图演示 代码示例12345678public void sort(int[] a)&#123; int n = a.length; for(int i=n-1; i&gt;=0; i--)&#123; for(int j=1; j&lt;=i; j++)&#123; if(a[j] &lt; a[j-1]) exch(a, j, j-1); &#125; &#125;&#125; 特点 时间复杂度根据估算法则，两个嵌套 for 循环，时间复杂度为 O(N²) 。 和输入序列高度相关 快速排序定义快速排序 Quick sort：是对冒泡排序的一种改进，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序是应用最广泛的排序算法，实现简单且比其他排序算法快的多。 切分切分 partition：快速排序在数据分割时，切分的位置取决于数组的内容。切分整个过程使得数组满足下面三个条件： 对于某个切分 j，a[j] 位置已经排定 a[low] 到 a[j-1] 中的所有元素都不大于 a[j] a[j] 到 a[high] 中的所有元素都不小于 a[j] 切分的策略通常是： 随意地取 a[low] 作为切分元素，该元素将会是被排定的元素 数组从左向右扫描，找到一个大于等于它的元素 a[i] 数组从右向左扫描，找到一个小于等于它的元素 a[j] 如果 i&gt;=j ，表示数组已经有序，退出循环 否则，交换上面两个元素，保证小的元素都在左边，大的元素都在右边 如此反复，直到循环退出后，交换 a[low], a[j] ，并返回 j，切分完毕 动图演示图示快速排序是从左到右扫描，并同时记录下第一个较大元素，和第一个较小元素交换。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// partition the subarray a[lo..hi] so that a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]// and return the index j.private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; // find item on lo to swap while (less(a[++i], v)) &#123; if (i == hi) break; &#125; // find item on hi to swap while (less(v, a[--j])) &#123; if (j == lo) break; // redundant since a[lo] acts as sentinel &#125; // check if pointers cross if (i &gt;= j) break; exch(a, i, j); &#125; // put partitioning item v at a[j] exch(a, lo, j); // now, a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi] return j;&#125;public static void sort(Comparable[] a) &#123; // 随机打乱输入顺序 StdRandom.shuffle(a); // 递归排序 sort(a, 0, a.length - 1);&#125;// 递归实现版本// quicksort the subarray from a[lo] to a[hi]private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi);&#125;// 非递归实现版本 // 使用栈来记录递归过程，这种方法多出一个记录栈，// 而且还需要装箱拆箱，并不是特别好的方法private void sortNonRecur(int[] a, int low, int high)&#123; if(high &lt;= low) return; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); stack.push(high); stack.push(low); int i,j,p; while(!stack.empty())&#123; i = stack.pop(); j = stack.pop(); p = partition(a, i, j); if(p &lt; j)&#123; stack.push(j); stack.push(p+1); &#125; if(p &gt; i)&#123; stack.push(p-1); stack.push(i); &#125; &#125;&#125; 特点 时间复杂度快速排序使用了分治思想 logN，而一次切分比较最多 N 次，所以复杂度估算为 NlogN 。 快速排序和归并排序的异同归并排序为先递归排序再归并；而快速排序为先切分排序再递归。 不适用小数组，通常在快速排序中，如果小数组直接切换为插入排序 快速排序平均时间复杂度推算： 三向切分快速排序对于普通快速排序，如果重复元素很多，这些重复元素的比较和交换都是无任何意义的。三向切分思路是：将数组切分为三部分，分别对应于小于、等于和大于切分元素。 三向切分快速排序实现步骤：从左向右遍历一遍数组，维护一个指针 lt 使得 a[low..lt-1] 中的元素都小于 v，一个指针 gt 使得 a[gt+1..high] 中的元素都大于 v ，一个指针 i 使得 a[lt..i-1] 中的元素都等于 v，a[i..gt] 中的元素未排序，直到 i&gt;gt 即 a[i..gt] 为空，所有元素排序完毕，遍历结束。 指定 a[low] 元素为切分元素 v，i,lt,low 相等同时指向 v gt,high 相等，即 gt 指向数组最后一个元素 如果 a[i] 小于 v，将 a[lt] 和 a[i] 交换，将 lt, i 分别加 1 如果 a[i] 大于 v，将 a[gt] 和 a[i] 交换，将 gt 减 1 如果 a[i] 等于 v，将 i 加 1 对拥有重复元素的数组，三向切分能大大提高排序速度。 12345678910111213141516171819202122232425public static void sort(Comparable[] a) &#123; // 随机打乱输入顺序 StdRandom.shuffle(a); sort(a, 0, a.length - 1);&#125;// quicksort the subarray a[lo .. hi] using 3-way partitioningprivate static void sort3Way(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; // 初始化 lt,gt,i int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo + 1; while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. // 递归调用 sort(a, lo, lt-1); sort(a, gt+1, hi);&#125; 排序算法的稳定性稳定性：如果一个排序算法能够保留数组中的已排好序元素的相对位置则可以被称为稳定的。也就是说排序算法在执行的过程中，对于已经排好序的元素，不会再次打乱，就是稳定的排序算法。 插入排序和归并排序是稳定的；选择排序、希尔排序、快速排序和堆排序都不是稳定的。 稳定性的意义是，可以多键值排序，后面键值的排序不会打乱前面已经排过序的键值。比如一张表先按时间排序，再按名称排序。稳定性算法排完名称后，相同名称的数据，仍然会按照时间排序。 排序算法性能 从图中可以看出，快速排序性能是最优的。JDK 中数组排序使用的是 DualPivotQuicksort.java，后续再介绍这种双轴排序算法。源码可以看出通常当被排序数组很小时，使用插入排序；大数组直接使用快速排序。 参考文档 《算法：第四版》 第 2 章 排序动态演示 快速排序法的平均复杂度为 O(nlogn) 图解排序-归并排序 七种排序介绍 动画详解各种排序]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 数学基础和时间复杂度]]></title>
    <url>%2F2018%2F07%2F21%2F0085-algorithms-complexity%2F</url>
    <content type="text"><![CDATA[算法相关的数学基础，以及时间复杂度的计算方式。 数学基础指数 Exponent指数是幂运算 aⁿ(a≠0) 中的一个参数，a 为底数，n 为指数，指数位于底数的右上角，幂运算表示指数个底数相乘。 对数 Logarithm对数是对求幂的逆运算，用于求解出幂运算中的指数。 在计算机科学中，除非有特别声明，所有的对数都是以 2 为底的，比如 logN 是标准写法。有些计算机相关书籍中提到的 lgN 也是以 2 为底的（这点需要特别注意，并不是数学中的以 10 为底）。 如果 a(a&gt;0，a≠1) 的 b 次幂等于 N，即 aᵇ=N，那么数 b 叫做以 a 为底 N 的对数，记作：logₐN=b，其中 a 叫做对数的底数，N 叫做真数 以 10 为底的对数叫常用对数，记作 log10N，简记为 lgN 以无理数 e(e=2.718 28…) 为底的对数叫做自然对数，记作 logₑN，简记为 lnN 级数 Series 模运算如果 N 整除 A - B，那么我们就说 A 与 B 模 N 同余 congruent，记为 A≡B(mod N)。直观地看，这意味着无论 A 还是 B 被 N 去除，所得余数都是相同的。于是：81≡61≡1(mod 10)。如同等号的情形一样，若 A≡B(mod N)，则 A+C ≡ B+C(mod N) 以及 AD≡BD(mod N) 。 证明方法数学归纳法 Mathematical induction归纳法证明有两个标准部分： 基准情形 base case确定定理对于某个小的值的正确性，这一步通常很简单，只需要验证最小值是否满足定理。 归纳假设 inductive hypothesis假设定理对直到某个有限数 k 的所有情况都是成立的，然后使用这个假设证明：定理对下一个值 k+1 也是成立的。 反证法 Reductio ad absurdum反证法证明是通过假设定理不成立，然后证明该假设导致某个已知的性质不成立，从而证明原假设是错误的。 ![0085-reductio-ad- absurdum.png](https://raw.githubusercontent.com/redspider110/blog-images/master/_images/0085-reductio-ad- absurdum.png) 递归递归的四条基本法则： 基准情形 base case必须要有某些基准情形，它们不需要递归就能求解。 不断推进 making progress对于那些需要递归求解的情形，递归调用必须能够朝着产生基准情形的方向推进。 设计法则 design rule假设所有的递归调用都能运行。 合成效益法则 compound interest rule在求解一个问题的同一个实例时，切勿在不同的递归调用中做重复性的工作。 通常使用数学归纳法来梳理递归的思路。 递归就是方法中调用自己，我们换个思路来理解递归，包含三要素： 递归总有一个最简单的情况。也就是说方法的第一条语句通常是 return 的条件语句 递归总是去尝试一个规模更小的子问题，这样递归才能收敛到最简单的情况 递归调用的父问题和尝试解决的子问题不应该有交集 不等式四个常见定义 如果存在正常数 c 和 n0 使得当 N≥n0 时 T(N)≤cf(N)，则记为 T(N)=Ο(f(N)) 如果存在正常数 c 和 n0 使得当 N≥n0 时 T(N)≥cg(N)，则记为 T(N)=Ω(g(N)) T(N)=Θ(h(N)) 当且仅当 T(N)=Ο(h(N)) 且 T(N)=Ω(h(N)) 如果 T(N)=Ο(p(N)) 且 T(N)≠Θ(p(N))，则 T(N)=ο(p(N)) ΟΩΘο 的读音和意义这四个记号表示的是比较它们的相对增长率 relative rate of growth 。 Ο读作 大O；表示 T(N) 的增长率小于等于 f(N) 的增长率。即最大增长率为 f(N) ，f(N) 是 T(N) 的上界。 Ω读作 omega:[oʊˈmegə]，欧米伽；表示 T(N) 的增长率大于等于 g(N) 的增长率。即最小增长率为 g(N) ，g(N) 是 T(N) 的下界。 Θ读作 theta[ˈθetə, ˈθi-] ；表示 T(N) 和 h(N) 的增长率相等。 ο读作 小ο ；表示 T(N) 的增长率小于 p(N) 的增长率。它不同于 大O，因为 Ο 包含增长率相同的可能性。 ΟΩΘο 统称：渐进符号 Asymptotically notation，在离散数学有详细的介绍，核心是极限的概念。 重要结论为了证明某个函数 T(N)=Ο(f(N)) ，通常不是形式的使用定义，而是使用一些已知结果。也就是锁证明是非常简单的，并不涉及到微积分相关。 如果 T1(N)=O(f(N)) 且 T2(N)=O(g(N))，那么： 12T1(N) + T2(N) = max(O(f(N)), O(g(N)))T1(N) * T2(N) = O(f(N) * g(N)) 如果 T(N) 是一个 k 次多项式，则 T(N)=Θ(Nᵏ) 对任意常数 k，logᵏN=O(N)，它告诉我们对数增长得非常缓慢。 注意事项 关于 大O将常数或低阶项放进 大O 是非常坏的习惯。通常在需要 大O 的任何分析中，需要各种简化：低阶项可以被忽略，常数可以舍弃。此时，要求精度很低。 极限 常见函数增长率 常见函数 数学特征函数图 y 轴为时间图 时间复杂度时间复杂度 Time Complexity：主要关心算法的平均运行时间和最坏情况下的运行时间。D.E.Knuth 认为一个程序运行的总时间主要和两点有关： 执行每条语句的耗时 执行每条语句的频率 每条语句的耗时和操作系统、计算机硬件等都高度相关；所以算法关注的时间复杂度主要是计算执行频率。 示例 时间计算一般法则 法则 1：FOR 循环一次 for 循环的运行时间至多是该 for 循环内语句的运行时间乘以迭代次数。通常为 O(N)。 法则 2：嵌套的 FOR 循环从里到外分析这些循环，在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组所有的 for 循环的大小的乘积。如下面程序为 O(N²) 。 123for(i=0; i&lt;N; i++) for(j=0; j&lt;N; j++) k++; 法则 3：顺序语句将各个语句的运行时间求和，即其中的最大值就是最终的运行时间。第一个 for 循环花费为 O(N)，第二个 for 循环花费为 O(N²)，最终总的开销为最大值 O(N²) 。 12345for(i=0; i&lt;N; i++) A[i] = 0;for(i=0; i&lt;N; i++) for(j=0; j&lt;N; j++) A[i] += A[j] + i + j; 法则 4：IF/ELSE 语句一个 if/else 语句的运行时间，不超过判断再加上 max(S1, S2) 的总运行时间。 1234if(condition) S1;else S2; 对数分析算法时间复杂度最混乱的方面大概集中在对数上面。对数最长出现的规律概括为： 如果一个算法用常数时间 O(1) 将问题的大小消减为其一部分（通常为一半 1/2），那么该算法就是 O(logN)。也就是说，通常的二分法或者对半分治等算法。 如果使用常数时间只是将问题减少一个常数（如将问题减少 1），那么该算法就是 O(N) 常见时间复杂度 典型示例递归转换为 for 循环 最大子序列和的估算与精算 例如：输入整数序列：-2, 11, 8, -4, -1, 16, 5, 0，则输出答案为 35，即从 A2～A6 。根据求和公式，很容易写出代码（简单的扩展求和公式）。 12345678910111213141516int MaxSubsequenceSum(const int A[], int N)&#123; int ThisSum, MaxSum, i, j, k; MaxSum = 0; for(i=0; i&lt;N; i++) for(j=i; j&lt;N; j++) &#123; ThisSum = 0; for(k=i; k&lt;=j; k++) ThisSum += A[k]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; return MaxSum;&#125; 估算上述算法由三重嵌套 for 循环语句组成，根据法则 2，估算出时间复杂度为 O(N³) 。 精确计算精确计算出来的时间复杂度仍然是 O(N³)，所以通常只需要估算，精确的计算往往涉及到复杂的数学运算。 其他数学知识数论基础 约数和倍数整数 a 除以整数 b(b≠0)，除得的商正好是整数而没有余数，我们就说 a 能被 b 整除，或 b 能整除 a。a 称为 b 的倍数，b 称为 a 的约数，约数也称为因数。 最大公约数gcd: greatest common divisor，也称最大公因数、最大公因子：指两个或多个整数共有约数中最大的一个。欧几里得算法：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。gcd(a,b) = gcd(b,a mod b) (不妨设a&gt;b 且r=a mod b ,r不为0) 最小公倍数lcm: least common multiple，两个或多个整数公有的倍数叫做它们的公倍数，除 0 以外最小的一个公倍数就叫做这几个整数的最小公倍数。 质数和合数质数 prime number 又称素数，有无限个。质数：在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数；否则称为合数。判断方法：对正整数 n，如果用 2 到 n 的根号之间的所有整数去除，均无法整除，则 n 为质数。 矩阵乘方只有在第一个矩阵的列数 column 和第二个矩阵的行数 row 相同时才有意义。设 A 为 m × p 的矩阵，B 为 p × n 的矩阵，那么称 m × n 的矩阵 C 为矩阵 A 与 B 的乘积，记作 C=AB，其中矩阵 C 中的第 i 行第 j 列元素可以表示为： 示例： 后续 空间复杂度 一个Java对象到底占用多大内存 参考文档 《数据结构与算法分析：C语言实现》第一、二章 《算法：第四版》 第 1.4 章 知乎：如何理解算法时间复杂度 What is a plain English explanation of “Big O” notation? wiki 时间复杂度 常见算法时间复杂度 上标及下标 Unicode Wiki Unicode 上下标 算法数学基础知识 十分钟搞定时间复杂度 快速排序法的平均复杂度为 O(nlogn)]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>Maths</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 - 数据结构和算法]]></title>
    <url>%2F2018%2F07%2F19%2F0084-algorithms-data-structure%2F</url>
    <content type="text"><![CDATA[介绍算法基础知识，算法书籍推荐等；常见算法分析方法：贪心、分治、动态规划以及摊还分析等；常见数据结构基础介绍。 算法介绍书籍推荐 算法通常说的橙书，指的就是《算法-第四版》，由普林斯顿大学教授 Robert Sedgewick 和 Kevin Wayne 共同编写，使用 Java 实现了教材中的所有算法。官网信息：官网 ，网页包含一部分章节的电子书，以及一些代码链接；算法测试数据集 。代码地址：官网 github 。习题答案：官网课后习题答案 ，知乎关于课后习题答案 。公开课：公开课-1 ，公开课-2 。 算法导论《算法导论》由 Thomas H.Cormen、Charles E.Leiserson、Ronald L.Rivest、Clifford Stein 四人合作编著，通常简称为 CLRs 。所有算法都用伪代码描述，包含大量严格的数学证明。学习资料：网易公开课 ，coursera公开课 。 数据结构与算法分析《数据结构与算法分析：C 语言描述》 由佛罗里达国际大学计算机学院教授 Mark Allen Weiss 编写，C 语言实现的算法。目录结构和国内教材非常类似，适合入门。 学习路线《算法导论》包含了大量数学相关知识，《算法》写的更通俗易懂，推荐先从《算法》开始学习。但是《算法导论》中的算法似乎更通用，《算法》中的算法实现加入了很多作者的优化和想法。知乎高票答案：如何学习数据结构 ，《算法导论》 还是先看完 《算法 第四版》 ，算法的作用。 算法可视化算法通过动画来演示效果，能非常直观的体现算法过程。有两个非常有用的可视化网站： visualgo usfca 算法博客推荐 July七月在线 如果天空不死 nullzx 程序员小灰-算法漫画 subetter 台湾人-演算法筆記 Lucida 算法白板编程 其他可能有用的信息 Matlab 官网 图形化库 jgraphx 图形化库 jgrapht 在线画图工具 计算机推荐书单 算法刷题网站 leetcode lintcode 九章刷题 数据结构和算法我们关注的大多数算法都需要适当地组织数据，而为了组织数据就产生了数据结构，数据结构也是计算机科学研究的核心对象，它和算法的关系非常密切。数据结构是算法的副产品或是结果，因此要理解算法必须学习数据结构。简单的算法也会产生复杂的数据结构，相应地复杂的算法也许只需要简单的数据结构。 算法分析方法贪心贪心算法 greedy algorithms ：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。贪心算法终止时，希望局部最优就是全局最优解；否则算法只能得到次最优解。贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。贪心选择是采用从顶向下、以迭代的方法做出相继选择，每做一次贪心选择就将所求问题简化为一个规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择的性质，我们必须证明每一步所作的贪心选择最终能得到问题的最优解。通常可以首先证明问题的一个整体最优解，是从贪心选择开始的，而且作了贪心选择后，原问题简化为一个规模更小的类似子问题。然后，用数学归纳法证明，通过每一步贪心选择，最终可得到问题的一个整体最优解。 最优子结构当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题。 示例贪心最通用的示例为：找零钱。通常我们都会优先使用大额钞票 50，再其次 20，依次到最小的 1 角；虽然找零钱有各种方式，但是贪心策略能最快得到解。其他常见贪心算法应用：最短路径树 Dijkstra 算法、最小生成树 Prim 算法、最小生成树 Kruskal 算法等。 分治分治 divide and conquer 算法，由两部分组成： 分 divide ：递归解决较小的问题（基本情况除外） 治 conquer ：从子问题的解构建原问题的解 分治算法的基本思想是将一个规模为 N 的问题分解为 K 个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原问题的解。即一种分目标完成程序算法，简单问题可用二分法完成。 分治算法基本上都是递归实现（算法中至少出现两个递归调用才算分治），但是有些递归调用（算法中只有一次递归调用）并不算是分治算法，而只是化简到一个更简单的情况。 分治递归常见的有：二分搜索、树的遍历（左子树、右子树），归并排序，快速排序等。 12345678910// 归并排序示例private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; // 至少有两个递归 sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); merge(a, aux, lo, mid, hi);&#125; 简单递归常见的有：二叉查找树查找算法，并查集查找，图的深度搜索等等，这些算法不是分治算法，只是进行了一次递归调用。 123456789101112// 图的深度搜索private void dfs(Graph G, int v) &#123; count++; marked[v] = true; for (int w : G.adj(v)) &#123; if (!marked[w]) &#123; parent[w] = v; // 仅仅进行一次递归调用 dfs(G, w); &#125; &#125;&#125; 分治算法对应的时间复杂度通常为 O(NlogN) 。 动态规划动态规划 DP: Dynamic Programming 是运筹学的一个分支，是求解决策过程最优化的数学方法。动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。动态规划算法与分治算法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。另外，分治法中使用的递归效率较低，通常会利用动态规划思想将算法写成非递归的方式，并把子问题的答案系统的记录在表中。 摊还分析摊还分析 amortized analysis ：我们求数据结构的一个操作序列中所执行的所有操作的平均时间，来评价操作的代价。即使序列中某个单一操作的代价很高，但是一个操作的平均代价是很低的。摊还分析并不同于平均情况，不涉及概率，可以保证最坏情况下每个操作的平均性能。摊还分析中最常用的三种技术： 聚合分析 aggregate analysis该方法用来确定一个 n 个操作的序列的总代价的上界 T(n)，因此每个操作的平均代价为 T(n)/n 。我们将平均代价作为每个操作的摊还代价，因此所有操作具有相同的摊还代价。 核算法 accounting method用来分析每个操作的摊还代价，当存在不止一种操作时，每种操作的摊还代价可能是不同的。核算法将序列中某些较早的操作的“余额”作为“预付信用”存储起来，与数据结构中的特定对象相关联。在操作序列中随后的部分，存储的信用即可用来为那些缴费少于实际代价的操作支付差额。 势能法 potential method与核算法类似，势能法也是分析每个操作的摊还代价，而且也是通过较早操作的余额来补偿稍后操作的差额。势能法将信用作为数据结构的“势能”存储起来，与核算法不同，它将势能作为一个整体存储，而不是将信用与数据结构中单个对象关联分开储存。 基础数据结构表我们将处理一般的形如 A1, A2, A3, ... , An 的表 list，我们称这个表的大小为 N 。大小为 0 的表为空表 empty list 。对于除空表外的任何表，说 Ai+1 后继 Ai，并称 Ai-1 前驱 Ai 。表支持查找、插入、删除等基本操作。表可以通过简单数组或链表的形式实现。 数组和链表 数组在内存中数组是一块连续的区域，使用前需要预留空间，即使没有利用也会占用内存。不利用扩展，扩容时需要重新申请大数组，并拷贝整个原数组。插入和删除效率低，但是随机访问速度快（下标直接访问）。 链表不要求内存是连续的，每个数据都保存了下一个数据的地址。不用指定大小，方便扩展。插入和删除效率高，但是随机访问效率低，需要逐个数据遍历一遍。 数组和链表是最基本的数据结构，单独或者组合使用，是所有复杂数据结构的数据存储器。 队列和栈 栈特点：LIFO: Last In First Out，后进先出。也就是插入和删除只能在栈顶操作，分别为进栈 Push 和出栈 Pop 。 队列特点：FIFO: First In First Out，先进先出。队列固定在一端进入另一端出去，分别为入队 Enqueue/Offer 和出队 Dequeue/Poll 。 栈和队列都是表，所以都可以通过数组或链表来实现。栈通常用于保存方法调用顺序，逆波兰表达式等等；队列适合任何需要排队实现的应用场景。 树树的基本概念树 Tree ：定义树的一种自然的方式是递归方法，一棵树是一些节点的集合。这个集合可以是空集；若非空，则一棵树由根 root 节点 r 以及 0 个或多个非空子树 T1, T2...Tk 组成，这些子树中每一颗的根都被根 r 的边 edge 连接。 子父节点：每颗子树的根叫做根 r 的儿子 child 或者子节点；而根 r 是每颗子树根的父亲 parent 或者父节点 树叶：每个节点可以有任意多个子节点，也可能是 0 个子节点；没有儿子的节点称为树叶 leaf 兄弟：具有相同父亲的节点称为兄弟 sibling 深度：任意节点的深度 depth 是从根到该节点边的条数。根的深度为 0 高度：树的高度 height 是从根到树叶的最长路径 二叉树二叉树 binary tree 是一棵树，其中每个节点都不能有多于两个的儿子。 二叉查找树二叉查找树 Binary Search Tree，又称二叉排序树 BST: Binary Sort Tree 、二叉搜索树；详解参考：算法 - 二叉查找树 。二叉查找树：是一颗二叉树，其中每个节点都含有一个 Comparable 的键（以及相关联的值），其中每个节点的键都大于左子树中的任意节点的键，并且小于右子树中的任意节点的键。 红黑树红黑树首先是一颗二叉查找树，详解参考：算法 - 红黑树 ；红黑树同时满足 5 条性质： 每个节点要么是红色要么就是黑色 根节点必须是黑色 每个空（NIL）节点必须是黑色 如果节点是红色，它的两个子节点必须是黑色 树是完美黑色平衡的：即任意空 NIL 节点到根节点路径上包含相同数量的黑色节点 其他常见查找树 B 树B 树：B-tree, Balanced tree, 也就是平衡树，也称为 B-, B_ 树，它是一种平衡的多叉树。2-3 树是最简单的 B 树。 B+ 树B+ 树是 B- 树的变体，也是一种多路搜索树。为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引。B+ 树总是到叶子结点才命中，适合文件索引系统。 B* 树B* 树是 B+ 树的变体，为非叶子结点也增加链表指针，提高节点利用率。 图图是一组顶点和一组能够将两个顶点相连的边组成的，详情参考：算法 - 图的基础概念 。四种重要的图模型： 无向图简单连接。无向图是由一组顶点和一组能够将两个顶点相连的边组成的。 有向图连接有方向性。有向图由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。 加权图无向图无向图的每条边，连接带有权值。 加权有向图有向图的每条边，连接既有方向性又带有权值。 常见数据结构散列表也称为哈希表，通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。详情参考：Java HashMap 简介 散列函数散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。 处理冲突散列表解决冲突的两种方式：拉链法和线性探测法。线性探测法的提前条件就是：大小为 M 的数组保存 N 个键值对，其中 M &gt; N，也就是数组要足够大。 优先队列优先队列 Priority queue ：是这样一种数据结构，支持删除优先级最高元素和插入元素。通常有两种实现方式： 最大优先队列支持删除最大元素，也称为大根堆。 最小优先队列支持删除最小元素，也称为小根堆。 优先队列有多种实现方式，常见的有：算法 - 优先队列 - 二叉堆 ，算法 - 优先队列 - 斐波那契堆 。 并查集并查集 Union-Find ，也称为不相交集。一个不相交集合数据结构 disjoint-set data structure 维护了一个不相交动态集的集合 S={S1, S2, S3, ..., Sk}。我们用一个代表 representative 来标识这个集合，它是这个集合的某个成员。详情参考：算法 - 并查集 ；这个数据结构支持下面三个操作： MAKE-SET(x) ：集 UNION(x, y) ：并 FIND-SET(x) ：查 数据结构设计思路 理清需要解决什么问题 设计对应的 API 接口 使用 API 设计测试程序 设计合适的数据结构 使用匹配的算法实现 API 接口设计作用是将使用和实现分离，以实现模块化编程。先定义 API 有两个目标：一是希望测试用例的代码清晰且正确（测试驱动）；二是希望这些操作确实是可以实现的。 参考文档 《算法：第四版》 《算法导论：第 3 版》 《数据结构与算法分析：C 语言描述》]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 语言基础]]></title>
    <url>%2F2018%2F06%2F12%2F0083-java-language-basic%2F</url>
    <content type="text"><![CDATA[Java 语言相关基础知识。 命名规范 驼式命名法类或接口，首字母大写；方法或变量，首字母小写。 常量大写字母和下划线组成，首字母不能是下划线。 原码，补码，反码，移码 正数原码，补码，反码都是相同的。 负数 反码是其绝对值按位取反，补码是反码加 1举例 1 ：[-0]原 = 1 000000，[-0]反 = 1 1111111，[-0]补 = 0 000000举例 2 ：[-1]原 = 1 000001，[-1]反 = 1 1111110，[-1]补 = 1 1111111 移码不管正负数，只要将其补码的符号位取反即可。 浮点数N = 2 ^E * F ，其中 E 为阶码， F 为尾数；阶码使用移码表示，尾数使用原码表示；浮点数运算前会先对阶。 补码快速计算符号位不变其他的从低位开始，直到遇见第一个 1 之前，什么都不变。遇见第一个 1 后保留这个 1 ，以后按位取反。例：[-7]原 = 1 0000111 ，[-7]补= 1 1111001 逻辑运算异或任何数连续两次与另外一个数异或，结果是本身。A ^ B ^ B = A ^ (B ^ B) = A ^ 0 = A 移位运算符 Java 中负数都是按照反码来表示的，移位运算基于值的反码。 规则如果移动的位数超过了该类型的最大位数，那么编译器会对移动的位数取模。如对 int 型移动 33 位，实际上只移动了 33%32=1 位。 &lt;&lt; 左移运算符高位移出舍弃，右边低位补零。如：[2] = 0 0000010，左移 2 位为 [8] = 0 0001000；[-2] = 1 1111110，左移 2 位为 [-8] = 1 1111000；[-127] = 1 0000001，左移 1 位为 [2] = 0 0000010; 也就是负数左移，并不保留符号位，直接舍弃。 &gt;&gt; 右移运算符符号位不变，左边高位补上符号位。如：[4] = 0 0000100，右移 1 位为 [2] = 0 0000010；[-4] = 1 1111100，右移 1 位为 [-2] = 1 1111110； &gt;&gt;&gt; 无符号右移运算符忽略了符号位扩展，最高位补零。无符号右移规则和右移运算是一样的，只是填充时不管左边的数字是正是负都用 0 来填充。[-8] = 1 1111000，右移 2 位为 [-2] = 0 0111110； 意义： Java 中数字二进制比特的最高位为符号位，即 int, long 只能使用 31/63 位来表示取值范围，无符号右移可以将最高位不做符号位来考虑，即变相扩大了数字的取值范围，可以使用 32/64 来表示 int, long，在图像处理，加解密等用的比较多。 作用 乘除在结果没有溢出的前提下：num &lt;&lt; n：表示 num 乘以 2 ^ n；如左移 3 位，表示乘以 8num &gt;&gt; n：表示 num 除以 2 ^ n；如右移 2 位，表示除以 4 截取数字高/低位比如： 1 &lt;&lt; 3 表示，低三位都是 0 ，在按位操作时，截取掉低三位 负数的除法和余数 除法表达式 a/b 的商会向 0 取整。 余数a % b 的余数的定义是 (a/b)*b + a % b 恒等于 a。 示例例如：-14/3 和 14/-3 的商都是 -4；但 -14 % 3 是 -2，而14 % -3 是 2。 数据类型数据类型分类 基本数据类型取值范围 浮点类型特殊数值：+0, -0, NaN(Not a Number), +infinities, -infinities，其中: 1234567891011121314151617181920212223// Float.javapublic static final float POSITIVE_INFINITY = 1.0F / 0.0; // 正无穷public static final float NEGATIVE_INFINITY = -1.0F / 0.0; // 负无穷public static final float NaN = 0.0F / 0.0; // 不定式public static final float MAX_VALUE = 3.4028235E38F; // 最大值public static final float MIN_NORMAL = 1.17549435E-38F; // 最小正规形式正数public static final float MIN_VALUE = 1.4E-45F; // 最小值public static final int MAX_EXPONENT = 127; // 最大指数public static final int MIN_EXPONENT = -126; // 最小指数public static final int SIZE = 32; // 位数public static final int BYTES = 4; // 字节数 // Double.javapublic static final double POSITIVE_INFINITY = 1.0D / 0.0;public static final double NEGATIVE_INFINITY = -1.0D / 0.0;public static final double NaN = 0.0D / 0.0;public static final double MAX_VALUE = 1.7976931348623157E308D;public static final double MIN_NORMAL = 2.2250738585072014E-308D;public static final double MIN_VALUE = 4.9E-324D;public static final int MAX_EXPONENT = 1023;public static final int MIN_EXPONENT = -1022;public static final int SIZE = 64;public static final int BYTES = 8; 包装类Java 为每种基本数据类型分别设计了对应的类，称之为包装类 Wrapper Classes。 8 种基本数据类型及对应的包装类 基本类型 包装类 byte Byte short Short int Integer long Long char Character float Float double Double boolean Boolean 自动装箱和拆箱 自动装箱 Auto Boxing Conversation基本类型自动转换为对应的封装类型（对象）即为自动装箱。 自动拆箱 Unboxing Conversation封装类型自动转换为基本类型为拆箱。 转换过程 装箱：*.valueOf(*) 拆箱：*.intValue() 源码如下，展示了常见的自动装箱和拆箱的用法： 12345678910// 自动装箱Integer i = 1; // 自动拆箱int j = i;List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();// 自动装箱intList.add(1);// 自动拆箱int number = intList.get(0); 经过反编译后，可以明确看到装箱和拆箱的动作： 123456Integer localInteger = Integer.valueOf(1); // 装箱int i = localInteger.intValue(); // 拆箱ArrayList localArrayList = new ArrayList();localArrayList.add(Integer.valueOf(1)); // 装箱int j = ((Integer)localArrayList.get(0)).intValue(); // 拆箱 自动装箱后的比较 因为是对象比较，所以建议直接使用 equal 而不是 == 。 == 比较的是对象的首地址。但是 Java 做了部分优化，在如下范围内使用的是相同的对象（封装类型的缓存），范围外则在装箱的过程中重新生成一个对象。 char[\u0000, \u007f]：即 ASCII 码表中的 128 个字符。 byte/short/int/long[-128, 128)：在 -128 &lt;= x &lt; 128 范围内，共用相同的对象（缓存），即 byte 能够表达的范围。 float/double没有缓存，直接重新生成一个新对象。 12345678910111213141516171819// charCharacter ca = '\u007f', cb = '\u007f';Character cc = '\u0080', cd = '\u0080';System.out.println(ca == cb); //tureSystem.out.println(cc == cd); //false// byte, short, int, long: [-128, 128)Short sa = -128, sb = -128;Short sc = -129, sd = -129;Integer ia = 1, ib = 1;Integer ic = 128, id = 128;Long la = 1L, lb = 1L;Long lc = 128L, ld = 128L;System.out.println(sa == sb); //trueSystem.out.println(sc == sd); //fasleSystem.out.println(ia == ib); //trueSystem.out.println(ic == id); //fasleSystem.out.println(la == lb); //trueSystem.out.println(lc == ld); //false String 的自动拆装箱基本概念：Java 中的 &quot;abc&quot; 对应的实际是常量，存储在常量池中。 1234567891011// 对应的都是常量池中 "abc" 的地址String str1 = "abc";String str2 = "abc";System.out.println(str2==str1); //true System.out.println(str2.equals(str1)); //true // 重新分配了一个对象，所以对象的首地址并不一样String str3 =new String("abc");String str4 =new String("abc"); System.out.println(str3 == str4); //false System.out.println(str3.equals(str4)); //true 注意事项 内存空间自动装箱涉及到重新生成对象，所以频繁大量的使用会创建很多无用的对象，增加 GC 压力，拉低程序的性能。 拆箱空指针异常如果封装类型并没有初始化，在拆箱时会报空指针异常，因为编译过程无法检测到，只能在运行时出现，需要特别注意。 BigInteger/BigDecimal 类型BigInteger/BigDecimal 用于大数操作和高精度计算：BigInteger 操作大整数，BigDecimal 可以指定小数保留位数。它们类似 String，但是它的初始化方式却没有 String 那么方便可以直接赋值，而是跟其他自定义的类一样，要调用它的构造器进行初始化。这个类的取值范围原则上是没有上限的，取决于你的计算机的内存。 12345678public static void main(String[] args)&#123; BigInteger a = new BigInteger("1234567890987654321"); BigInteger b = new BigInteger("8888888888888888888"); String c = a.add(b).toString(); System.out.println("a = " + a.toString()); System.out.println("b = " + b.toString()); System.out.println("a + b = " + c);&#125; 解析：a 和 b 的值刚好可以使用 long 表示，但是相加的结果超出了 long 的范围，而使用 float/double 计算出来精度不够，会在个位数上产生误差。使用 BigInteger 正好解决这个问题。 数据类型和存储存储区：栈和堆 栈内存用于存放基本类型的变量和引用变量。当超过变量的作用域后， Java 会自动释放掉为该变量分配的栈内存空间。 堆内存用于存放由 new 创建的对象和数组。堆中分配的内存由 Java 虚拟机自动垃圾回收器来管理。数组和对象在没有引用变量指向它的时候才变成垃圾，不能再被使用，但是仍然占着内存。在随后的一个不确定的时间被垃圾回收器释放掉，这个也是 Java 比较占内存的主要原因。 数据类型 基本数据类型基本数据类型只涉及一个存储区：是存在栈内存中的，保存的是数据值本身。 引用数据类型涉及到两块存储区：对象本身是存储在堆内存中；引用变量是存储在栈内存中，并存放指向该对象堆内存的首地址。 参数传递形参传递分为：值传递和引用传递。 值传递Java 的基本数据类型都属于值传递，即将栈内存中的数据传递给形参，所以值传递过程中，形参的修改不会影响到实参。String 比较特殊，根据 String 的源码可以认为 String 本身是一个常量，所有的修改都是拷贝生成一个新字符串，所以也属于值传递。 引用传递Java 中所有的对象都是引用传递（除了 String），引用传递实际室传递了引用变量，而该变量指向了对象的堆内存，所以改变引用变量指向对象的值时，实参会跟着改变（实参指向了同一个堆内存）。但是如果重新给引用变量赋值，即重新 new 一个对象或者指向另外一个对象，这时改变引用变量指向对象的值时，实参并不会受到影响（实参指向的堆内存并没有被改变）。 示例说明： 123456789101112131415161718192021222324private MyDataParcelable updateBookOut(MyDataParcelable myDataParcelable)&#123; if(myDataParcelable.getName() == null)&#123; Log.d(TAG, "updateBookOut: It is AIDL type out! Parameter is null!"); // new 一个新的对象 赋值给形参：myDataParcelable myDataParcelable = RandomData.genMyDataParcelable(); &#125; // 新对象对应新的堆内存，所以形参的改变，并不影响实参 return myDataParcelable;&#125;private MyDataParcelable updateBookOut(MyDataParcelable myDataParcelable)&#123; if(myDataParcelable.getName() == null)&#123; Log.d(TAG, "updateBookOut: It is AIDL type out! Parameter is null!"); // 形参指向的堆内存被赋值修改 myDataParcelable.setName("aaa"); MyDataParcelable.Book book = new MyDataParcelable.Book("bbb", 20); List&lt;MyDataParcelable.Book&gt; list = new ArrayList&lt;MyDataParcelable.Book&gt;(); list.add(book); myDataParcelable.setBookList(list); &#125; // 同一块堆内存被修改，所以形参的修改会同步影响到实参 return myDataParcelable;&#125; 数组Java 中二维数组有一下几个约定： 第一维为行数，第二维为列数即对于 int[][] a 中，a.length 为行数，a[0].length 为列数。 数组中默认会将数值型初始化为 0， 布尔型初始化为 false switchswitch 能否作用在 byte 上？能否作用在 long 上，能否作用在 String 上？switch 的表达式数据类型是：整型、字符型和枚举型；可以作用在 byte 上，不可作用域 long 上，Java 7 以后可作用于 String 上。 Log 打印System 打印123System.out.println(""); // 常规换行打印System.err.println(""); // 标红换行打印System.out.print(""); // 常规不换号打印 out 和 err 打印时不在同一个线程执行，所以混合使用它们打印时，时间上并不是顺序打印（看起来是异步在执行）。 堆栈打印打印当前堆栈调用信息：new Exception(&quot;This is a log.&quot;).printStackTrace(System.out);printStackTrace 默认使用的是 System.err 来打印的，如果其他 Log 都是 System.out 输出的，会导致信息看起来像是异步执行。所以要求堆栈也使用 out 打印，即 printStackTrace(System.out) 。 其他try-catch-finallyJava 7 中的新特性，带资源的 try 可以自动 close 实现了 Closeable 的对象。 参考文档 The Java™ Tutorials 官网 Java Language and Virtual Machine Specifications 官网 java浮点类型范围 IEEE_754浮点精度 Java 浮点数的范围和精度]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解解析 -- 处理器解析]]></title>
    <url>%2F2018%2F06%2F05%2F0082-java-annotation-parsing-processor%2F</url>
    <content type="text"><![CDATA[Java 注解的解析有两种方式：反射和注解处理器（APT/JSR 269），本文主要介绍注解处理器解析方式。 解析方式注解处理器解析注解的方式，是在编译期解析的，所以对注解的 Rentention 没有要求（即使 RetentionPolicy.SOURCE 也可以），可以根据编码需求自行设定。 工具属性注解处理器是 javac 的一个工具，它用来在编译时扫描和处理对应注解。一个注解的注解处理器，通常以 Java 代码（或者编译过的字节码）作为输入，生成文件（通常是 .java 文件）作为输出。这些生成的 Java 代码是在新生成的 .java 文件中，所以不能修改已经存在的 Java 类，例如向已有的类中添加方法。这些生成的 .java 文件，会同其他普通的手动编写的 Java 源代码一样被 javac 编译。 独立进程注解处理器是运行它自己的虚拟机 JVM 中的，javac 启动一个完整 Java 虚拟机来运行注解处理器，所以可以把注解处理器库看做一个独立的 Java 项目。 自定义注解处理器流程自定义注解和自定义注解处理器建议分成两个 jar 包，自定义注解处理器仅仅在编译期需要用到，所以工程中不需要将处理器打包到目标代码中。 自定义注解库 Custom Annotation在 AS 中新建 Java 库：File --&gt; New --&gt; New Module --&gt; Java Libary ，新建 myanno 注解库。 Gradle 文件： 12345678910// Java 库apply plugin: 'java-library'dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar'])&#125;// 使用 Java 1.8 来编译sourceCompatibility = "1.8"targetCompatibility = "1.8" 注解源文件： 1234567891011121314151617181920212223// 注解字段@Retention(RetentionPolicy.SOURCE)@Target(ElementType.FIELD)public @interface Field &#123; String value();&#125;// 注解类@Retention(RetentionPolicy.SOURCE)@Target(ElementType.TYPE)public @interface Info &#123; String author(); String date(); int version() default 1; String[] mails();&#125;// 注解任意元素，Java 8 新增@Target(ElementType.TYPE_USE)@Retention(RetentionPolicy.RUNTIME)public @interface AnyAnnotation &#123; String value();&#125; Gradle 中选择该库，编译生成对应的 jar: myanno。 自定义注解处理器 Custom Processor同样，需要新建一个自定义处理器 Java 库：processors。自定义注解处理器有两个步骤： 自定义注解处理器必须继承 AbstractProcessor 库的资源文件夹中添加 javax.annotation.processing.Processor 文件 继承 AbstractProcessor自定义注解处理器必须继承 AbstractProcessor ，使用 @SupportedAnnotationTypes 定义支持解析的注解，并重写 process 处理对应注解。 12345678910@SupportedAnnotationTypes(&#123;"com.ymzs.annotation.Field"&#125;)public class AnnotationParsingProcessor extends AbstractProcessor&#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment) &#123; System.out.println("AnnotationParsingProcessor::process"); return false; &#125;&#125; 添加 javax.annotation.processing.Processor 文件为了将自定义注解处理器注册到 javac 时，必须打包一个特殊的文件 javax.annotation.processing.Processor 到 META-INF/services 目录下。原因见 Java 技术手册。 12345678910111213141516171819202122// 源码目录结构main -java -com -ymzs -parsing -AnnotationParsingProcessor.java -resources -META-INF -services -javax.annotation.processing.Processor// jar 包目录结构processors.jar -com -ymzs -parsing -AnnotationParsingProcessor.class -META-INF -services -javax.annotation.processing.Processor -MANIFEST.MF javax.annotation.processing.Processor 文件的内容是一个列表，每一行对应一个注解处理器的全称。例如： 12com.ymzs.parsing.AnnotationParsingProcessorcom.ymzs.parsing.OtherProcessor Gradle 中选择该库，编译生成对应的 jar: processors。 注解处理器插件在 AS 中使用自定义注解处理器需要添加对应的 gradle 插件： 纯 Java 环境gradle 推荐的注解处理器插件为 net.ltgt.apt：Gradle 官网插件信息 ，插件的开源地址 gradle-apt-plugin， 使用方法参考： dagger, Annotation Processor in IntelliJ and Gradle 。使用该插件时，被注解代码工程的 gradle 文件中需要包含如下信息，关键词 annotationProcessor： 12345678910111213plugins&#123; id 'java-library' // 使用 net.ltgt.apt 插件，版本为最新的 0.15 id "net.ltgt.apt" version "0.15"&#125;dependencies &#123; ... // 自定义注解库 implementation project(":myanno") // 使用自定义注解库解析注解 annotationProcessor project(":processors")&#125; Android 环境Google 在发布 AS 时，开发了对应的 android-gradle-plugin，这是一系列插件包，并包含注解处理器插件：Android 注解处理器插件使用方法 。使用该插件时，被注解代码工程的 gradle 文件中需要包含如下信息，关键词 annotationProcessor： 1234567891011// 使用 android-gradle-plugin 插件中的 application apply plugin: 'com.android.application'dependencies &#123; ... // Custom Annotation and Processor // 自定义注解库 implementation project(":myanno") // 使用自定义处理器库解析注解 annotationProcessor project(":processors")&#125; 结果验证在 Gradle Projects 窗口中，选择需要被注解代码工程，选择 Tasks --&gt; build --&gt; assemble 编译工程，能正确的打印自定义注解处理器中的 Log ： 1234// 代码工程编译期，解析注解:javabase:compileJava// 自定义注解处理器解析注解AnnotationParsingProcessor::process APT 和 JSR269 APTAPT: Annotation-Processing Tool，相关 API 都在 com.sun.mirror 包下。从 Java 7 开始就被降级了，在 Java 8 被彻底移除，APT 移除原因 。 JSR269JSR 269 API: Pluggable Annotation Processing API，相关 API 都在 javax.annotation.processing, javax.lang.model 包下。从 Java 6 开始引入，后续版本逐步代替了 APT。JSR 269 不管是那种 API ，它们都是处理注解的工具，对源代码文件进行检测，并找出对应注解后解析（或生成对应文件）。通常用来简化开发者的工作量，或者生成附属文件。虽然 APT 被移除了，但是因为历史原因，注解处理器还是常用 APT 来称呼。本文都是基于 JSR 269 API 实现的自定义注解处理器。 AnnotatedConstruct 体系类图结构 AnnotatedConstruct 基本类AnnotatedConstruct JavaDoc 12345678910111213141516171819202122232425public interface AnnotatedConstruct &#123; // 返回直接存在于此元素上的注解集合 List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors(); // 返回指定类型的注解 &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; var1); // 返回指定类型注解集合 &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; var1);&#125;// 表示一个注解public interface AnnotationMirror &#123; // 返回注解的类型 DeclaredType getAnnotationType(); // 获取注解的：成员变量名（方法） 和对应的值，放到一个 Map 中 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; getElementValues();&#125;// 表示注解的值public interface AnnotationValue &#123; // 获取注解值 Object getValue(); String toString(); &lt;R, P&gt; R accept(AnnotationValueVisitor&lt;R, P&gt; var1, P var2);&#125; TypeMirror 体系TypeMirror JavaDoc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public enum TypeKind &#123; // 基本数据类型 BOOLEAN, BYTE, SHORT, INT, LONG, CHAR, FLOAT, DOUBLE, VOID, NONE, NULL, ARRAY, // 类或者接口 DECLARED, // 类或接口不能被解析 ERROR, // 类型变量 TYPEVAR, WILDCARD, PACKAGE, // 普通方法，构造方法，或者初始化代码 EXECUTABLE, OTHER, UNION, INTERSECTION; private TypeKind() &#123; &#125; public boolean isPrimitive() &#123; switch(this) &#123; case BOOLEAN: case BYTE: case SHORT: case INT: case LONG: case CHAR: case FLOAT: case DOUBLE: return true; default: return false; &#125; &#125;&#125;// 表示 Java 编译语言中的类型public interface TypeMirror extends AnnotatedConstruct &#123; // 返回类型的具体类别 TypeKind getKind(); boolean equals(Object var1); int hashCode(); String toString(); &lt;R, P&gt; R accept(TypeVisitor&lt;R, P&gt; var1, P var2);&#125;// 相交类型，即使用 &amp; 符号连接的，比如类型变量边界// 1.8 新增public interface IntersectionType extends TypeMirror &#123; // 获取边界列表 List&lt;? extends TypeMirror&gt; getBounds();&#125;// 联合类型，表示多个异常联合在一起，使用 | 连接// 1.7 新增public interface UnionType extends TypeMirror &#123; // 返回异常列表 List&lt;? extends TypeMirror&gt; getAlternatives();&#125;// 可执行类型：方法、构造方法、初始化代码等public interface ExecutableType extends TypeMirror &#123; // 返回类型变量列表 List&lt;? extends TypeVariable&gt; getTypeVariables(); // 返回值类型 TypeMirror getReturnType(); // 参数列表 List&lt;? extends TypeMirror&gt; getParameterTypes(); // 接收者类型 TypeMirror getReceiverType(); // 抛出列表 List&lt;? extends TypeMirror&gt; getThrownTypes();&#125;public interface NoType extends TypeMirror &#123;&#125;public interface PrimitiveType extends TypeMirror &#123;&#125;// 通配符类型public interface WildcardType extends TypeMirror &#123; // 上界 TypeMirror getExtendsBound(); // 下界 TypeMirror getSuperBound();&#125;// 引用类型public interface ReferenceType extends TypeMirror &#123;&#125;public interface ArrayType extends ReferenceType &#123; // 数组原始类型 TypeMirror getComponentType();&#125;public interface NullType extends ReferenceType &#123;&#125;// 类型变量public interface TypeVariable extends ReferenceType &#123; // 类型变量对应的元素 Element asElement(); TypeMirror getUpperBound(); TypeMirror getLowerBound();&#125;// 声明类型，类或者接口，包含泛型。public interface DeclaredType extends ReferenceType &#123; // 对应的元素 Element asElement(); // 获取封装此类型的类型 TypeMirror getEnclosingType(); // 返回泛型的实际类型参数列表：比如 Outer&lt;String&gt;.Inner&lt;Number&gt; List&lt;? extends TypeMirror&gt; getTypeArguments();&#125;public interface ErrorType extends DeclaredType &#123;&#125; Element 体系Element JavaDoc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173// 表示元素类别public enum ElementKind &#123; PACKAGE, ENUM, CLASS, ANNOTATION_TYPE, INTERFACE, ENUM_CONSTANT, FIELD, PARAMETER, LOCAL_VARIABLE, EXCEPTION_PARAMETER, METHOD, CONSTRUCTOR, STATIC_INIT, INSTANCE_INIT, TYPE_PARAMETER, OTHER, RESOURCE_VARIABLE; private ElementKind() &#123; &#125; public boolean isClass() &#123; return this == CLASS || this == ENUM; &#125; public boolean isInterface() &#123; return this == INTERFACE || this == ANNOTATION_TYPE; &#125; public boolean isField() &#123; return this == FIELD || this == ENUM_CONSTANT; &#125;&#125;// 表示元素的修饰符public enum Modifier &#123; PUBLIC, PROTECTED, PRIVATE, ABSTRACT, DEFAULT, STATIC, FINAL, TRANSIENT, VOLATILE, SYNCHRONIZED, NATIVE, STRICTFP; private Modifier() &#123; &#125; public String toString() &#123; return this.name().toLowerCase(Locale.US); &#125;&#125;// 表示内部类类型public enum NestingKind &#123; TOP_LEVEL, MEMBER, LOCAL, ANONYMOUS; private NestingKind() &#123; &#125; public boolean isNested() &#123; return this != TOP_LEVEL; &#125;&#125;// 表示程序任意元素，如：包、类、方法、字段属性、类型变量等public interface Element extends AnnotatedConstruct &#123; // 返回这个元素的类型 TypeMirror asType(); // 返回这个元素的类别 ElementKind getKind(); // 返回修饰符 Set&lt;Modifier&gt; getModifiers(); // 返回简单名称 Name getSimpleName(); // 返回封装此元素的元素，比如类，包等 Element getEnclosingElement(); // 返回此元素封装元素内部的所有子元素， // 如果封装元素是类，则返回类内部定义的所有变量，方法等 List&lt;? extends Element&gt; getEnclosedElements(); boolean equals(Object var1); int hashCode(); // 返回直接存在于此元素上的注解集合 List&lt;? extends AnnotationMirror&gt; getAnnotationMirrors(); // 返回指定类型注解 &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; var1); // 返回指定的结果 &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; var1, P var2);&#125;// 表示包含限定名的能力public interface QualifiedNameable extends Element &#123; // 返回全名称 Name getQualifiedName();&#125;// 表示包元素public interface PackageElement extends Element, QualifiedNameable &#123; Name getQualifiedName(); Name getSimpleName(); List&lt;? extends Element&gt; getEnclosedElements(); // 判断是否为未命名的包 boolean isUnnamed(); Element getEnclosingElement();&#125;// 表示变量元素：字段、常量、参数等public interface VariableElement extends Element &#123; // 返回常量的值，其他变量返回 null Object getConstantValue(); Name getSimpleName(); Element getEnclosingElement();&#125;// 表示泛型，参数化类型元素public interface TypeParameterElement extends Element &#123; // 返回定义此类型变量的类、接口、方法、构造方法等 Element getGenericElement(); // 返回类型变量边界的类型集合 List&lt;? extends TypeMirror&gt; getBounds(); Element getEnclosingElement();&#125;// 表示拥有泛型的能力public interface Parameterizable extends Element &#123; // 返回泛型集合 List&lt;? extends TypeParameterElement&gt; getTypeParameters();&#125;// 表示类或接口的方法、构造方法或初始化程序（静态或实例），包括注解类型元素public interface ExecutableElement extends Element, Parameterizable &#123; List&lt;? extends TypeParameterElement&gt; getTypeParameters(); // 返回值类型 TypeMirror getReturnType(); // 参数列表 List&lt;? extends VariableElement&gt; getParameters(); // 返回接受者类型 TypeMirror getReceiverType(); // 判断是否为可变长参数 boolean isVarArgs(); // 判断是否为接口的 default 方法 boolean isDefault(); // 返回抛出类型集合 List&lt;? extends TypeMirror&gt; getThrownTypes(); // 如果是注解元素，返回其默认值 AnnotationValue getDefaultValue(); Name getSimpleName();&#125;// 表示类或接口元素public interface TypeElement extends Element, Parameterizable, QualifiedNameable &#123; List&lt;? extends Element&gt; getEnclosedElements(); // 返回类的类型，即内部类类型 NestingKind getNestingKind(); Name getQualifiedName(); Name getSimpleName(); // 返回父类的类型 TypeMirror getSuperclass(); // 返回接口的类型集合 List&lt;? extends TypeMirror&gt; getInterfaces(); List&lt;? extends TypeParameterElement&gt; getTypeParameters(); Element getEnclosingElement();&#125; 源代码的每一个部分都是一个特定类型的 Element，也就是说 Element 代表程序的任意元素，例如包、类、方法等。每个 Element 代表一个静态的、语言级别的构件。 12345678910package com.example; // PackageElement public class Foo &#123; // TypeElement private int a; // VariableElement private Foo other; // VariableElement public Foo () &#123;&#125; // ExecuteableElement public void setA ( // ExecuteableElement int newA // TypeElement ) &#123;&#125;&#125; 换个角度来看源代码，它只是结构化的文本，不是可运行的。可以想象它就像要被解析的 XML 文件一样（或者是编译器中抽象的语法树）。就像 XML 解释器一样，有一些类似 DOM 的元素，可以从一个元素导航到它的父或者子元素上。举例来说，假如有一个代表 public class Foo 类的 TypeElement 元素，可以遍历它的所有元素： 1234TypeElement fooClass = ... ; for (Element e : fooClass.getEnclosedElements())&#123; // iterate over children Element parent = e.getEnclosingElement(); // parent == fooClass&#125; Elements 接口用来处理 Element 的工具类，Elements JavaDoc 。 123456789101112131415161718192021222324252627282930public interface Elements &#123; // 返回全限定名的包元素 PackageElement getPackageElement(CharSequence name); // 返回类或接口元素 TypeElement getTypeElement(CharSequence name); // 获取注解的：成员变量名（方法） 和对应的值，放到一个 Map 中 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; getElementValuesWithDefaults(AnnotationMirror var1); // 返回元素的 Javadoc 文档 String getDocComment(Element var1); boolean isDeprecated(Element var1); // 返回元素的二进制名称 Name getBinaryName(TypeElement var1); // 返回元素的包元素 PackageElement getPackageOf(Element var1); // 返回元素的所有成员 List&lt;? extends Element&gt; getAllMembers(TypeElement var1); // 返回元素的所有注解列表 List&lt;? extends AnnotationMirror&gt; getAllAnnotationMirrors(Element var1); // 判断元素是否隐藏了另外一个元素 boolean hides(Element hider, Element hidden); // 判断给定元素的方法，是否被重写 boolean overrides(ExecutableElement overrider, ExecutableElement overridden, TypeElement type); // 常量值转换为字符串 String getConstantExpression(Object var1); void printElements(Writer var1, Element... var2); Name getName(CharSequence var1); boolean isFunctionalInterface(TypeElement var1);&#125; Types 接口用来处理 TypeMirror 的工具类，Types JavaDoc 。 123456789101112131415161718192021222324252627282930313233343536public interface Types &#123; // 返回类型对应的元素 Element asElement(TypeMirror var1); boolean isSameType(TypeMirror var1, TypeMirror var2); boolean isSubtype(TypeMirror var1, TypeMirror var2); // 判断类型是否可以指派给另外一种类型 boolean isAssignable(TypeMirror var1, TypeMirror var2); boolean contains(TypeMirror var1, TypeMirror var2); // 测试方法的签名是否为另一个方法的子签名 boolean isSubsignature(ExecutableType var1, ExecutableType var2); // 返回直接超类型列表，接口排在最后 List&lt;? extends TypeMirror&gt; directSupertypes(TypeMirror var1); // 类型擦除后的类型 TypeMirror erasure(TypeMirror var1); // 基本类型的封装类型，类型装箱 TypeElement boxedClass(PrimitiveType var1); // 类型拆箱 PrimitiveType unboxedType(TypeMirror var1); // 参数化类型转换 TypeMirror capture(TypeMirror var1); PrimitiveType getPrimitiveType(TypeKind var1); NullType getNullType(); NoType getNoType(TypeKind var1); ArrayType getArrayType(TypeMirror var1); // 根据指定上界或下界，返回通配符类型 WildcardType getWildcardType(TypeMirror extendsBound, TypeMirror superBound); // 返回元素和指定类型的泛型 DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs); // 根据给定的包含类型，返回元素和指定类型的泛型 DeclaredType getDeclaredType(DeclaredType containing, TypeElement typeElem, TypeMirror... typeArgs); // 如果指定元素是指定类型的成员，则返回其类型 TypeMirror asMemberOf(DeclaredType containing, Element element);&#125; Filer 接口用来创建文件，Filer JavaDoc 。 12345678910public interface Filer &#123; JavaFileObject createSourceFile(CharSequence var1, Element... var2) throws IOException; JavaFileObject createClassFile(CharSequence var1, Element... var2) throws IOException; FileObject createResource(Location var1, CharSequence var2, CharSequence var3, Element... var4) throws IOException; FileObject getResource(Location var1, CharSequence var2, CharSequence var3) throws IOException;&#125; Messager 接口提供给注解处理器一个报告错误、警告以及提示信息的途径。Messager JavaDoc , 消息级别 Diagnostic.Kind 。因为注解处理器是在独立的 java 虚拟机运行，所以注解处理器中不能直接进行异常抛出，否则进程异常崩溃时，会弹出一大堆让人捉摸不清的堆栈调用日志显示，也就是目标工程报的错误来自于另外一个虚拟机的堆栈。通常使用 Messager 来写一些信息给使用此注解器的第三方开发者的。在官方文档中描述了消息的不同级别，非常重要的是 Kind.ERROR，因为这种类型的信息用来表示我们的注解处理器处理失败了，很有可能是第三方开发者错误的使用了注解。 123456789// 打印信息public interface Messager &#123; void printMessage(Kind var1, CharSequence var2); void printMessage(Kind var1, CharSequence var2, Element var3); void printMessage(Kind var1, CharSequence var2, Element var3, AnnotationMirror var4); void printMessage(Kind var1, CharSequence var2, Element var3, AnnotationMirror var4, AnnotationValue var5);&#125; AbstractProcessor 详细分析自定义处理器通常会继承 AbstractProcessor，并重写对应方法，来实现自定义注解的解析。所有的注解处理器类都必须有一个无参构造函数，否则执行时会报错。对应源码文件目录：src\javax\annotation\processing 类图结构 常用 API 介绍12345678910111213141516171819202122232425262728293031323334public interface Processor &#123; Set&lt;String&gt; getSupportedOptions(); // 必须指定：表示当前注解处理器支持哪些注解 // 返回值是一个字符串的集合，字符串为注解类型的合法全称 // 比如：Field.class.getCanonicalName()，或者 com.xxx.Field Set&lt;String&gt; getSupportedAnnotationTypes(); // 指定使用的 Java 版本，默认返回 SourceVersion.RELEASE_6 // 通常使用最新版本作为返回值：SourceVersion.latestSupported() SourceVersion getSupportedSourceVersion(); // 注解处理器运行的第一个方法，初始化环境 void init(ProcessingEnvironment processingEnv); // 注解处理器解析注解的入口 boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv); // Iterable&lt;? extends Completion&gt; getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText);&#125;// AbstractProcessor 实现了 Processor 大部分接口// 只有 process 是抽象的，需要子类去实现public abstract class AbstractProcessor implements Processor &#123; ... public abstract boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv); ...&#125; 两个有用的注解 @SupportedAnnotationTypes表示当前类支持的注解的完整类路径，支持通配符。当前 Processor 要处理的 Annotation 名字全称。等同于 getSupportedAnnotationTypes() ，支持通配符，使用 * 表示支持所有注解。 @SupportedSourceVersion表示该处理器支持的源码版本。等同于 getSupportedSourceVersion() 。 循环调用 processprocess 通常会被执行两次：根据 Log 可以发现，process 的返回值不管是 true/false 都会被执行两次？但是解析注解时，只有第一次执行 process 时，roundEnvironment.getElementsAnnotatedWith 才能获取到注解。具体原因参考 Processor JavaDoc 。官方文档中第一段就介绍了，注解处理器是个循环处理的过程，每次循环都会解析上次处理器产生的源文件。也就是说第一次 process 处理了编写的源文件，第二次处理了注解处理器生成的源文件（此时已经不包含被处理的注解了），直到所有支持的注解都被解析完毕。 存在的问题不管是使用 @SupportedAnnotationTypes 还是重写 getSupportedAnnotationTypes() ，只要支持注解包其中一个注解，注解处理器就能解析该包中的所有其他注解。 1234// Java library: myanno@Info@Field@AnyAnnotation 注解包 myanno 包含三个注解，但是在自定义注解器中，代码中规定只支持 Field 注解，自定义注解器仍然能解析 Info, AnyAnnotation ？ 注解处理器插件 gradle-apt-pluginJava 环境下注解插件，使用方法： 123456789plugins&#123; id "net.ltgt.apt" version "0.15"&#125;dependencies &#123; // 本地注解库 annotationProcessor project(":processors") // 引用网络开源注解库 annotationProcessor "com.custom:CustomProcessors:version1.2.3" &#125; android-aptAndroid 注解器框架，现在已经不再维护。 annotationProcessorAndroid Plugin for Gradle，google 为 gradle 开发的注解处理器框架，用于替换 android-apt。使用方法： 1234// 本地注解库annotationProcessor ":customProcessors"// 引用网络开源注解库annotationProcessor "com.custom:CustomProcessors:version1.2.3" 常用开源库 AutoService 官网自动生成 javax.annotation.processing.Processor 文件，并将自定义注解处理器按照规范加入该文件。 JavaPoet 官网生成 .java 源文件的 API 接口，非常强大实用。解析自定义注解时，可以使用 JavaPoet 来生成对应文件。 AutoService 用法 build.gradle 文件中添加依赖implementation &#39;com.google.auto.service:auto-service:1.0-rc4&#39; 具体版本号，到 github 官网上查看。 自定义注解处理器类上添加 AutoService 注解在自定义处理器类上，添加 @AutoService(Processor.class) 注解。该注解会自动生成对应的 META-INF/services/javax.annotation.processing.Processor 文件，并将自定义注解处理器按照规范加入该文件。 JavaPoet 用法 自定义注解之编译时注解-JavaPoet JavaPoet 看这一篇就够了 JavaPoet解放双手 其他调试注解处理器 如何调试编译时注解处理器 常用场景大量开源库都使用了注解处理器简化代码： ButterKnife Dagger2 Retrofit 参考文档 Java 注解处理器 Annotation Processing 101 AnnotatedConstruct 常用接口介绍 如何调试编译时注解处理器 APT 移除原因 JSR 269 Annotation 原理到案例 自定义注解之编译时注解 javax.annotation.processing.Processor 文件 Java 技术手册 Gradle 官网 Java apt 插件信息 gradle-apt-plugin Annotation Processor in IntelliJ and Gradle Android 注解处理器插件使用方法 Android 打造编译时注解解析框架 Android 注解使用之 annotationProcessor AutoService 官网 JavaPoet 官网 几个注解处理器名称]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解解析 -- 反射]]></title>
    <url>%2F2018%2F05%2F29%2F0081-java-annotation-parsing-reflect%2F</url>
    <content type="text"><![CDATA[Java 注解的解析有两种方式：反射和注释处理器（APT/JSR 269）。 本文主要介绍通过反射来解析注解，它是在运行时解析的，所以反射要求注解必须是 @Retention(RetentionPolicy.RUNTIME) 类型的。在 .class 文件和 JVM 中都会保留注解信息，运行时才能通过反射来获取并解析注解。但是反射比较慢，所以需要考虑效率问题。 注解体系所有的注解都是 Annotation 的子接口，类中所有的元素都是 AnnotatedElement 的实现。 源码分析12345678910111213141516171819202122232425262728293031// 所有注解的父接口public interface Annotation &#123; boolean equals(Object obj); int hashCode(); String toString(); // 返回注解自身的类型，如：interface com.***.CustomAnnotation Class&lt;? extends Annotation&gt; annotationType();&#125;// 被注解元素public interface AnnotatedElement &#123; // 判断指定类型注解是否存在 default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;...&#125; // 返回指定类型注解，包含父类 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass); // 返回所有注解 Annotation[] getAnnotations(); // 返回指定类型的注解数组，包含父类中的 default &lt;T extends Annotation&gt; T[] getAnnotationsByType (Class&lt;T&gt; annotationClass) &#123;...&#125; // 返回当前元素上指定类型的注解 default &lt;T extends Annotation&gt; T getDeclaredAnnotation (Class&lt;T&gt; annotationClass) &#123;...&#125; // 返回当前元素上指定类型的注解数组 default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType (Class&lt;T&gt; annotationClass) &#123;...&#125; // 返回当前元素上注解的数组 Annotation[] getDeclaredAnnotations();&#125; 类图结构 注解的本质 注解的位置只能放到类型前面，不能放到变量名，方法名之前。 注解是接口注解使用关键字 @interface 来表示，实际上它也的确是接口。 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface BindView &#123; int value();&#125; BindView 用来注解字段，并且在运行时也保留了注解信息。反编译结果如下： 1234567891011121314151617xmt@server005:~/annotation$ javap -v -c BindView.class...// 反编译发现注解实际就是一个接口文件，并继承了 Annotationpublic interface BindView extends java.lang.annotation.Annotation SourceFile: "BindView.java" RuntimeVisibleAnnotations: 0: #9(#4=e#10.#11) 1: #12(#4=[e#13.#14]) minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT, ACC_ANNOTATIONConstant pool: ...&#123; public abstract int value(); flags: ACC_PUBLIC, ACC_ABSTRACT&#125; 反编译后发现所有的注解实际是接口，并且继承了 Annotation。所以使用反射解析注解时，可以使用父接口 Annotation 来表示任意注解类型。 注解在 class 文件中自定义注解如果标注为 CLASS, RUNTIME，表示会在 class 文件中保留注解信息。 1234public class TestAnnotation&#123; @BindView(2) public int i;&#125; 测试类中使用 @BindView 注解整型变量 i，反编译结果： 1234567891011121314151617181920xmt@server005:~/annotation$ javap -v -c TestAnnotation...public class TestAnnotation SourceFile: "TestAnnotation.java" minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: ... #7 = Utf8 LBindView; #8 = Utf8 value #9 = Integer 2 ...&#123; public int i; flags: ACC_PUBLIC RuntimeVisibleAnnotations: 0: #7(#8=I#9) ...&#125; 反编译后发现，变量 i 中保留了一个 RuntimeVisibleAnnotations 标记。后续反射解析时，就是通过这个标记来获取相关注解的。 AnnotatedType 体系介绍AnnotatedType 体系是 Java 8 新加的，是泛型 Type 体系对应的被注解类型。AnnotatedType 既能获取被注解元素的类型，也能获取该元素上的注解数组。示例：@CustomAnnotation(&quot;value&quot;) CustomClass AnnotatedType.getType被注解元素的类型，即 CustomClass 。 AnnotatedElement.getAnnotations该元素上的注解数组，即 {CustomAnnotation} 。 AnnotatedType 类型并不是一定会有注解，只是代表拥有被注解的能力。比如 int i ，AnnotatedType 仅仅代表整型 int，而它并没有被注解。 源码分析123456789101112131415161718192021222324252627282930313233// 被注解类型 public interface AnnotatedType extends AnnotatedElement &#123; // 返回被注解元素的具体类型，如 CustomClass public Type getType();&#125;// 被注解的类型变量 public interface AnnotatedTypeVariable extends AnnotatedType &#123; // 返回被注解类型变量边界数组 AnnotatedType[] getAnnotatedBounds();&#125;// 代表被注解的成员是数组，必须递归解析，每次只能拿到第一维数组的注解public interface AnnotatedArrayType extends AnnotatedType &#123; // 返回被注解元素的数组元素类型 // 返回值可能还是 AnnotatedArrayType , 所以需要递归解析 // 比如 boolean[][][] 三维数组，返回值为 boolean[][] AnnotatedType getAnnotatedGenericComponentType();&#125;// 被注解泛型通配符类型public interface AnnotatedWildcardType extends AnnotatedType &#123; // 被注解泛型通配符下界 AnnotatedType[] getAnnotatedLowerBounds(); // 被注解泛型通配符上界 AnnotatedType[] getAnnotatedUpperBounds();&#125;// 被注解参数化类型public interface AnnotatedParameterizedType extends AnnotatedType &#123; // 被注解参数化类型数组，即泛型参数列表数组 AnnotatedType[] getAnnotatedActualTypeArguments();&#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243// 声明了两个类型变量 S, T，其中 S 的边界是多限定// 继承父类 Thread// 实现了接口 Runnable, Cloneable, Serializablepublic class TestGenericAnnotation&lt; @AnyAnnotation("classTypeParameter") S extends Number &amp; @AnyAnnotation("classTypeParameterBounds") Comparable, T extends Cloneable, U&gt; extends @AnyAnnotation("extends") Thread implements @AnyAnnotation("implements1") Runnable, Cloneable, @AnyAnnotation("implements2") Serializable &#123; // 字段属性注释的标准写法 @AnyAnnotation("field") public boolean typeAnnotatedBoolean; public @AnyAnnotation("array4") boolean @AnyAnnotation("array1") [] @AnyAnnotation("array2") [] @AnyAnnotation("array3") [] typeAnnotatedArray; public @AnyAnnotation("typeVariable") S s; public @AnyAnnotation("beforeType") int array[]; // 泛型字段 public @AnyAnnotation("map1") Map&lt; @AnyAnnotation("map2") ? extends @AnyAnnotation("map3") String, @AnyAnnotation("map4") List&lt;@AnyAnnotation("map5") Object&gt;&gt; typeAnnotatedMap; // 方法注释的标准写法 @AnyAnnotation("return") public &lt;@AnyAnnotation("methodTypeParameter") U, V&gt; Class&lt;?&gt; typeAnnotatedMethod( @AnyAnnotation("formalParameter") TestGenericAnnotation arg) throws @AnyAnnotation("throwException") ClassNotFoundException &#123; // 方法中的局部变量注解无法通过反射来解析，只能在编译前解析 @AnyAnnotation("local_variable_type") int foo = 0; throw new ClassNotFoundException(); &#125;&#125; 反射解析注解动态代理反射解析注解都使用的是动态代理技术访问注解的键值对，解析类源码文件：AnnotationParser.java, AnnotationInvocationHandler.java 12345678910111213141516171819202122public class AnnotationParser &#123; // 解析注解，并将注解作为键值对返回 public static Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations(byte[] rawAnnotations, ConstantPool constPool , Class&lt;?&gt; container) &#123;...&#125; // 最终都是通过 annotationForMap 来生成注解 // 使用了动态代理来访问原始注解 public static Annotation annotationForMap( final Class&lt;? extends Annotation&gt; type, final Map&lt;String, Object&gt; memberValues)&#123; return AccessController.doPrivileged(new PrivilegedAction&lt;Annotation&gt;()&#123; public Annotation run() &#123; return (Annotation) Proxy.newProxyInstance( type.getClassLoader(), new Class&lt;?&gt;[] &#123; type &#125;, new AnnotationInvocationHandler(type, memberValues)); &#125;&#125;); &#125; ...&#125; 测试代码打印反射获取的 Annotation 类类型： 123456789// 测试代码Annotation[] annotations = TestAnnotation.class.getDeclaredAnnotations();for (Annotation annotation : annotations)&#123; System.out.println(annotation.getClass());&#125;// 测试结果输出class com.sun.proxy.$Proxy1class com.sun.proxy.$Proxy3 从输出结果可以看出，反射获取的 Annotation 类类型都是动态代理生成新类的类名。 常规解析被注解的的类： 12345678910111213141516171819202122232425262728293031323334@MetaAnnotation( author = "xmt", date = "2018.4.27", currentVersion = 2, reviewer = &#123;"a", "b", "c"&#125;)@Roles(value = &#123;@Role(name = "doctor"), @Role(name = "police")&#125;)public class TestAnnotation &#123; @BindView(2) public String view; private int count; @Creatable public TestAnnotation()&#123; &#125; public TestAnnotation(int i)&#123; count = i; &#125; /** * This is testable method. */ @Testable public void testJavaDoc()&#123; System.out.println("Annotation viewValue = " + view); &#125; private void testAnnotationMethod()&#123; &#125;&#125; 注解反射解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122public class TestAnnotationParsingReflect &#123; private Class&lt;?&gt; clazz = TestAnnotation.class; private Object testAnnotation = null; // 反射解析类 private void parsingClass()&#123; // 获取当前类上的注解 Annotation[] annotations = clazz.getDeclaredAnnotations(); for (Annotation annotation : annotations)&#123; // 解析自定义的 MetaAnnotation 注解 if (annotation instanceof MetaAnnotation)&#123; MetaAnnotation metaAnnotation = (MetaAnnotation) annotation; System.out.println("author: " + metaAnnotation.author()); System.out.println("date: " + metaAnnotation.date()); System.out.println("currentVersion: " + metaAnnotation.currentVersion()); StringBuilder builder = new StringBuilder(); for (String s : metaAnnotation.reviewer())&#123; builder.append(s); builder.append(" "); &#125; System.out.println("reviewer: " + builder.toString()); // 解析自定义 Roles 注解 &#125;else if (annotation instanceof Roles)&#123; Roles roles = (Roles) annotation; // 重复注解的解析 for ( Role role : roles.value())&#123; System.out.println("name: " + role.name()); &#125; &#125; &#125; &#125; // 解析构造方法上的注解 private void parsingConstructor()&#123; // 获取当前类中的构造方法 Constructor[] constructors = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors)&#123; // 获取每个构造方法上的注解 Annotation[] annotations = constructor.getDeclaredAnnotations(); for (Annotation annotation : annotations)&#123; // 解析自定义 Creatable 注解 if (annotation instanceof Creatable)&#123; try &#123; // 如果被 Creatable 注解过的构造方法 // 自动实例化一个对象 testAnnotation = constructor.newInstance(null); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; // 解析属性上的注解 private void parsingField()&#123; // 获取当前类中的属性字段 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields)&#123; // 获取每个字段上的注解 Annotation[] annotations = field.getDeclaredAnnotations(); for (Annotation annotation : annotations)&#123; // 解析自定义 BindView 注解 if (annotation instanceof BindView)&#123; if (testAnnotation != null)&#123; int value = ((BindView) annotation).value(); try &#123; // 如果被 BindView 注解的字段 // 将注解的成员变量值赋值给该字段 field.set(testAnnotation, String.valueOf(value)); System.out.println("set testAnnotation." + field.getName() + " = " + value); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; // 解析普通方法上的注解 private void parsingMethod()&#123; // 获取当前类中的普通方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods)&#123; // 获取该方法上的注解 Annotation[] annotations = method.getDeclaredAnnotations(); for (Annotation annotation : annotations)&#123; // 解析自定义 Testable 注解 if (annotation instanceof Testable)&#123; if (testAnnotation != null)&#123; try &#123; // 如果被 Testable 注解 // 自动调用该方法 method.invoke(testAnnotation, null); System.out.println("invoke testAnnotation." + method.getName()); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; TestAnnotationParsingReflect reflect = new TestAnnotationParsingReflect(); reflect.parsingClass(); reflect.parsingConstructor(); reflect.parsingField(); reflect.parsingMethod(); &#125;&#125; AnnotatedType 体系解析AnnotatedType 是 Java 8 新增加强型注解，可以注解到任意代码位置，如下示例为解析 TestGenericAnnotation 类中的所有注解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public class TestGenericAnnotationParsingReflect &#123; // 被解析的类为 TestGenericAnnotation private Class&lt;?&gt; clazz = TestGenericAnnotation.class; // 解析类上的注解 private void parsingClass()&#123; // 解析类型变量列表 TypeVariable&lt;?&gt;[] typeVariables = clazz.getTypeParameters(); if (typeVariables != null &amp;&amp; typeVariables.length &gt; 0) &#123; for (int i = 0; i &lt; typeVariables.length; i++) &#123; // 获取类型变量的注解数组，遍历解析 Annotation[] annotations = typeVariables[i].getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println("Annotation: " + annotation); &#125; // 获取类型变量的边界数组 AnnotatedType[] annotatedBounds = typeVariables[i].getAnnotatedBounds(); // default extends Object, so it's always true. if (annotatedBounds != null &amp;&amp; annotatedBounds.length &gt; 0 )&#123; for (int j = 0; j &lt; annotatedBounds.length; j++)&#123; System.out.println("TypeVariable bounds: " + annotatedBounds[j].getType()); String boundName = annotatedBounds[j].getType().getTypeName(); // 边界不是 Object，即显示指定了类型变量边界 if (!boundName.equals(Object.class.getTypeName()))&#123; // 获取每个边界的注解数组 Annotation[] annotations1 = annotatedBounds[j].getAnnotations(); // 遍历解析边界的所有注解 for (Annotation annotation : annotations1) &#123; System.out.println("Annotation: " + annotation); &#125; &#125; &#125; &#125; &#125; &#125; // 解析当前类继承的父类 Class&lt;?&gt; superClass = clazz.getSuperclass(); // 确保父类不是 Object，即显示指定了 extends 父类 if (superClass != null &amp;&amp; superClass != Object.class)&#123; System.out.println("Super Class: " + superClass.getSimpleName()); // 获取父类的被注解类型 AnnotatedType annotatedSuperclass = clazz.getAnnotatedSuperclass(); if (annotatedSuperclass != null) &#123; // 获取父类上的注解数组，并遍历解析 Annotation[] annotations = annotatedSuperclass.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println("Annotation: " + annotation); &#125; &#125; &#125; // 解析当前类实现的接口数组 //Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); AnnotatedType[] annotatedTypes = clazz.getAnnotatedInterfaces(); if (annotatedTypes != null &amp;&amp; annotatedTypes.length &gt; 0) &#123; for (int i = 0; i &lt; annotatedTypes.length; i++) &#123; // 接口名称 String interfaceName = annotatedTypes[i].getType().getTypeName(); System.out.println("Implements interface: " + interfaceName); // 获取每个接口的注解数组，并遍历解析注解 Annotation[] annotations =annotatedTypes[i].getAnnotations(); for (Annotation annotation : annotations)&#123; System.out.println("Annotation: " + annotation); appendAnnotation(builder, annotation); &#125; &#125; &#125; &#125; // 递归解析 AnnotatedType 类型 private void recurseParsingAnnotatedType(AnnotatedType annotatedType)&#123; // 被注解元素的类型 System.out.println("recurseParsingAnnotatedType: " + annotatedType.getType()); // 获取该元素上的注解数组，遍历解析 Annotation[] annotations = annotatedType.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println("Annotation: " + annotation); &#125; if (annotatedType instanceof AnnotatedArrayType)&#123; // 被注解元素是数组类型，必须递归，每次只能获取第一维的数组的注解 AnnotatedArrayType arrayType = (AnnotatedArrayType)annotatedType; // 获取注解元素的数组原始类型 AnnotatedType genericComponentType = arrayType.getAnnotatedGenericComponentType(); // genericComponentType 返回的注解只是第一维的，递归获取剩下的维度 recurseParsingAnnotatedType(genericComponentType); &#125; else if (annotatedType instanceof AnnotatedParameterizedType)&#123; // 被注解元素是泛型 AnnotatedParameterizedType parameterizedType = (AnnotatedParameterizedType) annotatedType; // 获取泛型的参数列表 AnnotatedType[] annotatedTypes = parameterizedType.getAnnotatedActualTypeArguments(); // 递归解析各个参数的注解类型 for (AnnotatedType type : annotatedTypes)&#123; recurseParsingAnnotatedType(type); &#125; &#125; else if (annotatedType instanceof AnnotatedTypeVariable) &#123; // 被注解元素是类型变量 AnnotatedTypeVariable typeVariable = (AnnotatedTypeVariable) annotatedType; // 获取类型变量的边界 AnnotatedType[] typeBounds = typeVariable.getAnnotatedBounds(); // 递归解析类型变量的边界 for (AnnotatedType type : typeBounds)&#123; recurseParsingAnnotatedType(type); &#125; &#125; else if (annotatedType instanceof AnnotatedWildcardType) &#123; // 被注解元素为泛型通配符 AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) annotatedType; // 获取泛型通配符下界 AnnotatedType[] lowerBounds = wildcardType.getAnnotatedLowerBounds(); // 递归解析边界 for (AnnotatedType type : lowerBounds)&#123; recurseParsingAnnotatedType(type); &#125; // 获取泛型通配符上界 AnnotatedType[] upperBounds = wildcardType.getAnnotatedUpperBounds(); // 递归解析边界 for (AnnotatedType type : upperBounds)&#123; recurseParsingAnnotatedType(type); &#125; &#125; &#125; // 解析字段属性上的注解类型 private void parsingFields()&#123; // 获取当前类中所有字段属性 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields)&#123; System.out.println("Field: " + field.toGenericString()); // 获取字段属性元素的被注解类型 AnnotatedType annotatedType = field.getAnnotatedType(); // 递归遍历解析该注解类型 recurseParsingAnnotatedType(annotatedType); &#125; &#125; // 解析普通方法上的注解类型 private void parsingMethods()&#123; // 获取当前类中所有方法 Method[] methods = clazz.getDeclaredMethods(); for (Method method : methods)&#123; System.out.println("Method: " + method.toGenericString()); // 获取方法的返回值注解类型，并递归解析该注解类型 AnnotatedType returnType = method.getAnnotatedReturnType(); recurseParsingAnnotatedType(returnType); // 获取方法的参数列表数组，并递归解析数组的注解类型 AnnotatedType[] parameterTypes = method.getAnnotatedParameterTypes(); for (AnnotatedType parameterType : parameterTypes) &#123; recurseParsingAnnotatedType(parameterType); &#125; // 获取方法接收者注解类型，通常为定义该方法的类 AnnotatedType receiverType = method.getAnnotatedReceiverType(); // 遍历解析该注解类型 recurseParsingAnnotatedType(receiverType); // 获取方法抛出的异常数组，并递归解析异常数组的注解类型 AnnotatedType[] exceptionTypes = method.getAnnotatedExceptionTypes(); for (AnnotatedType exceptionType : exceptionTypes)&#123; recurseParsingAnnotatedType(exceptionType); &#125; &#125; &#125; public static void main(String[] args) &#123; TestGenericAnnotationParsingReflect parsingReflect = new TestGenericAnnotationParsingReflect(); parsingReflect.parsingClass(); parsingReflect.parsingFields(); // parsingReflect.parsingConstructors(); parsingReflect.parsingMethods(); &#125;&#125; 参考文档 Java Code Examples: AnnotatedType Annotation 及几个常用开源项目注解原理简析 annotation反射–动态代理 Annotation实现浅析 Java .class文件包含的注解信息 Annotation-原理到案例 Java 8 新特性：扩展注解 AnnotationParser.java AnnotationInvocationHandler.java]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <url>%2F2018%2F05%2F18%2F0080-java-reflect%2F</url>
    <content type="text"><![CDATA[通常在程序中对象类型都是编译期就确定下来的，而 Java 反射机制的核心是 JVM 在运行时才动态加载类或调用方法、属性，这样对象的类型在编译期是未知的，也就是可以通过反射机制直接创建编译期未知的对象。 反射并没有太多理论基础，主要是熟悉各种 API ，通过反射在运行时获得程序或程序集中每一个类型成员和成员变量的信息。 基本概念反射能做什么 对于任意一个类，都能够知道这个类的所有属性和方法 对于任意一个对象，都能够调用它的任意一个方法和属性 反射常见用途 编译期已知类名如果编译器已知类名、类对象，可以通过反射简写代码（比如工厂模式中去掉条件判断等），或者获取类的私有属性、方法、构造方法等。 编译期未知类名无法导入到当前类，可以通过反射动态加载类。通过配置文件或者泛型动态加载。反射最重要的用途就是开发各种通用框架，动态加载类。很多框架（比如 Spring）都是配置化的（通过 XML 文件配置 JavaBean, Action 等），为了保证框架的通用性，他们可能根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。 基本数据类型类对象 基本数据类型boolean.class, char.class, byte.class, short.class, int.class, long.class, float.class, double.class void 类型void.class 获取类对象的方法 编译器已知类名Class&lt;?&gt; myObjectClass = MyObject.class; 已有类对象Class&lt;?&gt; clazz = object.getClass(); 已知完整类全名反射Class&lt;?&gt; myObjectClass = Class.forName(&quot;com.simple.User&quot;); 类加载器加载二进制字节流Class clazz = classLoader.loadClass(&quot;com.***.User&quot;);，注意类加载器的双亲委派模型确保能找到该类。只要能拿到 .class 文件对应的二进制字节流，就能通过反射获取 Class 的所有信息。 类的内部类Class API 可以遍历内部类或者指定类。或者使用完整类全名反射，注意：内部类和外部类之间使用美元符连接 $ ：Class&lt;?&gt; myObjectClass = Class.forName(&quot;com.simple.User$InnerClass&quot;); 每个 Class 在类加载过程中，会将类对象加载到方法区中，确保 JVM 中只存在一个类对象，它保存了类相关的类型信息，属性，方法，构造方法等等。 常见类和对应 APIAnnotatedElementAnnotatedElement 注解元素贯穿了整个反射的基础类。 1234567891011121314151617181920public interface AnnotatedElement &#123; // 判断指定类型注解是否存在 default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) &#123;...&#125; // 返回指定类型注解，包含父类 &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass); // 返回所有注解 Annotation[] getAnnotations(); // 返回指定类型的注解数组，包含父类中的 default &lt;T extends Annotation&gt; T[] getAnnotationsByType (Class&lt;T&gt; annotationClass) &#123;...&#125; // 返回当前类上指定类型的注解 default &lt;T extends Annotation&gt; T getDeclaredAnnotation (Class&lt;T&gt; annotationClass) &#123;...&#125; // 返回当前类上指定类型的注解数组 default &lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType (Class&lt;T&gt; annotationClass) &#123;...&#125; // 返回当前类上注解数组 Annotation[] getDeclaredAnnotations();&#125; MemberMember 表示类的成员：字段属性、构造方法、普通方法。 12345678910111213public interface Member &#123; // public 成员，包含父类 int PUBLIC = 0; // 当前类声明，包含私有的 int DECLARED = 1; // 内部类在哪个类中声明定义 Class&lt;?&gt; getDeclaringClass(); String getName(); // 获取访问控制符 int getModifiers(); // 判断是否为编译器生成 boolean isSynthetic();&#125; AccessibleObjectAccessibleObject 表示可访问对象，用来修改查询访问控制符。 123456789public class AccessibleObject implements AnnotatedElement &#123; // 设置可访问性 public static void setAccessible(AccessibleObject[] array, boolean flag) throws SecurityException &#123;...&#125; public void setAccessible(boolean flag) throws SecurityException &#123;...&#125; // 判断是否有权限访问 public boolean isAccessible() &#123;...&#125; ...&#125; GenericDeclarationGenericDeclaration 声明类型变量的接口，代表着泛型。 1234public interface GenericDeclaration extends AnnotatedElement &#123; // 返回泛型中定义的类型变量数组 public TypeVariable&lt;?&gt;[] getTypeParameters();&#125; FieldField 代表类中的字段、属性。 12345678910111213141516171819202122232425262728293031public final class Field extends AccessibleObject implements Member &#123; // 返回定义该字段的类 public Class&lt;?&gt; getDeclaringClass() &#123;...&#125; // 判断是否为枚举常量 public boolean isEnumConstant() &#123;...&#125; // 判断是否为编译器生成 public boolean isSynthetic() &#123;...&#125; // 返回类型 public Class&lt;?&gt; getType() &#123;...&#125; // 返回泛型类型 public Type getGenericType() &#123;...&#125; // 返回对象该字段当前值 public Object get(Object obj) throws IllegalArgumentException, IllegalAccessException&#123;...&#125; public boolean getBoolean(Object obj) throws IllegalArgumentException, IllegalAccessException&#123;...&#125; ... public double getDouble(Object obj) throws IllegalArgumentException, IllegalAccessException&#123;...&#125; // 设置对象该字段的值；第一个表示对象，第二个表示值 public void set(Object obj, Object value) throws IllegalArgumentException, IllegalAccessException&#123;...&#125; public void setBoolean(Object obj, boolean z) throws IllegalArgumentException, IllegalAccessException&#123;...&#125; ... public void setDouble(Object obj, double d) throws IllegalArgumentException, IllegalAccessException // 返回该字段被注解类型 public AnnotatedType getAnnotatedType() &#123;...&#125; ...&#125; ExecutableExecutable 1.8 新增的抽象类，是构造方法和普通方法的基类。 12345678910111213141516171819202122232425public abstract class Executable extends AccessibleObject implements Member, GenericDeclaration &#123; ... // 返回形参的类型数组 public abstract Class&lt;?&gt;[] getParameterTypes(); // 返回形参个数，由子类实现 public int getParameterCount() &#123;...&#125; // 参数为泛型，获取形参类型数组，如返回形参为 &#123;java.util.List&lt;T&gt;, boolean&#125; public Type[] getGenericParameterTypes() &#123;...&#125; // 返回参数数组 public Parameter[] getParameters() &#123;...&#125; // 判断是否采用可变量参数 public boolean isVarArgs() &#123;...&#125; ... // 返回参数注解数组 public abstract Annotation[][] getParameterAnnotations(); // 返回方法返回值的被注解类型 public abstract AnnotatedType getAnnotatedReturnType(); // 返回方法接受者的被注解类型，通常返回值为定义该方法所在类 public AnnotatedType getAnnotatedReceiverType() &#123;...&#125; // 返回方法形参的被注解类型数组 public AnnotatedType[] getAnnotatedParameterTypes() &#123;...&#125; // 返回方法抛出异常，对应被注解类型数组 public AnnotatedType[] getAnnotatedExceptionTypes() &#123;...&#125; &#125; ConstructorConstructor 代表类中的构造方法。 12345678910public final class Constructor&lt;T&gt; extends Executable &#123; // 返回定义该构造方法的类 public Class&lt;T&gt; getDeclaringClass() &#123;...&#125; // 创建实例，对应类的空参数构造方法 public T newInstance(Object ... initargs) throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;...&#125; ...&#125; MethodMethod 代表类中的普通方法。 12345678910111213141516171819202122public final class Method extends Executable &#123; // 返回定义该方法的类 public Class&lt;?&gt; getDeclaringClass() &#123;...&#125; ... // 返回返回值对应类 public Class&lt;?&gt; getReturnType() &#123;...&#125; // 返回返回值泛型类型 public Type getGenericReturnType() &#123;...&#125; ... // 调用对象的方法：obj 表示对象，args 表示方法需要的可变量参数 // 返回值为 Object 也可以代表返回值为数组 public Object invoke(Object obj, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException&#123;...&#125; // 判断是否为桥方法 public boolean isBridge() &#123;...&#125; ... // 判断是否为 default 方法 public boolean isDefault() &#123;...&#125; // 返回注解元素的默认值 public Object getDefaultValue() &#123;...&#125;&#125; ClassClass 反射基石，可以对 .class 文件全解析，获取字段、构造方法、普通方法、内部类、注解等功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration, Type, AnnotatedElement &#123; ... // ************* 获取名称 ******************* // 返回类全名、基本数据类型、Void // 如果是数组则使用 [ 表示维度，类型会编码。如：int[] 返回 [I // boolean[2][3] 返回 [[Z ；Object[] 返回 [Ljava.lang.Object public String getName() &#123;...&#125; // getName 的前面加上 class 或 interface ，如：class java.lang.String public String toString() &#123;...&#125; // 返回简单类名及数组类型，如 String, boolean[][] public String getSimpleName() &#123;...&#125; // 返回类全名，如果是数组返回 int[], boolean[][] public String getTypeName() &#123;...&#125; // 返回类全名，如果是内部类，使用 . 代替 $，如 OuterClass.InnerClass public String getCanonicalName() &#123;...&#125; // ************* 类对象、实例、加载器 **************** // 根据类全限定名返回类对象，默认会执行类初始化 public static Class&lt;?&gt; forName(String className)&#123;...&#125; // 根据类全限定名，指定类加载器返回类对象，initialize 决定是否初始化 public static Class&lt;?&gt; forName(String name, boolean initialize , ClassLoader loader) // 类对象创建类实例 public T newInstance() throws InstantiationException, IllegalAccessException &#123;...&#125; // 返回类加载器 public ClassLoader getClassLoader() &#123;...&#125; // ************* 内部类 **************** // 返回局部内部类或者匿名内部类，具体是在哪个方法中定义的 public Method getEnclosingMethod() throws SecurityException &#123;...&#125; // 返回内部类在哪个构造方法中定义 public Constructor&lt;?&gt; getEnclosingConstructor() throws SecurityException &#123;...&#125; // 返回内部类在哪个外部类中定义 public Class&lt;?&gt; getEnclosingClass() throws SecurityException &#123;...&#125; // 返回成员内部类是在哪个类中定义的 public Class&lt;?&gt; getDeclaringClass() throws SecurityException &#123;...&#125; // 判断是否为匿名类 public boolean isAnonymousClass() &#123;...&#125; // 判断是否为局部内部类 public boolean isLocalClass() &#123;...&#125; // 判断是否为成员内部类 public boolean isMemberClass() &#123;...&#125; // 返回所有 public 成员内部类数组，包含父类定义的 public 成员内部类 public Class&lt;?&gt;[] getClasses() &#123;...&#125; // 返回当前类定义的所有内部类，包含 private 内部类 public Class&lt;?&gt;[] getDeclaredClasses() throws SecurityException &#123;...&#125; // *************类属性、普通方法、构造方法**************** // 返回所有 public 字段数组，包含父类定义 public 字段 public Field[] getFields() throws SecurityException &#123;...&#125; // 返回所有 public 方法数组，包含父类定义 public 方法，默认继承 Object public Method[] getMethods() throws SecurityException &#123;...&#125; // 返回所有 public 构造方法数组 public Constructor&lt;?&gt;[] getConstructors() throws SecurityException &#123;...&#125; // 返回指定名称 pulic 字段，包含父类定义的 public 字段 public Field getField(String name) throws NoSuchFieldException, SecurityException &#123;...&#125; // 返回指定名称及参数类型的 public 方法 public Method getMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123;...&#125; // 返回指定参数的 public 构造方法 public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123;...&#125; // 返回当前类定义的所有字段，包含 private 字段 public Field[] getDeclaredFields() throws SecurityException &#123;...&#125; // 返回当前类定义的所有方法，包含 private 方法 public Method[] getDeclaredMethods() throws SecurityException &#123;...&#125; // 返回当前类定义的所有构造方法，包含 private 构造方法 public Constructor&lt;?&gt;[] getDeclaredConstructors() throws SecurityException &#123;...&#125; // 返回当前类中定义的，指定名称字段，包含 private 字段 public Field getDeclaredField(String name) throws NoSuchFieldException, SecurityException &#123;...&#125; // 返回当前类中定义的，指定名称及参数类型的方法，包含 private 方法 public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123;...&#125; // 返回指定参数构造方法，包含 private 构造方法 public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) throws NoSuchMethodException, SecurityException &#123;...&#125; // ************* 注解 **************** // 判断类对象是否为注解 public boolean isAnnotation() &#123;...&#125; // 返回当前类上指定类型的注解 public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)&#123;&#125; // 判断指定类型注解是否存在 public boolean isAnnotationPresent (Class&lt;? extends Annotation&gt; annotationClass) &#123;...&#125; // 返回指定类型的注解数组，包含父类中的 public &lt;A extends Annotation&gt; A[] getAnnotationsByType (Class&lt;A&gt; annotationClass) &#123;...&#125; // 返回所有注解 public Annotation[] getAnnotations() &#123;...&#125; // 返回当前类使用的注解数组，不包含父类 public Annotation[] getDeclaredAnnotations() &#123;...&#125; // 返回 extends 后的父类的被注解类型，Object、接口、基本数据类、void 都返回 null // 即使父类没有被注解，也会返回包含父类的被注解类型 public AnnotatedType getAnnotatedSuperclass() &#123;...&#125; // 返回 implements 后的接口的被注解类型数组 // 即使所有接口都没有被注解，也会返回包含这些接口的被注解类型数组 public AnnotatedType[] getAnnotatedInterfaces() &#123;...&#125; // ************* 泛型 **************** // 返回类的类型变量数组 public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() &#123;...&#125; // 返回泛型的父类 public Type getGenericSuperclass() &#123;...&#125; // 返回类实现的泛型接口数组 public Type[] getGenericInterfaces() &#123;...&#125; // ************* 其他 **************** // 返回类的父类，但是 Object, 接口，基本数据类型，void 都返回 null public native Class&lt;? super T&gt; getSuperclass(); // 返回类实现的接口数组 public Class&lt;?&gt;[] getInterfaces() &#123;...&#125; // 获取数组的组件类型，如：int[] 返回 int public native Class&lt;?&gt; getComponentType(); // 返回访问控制符 public native int getModifiers(); // 获取资源文件 public InputStream getResourceAsStream(String name) &#123;...&#125; // 获取资源文件 public java.net.URL getResource(String name) &#123;...&#125; // 判断是否为枚举 public boolean isEnum() &#123;...&#125; // 返回枚举类的值数组 public T[] getEnumConstants() &#123;...&#125; // 对象安全转换 public T cast(Object obj) &#123;...&#125; // 类安全转换 public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) &#123;...&#125; // 判断类对象是否为编译器生成类 public boolean isSynthetic() &#123;...&#125; // 判断当前类对象是否表示为数组 public native boolean isArray(); ...&#125; get*** 和 getDeclared*** 的区别 getDeclared***获取当前类中所有的字段属性，方法等，包含私有的，但不包含父类。 get***获取公共的字段属性，方法等，包含父类的。 总结 泛型中类型变量定义声明GenericDeclaration 表示类型变量声明的接口，其实现类为：Class, Constructor, Method，也就是说只有在类、构造方法、普通方法定义时才能声明类型变量，其他地方不允许。 访问权限控制AccessibleObject 表示可以控制访问权限的对象，其实现类为：Field, Constructor, Method。也就是说只有在字段、构造方法、普通方法上可以设置访问权限 AccessibleObject.setAccessible(true)，并访问非 public 类型。 数组辅助类 ArrayArray 提供一系列静态方法用来动态创建和访问数组。 12345678910111213141516171819202122232425262728public final class Array &#123; // 实例化指定类型，指定长度的一维数组 public static Object newInstance(Class&lt;?&gt; componentType, int length) throws NegativeArraySizeException &#123;...&#125; // 实例化指定类型，指定维度的数组 public static Object newInstance(Class&lt;?&gt; componentType, int... dimensions) throws IllegalArgumentException, NegativeArraySizeException &#123;...&#125; // 返回数组长度 public static native int getLength(Object array) throws IllegalArgumentException; // 返回指定位置的数组，返回值 Object 也可以表示数组 public static native Object get(Object array, int index) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; // 返回 boolean 值 public static native boolean getBoolean(Object array, int index) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; ... public static native double getDouble(Object array, int index) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; // 对数组指定位置设置对应值 public static native void set(Object array, int index, Object value) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; // 设置 boolean 值 public static native void setBoolean(Object array, int index, boolean z) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; ... public static native void setDouble(Object array, int index, double d) throws IllegalArgumentException, ArrayIndexOutOfBoundsException; 定义数组Java 中可以明确类型定义数组，也可以使用 Object/Class&lt;?&gt; 来表示数组： 1234567String[] strings = &#123;"a", "b", "c"&#125;;Class&lt;?&gt; classes = int[].class;Object object = new int[]&#123;1, 2, 3&#125;;// Array 创建一维数组Object object1 = Array.newInstance(String.class, 2);// Array 创建三维数组Object object2 = Array.newInstance(int.class, 2, 3, 2); 反射中通常使用 Object/Class&lt;?&gt; 来表示参数或返回值，注意：它们同时代表了数组类型。 判断是否为数组判断当前类对象或实例是否表示数组，可以使用 Class.isArray() 来判断： 123System.out.println(int[].class.isArray()); // trueSystem.out.println(strings.getClass().isArray()); // trueSystem.out.println(object.getClass().isArray()); // true 反射中转换为数组通过反射调用方法后返回 Object/Class&lt;?&gt; ，可以先判断是否为数组，然后再做转换。转换可以显示强制转换为对应类型数组，也可以通过 java.lang.reflect.Array 辅助类来处理。 1234567891011// 判断是否为数组if (object.getClass().isArray()) &#123; // 显示强制转换 int[] converts = (int[]) object; for (int i : converts) &#123; System.out.println(i); &#125; // Array 辅助类，先获取数组长度，再获取数组最后一个值 System.out.println(Array.get(object, Array.getLength(object) - 1));&#125; 示例实例化反射创建类实例，有两种方法： Constructor.newInstance()构造方法实例化，可以传递构造方法的参数。 Class.newInstance()直接通过类来实例化，相当于构造方法空参数来实例化。 123456789Class&lt;?&gt; clazz = Class.forName("com.ymzs.javabase.reflect.ReflectedClass");// 类直接实例化Object object1 = clazz.newInstance();System.out.println("object1 = " + object1);// 构造方法实例化Constructor constructor = clazz.getConstructor(String.class, byte[].class);byte[] paras = &#123;1, 2&#125;;Object object2 = constructor.newInstance("s", paras); 获取和设置字段属性先将类实例化，然后使用该实例修改字段属性；如果是 static 字段，它属于类的字段属性，所以将实例设置为 null。 123456789101112131415161718192021222324252627// 1. 先将类实例化Class&lt;?&gt; clazz = Class.forName("com.ymzs.javabase.reflect.ReflectedClass");// Object object = clazz.newInstance();Object object = clazz.newInstance();// 2. 通过 getDeclaredField 可以获取任意字段，包含私有的Field declaredField = clazz.getDeclaredField("mPrivateStr");System.out.println("Declared Field is: " + declaredField);// 私有属性设置为可访问declaredField.setAccessible(true);String value = (String) declaredField.get(object);System.out.println("get private: " + declaredField.getName() + " = " + value);String changeString = "ChangePrivateString";// 设置declaredField.set(object, changeString);value = (String) declaredField.get(object);System.out.println("set private: " + declaredField.getName() + " = " + value);// 3. 通过 getField 只能修改公共字段，包含父类的Field publicField = clazz.getField("mSuperClassPublicStr");// 设置publicField.set(object, "ChangePublicString");// 4. 静态 static 属于类，实例传入 nullField staticPublicField = clazz.getField("sPublicStr");// 设置staticPublicField.set(null, "changeStaticString"); 调用方法先将类实例化，然后使用该实例调用方法；如果是 static 字段，它属于类方法，所以将实例设置为 null。 12345678910111213141516171819202122232425262728293031Class&lt;?&gt; clazz = Class.forName("com.ymzs.javabase.reflect.ReflectedClass");// 1. 通个 getMethod 获取公共方法，包含父类的Method publicMethod = clazz.getMethod("superPublicMethod", int.class);// 2. 通过 getDeclaredMethod 获取任意方法，包含私有的Method declaredMethod = clazz.getDeclaredMethod("testPrivateMethod" , new Class[]&#123;byte[].class&#125;);// 3. 类实例化Object object = clazz.newInstance();// 方法的数组参数byte[] parameters = &#123;1, 0, 1&#125;;// 私有方法设置为可访问declaredMethod.setAccessible(true);// 4. 调用方法Object results = declaredMethod.invoke(object, parameters);// 5. 判断方法返回结果是否为数组 if (results.getClass().isArray())&#123; // 如果为数组，强制转换 String[] array = (String[]) results; String value = ""; for (String s : array)&#123; value += s; &#125; System.out.println("Declared method return value: " + value);&#125;// 5. 获取 static 方法，实例传入 nullMethod staticMethod = clazz.getMethod("staticMethod", String.class);System.out.println("Static Method return value: " // 6. 调用静态方法 + staticMethod.invoke(null, "110")); 内部类通过反射接口可以获取内部类是在哪个类/构造方法/普通方法中定义，以及判断它们属于成员/匿名/局部内部类的哪一种。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 内部类定义public class OuterClass&#123; public Runnable runnable; // 成员内部类 public class MemberInnerClass &#123; &#125; // 匿名内部类 public OuterClass()&#123; runnable = new Runnable() &#123; @Override public void run() &#123; // &#125; &#125;; &#125; // 局部内部类 public Object testMethodClass()&#123; class MethodClass&#123; &#125; return new MethodClass(); &#125;&#125;// 测试代码 private void testInnerClass()&#123; System.out.println("***********testInnerClass***********"); OuterClass outerClass = new OuterClass(); Class&lt;?&gt; clazz = outerClass.testMethodClass().getClass(); System.out.println("Method class from : " + clazz.getEnclosingMethod()); System.out.println("Outer class is : " + clazz.getEnclosingClass()); System.out.println("is Method class: " + clazz.isLocalClass()); // true clazz = OuterClass.MemberInnerClass.class; System.out.println("Member class from: " + clazz.getDeclaringClass()); System.out.println("Outer class is : " + clazz.getEnclosingClass()); System.out.println("is Member class: " + clazz.isMemberClass()); // true clazz = outerClass.runnable.getClass(); System.out.println("Anonymous class from : " + clazz.getEnclosingConstructor()); System.out.println("Outer class is : " + clazz.getEnclosingClass()); System.out.println("is Anonymous class = " + clazz.isAnonymousClass()); // true System.out.println("***********testInnerClass***********");&#125;// 测试结果Method class from :public java.lang.Object com.*.OuterClass.testMethodClass()Outer class is : class com.***.OuterClassis Method class: trueMember class from: class com.***.OuterClassOuter class is : class com.ymzs.***.OuterClassis Member class: trueAnonymous class from : public com.***.OuterClass()Outer class is : class com.***.OuterClassis Anonymous class = true 反射常见场景 反射与泛型反射与泛型的混合使用在很多框架中都会出现，应用非常广泛。基础知识点可以参考Java Type类型 ，主要是通过反射获取泛型相关信息。 反射与注解反射是注解解析方式的一种，在运行时解析注解并实现对应功能。 动态代理代理模式的一种，通过反射动态生成代理对象。设计模式参考：代理模式 动态代理代理模式：为其他对象提供一种代理以控制对这个对象的访问。 这是设计模式中对代理模式的介绍，代理模式分为静态代理和动态代理。静态代理即编译期前代码及代理关系就已经明确存在；动态代理是通过反射机制动态地生成代理对象，也就是代码编译中并不知道代理关系，动态代理将代理和被代理对象进行了解耦。Java 反射技术是在内存中，动态生成一个新类来实现动态代理。 Java 中只能为接口 interface 实现动态代理。 基础类123456789101112131415161718192021222324252627282930// 动态代理必须通过这个接口来实现代理方法调用public interface InvocationHandler &#123; /** * 调用被代理对象的方法 * Object: 被代理的真实对象 * method：被代理实例对应的方法 * args：传入的参数数组 */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125;// Proxy 辅助类，用来创建代理对象类或者实例public class Proxy implements Serializable &#123; // 创建动态代理对应的 class 对象 // ClassLoader 动态代理类的类加载器；interfaces 为接口数组 public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException /** * JVM 运行时动态创建代理对象，对应类名为 com.sun.proxy.$Proxy** * ClassLoader: 代理对象的类加载器 * Class&lt;?&gt;[]：被代理对象对应的接口数组（多态） * InvocationHandler：我们实现的动态代理对象 */ public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123;...&#125; ...&#125; 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. 目标接口，被动态代理public interface Subject &#123; void operation();&#125;// 2. RealSubject，真实对象public class RealSubject implements Subject&#123; public void operation()&#123; System.out.println(&quot;RealSubject::operation.&quot;); &#125;&#125;// 3. DynamicProxy，实现动态代理public class DynamicProxy implements InvocationHandler&#123; private Object object; public DynamicProxy(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; // 可以在这里增加权限控制，或者添加其他功能 ... Object result = method.invoke(object, objects); ... return result; &#125;&#125;// 4. Testpublic class TestDynamicProxy &#123; public static void main(String[] args) &#123; RealSubject realSubject = new RealSubject(); InvocationHandler dynamicProxy = new DynamicProxy(realSubject); Subject subject = (Subject) Proxy.newProxyInstance( Subject.class.getClassLoader(), new Class[]&#123;Subject.class&#125;, dynamicProxy); System.out.println(subject.getClass()); subject.operation(); &#125;&#125;// 5. Resultclass com.sun.proxy.$Proxy0RealSubject::operation. InvocationHandler.invoke在这里实现动态代理，同时可以在动态代理前增加权限检查，或者添加功能（相当于装饰模式）。 com.sun.proxy.$Proxy0从输出的 Log 可以看出，动态代理是重新生成了一个新的类 com.sun.proxy.$Proxy0，并实现了动态代理的功能。新类命名格式：包名 + $Proxy + id 序号。 ClassDump 工具工具介绍ClassDump 是 HotSpot 虚拟机特有的，它是 HotSpot SA: Serviceability Agent 中的一个工具。ClassDump 可以在运行时 dump 类文件，特别是动态生成或者运行时被修改了字节码的类。HotSpot 有一套私有 API 提供了对 JVM 内部数据结构的审视功能，称为 Serviceability Agent。可以通过 API 直接写 Java 代码来查看一个跑在 HotSpot 上的 Java 进程的内部状态。它也提供了一些封装好的工具，可以直接在命令行上跑，包括 ClassDump 工具。SA 的一个重要特征是它是“进程外审视工具”。也就是说 SA 并不运行在要审视的目标进程中，而是运行在一个独立的 Java 进程中，通过操作系统上提供的调试 API 来连接到目标进程上。这样 SA 的运行不会受到目标进程状态的影响，因而可以用于审视一个已经挂起的 Java 进程。一个被调试器连接上的进程会被暂停下来。所以在 SA 连接到目标进程时，目标进程也是一直处于暂停状态的，直到 SA 解除连接。如果需要在线上使用SA的话需要小心，不要通过 SA 做过于耗时的分析，宁可先把数据都抓出来，把连接解除掉之后再离线分析。目前的使用经验是，连接上一个小 Java 进程的话很快就好了，但连接上一个“大”的 Java 进程（堆比较大、加载的类比较多）可能会在连接阶段卡住好几分钟，线上需要慎用。ClassDump 的特点：需要目标 Java 进程必须在运行中；连接时会导致目标进程暂停。 示例过滤器示例：使用 ClassDump 工具 Dump 出动态代理生成的类，其类特点是文件名都是 com.sun.proxy.$Proxy 开头的 class 文件。 12345678910111213import sun.jvm.hotspot.oops.InstanceKlass;import sun.jvm.hotspot.tools.jcore.ClassFilter;public class MyClassNameFilter implements ClassFilter &#123; private static final String CLASSNAME_PREFIX = "com/sun/proxy/$Proxy"; @Override public boolean canInclude(InstanceKlass instanceKlass) &#123; String klassName = instanceKlass.getName().asString(); return klassName.startsWith(CLASSNAME_PREFIX); &#125;&#125; 注意：过滤器中需要过滤的类名是以 / 分割的而不是 . ，如：com/sun/proxy/$Proxy 。 执行过程 当前是在 Ubuntu 环境中运行的，执行时必须使用 root 权限（使用 sudo 也会报错）。 修改动态代理源文件，确保进程持续运行。 123456789public class TestDynamicProxy &#123; public static void main(String[] args) &#123; RealSubject realSubject = new RealSubject(); ... subject.operation(); // 添加这一句，使进程阻塞等待，不会退出 System.in.read(); &#125;&#125; 运行该测试程序，并查看对应的进程名： 12345// 找到目标进程 id: 81249root@server005:~/classdump# jps83496 Jps119412 ServerLauncher81249 TestDynamicProxy MyClassNameFilter.java 文件并不需要编译（也编译不过导入的包名找不到），在 MyClassNameFilter.java 文件所在目录运行，命令使用方法： 12345678910111213141516// 0. root 用户下执行// 1. 指定过滤器类文件为 MyClassNameFilter// 2. 指定 classdump 进程 id：81249root@server005:~/classdump# java -classpath "$JAVA_HOME/lib/sa-jdi.jar" -Dsun.jvm.hotspot.tools.jcore.filter=MyClassNameFilter sun.jvm.hotspot.tools.jcore.ClassDump 81249Warning: Can not create class filter!Attaching to process ID 81249, please wait...Debugger attached successfully.Server compiler detected.JVM version is 24.121-b00root@server005:~/classdump# tree com/com/└── sun └── proxy └── $Proxy0.class2 directories, 1 file 执行完毕后，会生成三个代码目录：com, java, sun，其中 com 为动态代理中生成的类，其他为加载的系统类。 没有使用 root 账号运行出现的错误： 12345678// 1. 直接使用其他账户运行，无法 attach 到目标进程Warning: Can not create class filter!Attaching to process ID 80662, please wait...Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can't attach to the process// 2. sudo 运行，无法打开对应库文件Attaching to process ID 81297, please wait...Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file 结果分析使用 jd-gui 打开 $Proxy0.class 文件分析动态代理生成的类实现了哪些功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 继承了 Proxy 类，并实现了 Subject 接口，// 动态代理前提条件就要求被代理是接口public final class $Proxy0 extends Proxy implements Subject&#123; private static Method m1; private static Method m0; private static Method m3; private static Method m2; public $Proxy0(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; // 静态代码块，类加载时执行 static &#123; try &#123; // 使用了反射技术 // 获取 Object 的默认方法：equals, toString, hashCode // 获取 Subject 定义的方法：operation m1 = Class.forName("java.lang.Object").getMethod("equals", new Class[] &#123; Class.forName("java.lang.Object") &#125;); m0 = Class.forName("java.lang.Object").getMethod("hashCode", ew Class[0]); m3 = Class.forName("Subject").getMethod("operation", new Class[0]); m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]); return; &#125; .. &#125; public final boolean equals(Object paramObject) &#123; .. return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); ... &#125; public final String toString() &#123; ... return (String)this.h.invoke(this, m2, null); ... &#125; public final int hashCode() &#123; ... return ((Integer)this.h.invoke(this, m0, null)).intValue(); ... &#125; // 通过反射 InvocationHandler.invoke 调用目标方法 public final void operation() &#123; try &#123; this.h.invoke(this, m3, null); return; &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; 可以看出生成的代理类，最终是通过 InvocationHandler 来调用目标方法的。 参考文档 Java reflect guide Class: Java Doc Field: Java Doc Method: Java Doc 疯狂 Java 讲义-第二版 – 第 18 章 类加载机制与反射 Java 反射完全解析 Java 反射-数组 Java synthetic 关键字 Java 动态代理 Java动态代理机制详解 轻松学 Java 中动态代理 HotSpot SA #2：ClassDump R大–dump Java 进程里的类对应的 Class 文件 从 Java 进程里 dump 出类的字节码文件 ClassDump.java 源码]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Type 类型]]></title>
    <url>%2F2018%2F05%2F15%2F0079-java-type%2F</url>
    <content type="text"><![CDATA[Type 只在反射中才有真正的意义，表示 Java 中所有类型的公共父接口。它包含：原始类型、参数化类型、数组类型、类型变量和基础数据类型。 Java 语言规范中指出变量只有下面三种类型 JLS： 基本类型 primitive types：boolean, byte, short, int, long, char, float, double 引用类型 reference types：class, interface, array, type variables 空类型 null type 关于泛型和语言规范中三种类型的关系如下： 如果类或接口声明了类型变量，那么它就是泛型 类和接口如果是泛型，那么它就定义了一个参数化类型，简单理解为泛型就是参数化类型。但是参数化类型是属于类类型或者接口类型的 参数化类型的参数 Type Arguments of Parameterized Types：可以是引用类型和通配符 在学习 Type 及子接口或实现类时，很容易将它们和语言规范中的类型混淆。语言规范简单来讲类型分为：基本数据类型，类类型（包含接口），数组（另外算上一个类型变量）。总是在想：为什么会多出 Type 这几种类型？它们和基本语言规范中类型的区别是什么呢？实际上从语言规范中的类型来讲，它们是标准的类类型（包含接口），只有在反射解析变量时，它们才有实际的意义，用来区分泛型的几种情景。 类图结构 Type 基本概念Type 的引入主要是为了反射和泛型服务的，它能代表一切类型。在编码使用中（抛开反射概念），这几种类型是标准的类类型和接口类型；它们只能在反射中才能体现真正的意义，能代表泛型的几种细分场景： Type表示 Java 中所有类型的公共接口。也就是反射中 Type 代表 Java 语言规范中的所有类型。 TypeVariable表示类型变量，即泛型中的 T, K, V 等等。 ParameterizedType表示参数化类型，即泛型，如：Collection&lt;String&gt; 。 GenericArrayType表示数组中的：参数化类型数组，类型变量数组，如：Collection&lt;String&gt;[], T[] 。并不包含基本类型和类类型数组。 WildcardType表示通配符类型表达式，如 ?，? extends Number，? super Integer 。它只是参数化类型中参数的一种类型，无法直接修饰变量。 Class它是 Type 的实现类，表示除了上面泛型中的几个特定类型之外的所有类型，包含基本数据类型，引用类型等。每个类在加载后都会对应一个 Class 类对象，它包含了 .class 文件转换为内存运行时数据结构，也就是包含类中的一切信息。参考：类加载机制 Class 对象是否反射的基石，在 Java 中使用 类名.clas 表示类对象。如：String.class, Object.class 等等。 源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * Type is the common superinterface for all types in the Java * programming language. These include raw types, parameterized types, * array types, type variables and primitive types. * * @since 1.5 */public interface Type &#123; /** * Returns a string describing this type, including information * about any type parameters. * * @implSpec The default implementation calls &#123;@code toString&#125;. * * @return a string describing this type * @since 1.8 */ default String getTypeName() &#123; return toString(); &#125;&#125;/** * ParameterizedType represents a parameterized type * such as Collection&lt;String&gt;. */public interface ParameterizedType extends Type &#123; // 返回参数化类的，参数数组 Type[] getActualTypeArguments(); // 返回泛型类或者接口的原始类型 Type getRawType(); // getRawType 返回泛型如果为顶级类，则返回空；如果是内部类，则返回外部类 Type getOwnerType();&#125;// TypeVariable is the common superinterface for type variables of kinds.public interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type, AnnotatedElement &#123; // 类型变量的上界 Type[] getBounds(); // 声明这个类型变量的泛型类 D getGenericDeclaration(); // 类型变量使用的名字 String getName(); // 1.8 添加的方法，返回 AnnotatedType 数组 AnnotatedType[] getAnnotatedBounds();&#125;/** * GenericArrayType represents an array type whose component type * is either a parameterized type or a type variable. */public interface GenericArrayType extends Type &#123; // 泛型数组元素类型 Type getGenericComponentType();&#125;/** * WildcardType represents a wildcard type expression, * such as ?, ? extends Number, or ? super Integer. */public interface WildcardType extends Type &#123; // 获取通配符上界 Type[] getUpperBounds(); // 获取通配符下界 Type[] getLowerBounds();&#125;/** * Instances of the class Class represent classes and interfaces * in a running Java application. */public final class Class&lt;T&gt; implements Serializable, GenericDeclaration, Type, AnnotatedElement &#123;...&#125; 示例源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class TestType &#123; private void testParameterizedType()&#123; class ParameterizedTypeTestClass&#123; List&lt;String&gt; list; Map.Entry&lt;Integer, String&gt; entry; Class&lt;?&gt; clazz; &#125; showTypeDetails(ParameterizedTypeTestClass.class); &#125; private void testTypeVariable()&#123; class TypeVariableTestClass&lt;K extends Runnable, V&gt; &#123; K k; V v; List&lt;K&gt; list; &#125; showTypeDetails(TypeVariableTestClass.class); &#125; private void testGenericArrayType()&#123; class GenericArrayTypeTestClass&lt;T&gt;&#123; List&lt;String&gt;[] lists; T[] ts; &#125; showTypeDetails(GenericArrayTypeTestClass.class); &#125; private void testWildcardType()&#123; class WildcardTypeTestClass&#123; List&lt;? extends Number&gt; numbers; List&lt;? super Integer&gt; list; &#125; showTypeDetails(WildcardTypeTestClass.class); &#125; private void testAllTypes()&#123; class AllTypes&#123; int i; boolean b; float f; byte[] bytes; String s; Object o; Runnable runnable; Object[] os; &#125; showTypeDetails(AllTypes.class); &#125; private void showTypeDetails(Class&lt;?&gt; clazz)&#123; Field[] fields = clazz.getDeclaredFields(); for (Field field : fields)&#123; System.out.println("*************************"); System.out.println("showTypeDetails: " + clazz); System.out.println("Field: " + field); Type type = field.getGenericType(); System.out.println("TypeName: " + type.getTypeName()); if (type instanceof ParameterizedType) &#123; ParameterizedType parameterizedType =(ParameterizedType)type; System.out.println("ParameterizedType--RawType: " + parameterizedType.getRawType()); System.out.println("ParameterizedType--OwnerType: " + parameterizedType.getOwnerType()); Type[] types = parameterizedType.getActualTypeArguments(); System.out.println("ParameterizedType--Args.length = " + types.length); for (Type t : types)&#123; System.out.println("ParameterizedType--ActualTypeArguments: " + t); if (t instanceof WildcardType)&#123; WildcardType wildcardType = (WildcardType) t; Type[] uppers = wildcardType.getUpperBounds(); System.out.println("WildcardType--uppers.length = " + uppers.length); for (Type t1 : uppers) &#123; System.out.println("WildcardType--uppers, type =" + t1); &#125; Type[] lowers = wildcardType.getLowerBounds(); System.out.println("WildcardType--lowers.length = " + lowers.length); for (Type t2 : lowers)&#123; System.out.println("WildcardType--lowers. type =" + t2); &#125; &#125; &#125; &#125; else if (type instanceof TypeVariable) &#123; TypeVariable typeVariable = (TypeVariable) type; Type[] types = typeVariable.getBounds(); System.out.println("TypeVariable--Bounds.length = " + types.length); for (Type t : types)&#123; System.out.println("TypeVariable--Bounds = " + t); &#125; System.out.println("TypeVariable--GenericDeclaration = " + typeVariable.getGenericDeclaration()); System.out.println("TypeVariable--Name = " + typeVariable.getName()); &#125; else if (type instanceof GenericArrayType) &#123; GenericArrayType genericArrayType = (GenericArrayType) type; System.out.println("GenericArrayType--ComponentType: " + genericArrayType.getGenericComponentType()); &#125; else if (type instanceof Class) &#123; System.out.println("Class--SimpleName = " + ((Class) type).getSimpleName()); &#125; &#125; &#125; public static void main(String[] args) &#123; TestType testType = new TestType(); testType.testParameterizedType(); testType.testTypeVariable(); testType.testGenericArrayType(); testType.testWildcardType(); &#125;&#125; 源码解析： 反射后的字段类型只有四种：ParameterizedType, TypeVariable, GenericArrayType, Class，它们的公共父接口为 Type 。 反射后参数化类型的参数类型为：通配符 WildcardType 和上面四种类型。 123456Class&lt;?&gt; clazz; // WildcardTypeList&lt;? extends Number&gt; numbers; // WildcardTypeList&lt;List&lt;String&gt;&gt; listList; // ParameterizedTypeList&lt;K&gt; listK; // TypeVariableList&lt;V[]&gt; listVArray; // GenericArrayTypeList&lt;String&gt; list; // Class 结果分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157*************************// 传入的类名为 TestType 的内部类 1ParameterizedTypeTestClassshowTypeDetails: class com.***.TestType$1ParameterizedTypeTestClass// 获取的字段为 list，类型为：参数化类型 List&lt;String&gt;，// 其原始类型为 List，参数为 StringField: java.util.List com.***.TestType$1ParameterizedTypeTestClass.listTypeName: java.util.List&lt;java.lang.String&gt;ParameterizedType--RawType = interface java.util.ListParameterizedType--OwnerType = nullParameterizedType--Args.length = 1ParameterizedType--ActualTypeArguments = class java.lang.String*************************showTypeDetails: class com.***.TestType$1ParameterizedTypeTestClassField: java.util.Map$Entry com.***.TestType$1ParameterizedTypeTestClass.entryTypeName: java.util.Map.java.util.Map$Entry&lt;java.lang.Integer, java.lang.String&gt;ParameterizedType--RawType = interface java.util.Map$EntryParameterizedType--OwnerType = interface java.util.MapParameterizedType--Args.length = 2ParameterizedType--ActualTypeArguments = class java.lang.IntegerParameterizedType--ActualTypeArguments = class java.lang.String*************************showTypeDetails: class com.***.TestType$1ParameterizedTypeTestClass// 获取的字段为 clazz，类型为：参数化类型 Class&lt;?&gt;Field: java.lang.Class com.***.TestType$1ParameterizedTypeTestClass.clazzTypeName: java.lang.Class&lt;?&gt;ParameterizedType--RawType = class java.lang.ClassParameterizedType--OwnerType = nullParameterizedType--Args.length = 1ParameterizedType--ActualTypeArguments = ?// 其参数为通配符类型WildcardType--uppers.length = 1WildcardType--uppers, type = class java.lang.ObjectWildcardType--lowers.length = 0*************************// 内部类持有外部类的引用 showTypeDetails: class com.***.TestType$1ParameterizedTypeTestClassField: final com.***.TestType com.***.TestType$1ParameterizedTypeTestClass.this$0TypeName: com.***.TestTypeClass--SimpleName = TestType*************************showTypeDetails: class com.***.TestType$1TypeVariableTestClass// 获取的字段为 k，类型为：类型变量 KField: java.lang.Runnable com.***.TestType$1TypeVariableTestClass.kTypeName: KTypeVariable--Bounds.length = 1TypeVariable--Bounds = interface java.lang.RunnableTypeVariable--GenericDeclaration = class com.***.TestType$1TypeVariableTestClassTypeVariable--Name = K*************************showTypeDetails: class com.***.TestType$1TypeVariableTestClassField: java.lang.Object com.***.TestType$1TypeVariableTestClass.vTypeName: VTypeVariable--Bounds.length = 1TypeVariable--Bounds = class java.lang.ObjectTypeVariable--GenericDeclaration = class com.***.TestType$1TypeVariableTestClassTypeVariable--Name = V*************************showTypeDetails: class com.***.TestType$1TypeVariableTestClassField: java.util.List com.***.TestType$1TypeVariableTestClass.listTypeName: java.util.List&lt;K&gt;ParameterizedType--RawType = interface java.util.ListParameterizedType--OwnerType = nullParameterizedType--Args.length = 1ParameterizedType--ActualTypeArguments = K*************************showTypeDetails: class com.***.TestType$1TypeVariableTestClassField: final com.***.TestType com.***.TestType$1TypeVariableTestClass.this$0TypeName: com.***.TestTypeClass--SimpleName = TestType*************************showTypeDetails: class com.***.TestType$1GenericArrayTypeTestClass// 获取字段为 lists，类型为：泛型数组 List&lt;String&gt;[]Field: java.util.List[] com.***.TestType$1GenericArrayTypeTestClass.listsTypeName: java.util.List&lt;java.lang.String&gt;[]GenericArrayType--ComponentType = java.util.List&lt;java.lang.String&gt;*************************showTypeDetails: class com.***.TestType$1GenericArrayTypeTestClassField: java.lang.Object[] com.***.TestType$1GenericArrayTypeTestClass.tsTypeName: T[]GenericArrayType--ComponentType = T*************************showTypeDetails: class com.***.TestType$1GenericArrayTypeTestClassField: final com.***.TestType com.***.TestType$1GenericArrayTypeTestClass.this$0TypeName: com.***.TestTypeClass--SimpleName = TestType*************************showTypeDetails: class com.***.TestType$1WildcardTypeTestClass// 获取字段为 numbers，类型为：参数化类型// 参数化类型的参数为：通配符Field: java.util.List com.***.TestType$1WildcardTypeTestClass.numbersTypeName: java.util.List&lt;? extends java.lang.Number&gt;ParameterizedType--RawType = interface java.util.ListParameterizedType--OwnerType = nullParameterizedType--Args.length = 1ParameterizedType--ActualTypeArguments = ? extends java.lang.NumberWildcardType--uppers.length = 1WildcardType--uppers, type = class java.lang.NumberWildcardType--lowers.length = 0*************************showTypeDetails: class com.***.TestType$1WildcardTypeTestClassField: java.util.List com.***.TestType$1WildcardTypeTestClass.listTypeName: java.util.List&lt;? super java.lang.Integer&gt;ParameterizedType--RawType = interface java.util.ListParameterizedType--OwnerType = nullParameterizedType--Args.length = 1ParameterizedType--ActualTypeArguments = ? super java.lang.IntegerWildcardType--uppers.length = 1WildcardType--uppers, type = class java.lang.ObjectWildcardType--lowers.length = 1WildcardType--lowers. type = class java.lang.Integer*************************showTypeDetails: class com.***.TestType$1WildcardTypeTestClassField: final com.***.TestType com.***.TestType$1WildcardTypeTestClass.this$0TypeName: com.***.TestTypeClass--SimpleName = TestType*************************// 获取基本数据类型、非泛型数组字段showTypeDetails: class com.***.TestType$1AllTypesField: int com.***.TestType$1AllTypes.iTypeName: intClass--SimpleName = int*************************showTypeDetails: class com.***.TestType$1AllTypesField: boolean com.***.TestType$1AllTypes.bTypeName: booleanClass--SimpleName = boolean*************************showTypeDetails: class com.***.TestType$1AllTypesField: float com.***.TestType$1AllTypes.fTypeName: floatClass--SimpleName = float*************************showTypeDetails: class com.***.TestType$1AllTypesField: byte[] com.***.TestType$1AllTypes.bytesTypeName: byte[]Class--SimpleName = byte[]*************************showTypeDetails: class com.***.TestType$1AllTypesField: java.lang.String com.***.TestType$1AllTypes.sTypeName: java.lang.StringClass--SimpleName = String*************************showTypeDetails: class com.***.TestType$1AllTypesField: java.lang.Object com.***.TestType$1AllTypes.oTypeName: java.lang.ObjectClass--SimpleName = Object*************************showTypeDetails: class com.***.TestType$1AllTypesField: java.lang.Runnable com.***.TestType$1AllTypes.runnableTypeName: java.lang.RunnableClass--SimpleName = Runnable*************************showTypeDetails: class com.***.TestType$1AllTypesField: final com.***.TestType com.***.TestType$1AllTypes.this$0TypeName: com.***.TestTypeClass--SimpleName = TestType 参考文档 Type JavaDoc Java Language Specification - Type,values,variables Java-Type体系-1 Java-Type体系-2 Java Type 详解 Java reflect Type类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 类加载机制]]></title>
    <url>%2F2018%2F05%2F02%2F0078-java-classloading%2F</url>
    <content type="text"><![CDATA[类加载机制：虚拟机把描述类的数据从 Class 文件加载到内存，并对数据校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。 类加载过程类从被加载到虚拟机内存中开始，到类卸载出内存为止，它的整个生命周期包括：加载 Loading， 验证 Verification，准备 Preparation，解析 Resolution，初始化 Initialization，使用 Using 和卸载 Unloading 共七个阶段。其中验证、准备、解析这三个阶段部分统称为连接 Linking，七个阶段出现的顺序如图所示： 其中：加载、验证、准备、初始化、卸载这五个阶段的顺序是固定的，类的加载过程必须按照这个顺序执行，而解析有可能会在初始化之后才开始（比如：动态绑定，也称为晚绑定、动态分派 Difference between Binding and Dispatching in Java, wiki:Late_binding in java）。类加载全过程也就是：加载、验证、准备、解析、初始化这五个阶段。 加载 Loading加载是类加载过程的一个阶段，加载需要完成三件事： 通过类的全限定名获取定义此类的二进制字节流。这个字节流可以是从本地 Class 文件、网络下载、使用动态代理运行时生成等方式获取 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口 非数组类的加载阶段，也就是通过全限定名获取类的二进制字节流，这个过程可控性很强，可以默认使用系统提供的类加载器去加载，也可以自定义加载器实现。而数组类本身不通过类加载器创建，它是由虚拟机直接创建的，但是数组类的元素类型 Element Type （也就是数组类型）还是要靠类加载器加载。 加载完成后，虚拟机将外部的二进制字节流，按照虚拟机所需格式存储到方法区中，并在方法区中实例化 java.lang.Class 对象，这个类对象将作为程序访问类型数据的接口。 验证 Verification验证阶段确保加载的二进制字节流包含的信息符合虚拟机需求，以及做一些安全检查。 文件格式验证比如验证文件是否以魔数开头 0xCAFEBABE 开头；主次版本号是否符合虚拟机范围；Class 文件本身是否有被删除信息等等。 元数据格式验证对字节码描述的信息进行语义分析，确保符合 Java 语言规范。比如：类是否具有父类；是否能被继承；是否为抽象类；字段、方法是否和父类矛盾等等。 字节码验证通过数据流和控制流分析，确定程序语义是否合法符合逻辑，使用类型检查完成数据流分析。比如：操作数栈的数据类型和指令能配合工作；确保类型转换是安全的等等。 符号引用验证这个转换动作主要在解析阶段发生，确保解析阶段能够正常执行。符号引用验证主要对类自身以外的信息进行校验：符号引用中的全限定名能否找到对应的类；指定类中是否存在符合方法的字段描述符；符号引用中的访问控制符是否可以被当前类访问等等。 准备 Preparation准备阶段是正式为类变量分配内存并设置类变量的初始值的阶段，这些变量都在方法区分配内存。需要注意两点： 内存分配仅仅包含类变量（static 变量），并不包含实例变量（分配到堆内存） 初始值是指数据类型的零值，而不是声明变量时的赋值 12public static int number = 123;public static final int value = 100; 示例中 number 在准备阶段值为 0，而 value 因为是常量 static final ，在准备阶段会被直接赋值为 100 。 解析 Resolution解析阶段是虚拟机将常量池中的符号引用替换为直接引用的过程。 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能准确定位到目标即可。符号引用字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 直接引用可以只直接指向目标的指针、偏移量或者间接定位到目标的句柄。有了直接引用，那么引用目标一定是已经在内存中存在了。 解析动作主要针对类、接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。这几类符号引用的解析过程，《深入理解 Java 虚拟机》第七、八章中有详细介绍。 初始化 Initialization类初始化阶段是类加载过程的最后一步，该阶段才真正开始执行 Java 程序代码。在准备阶段，类变量仅仅赋为零值，在类初始化阶段才会执行代码并赋值。类初始化阶段是执行类构造器 &lt;clinit&gt;() 方法的过程。 &lt;clinit&gt;() 方法是由编译器自动收集类中所有类变量的赋值动作和 static{} 静态语句代码块合并产生的，收集顺序就是代码中出现的顺序。静态语句块只能访问定义在之前的静态变量，定义在之后的变量只能赋值不能访问 &lt;clinit&gt;() 方法与类实例构造器（&lt;init&gt;()）不同，它不需要显示调用父类构造器，虚拟机会确保子类 &lt;clinit&gt;() 方法之前执行完父类的 &lt;clinit&gt;() 方法，也就是说虚拟机第一个被执行的 &lt;clinit&gt;() 方法肯定是 java.lang.Object 的。这也意味着父类的静态语句会先于子类执行。 &lt;clinit&gt;() 方法对于类或者接口并不是必须的，类中可以没有静态变量赋值及静态语句块，编译器也就不会生成 &lt;clinit&gt;() 方法 接口中不能有静态语句块， 但可以有静态变量定义和赋值，所以也会生成 &lt;clinit&gt;() 方法。但需要注意接口与类不同的是：执行接口 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法，只有父接口的变量在使用时才会执行；实现接口的类初始化时也不会执行接口的 &lt;clinit&gt;() 方法 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境中被正确的加锁、同步。多线程同时执行类初始化，那么只会有一个线程去执行类的 &lt;clinit&gt;() 方法，其他线程会阻塞等待直到 &lt;clinit&gt;() 方法执行完毕。 同一个类加载器下，类只会被初始化一次，也就是 &lt;clinit&gt;() 方法只会被执行一次 &lt;clinit&gt;() 方法是类初始化过程，即类加载过程的初始化阶段；&lt;init&gt;() 是类实例化过程，即遇到 new 关键字生成类对象阶段。 &lt;clinit&gt;()类构造器，包含类变量（static 变量）初始化赋值，静态语句代码块（static{}）。 &lt;init&gt;()实例构造器，包含实例变量初始化赋值，构造语句代码块（{}），构造方法。 类加载的时机类初始化时机什么时候开始进行类加载过程中的第一个阶段：加载？虚拟机并没有明确规定。但是虚拟机严格规定了：有且只有 5 种情况必须对类进行初始化（也就是一定会触发类加载过程）： 遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这几条指令的场景如下使用 new 关键字实例化对象；读取或设置类的静态字段（被 final 进入常量池的静态字段除外）；调用一个类的静态方法。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，需要先触发初始化 初始化一个类的时候，如果发现父类还没有初始化，先触发父类初始化 用户指定要执行额主类：即包含 main 主类的先初始化 如果 java.lang.invoke.MethodHandle 实例最后解析的结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，如果没有初始化会触发其初始化 主动/被动引用上面明确的 5 种类初始化场景，称为类的主动引用；而不会触发类初始化的引用，称为类的被动引用。主动/被动引用，是否触发类加载过程的加载阶段，虚拟机没有明确规定，当前测试的虚拟机只要引用了，都会触发类加载过程的加载阶段。被动引用有如下几种情形： 子类引用父类静态字段子类不会被初始化，而父类会被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。 类数组数组引用类，不会触发类初始化。 静态常量静态常量如果在编译期能够被确定，则不会触发类初始化，甚至都不会进入类加载阶段，比如字符串常量。它们会直接放入常量池，并且在编译器优化中，直接将该常量放入到引用类的常量池中，也就是说生成的引用类 Class 文件中并不包含被引用类的符号引用，它们在 Class 文件中毫无关系了。而编译期无法确定，必须在运行时才能确定的字段，这类静态常量会导致类初始化（只有在类初始化阶段才开始执行代码），比如当前时间 static final String STATIC_TIME = System.currentTimeMillis() + &quot;&quot;;。 反射 Classloader.loadClass在使用反射过程中，ClassLoad.loadClass 只会触发类加载阶段，不会执行类初始化。 反射 Class.forName在使用反射过程中，Class.forName 时会同时触发类加载和类初始化阶段，默认使用调用类的类加载器进行类加载。 类加载器类加载阶段中：通过一个类的全限定名来获取描述此类的二进制字节流，这个过程是在虚拟机外部实现的，实现这个过程的模块即为类加载器。对于任一个类：都需要由类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。每个类加载器，都有一个独立的类名称空间。也就是说，比较两个类是否相等，只有在同一个类加载器中加载才有意义。即使两个类属于同一个 Class 文件，由同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。相等的测试，可以是 Class 的 equals(), isAssignableFrom(), isInstance() 等方法，或者 instanceof 关键字。 类加载器分类 启动类加载器 Bootstrap ClassLoader这个是 C/C++ 实现，虚拟机的一部分，负责加载系统类，JAVA_HOME\lib 目录或者 -Xbootclasspath 参数指定路径下的类库（rt.jar 等基础库）加载到虚拟机内存中。启动类加载器无法被用户程序直接引用，引导类加载器没有对应的 ClassLoader 。虚拟机只加载 JAVA_HOME\lib 按照文件名识别的类库，自定义类库即使放到这个目录下，虚拟机并不会去加载。 扩展类加载器 Extension ClassLoader由 sun.misc.Launcher$ExtClassLoader 实现，负责加载 JAVA_HOME\lib\ext 中的标准扩展类库，用户可以直接使用这些扩展类加载器。如果将自定义 jar 包放到这个路径下，扩展类加载器将会加载这些类。 应用程序类加载器 Application ClassLoader由 sun.misc.Launcher$AppClassLoader 实现，负责加载 CLASSPATH 中的类库及应用类。这个类加载器是 ClassLoader.getSystemClassLoader() 的返回值，所以一般称为系统类加载器，用户可以直接使用。 通常在搭建 Java 开发环境时，都需要添加 JAVA_HOME, CLASSPATH 两个全局环境变量，就是为了给类加载器指定路径的。 双亲委派模型 Parents Delegation Model 上图所示的类加载器之间的层次关系，称为类加载器的双亲委派模型。该模型要求除了顶层启动类加载器外，其余的类加载器都应当有自己的父加载器。这里的父子关系不是继承关系，而是组合关系来复用父类代码。双亲委派模型原则：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。 破坏双亲委派模型双亲委派模型并不是强制性的约束，而是 Java 推荐使用这种方式。 自定义类加载器后面源码分析中可以看到 ClassLoader.loadClass() 方法实现了双亲委派模型，该方法可以被重写 loadClass，但是一般情况下会遵循双亲委派模型。所以 JDK 中定义了 findClass 方法，推荐自定义类加载器重写该方法，既不会破坏双亲委派模型，又可以实现自己的加载器。 线程上下文加载器 Thread Context ClassLoader可以通过 Thread.setContextClassLoader 来设置。如果线程创建时没有设置，它将从父线程中继承一个；如果全局范围内都没有设置，默认使用应用程序类加载器。它打破了双亲委派模型，也就是父加载器请求子加载器去完成类加载的动作。系统默认的上下文加载器为系统加载器，可以参考 Launcher 源码。 代码热替换 HotSwap 和模块热部署 HotDeployment应用程序像计算机的外设一样，可以热插拔鼠标、U 盘等，不需要重启。自定义加载器可以实现这些功能，并且有非常广泛的应用，如 Android 热部署、插件化等。 类加载源码虚拟机加载程序的入口类：sun.misc.Launcher.java，学习类加载机制也选这个文件开始分析。 类图结构 从类图结构中可以看出：AppClassLoader 和 ExtClassLoader 都是 ClassLoader 的子类，他们在类关系中是并行的，并不是父子结构。 Launcher 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 1. Launcherpublic class Launcher &#123; ... private static Launcher launcher = new Launcher(); private static String bootClassPath = System.getProperty("sun.boot.class.path"); private ClassLoader loader; ... public static Launcher getLauncher() &#123; return launcher; &#125; public Launcher() &#123; Launcher.ExtClassLoader extcl; try &#123; // 2. Launcher 构造方法中实例化 ExtClassLoader extcl = Launcher.ExtClassLoader.getExtClassLoader(); &#125; catch (IOException var10) &#123; throw new InternalError ("Could not create extension class loader", var10); &#125; try &#123; // 3. Launcher 构造方法中实例化 AppClassLoader // 并将 ExtClassLoader 传递给 AppClassLoader this.loader = Launcher.AppClassLoader.getAppClassLoader(extcl); &#125; catch (IOException var9) &#123; throw new InternalError ("Could not create application class loader", var9); &#125; // 4. 设置 ContextClassLoader 类加载器 Thread.currentThread().setContextClassLoader(this.loader); ... &#125; /* * Returns the class loader used to launch the main application. */ public ClassLoader getClassLoader() &#123; return loader; &#125; // 5. AppClassLoader static class AppClassLoader extends URLClassLoader &#123; ... public static ClassLoader getAppClassLoader(final ClassLoader var0) throws IOException &#123; final String var1 = System.getProperty("java.class.path"); final File[] var2 = var1 == null ? new File[0] : Launcher.getClassPath(var1); return (ClassLoader)AccessController.doPrivileged (new PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123; public Launcher.AppClassLoader run() &#123; URL[] var1x = var1 == null ? new URL[0] : Launcher.pathToURLs(var2); return new Launcher.AppClassLoader(var1x, var0); &#125; &#125;); &#125; AppClassLoader(URL[] var1, ClassLoader var2) &#123; // 6. AppClassLoader 的父加载器设置为 ExtClassLoader super(var1, var2, Launcher.factory); this.ucp.initLookupCache(this); &#125; ... &#125; // 7. ExtClassLoader static class ExtClassLoader extends URLClassLoader &#123; public static Launcher.ExtClassLoader getExtClassLoader() throws IOException &#123; final File[] var0 = getExtDirs(); try &#123; return (Launcher.ExtClassLoader)AccessController.doPrivileged (new PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123; public Launcher.ExtClassLoader run() throws IOException &#123; ... return new Launcher.ExtClassLoader(var0); &#125; &#125;); &#125; catch (PrivilegedActionException var2) &#123; throw (IOException)var2.getException(); &#125; &#125; void addExtURL(URL var1) &#123; super.addURL(var1); &#125; public ExtClassLoader(File[] var1) throws IOException &#123; // 8. ExtClassLoader 的父加载器为 null // 实际其父加载器默认为 BootstrapClassLoader super(getExtURLs(var1), (ClassLoader)null, Launcher.factory); SharedSecrets.getJavaNetAccess() .getURLClassPath(this).initLookupCache(this); &#125; private static File[] getExtDirs() &#123; String var0 = System.getProperty("java.ext.dirs"); ... &#125; ... &#125; ...&#125; Launcher, ExtClassLoader, AppClassLoader 三个类的构造方法： Launcher依次实例化 ExtClassLoader, AppClassLoader，并将 ExtClassLoader 的实例传递给 AppClassLoader；设置当前线程的加载器 setContextClassLoader，即每个线程默认加载器是 AppClassLoader。 ExtClassLoader其父加载器设置为空 null，虚拟机默认 null 为启动类加载器，即其父加载器是 BootstrapClassLoader 。 AppClassLoader其父加载器设置为 ExtClassLoader。 各个类加载器对应的属性从上面 Launcher 的源码中也可以看出，各个加载器的路径都是通过属性来读取的： 启动类加载器 Bootstrap ClassLoader：sun.boot.class.path 扩展类加载器 Extension ClassLoader：java.ext.dirs 应用程序类加载器 Application ClassLoader：java.class.path ClassLoader 源码分析ClassLoader 包含几个重要的方法，其中 ClassLoader.loadClass 中实现了双亲委派模型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192public abstract class ClassLoader &#123; ... public Class&lt;?&gt; loadClass(String var1) throws ClassNotFoundException &#123; return this.loadClass(var1, false); &#125; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded // 1. 先确认类是否已经被加载 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; // 2. 如果没有被加载，父加载器是否为空 // 不为空则父加载器加载，依次递归 c = parent.loadClass(name, false); &#125; else &#123; // 3. 父加载器为空，则启动类加载器加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader // 4. 如果父加载器抛出 ClassNotFoundException // 说明父加载器无法完成类加载请求 &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); // 5. 父加载器无法完成加载或者其他原因没有加载成功 // 则调用本身的 findClass 进行类加载 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime() .addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime() .addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125; ... public final ClassLoader getParent() &#123; if (this.parent == null) &#123; return null; &#125; else &#123; ... return this.parent; &#125; &#125; protected final Class&lt;?&gt; defineClass(...) throws ClassFormatError &#123; ... &#125; public static ClassLoader getSystemClassLoader() &#123; initSystemClassLoader(); if (scl == null) &#123; return null; &#125; ... return scl; &#125; private static synchronized void initSystemClassLoader() &#123; if (!sclSet) &#123; if (scl != null) throw new IllegalStateException("recursive invocation"); sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); if (l != null) &#123; Throwable oops = null; scl = l.getClassLoader(); ... &#125; sclSet = true; &#125; &#125;&#125; loadClassloadClass 传入的参数是类全名，比如：com.***.Test, com.***.Test$innerclass，并返回一个 Class 类型的实例。它实现了双亲委派模型，如果父加载器都没有加载成功，则调用 findClass 来查找。 findClassfindClass 方法中直接抛出异常，也就是必须由子类实现。我们自定义类加载器时，通常需要重写 findClass ，而不是 loadClass（会覆盖掉双亲委派）。该方法是 protected 的，也就是外部类并不需要主动调用，参数为 loadClass 传入的类全名。 getParent获取父加载器。 defineClass有多个重载方法，作用是将一个 byte 数组转换为 Class 类的实例，通常是将 .class 文件转换为二进制数组并通过 defineClass 来获取类实例。这个方法非常重要，将指定类全名的二进制数组转换成运行时内存数据结构，并校验有效性等等。 getSystemClassLoader静态方法，获取系统类加载器。系统类加载器初始化时，会调用 sun.misc.Launcher.getLauncher() ，即 Launcher.AppClassLoader 是 Java 中的系统类加载器。 类加载示例类加载的日志开关，设置 JVM 参数：-verbose:class/-XX:+TraceClassLoading 来打印类加载过程。 子类引用父类静态字段子类不会被初始化，而父类会被初始化。虽然虚拟机没有明确规定是否触发子类加载，但是当前测试虚拟机表现为：只要引用了，父类子类都会被加载。 12345678910111213141516171819public class TestSubClassReferenceSuperStaticFiled &#123; private static class Super&#123; public static int value = 123; static &#123; System.out.println("Super Class Init."); &#125; &#125;private static class Sub extends Super&#123; static &#123; System.out.println("Sub Class Init."); &#125;&#125; public static void main(String[] args) &#123; // SubClass not init. System.out.println("Sub.value = " + Sub.value); &#125;&#125; 类加载过程及输出结果： 123456789101112131415[Opened /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Object from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...// 1. 父类、子类、测试类都被加载[Loaded TestSubClassReferenceSuperStaticFiled from file:/home/xmt/test/classloading/][Loaded java.lang.Void from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded TestSubClassReferenceSuperStaticFiled$Super from file:/home/xmt/test/classloading/][Loaded TestSubClassReferenceSuperStaticFiled$Sub from file:/home/xmt/test/classloading/]...// 2. 父类初始化Super Class Init.// 3. 结果输出Sub.value = 123[Loaded java.lang.Shutdown from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar] 测试结果可以看出，父类、子类、测试类都被加载，但是只执行了父类初始化阶段，子类没有被初始化。 数组定义的引用类123456789101112public class TestClassArray &#123; private static class Test&#123; static &#123; System.out.println("Test Class Init."); &#125; &#125; public static void main(String[] args) &#123; Test[] tests = new Test[3]; System.out.println("Array length = " + tests.length); &#125;&#125; 类加载过程及输出结果： 123456789101112[Opened /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Object from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...// 1. 类加载阶段[Loaded TestClassArray from file:/home/xmt/test/classloading/][Loaded java.lang.Void from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded TestClassArray$Test from file:/home/xmt/test/classloading/]...// 2. 结果输出Array length = 3[Loaded java.lang.Shutdown from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar] 测试结果可以看出，只有类加载阶段，没有被初始化。 静态字段123456789101112131415161718192021public class TestStaticField &#123; private static class Test&#123; static final String STATIC_STR= "TestStaticFieldStr"; static final String STATIC_TIME = System.currentTimeMillis() + ""; static &#123; System.out.println("Test Class Init."); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // do not loading class System.out.println("STATIC FINAL STR: " + Test.STATIC_STR); System.out.println("***********************************"); // loading &amp; init class: Test System.out.println("STATIC FINAL TIME: " + Test.STATIC_TIME); Thread.sleep(1000); // STATIC_TIME value assigned when class loading. System.out.println("STATIC FINAL TIME: " + Test.STATIC_TIME); &#125;&#125; 上面源码中，静态字段 STATIC_STR 是字符串常量；而 STATIC_TIME 虽然也是静态常量，但是需要在运行时才能确定。 123456789101112131415161718[Opened /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Object from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...// 1. 加载测试类 TestStaticField[Loaded TestStaticField from file:/home/xmt/test/classloading/]...// 2. 直接输出静态常量结果，没有执行 Test 类初始化，甚至类加载阶段都没有STATIC FINAL STR: TestStaticFieldStr***********************************// 3. 加载类 Test[Loaded TestStaticField$Test from file:/home/xmt/test/classloading/]// 4. Test 类初始化，并在运行时对 STATIC_TIME 赋值Test Class Init.STATIC FINAL TIME: 1525837181577// 5. STATIC_TIME 被 final 修饰，只会被赋值一次STATIC FINAL TIME: 1525837181577[Loaded java.lang.Shutdown from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar] 静态字段 STATIC_STR编译时确定，属于常量，不会触发类初始化，甚至不会进入类加载阶段。 静态字段 STATIC_TIME运行时确定，会触发类初始化并运行代码计算时间。STATIC_TIME 被 final 修饰，只会被赋值一次。 反射类加载和初始化不同阶段1234567891011121314151617181920212223242526public class TestClassLoadingAndInit &#123; private static class Tester&#123; static &#123; System.out.println("Tester Class Init."); &#125; &#125; private static class TesterForName&#123; static &#123; System.out.println("TesterForName Class Init."); &#125; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; String TesterClassName = "com.***.TestClassLoadingAndInit$Tester"; ClassLoader classLoader = ClassLoader.getSystemClassLoader(); System.out.println("Test Class loading..."); classLoader.loadClass(TesterClassName); System.out.println("**********************"); System.out.println("TesterForName Class loading and init."); String testForName = "com.***.TestClassLoadingAndInit$TesterForName"; Class.forName(testForName); &#125;&#125; 类加载阶段、类初始化阶段的输出结果： 12345678910111213141516[Opened /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Object from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...// 1. 加载测试类 TestClassLoadingAndInit[Loaded TestClassLoadingAndInit from file:/home/xmt/test/classloading/]...Tester Class loading...// 2. ClassLoad.loadClass 仅仅会触发 Tester 类加载[Loaded TestClassLoadingAndInit$Tester from file:/home/xmt/test/classloading/]**********************TesterForName Class loading and init.// 3. Class.forName 会触发 TesterForName 类加载及类初始化[Loaded TestClassLoadingAndInit$TesterForName from file:/home/xmt/test/classloading/]TesterForName Class Init.[Loaded java.lang.Shutdown from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar] 反射过程中，这两个阶段分别由不同方法触发： 类加载阶段ClassLoad.loadClass 仅仅会触发类加载阶段。 类初始化阶段Class.forName 会触发类加载及类初始化阶段，默认使用调用类的类加载器进行类加载。 类初始化顺序虚拟机会确保子类初始化之前会执行父类初始化。 1234567891011121314151617181920212223public class TestClassInitSeq &#123; private static class Father&#123; static &#123; value = 2; // Illegal forward reference. // System.out.println(value); System.out.println("Father Class Init."); &#125; static int value = 1; &#125; private static class Son extends Father&#123; static int number = 3; static &#123; System.out.println("Son Class Init."); &#125; &#125; public static void main(String[] args) &#123; System.out.println("Son.number = " + Son.number); &#125;&#125; 在静态代码块中，只能对定义在之后的静态变量赋值，不能访问！否则会提示 Illegal forward reference. 。 12345678910111213141516[Opened /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Object from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...// 1. 加载测试类 TestClassInitSeq[Loaded TestClassInitSeq from file:/home/xmt/test/classloading/][Loaded java.lang.Void from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]// 2. 先加载父类，再加载子类[Loaded TestClassInitSeq$Father from file:/home/xmt/test/classloading/][Loaded TestClassInitSeq$Son from file:/home/xmt/test/classloading/]...// 3. 先初始化父类，再初始化子类Father Class Init.Son Class Init.Son.number = 3[Loaded java.lang.Shutdown from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar] 父类 &lt;clinit&gt;() 方法会优先于子类 &lt;clinit&gt;() 方法执行。 类加载器默认属性和父加载器123456789101112131415public class TestPropAndParent &#123; public static void main(String[] args) &#123; System.out.println("Boot: " + System.getProperty("sun.boot.class.path")); System.out.println("Ext: " + System.getProperty("java.ext.dirs")); System.out.println("App: " + System.getProperty("java.class.path")); System.out.println("SystemLoader: " + ClassLoader.getSystemClassLoader()); System.out.println("Parent: " + ClassLoader.getSystemClassLoader().getParent()); System.out.println("GrandFather: " + ClassLoader.getSystemClassLoader().getParent().getParent()); &#125;&#125; 运行结果： 1234567xmt@server005:~/$ java TestPropBoot: /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/resources.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/sunrsasign.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jsse.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jce.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/charsets.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rhino.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/lib/jfr.jar:/usr/lib/jvm/java-7-openjdk-amd64/jre/classesExt: /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/ext:/usr/java/packages/lib/extApp: .:/usr/lib/jvm/java-1.7.0-openjdk-amd64/lib/dt.jar:/usr/lib/jvm/java-1.7.0-openjdk-amd64/lib/tools.jarSystemLoader: sun.misc.Launcher$AppClassLoader@18b4aac2Parent: sun.misc.Launcher$ExtClassLoader@75b84c92GrandFather: null 系统默认的类加载器为 AppClassLoader，其父加载器为 ExtClassLoader。而 ExtClassLoader 的父加载器为 null ，虚拟机默认其为启动类加载器。 自定义类加载器自定义加载器的主要步骤： 获取字节数组读取本地 class 文件转换为数组，或者从网络等其他地方读取到二进制字节流并转换为数组。 defineClass 转换将字节数组转换为方法区的运行时数据结构。 重写 loadClass/findClass 方法加载推荐重写 findClass 方法自定义加载类，loadClass 很容易破坏双亲委派模型。 重写 loadClass 方法注意：在重写 loadClass 时，需要调用 super.loadClass 尽量保留双亲委派模型来处理父类。对于任一个类：都需要由类加载器和这个类本身一同确立其在虚拟机中的唯一性。如下为自定义类加载器并验证 instanceof 判断类是否相同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestClassInstanceOf &#123; public static void main(String[] args) throws Exception&#123; // 1. 自定义类加载器，重写 loadClass ClassLoader classLoader = new ClassLoader() &#123; @Override public Class&lt;?&gt; loadClass(String s) throws ClassNotFoundException &#123; try &#123; String fileName = s.substring(s.lastIndexOf(".") + 1) + ".class"; System.out.println("fileName = " + fileName); // 增加堆栈打印 log，查看调用信息 new Exception("This is a log.").printStackTrace(System.out); InputStream inputStream = getClass() .getResourceAsStream(fileName); // 2. 如果找不到 class 文件，交给父类执行双亲委派模型加载 if (inputStream == null) &#123; System.out.println("cant find class file: " + s); return super.loadClass(s); &#125; byte[] data = new byte[inputStream.available()]; inputStream.read(data); // 3. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 System.out.println("defineClass."); Class clazz = defineClass(s, data, 0, data.length); System.out.println("clazz = " + clazz); return clazz; &#125;catch (IOException e)&#123; throw new ClassNotFoundException(s); &#125; &#125; &#125;; // 4. 使用自定义类加载器加载 Class clazz = classLoader.loadClass("com.***.TestClassInstanceOf"); System.out.println("clazz loader: " + clazz.getClassLoader()); Object object = clazz.newInstance(); // 5. 打印当前自定义类加载器加载的类 System.out.println("object = " + clazz.getClass()); // 判断和系统加载器加载的是否为同一个类 System.out.println("the same class but two different classLoaders, " + " instanceof = " + (object instanceof TestClassInstanceOf)); &#125;&#125; 测试结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[Opened /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Object from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...// 1. 系统加载器加载: TestClassInstanceOf 和自定义类加载器[Loaded TestClassInstanceOf from file:/home/xmt/test/classloading/][Loaded TestClassInstanceOf$1 from file:/home/xmt/test/classloading/]...// 2. 自定义类加载器开始加载：TestClassInstanceOf fileName = TestClassInstanceOf.class[Loaded java.lang.Throwable$PrintStreamOrWriter from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar]...java.lang.Exception: This is a log. at TestClassInstanceOf$1.loadClass(TestClassInstanceOf.java:12) at TestClassInstanceOf.main(TestClassInstanceOf.java:30)// 3. defineClass 中会递归加载 TestClassInstanceOf 的父类 Object// 自定义加载器中，父类由双亲委派模型处理fileName = Object.classjava.lang.Exception: This is a log. at TestClassInstanceOf$1.loadClass(TestClassInstanceOf.java:12) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:800) at java.lang.ClassLoader.defineClass(ClassLoader.java:643) at TestClassInstanceOf$1.loadClass(TestClassInstanceOf.java:21) at TestClassInstanceOf.main(TestClassInstanceOf.java:30)cant find class file: java.lang.Object// 4. 自定义类加载器：从虚拟机中成功加载 TestClassInstanceOf// 将字节文件转换为方法区的运行时数据结构[Loaded TestClassInstanceOf from __JVM_DefineClass__]clazz = class TestClassInstanceOf// 5. 对类 TestClassInstanceOf 进行反射调用时，触发类加载过程的类初始化阶段// 初始化阶段：如果类没有初始化，需要先触发类初始化；如果父类没有初始化，先触发父类初始化// 这里触发的是自定义类加载器自身及其父类 ClassLoad 的类初始化// 父类 ClassLoad 类加载由双亲委派模型去处理fileName = ClassLoader.classjava.lang.Exception: This is a log. at TestClassInstanceOf$1.loadClass(TestClassInstanceOf.java:12) at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2595) at java.lang.Class.getConstructor0(Class.java:2895) at java.lang.Class.newInstance(Class.java:354) at TestClassInstanceOf.main(TestClassInstanceOf.java:32)cant find class file: java.lang.ClassLoader// 6. 自定义类加载器开始加载自己： TestClassInstanceOf$1fileName = TestClassInstanceOf$1.classjava.lang.Exception: This is a log. at TestClassInstanceOf$1.loadClass(TestClassInstanceOf.java:12) at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2595) at java.lang.Class.getConstructor0(Class.java:2895) at java.lang.Class.newInstance(Class.java:354) at TestClassInstanceOf.main(TestClassInstanceOf.java:32)defineClass.// 7. 自定义类加载器：从虚拟机中成功加载自己 TestClassInstanceOf$1[Loaded TestClassInstanceOf$1 from __JVM_DefineClass__]clazz = class TestClassInstanceOf$1// 8. 使用 instanceof 比较，同一个类不同类加载器加载后，并不相等object = class TestClassInstanceOfthe same class but two different classLoaders, instanceof = false[Loaded java.lang.Shutdown from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar][Loaded java.lang.Shutdown$Lock from /usr/lib/jvm/java-7-openjdk-amd64/jre/lib/rt.jar] 重写 loadClass 方法的注意事项： 如果找不到指定 class 文件，调用父类方法处理当找不到指定 class 文件时，需要父类方法的双亲委派模型处理，比如 defineClass 会加载父类，而很多基础父类组件如 Object 是三大父加载器加载的。 被加载类 class 文件位置因为重写 loadClass 可以直接避开双亲委派模型，所以任意位置的 class 文件都可以正确解析。 疑问：自定义类加载器为什么要加载自己 TestClassInstanceOf$1 ? 如果将自定义类加载器改为 static class 静态内部类，则不会加载自己。反编译 TestClassInstanceOf$1.class 文件，可以发现 static 方法内的匿名内部类，反编译后是一个 final class，而且和静态内部类一样，不会引用外部类 this 。 重写 findClass 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 被加载测试类，它的 class 文件不能放在：自定义类加载器文件的当前目录及其子目录中// 否则会因为双亲委派模型，被系统加载器扫描到并加载// 当前示例放在 javabase/src/main/resources/ 目录下public class Test &#123; static &#123; System.out.println("Test.class file is loaded by: " + Test.class.getClassLoader()); &#125; public void test()&#123; System.out.println("It is Test::test."); &#125;&#125;// 自定义类加载器public class MyClassLoader extends ClassLoader&#123; // Test.class file dir // 指定被加载 class 文件的路径 private String mClassFileDir; public MyClassLoader(String classFileDir) &#123; mClassFileDir = classFileDir; &#125; @Override protected Class&lt;?&gt; findClass(String s) throws ClassNotFoundException &#123; System.out.println("MyClassLoader::findClass"); Class clazz = null; try &#123; // 根据类全名查找对应的 class 文件，读取后转化为数组 byte[] data = loadClassData(s); if (data != null) &#123; // 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 clazz = defineClass(s, data, 0, data.length); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; if (clazz == null)&#123; throw new ClassNotFoundException(s); &#125; System.out.println("MyClassLoader::findClass, clazz = " + clazz); return clazz; &#125; private byte[] loadClassData(String s) throws IOException &#123; // 判断给定的 class 文件目录，及对应的 class 文件是否存在 File dir = new File(mClassFileDir); if (!dir.exists())&#123; throw new IOException("mClassFileDir is not exists."); &#125; String fileName = s + ".class"; File classFile = new File(dir.getAbsolutePath(), fileName); if (!classFile.exists())&#123; throw new IOException(fileName + " file is not exists."); &#125; System.out.println("loadClassData: classFilePath = " + classFile.getAbsolutePath()); // 如果 class 文件存在，读取到数组中 byte[] data = null; FileInputStream fileInputStream = new FileInputStream(classFile); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int count = 0; while ((count = fileInputStream.read()) != -1) &#123; byteArrayOutputStream.write(count); &#125; data = byteArrayOutputStream.toByteArray(); return data; &#125;&#125;// 测试自定义类加载器public class TestCustomClassLoader &#123; public static void main(String[] args) &#123; // 指定 class 文件所在目录 String classFileDir = "javabase/src/main/resources/"; MyClassLoader myClassLoader = new MyClassLoader(classFileDir); try &#123; // 使用自定义类加载器加载，并实例化 Class testReflect = myClassLoader.loadClass("Test"); Object object = testReflect.newInstance(); Method method = testReflect.getMethod("test", null); // 调用被加载类的测试方法 method.invoke(object, null); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125;// 输出结果MyClassLoader::findClassloadClassData: classFilePath = C:\Users\xmt\***\src\main\resources\Test.classMyClassLoader::findClass, clazz = class TestTest.class file is loaded by: com.***.classloading.MyClassLoader@6bc7c054It is Test::test. 重写 findClass 方法的注意事项： 被加载类 class 文件位置被加载类 Test.class 文件，不能放在 MyClassLoader 文件所在目录及其子目录中。重写 findClass 保留了双亲委派模型，会被 AppClassLoader 系统加载器扫描到并加载，自定义加载器无法生效。在 Android Studio 中，这个 class 文件甚至不能直接由 AS 生成。打印 AppClassLoader 加载路径为：...;C:\Users\xmt\AndroidStudioProjects\xmt\gitlab\04_androidbasic\android_basic_knowledge\javabase\build\classes\java\main;...，也就是说，所有由 AS 工具生成的 class 文件都会默认被系统加载器加载。 自定义加载器判断传入的 class 文件目录及对应文件是否存在，如果存在则先转换为数组，并通过 defineClass 将二进制文件转换为运行时数据结构。 后续 线程上下文加载器 Android 类加载机制 参考文档 疯狂 Java 讲义-第二版 – 第 18 章 类加载机制与反射 深入理解 Java 虚拟机: JVM 高级特性与最佳实践 第 2 版 - 第 7 章 虚拟机类加载机制 sun: Launcher.java 超详细java中的ClassLoader详解 深入理解Java类加载器(一)：Java类加载原理解析 Understanding Extension Class Loading JVM常见问题-类加载机制 深入浅出ClassLoader Dynamic Class Loading and Reloading 深入理解Java类加载器]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解 Annotation]]></title>
    <url>%2F2018%2F04%2F27%2F0077-java-annotation%2F</url>
    <content type="text"><![CDATA[Java 注解 Annotation：代码中的特殊标记，这些标记可以在编译、类加载、运行时读取，并执行相应的解析处理。注解本身并不影响代码以及运行结果，只有在解析这些注解后才会生效。 Annotation 很像一个接口（反编译后发现注解就是一个接口），通过 @interface 修饰来，同一个文件中只能有一个 Annotation 的定义。 元注解元注解 Meta Annotation，用来修饰其他 Annotation ，即表示“其他注解”的注解。 @Retention用于指定被修饰 Annotation 能保留多长时间。包含三个 RetentionPolicy 类型的 value 成员变量： RetentionPolicy.SOURCE注解只保留在源代码中，编译时直接丢弃这些注解。 RetentionPolicy.CLASS编译器将注解记录在 class 文件中，在运行时 JVM 不再保留注解。它也是@Retention 的默认值。 RetentionPolicy.RUNTIME编译器不仅将注解记录在 class 文件中，运行时 JVM 也会保留注解。也就是说程序想通过反射来获取注解信息，则必须使用 RUNTIME 类型。 使用 @Retention 的示例： 12345@Retention(value = RetentionPolicy.RUNTIME)public @interface Testable&#123;&#125;@Retention(RetentionPolicy.CLASS)public @interface Testable&#123;&#125; @Target只能用来修饰一个 Annotation 的定义，用于指定被修饰的 Annotation 能够修饰哪些程序元素。包含如下 ElementType 类型的 value 成员变量： ElementType.TYPE：指定该注释可以修饰类、接口或枚举 ElementType.FIELD：指定该注解只能修饰成员变量 ElementType.METHOD：指定该注解只能修饰方法 ElementType.PARAMETER：指定该注解只能修饰参数 ElementType.CONSTRUCTOR：指定该注解只能修饰构造器 ElementType.LOCAL_VARIABLE：指定该注解只能修饰局部变量（不能通过反射解析，class 文件并不保留局部变量注解。只能通过源码在编译前解析） ElementType.ANNOTATION_TYPE：指定该注解只能修饰注解 ElementType.PACKAGE：指定该注解只能修饰包定义 ElementType.TYPE_PARAMETER：指定该注解只能参数化类型 ElementType.TYPE_USE：指定该注解可以修饰上面几种任意类型 如果需要指定多个 ElementType 类型的成员变量，使用数组赋值。 1234567// 修饰单个元素@Target(ElementType.METHOD)public @interface Testable &#123;&#125;// 修饰多个元素@Target(value = &#123;ElementType.METHOD, ElementType.FILED&#125;)public @interface Testable2 &#123;&#125; @Documented修饰其他 Annotation 时，通过 javadoc 工具提取文档会保留这个 Annotation 信息。 123456789101112@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Testable&#123;&#125;public class Test&#123; /** * This is testable method. */ @Testable public void myJavaDocInfo()&#123;...&#125;&#125; javadoc 生成文档时，myJavaDocInfo 方法文档会保留 @Testable 信息。如果 Testable 的元注解中去掉 @Documented，则生成的文档不会保留 @Testable 信息。 @Inherited修饰其他 Annotation 时，表示该注解具有继承性。比如 @A 被 @Inherited 注解，@A 注解父类，则其所有子类自动被 @A 注解。 1234567891011121314151617181920// 1. Annotation@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface Inheritable &#123;&#125;// 2. Father@Inheritablepublic class Father &#123;&#125;// 3. Sonpublic class Son extends Father &#123; public static void main(String[] args) &#123; System.out.println(Son.class.isAnnotationPresent(Inheritable.class)); &#125;&#125;// 4. Resulttrue 运行结果显示，虽然 Son 并没有被 Inheritable 注解，但是自动从 Father 那继承了该注解。 @RepeatableJava 8 加入的新特性，表示注解中相同元素的值可以取多个。比如某个类需要扮演多个角色：医生、护士、警察。在 Java 8 之前是不允许有相同注解重复的。 1234567891011121314151617181920212223242526272829303132333435// 1. 定义角色注解 @Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Role &#123; String name() default "role";&#125;// 2. 定义角色数组，用来存储多个角色@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface Roles &#123; Role[] value();&#125;// 3. 回过头来，将 Role 定义为可重复@Documented@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Repeatable(Roles.class)public @interface Role &#123; String name() default "role";&#125;// 4. 使用示例// 单独重复使用@Role(name = "doctor")@Role(name = "nurse")public static class RepeatAnn&#123;&#125;// 使用数组@Roles(&#123;@Role(name="doctor"), @Role(name="policeman")&#125;)public static class Annotations&#123;&#125; 元注解的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 1. Retention@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125;public enum RetentionPolicy &#123; //Annotations are to be discarded by the compiler. SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125;// 2. Target@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125;public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 * @hide 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 * @hide 1.8 */ TYPE_USE&#125;// 3. Documented@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125;// 4. Inherited@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125;// 5. Repeatable@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123; /** * Indicates the &lt;em&gt;containing annotation type&lt;/em&gt; for the * repeatable annotation type. * @return the containing annotation type */ Class&lt;? extends Annotation&gt; value();&#125; 自定义注解自定义注解使用 @interface 作为关键字。 定义格式，注意成员变量后有个双括号 ()，以 ; 结尾： 123访问控制符 @interface 注解名称&#123; 返回类型 成员变量名() default 默认值;&#125; 标记 Annotation如果没有定义成员变量，则该注解被称为标记。这种注解仅仅利用自身存在来给我们提供信息，比如 @Override 等等。 12@Target(ElementType.PARAMETER)public @interface TestPara&#123;&#125; 元数据 Annotation包含成员变量，他们可以接受更多的元数据，每个成员变量可以有默认值，使用 default 关键字。 1234567@Retention(RetentionPolicy.RUNTIME)public @interface MetaAnnotation &#123; String author(); String date(); int currentVersion() default 1; String[] reviewer();&#125; 使用方法格式： 1234@自定义注解(成员变量1=指定值1, 成员变量2=指定值2 成员变量数组=&#123;指定值3, 指定值4&#125;)被注解程序元素 成员变量是以名字和值 name=value 形式成对出现的，如果只有一个，可以省略成员变量名称。被注解元素，是依据 @Target 指定的类型。 123456789101112@MetaAnnotation( author = "xmt", date = "2018.4.27", currentVersion = 2, reviewer = &#123;"a", "b", "c"&#125;)@Role("nurse") // 忽略名称@Roles(value = &#123;@Role(name = "doctor"), @Role(name = "police")&#125;) // 名字值对public class TestAnnotation &#123; private void testPara(@TestPara String para)&#123;...&#125; ...&#125; Java 预置的基本注解@Override@Override 只能注解方法，用来表示方法重写。编译器会检查该方法，保证父类要包含一个被重写的方法，否则会编译报错。 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override &#123;&#125; @Deprecated@Deprecated 用于注解方法，类，字段等，表示该程序元素已过时。当其他程序调用时，编译器会给出警告。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; @SuppressWarnings@SuppressWarnings 注解表示取消显示指定的编译器警告。比如：unused, unchecked, all 等警告。 123456789101112131415161718@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)@Retention(RetentionPolicy.SOURCE)public @interface SuppressWarnings &#123; /** * The set of warnings that are to be suppressed by the compiler in the * annotated element. Duplicate names are permitted. The second and * successive occurrences of a name are ignored. The presence of * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must * ignore any warning names they do not recognize. They are, however, * free to emit a warning if an annotation contains an unrecognized * warning name. * * &lt;p&gt;Compiler vendors should document the warning names they support in * conjunction with this annotation type. They are encouraged to cooperate * to ensure that the same names work across multiple compilers. */ String[] value();&#125; @SafeVarargsJava 7 新增的注解，参数安全类型注解，它的目的是提醒开发者不要用参数做一些不安全的操作。比如堆污染：把一个不带泛型的对象赋给一个带泛型的变量是，就会发生堆污染。 1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD&#125;)public @interface SafeVarargs &#123;&#125; @FunctionalInterfaceJava 8 新增的注解，表示函数式接口注解。函数式接口 Functional Interface：就是只有一个方法的普通接口，使用 @FunctionalInterface 注解后，编译器会检查确保符合规范。 1234@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 其他注解是一种类型注解是具体的类型，可以使用 instanceof 来判断，示例：if (annotation instanceof GET) {...} 。 注解的解析 通过反射处理注解这种处理方式要求注解必须是 @Retention(RetentionPolicy.RUNTIME) 类型的。在运行时，通过反射来获取并解析注解。但是反射比较慢，所以需要考虑效率问题。 编译时处理注释因为反射效率和性能问题，Java 还提供了编译时解析注解并自动生成代码。Java 7 之前可以使用 APT: Annotation Processing Tool 工具提取注解并解析后，生成对应的代码。但是 Java 7 开始降级移除了 APT 并采用 JSR 269: Pluggable Annotation Processing API，原因及说明见官网解释，原因。 参考文档 疯狂 Java 讲义 – 第 14 章 Annotation 注释 官方教程 Annotation 秒懂 Java 注解 Java Annotation 及几个常用开源项目注解原理简析 元注解之 Repeatable Java 8 新特性：扩展注解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM 内存分配及垃圾回收]]></title>
    <url>%2F2018%2F04%2F23%2F0076-java-gc%2F</url>
    <content type="text"><![CDATA[Java 中的内存分配及垃圾回收策略。本文是《深入理解 Java 虚拟机: JVM 高级特性与最佳实践 第 2 版 - 第三章 垃圾收集器与内存分配策略》的读书笔记。 GC [Garbage Collection]：垃圾回收器 。Java 使用 GC 进行内存回收理，不用手动释放内存而提升开发效率。GC 主要完成三件事： 确定哪些内存需要回收 什么时候回收 怎么回收 内存分配虚拟机运行时数据区 如图所示，JVM 内存模型将内存分为： 程序计数器占用一块很小的内存空间，当前线程执行的字节码的行号指示器，用来选取下一条需要执行的字节码。 虚拟机栈每个方法执行时会创建一个栈帧，存储局部变量表，操作数栈等等。局部变量表只保存基本数据类型、对象的引用、返回地址字节码。当方法退出时，虚拟机栈就会自动清空，释放内存。 本地方法栈虚拟机栈是为 Java 服务的，而本地方法栈针对的是 Native 方法的。本地方法栈也是在方法退出时就会释放内存。 堆所有的对象实例和数组都是在堆中分配的内存，是垃圾回收的主要区域，有时候也称为 GC 堆。类的成员变量是在对象实例化时分配在堆中的。 方法区用于保存类信息，常量，静态变量等，也叫 Non-Heap （非堆）。运行时常量池：方法区的一部分，保存类信息，常量池。 通常将内存分为栈和堆，指的就是虚拟机栈和堆，而内存泄露、内存溢出、垃圾回收等都主要针对的是堆内存。程序计数器、虚拟机栈、本地方法栈都是随线程生而生，灭而灭；栈在方法退出时自动清空，而方法区的回收性价比非常低，条件苛刻；所以内存回收主要集中在堆中。 对象访问定位建立对象后，Java 程序需要通过栈上的 reference 数据来操作堆上的对象。Java 采用的是直接指针访问对象，这要求堆对象布局中需要考虑如何放置访问类型数据的相关信息，而 reference 存储的直接就是对象地址。 内存溢出 OutOfMemoryError无法申请到足够的存储空间，都会抛出 OOM。 StackOverflowError虚拟机栈和本地方法栈，如果请求的栈深度大于虚拟机允许的最大深度，将会抛出 StackOverflowError。 它们都不属于 Exception 的子类，所以 catch 时，只能使用 Throwable。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 1. OutOfMemoryErrorpublic class TestOutOfMemory &#123; private static final int _1M = 1024 * 1024; public static void main(String[] args) &#123; List&lt;byte[]&gt; list = new ArrayList&lt;&gt;(); int count = 0; boolean flag = true; while (flag)&#123; try &#123; list.add(new byte[_1M]); count++; &#125;catch (Throwable e)&#123; e.printStackTrace(); flag = false; System.out.println("count = " + count); &#125; &#125; &#125;&#125;// Resultcount = 1697java.lang.OutOfMemoryError: Java heap space at com.***.jvm.TestOutOfMemory.main(TestOutOfMemory.java:15)// 2. StackOverflowErrorpublic class TestStackOverFlow &#123; private static int index; private void call()&#123; index++; call(); &#125; public static void main(String[] args) &#123; TestStackOverFlow stackOverFlow = new TestStackOverFlow(); try &#123; stackOverFlow.call(); &#125;catch (Throwable e)&#123; System.out.println("Stack deep: " + index); e.printStackTrace(); &#125; &#125;&#125;// ResultStack deep: 11413java.lang.StackOverflowError at com.***.jvm.TestStackOverFlow.call(TestStackOverFlow.java:7) at com.***.jvm.TestStackOverFlow.call(TestStackOverFlow.java:8) at com.***.jvm.TestStackOverFlow.call(TestStackOverFlow.java:8) ... 垃圾对象的判断GC 之前要判断回收哪些内存？Java 中采用的是可达性分析算法来判断的。 引用计数算法引用计数算法：给对象添加一个引用计算器，每当有一个地方引用它时，计数器自动加 1；当引用失效时，计数器自动减 1。当计算器为 0 时，表示该对象没有被引用了。引用计数算法使用非常广泛，但是 Java 中并没有选用它来管理内存，最主要的原因是它很难解决对象之间相互循环引用的问题。 可达性分析算法可达性分析算法：通过一系列的称为 GC Roots 的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链 Reference Chain，当一个对象到 CC Roots 没有任何引用链相连（即图论中的，GC Roots 到达这个对象是不可达的），则证明此对象是不可用的。 如果对象 C 是可达的，则认为该对象是被引用的，GC 不会回收。如果对象 F 或者块 E（多个对象引用组成的对象块）是不可达的，那么该对象或者块则判定是不可达的垃圾对象，GC 会回收。 可作为 GC Roots 的对象包含如下几种： 虚拟机栈（栈帧中的局部变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI （即 Native 方法）引用的对象 换句话说，如果对象被上面这几种对象引用，则无法被回收。通常在内存泄露和优化时，从这几种对象着手分析。 对象引用的四种分类 强引用 Strong Reference最常见的应用： Object obj = new Object()，这类引用就是强引用，也就是我们一般声明对象是时虚拟机生成的引用。垃圾回收时需要严格判断当前对象是否被强引用，只要强引用还存在，则不会被垃圾回收。 软引用 Soft Reference使用 SoftReference 类来实现软引用，用来描述有用但并非必需的对象。对于软引用关联着的对象在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。在系统要发生内存溢出异常之前，会将这些对象进行回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。换句话说，虚拟机在发生 OutOfMemory 时，肯定是没有软引用存在的。 弱引用 Weak Reference使用 WeakReference 类来实现弱引用，用来描述非必需对象，但是强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾回收发生时，无论当前内存是否足够，被弱引用关联的对象都会被回收，因此其生命周期只存在于一个垃圾回收周期内。 总结软引用：当虚拟机内存不足时（内存溢出，OOM 之前），会回收它指向的对象。弱引用：随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收，每次 GC 都会回收。软引用多用作来实现缓存机制（cache），而弱引用一般用来防止内存泄漏，要保证内存被虚拟机回收。 在垃圾回收前，弱引用可以确保对象被回收，可以规避内存泄露。 finalize 方法可达性分析中不可达对象，也并不是必须被回收。GC 在回收对象之前会调用 finalize方法，我们可以在该方法中再次引用对象达到复活。但是 finalize 方法最多只会被系统调用一次，或者不调用。JVM 作者建议忘掉这个方法的存在，这个方法运行的不确定性太大，无法保证 GC 时一定会调用该方法。 堆内存及 GC 分类堆内存分类Java 中为了方便优化 GC 性能，将堆划分成两个不同的区域： 新生代 Young新生代内部被划分为三个区域：Eden[&#39;i:dn], From Survivor[sərˈvaɪvə(r)], To Survivor，即 Eden 区和两个 Survivor 区。 老年代 Old JVM 默认配置中，通常新生代占用 1/3, 老年代占用 2/3；在新生代中 Eden:From:To 的比率为 8:1:1。详细划分图如下： 新生代和老年代的比率，以及 Eden 和两个 Survivor 的比率，都可以可以通过 JVM 参数（–XX:NewRatio, –XX:SurvivorRatio）来设置。参数含义详见“ JVM 常见参数”中的描述。 GC 分类 Minor GC通常指发生在新生代的垃圾回收动作，因为 Java 对象大多数具有朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也非常快。 Full GCFull GC 前通常默认至少会执行一次 Minor GC（并非绝对），Full GC 速度一般会比 Minor GC 慢 10 倍以上。Full GC 是对整个 Java 堆回收，包含：新生代，老年代，永久代（或者元空间）。Major GC 通常是跟 Full GC 是等价的，但有时特指回收老年代。 GC 停顿，GC 进行时停顿所有的 Java 执行线程，即 STW: Stop The World 。所以 GC 过于频繁或者时间过长，将会显著影响到程序的运行。 参考：各GC的区别 ，Minor GC、Major GC和Full GC之间的区别 常见垃圾收集算法垃圾收集算法的实现各虚拟机平台实现各不相同，但是算法思想基本一致。 标记清除算法 Mark-Sweep标记清除算法：也是最基础的收集算法，分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。其他收集算法基本都是基于这种思路并对不足进行改进的，该算法的不足之处有两个： 效率问题标记和清除两个阶段效率都不高。 空间问题标记清除后会产生大量不连续的内存碎片，空间碎片太多会导致后续分配大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法 Copying复制算法：将内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存用完后，将还存活的对象复制到另一块上面，然后将使用完的这块内存空间一次全部清理掉。这样每次都是对整个半区进行内存回收，只要移动堆顶指针，按顺序分配内存即可，实现简单高效。解决了 Mark-Sweep 的效率问题，同时也不用考虑内存碎片。但是 Copying 算法是将内存缩小为原来的一半，代价太高。 标记整理算法 Mark-Compact标记整理算法：标记过程仍然与“标记-清除”算法一样，但后续并不会直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。 垃圾收集器 Serial 收集器Serial 收集器是最基本的，发展最悠久的收集器。它是一个单线程收集器，使用复制算法。 ParNew 收集器它是 Serial 的多线程版本。 Parallel Scavenge 收集器使用复制算法，并行多线程收集器。它有一个更重要的功能：GC 自适应调节策略，由虚拟机来决定内存调优。该收集器相对于其他收集器更关注吞吐量（运行代码时间 / (运行代码时间 + 垃圾收集时间)），也就是它可能为了吞吐量主动触发 Full GC，或者不触发 GC，以确保吞吐量最优。 Serial Old 收集器它是 Serial 收集器的老年代版本，单线程，标记整理算法。 Parallel Old 收集器它是 Parallel Scavenge 收集器的老年代版本，多线程，标记整理算法。 CMS 收集器CMS: Concurrent Mark Sweep，是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法，并发收集，低停顿。 G1 收集器G1: Garbage First，它将堆内存区域划分为多个大小相等的独立区域，虽然保留了新生代和老年代的概念，但是新生代和老年代将不再是物理隔离，他们都是独立区域集合。这和其他收集器直接划分为新生代老年代有非常大的区别。 其中 ? 部分就是 G1 收集器。ParNew 和 Parallel Scavenge 最大的区别是，Parallel Scavenge 不能与 CMS 配合工作。参考：收集器分类 堆内存回收策略分代收集算法商业虚拟机的垃圾回收通常采用“分代收集 Generational Collection ”算法，它并没有引入新的算法，而是针对新生代和老年代的特点采用适当的算法。 新生代通常会有大量对象创建及死亡，只有少量对象存活，采用复制算法。 老年代对象存活率高，而且也没有额外的空间担保，使用“标记-清理”或者“标记-整理”算法。 对象分配 优先 Eden 区Java 对象大多数具有朝生夕灭的特性，所以新创建的对象通常优先分配在新生代堆中，默认为 Eden 和 From 区，也就是说新生代的可用内存空间默认为整个新生代容量的 90%，剩下 10% 为复制算法备用空间。当没有足够空间进行分配时，虚拟机发起一次 Minor GC。但是对象回收时，无法确保只有不多于 10% 的对象存活，如果 To Survivor 空间不够，需要老年代进行分配担保，也就是说超出空间的对象直接会进入老年代。如果新生代 GC 的平均晋升大小比目前老年代剩余空间大，则会触发一次 Full GC。 大对象直接分配在老年代所谓大对象是指需要大量连续内存空间的对象，最典型的大对象就是很长的字符串和数组。JVM 可以通过设置 -XX:PretenureSizeThreshold 来决定对象大小门限值，如果超过指定值的对象直接分配到老年代，避免垃圾回收时在新生代中发生大量的内存复制。不过这个参数只对 Serial 和 ParNew 收集器生效。 长期存活对象进入老年代虚拟机给每个对象定义一个对象年龄 Age 计数器。如果对象在 Eden 出生并经历过一次 Minor GC 后仍然存活，并且有足够的空间移动到 To Survivor 区，此时将对象年龄设为 1 。后续对象在 To Survivor 区，每熬过一次 Minor GC ，年龄都会加 1，当年龄到达一定程度（默认为 15），它将会被晋升到老年代中。可以通过设置 -XX:MaxTenuringThreshold 来设置这个晋升阀值。 动态对象年龄判断当 To Survivor 空间相同年龄所有对象大小的总和大于 To Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到 -XX:MaxTenuringThreshold 要求的年龄。 实际上：对象优先分配到 Eden 堆，但是是否进入老年代或者晋升老年代，这些和垃圾收集器强相关，和下面的 GC 触发机制一样，并没有严格定义。 GC 触发机制根据上面对象分配规则，不同场景触发 GC 类型不一样。大体的触发条件：Eden 区满了就会触发新生代 GC；新生代晋升时如果老年代剩余空间不足会触发 Full GC。具体参考：各GC的区别及触发条件总的来讲：GC 触发条件取决于 JVM 垃圾收集器的算法实现，并没有严格的定义。如果不对收集器算法做深入研究，不用过于关注。Java 8 中调试时，GC Log 会显示基本的触发原因。对象分配和 GC 触发和垃圾收集器的关系，可以参考最下面的 GC 日志中的实例。 方法区回收策略方法区回收条件方法区也存在垃圾回收，只是回收效率和性价比非常低。方法区会回收两部分内容：废弃常量和无用的类。类被回收时才会卸载，但是方法区回收类时条件比较严格，只有同时满足以下三个条件，才会回收： 该类所有的实例都已经被回收（GC），也就是虚拟机中不存在该 Class 的任何实例 加载该类的 ClassLoader 已经被回收（GC） 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问改类的方法静态变量在类没有被销毁，也没有置 null 的情况下，是不会被回收的（GC）。 回收废弃常量和回收堆中对象非常类似，判断一个废弃常量比较简单：假如这个常量没有被任何地方引用，当方法区出现内存回收并且有必要的情况下，该常量就会被清理出常量池。 方法区存储空间各版本的区别方法区的存储空间在不同的虚拟机中有不同的实现， HotSpot 中被称为永久代（PermGen Space），而 JRockit(Oracle) 等其他虚拟机并没有永久代。GC 不会在主程序运行期对永久代进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM: java.lang.OutOfMemoryError: PermGen space 异常。而在 Java 8 开始已经不存在永久代，而使用的是元空间 Metaspace。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 native memory, 字符串池和类的静态变量放入堆中。这样可以加载多少类的元数据就不再由 MaxPermSize 控制, 而由系统的实际可用空间来控制。 JVM 常见参数 选项 描述 -Xms 初始堆大小。如：-Xms256m -Xmx 最大堆大小。如：-Xmx512m -Xmn 新生代大小。通常为最大堆的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + From，即 90% 的空间 -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3 -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 -XX:PretenureSizeThreshold 老年代门限值，大小大于这个值的对象直接分配进老年代，这个参数只对 Serial 和 ParNew 收集器生效 -XX:MaxTenuringThreshold 对象从新生代晋升到老年代的年龄阀值，默认为 15 -XX:+PrintGC 开启 GC 打印简单信息，别名 -verbose:gc -XX:+PrintGCDetails 打印 GC 详细信息，通常默认会包含 -XX:+PrintGC 的信息 -XX:+PrintHeapAtGC 打印 GC 前后的堆信息 -Xss JDK1.5+ 每个线程堆栈大小为 1M 。如果超出抛出 StackOverflowError -XX:PermSize 永久代（方法区）的初始大小，Java 8 中已经使用元空间，降级 -XX:MaxPermSize 永久代（方法区）的最大值，Java 8 中已经使用元空间，降级 -XX:+HeapDumpOnOutOfMemoryError 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用 -XX:+UseSerialGC 使用 Serial + Serial Old 收集器组合回收内存 -XX:+UseParNewGC 使用 ParNew + Serial Old 收集器组合回收内存 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 收集器组合回收内存，Serial Old 作为 CMS 失败时的备用收集器 -XX:+UseParallelGC 使用 Parallel Scavenge 收集新生代 -XX:+UseParallelOldGC 使用 Parallel Old 收集老年代，默认同时开启 -XX:+UseParallelGC GC 日志阅读和分析 GC 日志是处理 Java 虚拟机内存问题的基本技能，每种收集器的日志都是由其自身决定，也就是说格式可能不一样，但是虚拟机为了方便用户阅读，各个收集器的日志有很大的共性。参考：Java虚拟机详解03—-常用JVM配置参数 ，这篇博客的虚拟机系列写的都不错。 各字段含义 一段示例 Log： 1234567891011[GC [PSYoungGen: 6635K-&gt;800K(9216K)] 6635K-&gt;6944K(19456K), 0.0075650 secs] [Times: user=0.15 sys=0.00, real=0.00 secs][Full GC [PSYoungGen: 800K-&gt;0K(9216K)] [ParOldGen: 6144K-&gt;6371K(10240K)] 6944K-&gt;6371K(19456K) [PSPermGen: 2733K-&gt;2732K(21504K)], 0.0107750 secs] [Times: user=0.12 sys=0.01, real=0.02 secs]Heap PSYoungGen total 9216K, used 2214K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 27% used [0x00000000ff600000,0x00000000ff829848,0x00000000ffe00000) from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 6371K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 62% used [0x00000000fec00000,0x00000000ff238d38,0x00000000ff600000) PSPermGen total 21504K, used 2739K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48aced8,0x00000000f5b00000) GC 类型疑问：根据垃圾收集器中的介绍，所有 GC 都会出现停顿，而“深入理解虚拟机”一文中特意强调了 [GC 和 [Full GC 并不是用来区分新生代和老年代的，而是用来区分是否停顿（Stop The World）的？但是搜了下大部分网络博客或问答上基本都认为 [GC 特指新生代，而 [Full GC 是指全堆。参考：各GC的区别 垃圾收集器类型以及堆位置[PSYoungGen] 表示使用 Parallel Scavenge 收集器回收新生代堆；[ParOldGen] 表示使用 Parallel Old 收集器回收老年代；[PSPermGen] 表示使用 Parallel Scavenge 收集器回收永久代。可以通过设置 JVM 参数来指定对应的垃圾收集器，PS 是当前环境下默认的收集器。 Java 版本及环境如下示例都是在 Ubuntu Java 1.7 中执行的。 1234xmt@server005:~/$ java -versionjava version "1.7.0_91"OpenJDK Runtime Environment (IcedTea 2.6.3) (7u91-2.6.3-0ubuntu0.12.04.1)OpenJDK 64-Bit Server VM (build 24.91-b01, mixed mode) 一个怪异现象示例源码中，堆内存申请大小如下： 123456789101112131415161718192021222324252627282930313233343536373839public class TestGCLog &#123; private static final int _1MB = 1024 * 1024; private static void testAllocation()&#123; byte[] allocation1, allocation2, allocation3,allocation4,allocation5; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[1572864]; //1.5M int i = 0; for (i = 0; i &lt; allocation1.length; i++ )&#123; allocation1[i] = 1; &#125; for (i = 0; i &lt; allocation2.length; i++ )&#123; allocation2[i] = 1; &#125; for (i = 0; i &lt; allocation3.length; i++ )&#123; allocation3[i] = 1; &#125; for (i = 0; i &lt; allocation4.length; i++ )&#123; allocation4[i] = 1; &#125; allocation5 = new byte[20542]; System.out.println(allocation1.length); System.out.println(allocation2[1]); System.out.println(allocation3[2]); System.out.println(allocation4[8]); &#125; public static void main(String[] args) &#123; testAllocation(); &#125;&#125; 执行结果： 1234567891011121314151617181920212223242526272829303132333435xmt@server005:~/$ javac TestGCLog.javaxmt@server005:~/$ java -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintHeapAtGC TestGCLog&#123;Heap before GC invocations=1 (full 0): PSYoungGen total 9216K, used 8191K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 99% used [0x00000000ff600000,0x00000000ffdfffb8,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000) PSPermGen total 21504K, used 2733K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ab7a0,0x00000000f5b00000)[GC [PSYoungGen: 8191K-&gt;1024K(9216K)] 8191K-&gt;1080K(19456K), 0.0014510 secs] [Times: user=0.04 sys=0.00, real=0.00 secs]Heap after GC invocations=1 (full 0): PSYoungGen total 9216K, used 1024K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000) from space 1024K, 100% used [0x00000000ffe00000,0x00000000fff00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 56K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 0% used [0x00000000fec00000,0x00000000fec0e000,0x00000000ff600000) PSPermGen total 21504K, used 2733K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ab7a0,0x00000000f5b00000)&#125;2097152111Heap PSYoungGen total 9216K, used 1271K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 3% used [0x00000000ff600000,0x00000000ff63de78,0x00000000ffe00000) from space 1024K, 100% used [0x00000000ffe00000,0x00000000fff00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 56K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 0% used [0x00000000fec00000,0x00000000fec0e000,0x00000000ff600000) PSPermGen total 21504K, used 2741K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ad4b8,0x00000000f5b00000) 运行时 JVM 的配置为：初始堆和最大堆都是 20M；新生代配置为 10M，比率为 8，也就是说 Eden 为 8M(8192K)，From/To 各 1M(1024K)，新生代可用总大小为 9M(9216K)；这些信息从 Heap 的 Log 中也可以得到验证。从代码中可以看出 allocation5 再分配空间时出现 GC，但是从 [GC [ 前后的堆中看到的 Log 出现了一个怪异现象： GC 前堆PSYoungGen total 9216K, used 8191K; eden space 8192K, 99% used; from/to space 1024K, 0% used：表明新生代中 Eden 区基本已经全部用完，而 From 空置。再分配 allocation5 的空间会导致新生代触发一次 GC。 GC 后堆PSYoungGen total 9216K, used 1024K; eden space 8192K, 0% used; from space 1024K, 100% used; to space 1024K, 0% used：表明 GC 清空了 Eden 区，allocation5 的堆内存需求都分配到了 From 区。 诡异问题：既然新生代 GC 后基本被清空，allocation1/2/3/4 四个对象此时也并没有被回收，而 ParOldGen total 10240K, used 56K; object space 10240K, 0% used 表明老年代的堆也没有被使用。allocation1/2/3/4 这部分堆既没有回收，又没有晋升到老年代，那它到底去哪了呢？ 我们将源码中的 allocation5 = new byte[25542]; 内存需求改大到 25542，重新编译并执行，结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354xmt@server005:~/$ java -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintHeapAtGC TestGCLog&#123;Heap before GC invocations=1 (full 0): PSYoungGen total 9216K, used 8171K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 99% used [0x00000000ff600000,0x00000000ffdfaf68,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000) PSPermGen total 21504K, used 2734K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ab930,0x00000000f5b00000)[GC [PSYoungGen: 8171K-&gt;960K(9216K)] 8171K-&gt;8640K(19456K), 0.0059180 secs] [Times: user=0.17 sys=0.01, real=0.01 secs]Heap after GC invocations=1 (full 0): PSYoungGen total 9216K, used 960K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000) from space 1024K, 93% used [0x00000000ffe00000,0x00000000ffef0000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 7680K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 75% used [0x00000000fec00000,0x00000000ff380040,0x00000000ff600000) PSPermGen total 21504K, used 2734K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ab930,0x00000000f5b00000)&#125;&#123;Heap before GC invocations=2 (full 1): PSYoungGen total 9216K, used 960K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000) from space 1024K, 93% used [0x00000000ffe00000,0x00000000ffef0000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 7680K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 75% used [0x00000000fec00000,0x00000000ff380040,0x00000000ff600000) PSPermGen total 21504K, used 2734K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ab930,0x00000000f5b00000)[Full GC [PSYoungGen: 960K-&gt;0K(9216K)] [ParOldGen: 7680K-&gt;7907K(10240K)] 8640K-&gt;7907K(19456K) [PSPermGen: 2734K-&gt;2733K(21504K)], 0.0077670 secs] [Times: user=0.07 sys=0.01, real=0.01 secs]Heap after GC invocations=2 (full 1): PSYoungGen total 9216K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 0% used [0x00000000ff600000,0x00000000ff600000,0x00000000ffe00000) from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 7907K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 77% used [0x00000000fec00000,0x00000000ff3b8d48,0x00000000ff600000) PSPermGen total 21504K, used 2733K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ab5a0,0x00000000f5b00000)&#125;2097152111Heap PSYoungGen total 9216K, used 275K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 3% used [0x00000000ff600000,0x00000000ff644f68,0x00000000ffe00000) from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) to space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) ParOldGen total 10240K, used 7907K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 77% used [0x00000000fec00000,0x00000000ff3b8d48,0x00000000ff600000) PSPermGen total 21504K, used 2779K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48b6da0,0x00000000f5b00000) 虽然 allocation5 的内存需求只增加了几K，但是触发了 2 次 GC。第一次 GC 前后堆中可以明确看到新生代堆中变量晋升到了老年代 ParOldGen total 10240K, used 7680K; object space 10240K, 75% used，新生代也基本清空。但是接着又来了一次 Full GC？Java 7 中并没有给出原因，但是使用 Java 8 重新编译执行一次，可以明确看到：[Full GC (Ergonomics)，是因为 JVM 认为需要优化下主动触发的 Full GC，直接将新生代完全清空，全部晋升到老年代。我们也可以在执行时，将 JVM 参数的初始堆和最大堆大小加大避免触发 Full GC。本地验证设置为 -Xms26M -Xmx26M 时，第一次 GC 后 ParOldGen total 16384K, used 7680K; object space 16384K, 46% used，老年代只使用了 46%，JVM 不用优化并触发 Full GC。这也侧面证明 Full GC 的触发多取决于垃圾回收器算法的实现，不同回收器触发机制并不一致。 大对象直接分配在老年代先看源码： 12345678910public class TestLargeObject &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args)&#123; byte[] allocation1, allocation2, allocation3; allocation1 = new byte[1 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[4 * _1MB]; &#125;&#125; 根据计算 Eden 区完全可以容下三个大对象，执行结果也匹配： 12345678910xmt@server005:~/$ java -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintHeapAtGC TestLargeObjectHeap PSYoungGen total 9216K, used 7823K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 95% used [0x00000000ff600000,0x00000000ffda3f18,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000) PSPermGen total 21504K, used 2740K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ad158,0x00000000f5b00000) 使用 -XX:PretenureSizeThreshold 参数设置为 3M，当大对象大小超过这个值后直接进入老年代。 12345678910xmt@server005:~/$ java -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:PretenureSizeThreshold=3145728 TestLargeObjectHeap PSYoungGen total 9216K, used 7823K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 95% used [0x00000000ff600000,0x00000000ffda3f18,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000) PSPermGen total 21504K, used 2740K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ad158,0x00000000f5b00000) 结果显示 -XX:PretenureSizeThreshold 参数并没有生效，allocation3 还是进入了 Eden 区。原因是当前环境下默认的新生代 Parallel Scavenge 收集器并不识别这个参数，而指定新生代收集器为 -XX:+UseSerialGC 则会生效。参考：PretenureSizeThreshol参数不识别 1234567891011xmt@server005:~/$ java -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:PretenureSizeThreshold=3145728 -XX:+UseSerialGC TestLargeObjectHeap def new generation total 9216K, used 3727K [0x00000000f4600000, 0x00000000f5000000, 0x00000000f5000000) eden space 8192K, 45% used [0x00000000f4600000, 0x00000000f49a3f08, 0x00000000f4e00000) from space 1024K, 0% used [0x00000000f4e00000, 0x00000000f4e00000, 0x00000000f4f00000) to space 1024K, 0% used [0x00000000f4f00000, 0x00000000f4f00000, 0x00000000f5000000) tenured generation total 10240K, used 4096K [0x00000000f5000000, 0x00000000f5a00000, 0x00000000f5a00000) the space 10240K, 40% used [0x00000000f5000000, 0x00000000f5400010, 0x00000000f5400200, 0x00000000f5a00000) compacting perm gen total 21248K, used 2740K [0x00000000f5a00000, 0x00000000f6ec0000, 0x0000000100000000) the space 21248K, 12% used [0x00000000f5a00000, 0x00000000f5cad158, 0x00000000f5cad200, 0x00000000f6ec0000)No shared spaces configured. 指定 -XX:+UseSerialGC 后，allocation3 直接进入老年代 tenured generation total 10240K, used 4096K; the space 10240K, 40% used 。 但是当 allocation3 = new byte[5 * _1MB]; 分配 5M 空间时，默认的 Parallel Scavenge 收集器会直接将该对象分配到老年代，避免触发 GC。 12345678910xmt@server005:~/$ java -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGCDetails -XX:+PrintHeapAtGC TestLargeObjectHeap PSYoungGen total 9216K, used 3727K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) eden space 8192K, 45% used [0x00000000ff600000,0x00000000ff9a3f08,0x00000000ffe00000) from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000) to space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000) ParOldGen total 10240K, used 5120K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) object space 10240K, 50% used [0x00000000fec00000,0x00000000ff100010,0x00000000ff600000) PSPermGen total 21504K, used 2740K [0x00000000f4600000, 0x00000000f5b00000, 0x00000000fec00000) object space 21504K, 12% used [0x00000000f4600000,0x00000000f48ad158,0x00000000f5b00000) 其他垃圾收集器日志如果想使用或者验证其他垃圾收集器，可以在执行时添加 JVM 参数：-XX:+UseSerialGC, -XX:+UseParNewGC, -XX:+UseConcMarkSweepGC, -XX:+UseParallelGC, -XX:+UseParallelOldGC，各参数含义参考“ JVM 常见参数”。 Android GC 日志Android GC 日志非常简单，信息并不是很多。参考：解读Android日志消息 Dalvik/ART 简介Android 的虚拟机是 Google 自己实现的：Dalvik/ART。Android L 开始使用 ART 并废除 Dalvik 。先简单介绍下两者的区别，参考JVM、Dalvik以及ART的区别 ： Dalvik.dex 格式是专为 Dalvik 设计的一种压缩格式，适合内存和处理器速度有限的系统，Dalvik 指令集是基于寄存器的架构。 ARTART: Android runtime，ART 的机制与 Dalvik 不同。在 Dalvik 下应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率。而 ART 在应用第一次安装时就预编译字节码到机器语言，移除解释代码这一过程，应用程序执行更有效率启动更快，但是 ART 占用空间比 Dalvik 大 10%~20%，属于空间换时间。 Dalvik 日志格式格式：D/dalvikvm: &lt;GC_Reason&gt; &lt;Amount_freed&gt;, &lt;Heap_stats&gt;, &lt;External_memory_stats&gt;, &lt;Pause_time&gt;示例：D/dalvikvm( 9050): GC_CONCURRENT freed 2049K, 65% free 3571K/9991K, external 4703K/5261K, paused 2ms+2ms 垃圾回收的原因： GC_CONCURRENT在堆开始占用内存时可以释放内存的并发垃圾回收。 GC_FOR_MALLOC堆已满而系统不得不停止应用并回收内存时，应用尝试分配内存而引起的垃圾回收。 GC_HPROF_DUMP_HEAP当请求创建 HPROF 文件来分析堆时出现的垃圾回收。 GC_EXPLICIT显式垃圾回收，例如当调用 gc() 时（应避免调用，而应信任垃圾回收会根据需要运行）。 GC_EXTERNAL_ALLOC这仅适用于 API &lt;= 10 。外部分配内存的垃圾回收（例如存储在原生内存或 NIO 字节缓冲区中的像素数据）。 ART 日志格式格式：I/art: &lt;GC_Reason&gt; &lt;GC_Name&gt; &lt;Objects_freed&gt;(&lt;Size_freed&gt;) AllocSpace Objects, &lt;Large_objects_freed&gt;(&lt;Large_object_size_freed&gt;) &lt;Heap_stats&gt; LOS objects, &lt;Pause_time(s)&gt;示例：I/art : Explicit concurrent mark sweep GC freed 104710(7MB) AllocSpace objects, 21(416KB) LOS objects, 33% free, 25MB/38MB, paused 1.230ms total 67.216ms GC_Reason：垃圾回收原因 Concurrent不会暂停应用线程的并发垃圾回收。此垃圾回收在后台线程中运行，而且不会阻止分配。 Alloc应用在堆已满时尝试分配内存引起的垃圾回收。在这种情况下，分配线程中发生了垃圾回收。 Explicit由应用明确请求的垃圾回收，例如通过调用 gc()。与 Dalvik 相同，在 ART 中，最佳做法是信任垃圾回收并避免请求显式垃圾回收。不建议使用显式垃圾回收，因为它们会阻止分配线程并不必要地浪费 CPU 周期。如果显式垃圾回收导致其他线程被抢占，那么它们也可能会导致卡顿（应用中出现间断、抖动或暂停）。 NativeAlloc原生分配（如位图或 RenderScript 分配对象）导致出现原生内存压力，进而引起的回收。 CollectorTransition由堆转换引起的回收；此回收由运行时切换垃圾回收引起。回收器转换包括将所有对象从空闲列表空间复制到碰撞指针空间（反之亦然）。当前，回收器转换仅在以下情况下出现：在 RAM 较小的设备上，应用将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态（反之亦然）。 HomogeneousSpaceCompact齐性空间压缩是空闲列表空间到空闲列表空间压缩，通常在应用进入到可察觉的暂停进程状态时发生。这样做的主要原因是减少 RAM 使用量并对堆进行碎片整理。 DisableMovingGc这不是真正的垃圾回收原因，但请注意发生并发堆压缩时，由于使用了 GetPrimitiveArrayCritical，回收遭到阻止。一般情况下，强烈建议不要使用 GetPrimitiveArrayCritical，因为它在移动回收器方面具有限制。 HeapTrim这不是垃圾回收原因，但请注意，堆修剪完成之前回收会一直受到阻止。 GC_Name：ART 具有可以运行的多种不同的垃圾回收： Concurrent mark sweep (CMS)整个堆回收器，会释放和回收映像空间以外的所有其他空间。 Concurrent partial mark sweep几乎整个堆回收器，会回收除了映像空间和 zygote 空间以外的所有其他空间。 Concurrent sticky mark sweep生成回收器，只能释放自上次垃圾回收以来分配的对象。此垃圾回收比完整或部分标记清除运行得更频繁，因为它更快速且暂停时间更短。 Marksweep + semispace非并发、复制垃圾回收，用于堆转换以及齐性空间压缩（对堆进行碎片整理）。 Objects_freed 释放的对象：此次垃圾回收从非大型对象空间回收的对象数量。Size_freed 释放的大小：此次垃圾回收从非大型对象空间回收的字节数量。Large_objects_freed 释放的大型对象：此次垃圾回收从大型对象空间回收的对象数量。Large_object_size_freed 释放的大型对象大小：此次垃圾回收从大型对象空间回收的字节数量。Heap_stats 堆统计数据：空闲百分比与（活动对象数量）/（堆总大小）。Pause_time 暂停时间：通常情况下，暂停时间与垃圾回收运行时修改的对象引用数量成正比。当前，ART CMS 垃圾回收仅在垃圾回收即将完成时暂停一次。移动的垃圾回收暂停时间较长，会在大部分垃圾回收期间持续出现。 如果在 logcat 中看到大量的垃圾回收，请注意堆统计数据的增大（上面示例中的 25MB/38MB 值）。如果此值继续增大，且始终没有变小的趋势，则可能会出现内存泄漏。或者如果看到原因为 Alloc 的垃圾回收，那么意味着操作已经快要达到堆容量，并且将很快出现 OOM 异常。 参考文档 深入理解 Java 虚拟机: JVM 高级特性与最佳实践 第 2 版 - 第三章 垃圾收集器与内存分配策略 Java GC、新生代、老年代 收集器分类 各GC的区别及触发条件 JVM内存结构 解读Android日志消息 Java虚拟机详解03—-常用JVM配置参数 Minor GC、Major GC和Full GC之间的区别 JVM常见参数 JVM的新生代、老年代、元空间 JDK8-废弃永久代（PermGen）迎来元空间（Metaspace） GC日志分析 JVM实用参数 PretenureSizeThreshol参数不识别]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 泛型]]></title>
    <url>%2F2018%2F04%2F13%2F0075-java-generic-class%2F</url>
    <content type="text"><![CDATA[Java 泛型本质是参数化类型 Parametersized Type 的应用，也就是说操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别被称为泛型类、泛型接口和泛型方法。我们使用尖括号 &lt;&gt;来表示泛型。Java 7 及以后版本，运行构造器后不需要带完整的泛型信息，只要给出一对尖括号 &lt;&gt; 即可，Java 可以推断出尖括号里应该是什么泛型信息。比如：List&lt;String&gt; list = new ArrayList&lt;&gt;(); 。两个尖括号看起来很想菱形，也称为这种用法为菱形语法。 基本概念类型变量和参数化类型它们是组成泛型的两个最基本的概念，如泛型 List&lt;T&gt; ： 类型变量 type variablesT，即为类型变量，它只能在类，构造方法，普通方法中定义它。 参数化类型 parameterized typeList&lt;T&gt; 这个整体表示参数化类型，可以用来定义变量，如 List&lt;String&gt; lists。在类型擦除后，并不会保留泛型信息，所以参数化类型实际上是类类型（包含接口）。 相关概念从反射角度也有解释：Type 类型 类型形参和实参泛型允许在定义类、接口、方法时使用类型参数（type parameter），这个类型参数在声明变量、创建对象、调用方法时动态的指定。 类型形参泛型在定义时的参数，如 &lt;K, V&gt; 。 类型实参泛型在使用时指定的参数，即具体参数，如 &lt;K, V 在使用时实际指定的 &lt;Integer, String&gt;。类型实参只能是类类型（包含接口），不能是基本数据类型。 1234567// 1. 定义时，为类型形参 E public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;...&#123; ...&#125;// 2. 使用时，需要指定类型实参 StringList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 泛型接口123public interface GenericInterface&lt;K, V&gt;&#123; V put(K key, V value);&#125; 定义接口时使用泛型声明，指定两个类型形参 K, V，在接口中形参名 K, V 可以作为类型来使用。 泛型类123456789101112131415public class GenericClass&lt;T&gt; &#123; private T t; public GenericClass(T t) &#123; this.t = t; &#125; public void setT(T t)&#123; this.t = t; &#125; public T getT()&#123; return t; &#125;&#125; 定义类时使用了泛型声明，指定类型形参为 T，类中使用形参 T 定义了变量 t，并使用形参 T 定义了构造方法。在定义构造方法时不需要使用类型形参，只有在实例化话时才需要。 泛型方法泛型方法的类型参数不需要在定义类或者接口时声明，只需要在方法返回值前面声明就可以了。 123修饰符 &lt;类型形参列表&gt; 返回值 方法名(方法形参列表)&#123; ...&#125; 123456789101112131415161718// 1. 泛型方法定义public class GenericClass&#123; // 构造方法 public &lt;TT&gt; GenericClass(TT tt, String s)&#123;...&#125; // 普通方法 public &lt;M, N&gt; void genericMethod(M key, N value, Map&lt;M, N&gt; map)&#123; map.put(key, value); &#125;&#125;// 2. 泛型方法的 2 种调用方式GenericClass genericClass = new GenericClass();HashMap&lt;Integer, String&gt; hashMap1 = new HashMap&lt;&gt;();HashMap&lt;String, String&gt; hashMap2 = new HashMap&lt;&gt;();// 调用方式一：显示指定传入的类型genericClass.&lt;Integer, String&gt;genericMethod(5, "5", hashMap1);// 调用方式二：Java 7 及之后，编译器会自行推断类型genericClass.genericMethod("6", "6", hashMap2); 定义方法时使用泛型声明，指定类型形参为 M, N，方法的形参列表和方法体中都可以将 M, N 作为类型使用。 值得注意的是，构造方法也可以使用泛型。 泛型继承和子类型重要概念在面向对象中有个非常重要的使用方式：向上转型，也就是父类变量引用子类对象。比如： 123Object someObject = new Object();Integer someInteger = new Integer(10);someObject = someInteger; // OK 在方法的形参中，也可以使用向上转型。 1234public void someMethod(Number n) &#123; /* ... */ &#125;someMethod(new Integer(10)); // OKsomeMethod(new Double(10.1)); // OK 在泛型中我们也可以使用向上转型，这也是集合中非常常用的一种方式。 123Box&lt;Number&gt; box = new Box&lt;Number&gt;();box.add(new Integer(10)); // OKbox.add(new Double(10.1)); // OK 但是请注意：方法的形参列表在使用泛型时，传入的参数必须完全匹配。 12345678Box&lt;Number&gt; box = new Box&lt;Number&gt;();Box&lt;Integer&gt; boxI = new Box&lt;Integer&gt;();Box&lt;Double&gt; boxD = new Box&lt;Double&gt;();public void boxTest(Box&lt;Number&gt; n) &#123; /* ... */ &#125;boxTest(box); // OKboxTest(boxI); // compile-time errorboxTest(boxD); // compile-time error 形参并不能传入 Box&lt;Integer&gt;, Box&lt;Double&gt;。也就是说 Box&lt;Integer&gt;, Box&lt;Double&gt; 并不是 Box&lt;Number&gt; 的子类型。 泛型使用的重要概念：给定的两个类型 A 和 B，不管 A, B 是否存在继承关系，MyGenericClass&lt;A&gt; 和 MyGenericClass&lt;B&gt; 都没有任何直接关系，他们的共同父类是 Object。 泛型类型的继承和接口的实现泛型接口的实现类，泛型类的子类，在定义泛型时需要注意： 指定具体类型实参 不指定类型参数 指定相同的类型形参 123456789101112131415161718192021222324// 指定具体类型实参public class MyGenericInterface implements GenericClass.GenericInterface&lt;Integer, String&gt;&#123; @Override public String put(Integer key, String value) &#123; return null; &#125;&#125;// 不指定类型参数public class SubGenericClass extends GenericClass &#123; public SubGenericClass(Object o) &#123; super(o); &#125;&#125;// 指定相同的类型形参public class SecondSubGenericClass&lt;T&gt; extends GenericClass&lt;T&gt; &#123; public SecondSubGenericClass(T t) &#123; super(t); &#125;&#125; 示例中泛型接口的实现类指定具体类型实参 Integer, String，继承泛型类时不指定类型参数，默认将类型实参设置为 Object，或者指定相同的类型参数。在实际使用中推荐指定相同的类型参数。 泛型类的类型实参如果不同，则不存在继承关系，即使类型实参之间有继承关系。也就是说泛型中只有类型参数相同时，泛型类才存在继承关系。 1234interface PayloadList&lt;E,P&gt; extends List&lt;E&gt; &#123; void setPayload(int index, P val); ...&#125; PayloadList&lt;String,String&gt;, PayloadList&lt;String,Integer&gt;, PayloadList&lt;String,Exception&gt; 三者的关系如下： 这部分参考教程：Generics, Inheritance, and Subtypes 泛型中类型变量边界限定语法格式类型变量 T 可以表示任何类型，通过关键字 extends 可以限制类型变量的边界，语法格式： 1234// 1. 单个限定&lt;T extends BoundingType&gt;// 2. 多个限定&lt;T extends BoundingType1 &amp; BoundingType2 &amp; BoundingType3&gt; 表示 T 是“边界类型”的子类型，“边界类型”可以是类也可以是接口，如果不做边界限定，默认边界为 Object。但是在多限定中，只能有一个类，而且必须放在限定表的第一位；接口的数量和位置没有限制。 示例1234567891011121314151617181920212223public class GenericTypeParaBounder&lt;T extends Number&gt;&#123; T t; // 1. 单限定 public &lt;T1 extends Number&gt; void testGenericBounder(T1 t1)&#123; //... &#125; // 2. 多限定，只能有一个类而且必须放在第一位 public &lt;T2 extends A &amp; B &amp; C&gt; void testGenericMultipleBounder(T2 t2)&#123; //... &#125; private class A&#123;&#125; private interface B&#123;&#125; private interface C&#123;&#125; // 3. 多限定，接口数量和位置没有限制 public &lt;T3 extends Comparable &amp; Serializable&gt; void testGenericMultipleBounder2(T3 t3)&#123; //... &#125;&#125; 泛型通配符通配符为了解决类型不能动态根据实例来确定的缺点，引入“通配符泛型 ?”。但通配符并不是具体的类型，所以代码中不能使用 ? 作为一种类型。 不限定通配符使用 ? 代替类型实参，即它可以是任何类型，如 Class &lt;?&gt;。 限定性通配符上界 extends&lt;? extends Father&gt; 表示上界，即参数化类型的可能是 Father 或是 Father 的子类。也可以看出不限定通配符实际上是 &lt;? extends Object&gt;。 限定性通配符下界 super&lt;? super Son&gt; 表示下界，表示参数化类型是 Son 的超类型（父类型），直至 Object。 通配符泛型继承使用通配符可以解决泛型类向上转型时的问题。 无限定通配符List&lt;Number&gt;, List&lt;Integer&gt; 都是 List&lt;?&gt; 的子类。 限定通配符List&lt;Number&gt;, List&lt;Integer&gt;, List&lt;Long&gt;, List&lt;Float&gt; 都是 List&lt;? extends Number&gt; 的子类。List&lt;Integer&gt;, List&lt;Number&gt;, List&lt;Object&gt; 都是 List&lt;? super Integer 的子类。 示例 123456789101112131415// 泛型中使用向上转型时，Integer 继承 Number// 但是 List&lt;Number&gt; 和 List&lt;Integer&gt; 并没有继承关系List&lt;Integer&gt; li = new ArrayList&lt;&gt;();List&lt;Number&gt; ln = li; // compile-time error// 1. 无限定通配符List&lt;?&gt; l = li; // OK// 2. 上界List&lt;? extends Integer&gt; eli = new ArrayList&lt;&gt;();List&lt;? extends Number&gt; eln = eli; // OK// 3. 下界List&lt;? super Number&gt; sln = new ArrayList&lt;&gt;();List&lt;? super Integer&gt; sli = sln; // OK 通配符集合操作注意事项 在集合中，对于边界，上界不能 add，下界不能 get。 首先我们需要明白集合中限定性通配符的意义： 1234567List&lt;? extends Number&gt; ln = new ArrayList&lt;&gt;();// 根据限定性通配符上界的继承关系// ln 表示这个集合可以是 List&lt;Number&gt;,List&lt;Integer&gt;, List&lt;Long&gt;,List&lt;Float&gt; 等等List&lt;? super Integer&gt; li = new ArrayList&lt;&gt;();// 根据限定性通配符下界的继承关系// li 表示这个集合可以是 List&lt;Integer&gt;, List&lt;Number&gt;, List&lt;Object&gt; 上界不能 add 边界 123List&lt;? extends Number&gt; ln = new ArrayList&lt;&gt;();Number n = ln.get(0); // OK//ln.add(n); // compile-time error. 将 get/add 的类型展开： 12? extends Number get(int i);void add(? extends Number); ln = {List&lt;Number&gt;, List&lt;Integer&gt;, List&lt;Long&gt;, List&lt;Float&gt;...}，ln 是其中某一类型，边界是 Number。在 get 时不管拿到的是哪种类型 Number, Integer, Long, Float，都可以向上转型到边界 Number 。而如果 ln 当前是 List&lt;Float&gt;，在 add 时添加边界 Number 会存在不安全的向下转型，导致编译报错。 下界不能 get 边界 123List&lt;? super Integer&gt; li = new ArrayList&lt;&gt;();// Integer i = li.get(0); // compile-time error.li.add(1); // OK. 将 get/add 的类型展开： 12? super Integer get(int i);void add(? super Integer); li = {List&lt;Integer&gt;, List&lt;Number&gt;, List&lt;Object&gt;...}，li 是其中某一类型，边界是 Integer。在 add 边界 Integer 时，不管 li 是哪种类型，Integer 都能正确的向上转型到 Integer, Number, Object。而如果 li 当前是 List&lt;Object&gt;，在 get 时转换为边界 Integer 是不安全的向下转型，导致编译错误。 类型擦除Java 的泛型只在源码中存在，在编译后的字节码文件中都会被替换为原始类型 Raw Type，并且在相应的地方插入了强制转型代码。 Java 语言泛型的实现方法称为类型擦除（Type Erasure），这种实现也被称为伪泛型。类型擦除后的原始类型为限定类型（如果是不限定则为 Object）。 类型擦除示例123456789101112131415// 1. 源码Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put("hello", "world");System.out.println(map.get("hello"));// 限定符List&lt;? extends Number&gt; list = new ArrayList&lt;&gt;();Number n = list.get(0);// 2. 反编译结果：类型擦除后在使用时做强行转换Map map = new HashMap();map.put("hello", "world");System.out.println((String) map.get("hello"));// 限定符使用边界ArrayList localArrayList = new ArrayList();Number localNumber = (Number)localArrayList.get(0); JVM 中关于方法的几个基本概念Class 文件格式中方法表，包含的几个重要字段：名称、描述符、属性组等。 特征签名方法特征签名：仅仅包括方法名称、参数类型以及参数顺序（不包含返回值）。 描述符描述符的作用用来描述字段的数据类型、方法的参数列表（包含数量、类型和顺序）和返回值，只有描述符不一致的两个方法才能再同一个 Class 文件中共存。 Sigature 属性在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或者参数化类型，则 Signature 属性会记录泛型签名信息。所以类型擦除仅仅是对方法的字节码进行了擦除，实际上 Signature 属性保留了泛型信息。 泛型方法不能重载如下示例中方法 mytest 重载，但是参数类型都是泛型 List&lt;E&gt;。 1234567891011121314151617import java.util.List;import java.util.ArrayList;public class TestGeneric&#123; public static int mytest(List&lt;Integer&gt; s) &#123; return 0; &#125; public static String mytest(List&lt;String&gt; s) &#123; return ""; &#125; public static void main(String[]agrs)&#123; mytest(new ArrayList&lt;String&gt;()); mytest(new ArrayList&lt;Integer&gt;()); &#125;&#125; 关于泛型方法的重载，Java 6 和以后的版本表现完全不一样： Java 6 能通过编译并正常运行在 Java 6 只需要 class 文件中方法描述符（返回值不同）不一致就可以共存，并且 Singture 属性保留了泛型信息，所以能正常编译和运行。 Java 7 及以后版本不能正常编译从 Java 7 开始，编译开始就检查泛型的特征签名（不包含返回值）。根据特征签名的定义，以及泛型的类型擦除特性，mytest 特征签名是一样的，所以在编译过程中报错。 12345678910111213141516171819// Java 7 及以上不能编译通过xmt@server005:~/test/java$ java -versionjava version "1.7.0_91"OpenJDK Runtime Environment (IcedTea 2.6.3) (7u91-2.6.3-0ubuntu0.12.04.1)OpenJDK 64-Bit Server VM (build 24.91-b01, mixed mode)xmt@server005:~/test/java$ javac TestGeneric.javaTestGeneric.java:9: error: name clash: mytest(List&lt;String&gt;) and mytest(List&lt;Integer&gt;) have the same erasure public static String mytest(List&lt;String&gt; s) &#123; ^1 error// Java 6 可以编译通过并正常运行xmt@server005:~/test/java$ java -versionjava version "1.6.0_31"Java(TM) SE Runtime Environment (build 1.6.0_31-b04)Java HotSpot(TM) 64-Bit Server VM (build 20.6-b01, mixed mode)xmt@server005:~/test/java$ javac TestGeneric.javaxmt@server005:~/test/java$ java TestGeneric 详细参考：JVM：深入理解Java虚拟机–读书笔记：泛型 泛型方法重写泛型方法支持重写，支持的原因是 Java 编译器会自动为重写方法添加一个适配的方法，这个方法称为桥方法。 源码 1234567891011121314151617181920212223242526272829303132public class Node&lt;T&gt; &#123; public T data; public Node(T data) &#123; this.data = data; &#125; public void setData(T data) &#123; System.out.println("Node.setData"); this.data = data; &#125; public class MyNode extends Node&lt;Integer&gt; &#123; public MyNode(Integer data) &#123; super(data); &#125; @Override public void setData(Integer data) &#123; System.out.println("MyNode.setData"); super.setData(data); &#125; &#125; public void testGenericOverride()&#123; MyNode mn = new MyNode(5); // A raw type - compiler throws an unchecked warning Node n = mn; n.setData("Hello"); // Causes a ClassCastException to be thrown. Integer x = mn.data; &#125;&#125; 类型擦除后 12345678910111213141516171819202122232425262728public class Node &#123; public Object data; public Node(Object data) &#123; this.data = data; &#125; public void setData(Object data) &#123; System.out.println("Node.setData"); this.data = data; &#125; public class MyNode extends Node &#123; public MyNode(Integer data) &#123; super(data); &#125; public void setData(Integer data) &#123; System.out.println("MyNode.setData"); super.setData(data); &#125; &#125; public void testGenericOverride()&#123; MyNode mn = new MyNode(5); //A raw type-compiler throws an unchecked warning Node n = (MyNode)mn; n.setData("Hello"); //Causes a ClassCastException to be thrown. Integer x = (String)mn.data; &#125;&#125; 类型擦除后，可以看出 setData 的参数类型并不一样，也就说 setData 在重载。那 Java 中是如何实现重写的呢？ 桥方法反编译 MyNode 的字节码： 123456789101112131415161718192021222324252627282930313233xmt@server005:~/$ javap -v Node\$MyNode.class... public void setData(java.lang.Integer); flags: ACC_PUBLIC Code: stack=2, locals=2, args_size=2 0: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #4 // String MyNode.setData 5: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: aload_0 9: aload_1 10: invokespecial #6 // Method Node.setData:(Ljava/lang/Object;)V，调用桥方法 13: return LineNumberTable: line 19: 0 line 20: 8 line 21: 13 // Java 编译器自动添加的 桥方法 public void setData(java.lang.Object); flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC Code: stack=2, locals=2, args_size=2 0: aload_0 1: aload_1 2: checkcast #7 // class java/lang/Integer 5: invokevirtual #8 // Method setData:(Ljava/lang/Integer;)V 8: return LineNumberTable: line 14: 0&#125;... 从反编译的字节码中可以看出，多了一个 setData(Object)，这个就是编译器自动添加的桥方法，从而实现了重写。 泛型数组不能直接创建泛型数组1234567891011// 1. Normal Array.Object[] strings = new String[2];strings[0] = "hi"; // OKstrings[1] = 100; // An ArrayStoreException is thrown.// 2. Cannot create generic array directly.Object[] stringLists = null;//stringLists = new List&lt;String&gt;[2]; // compiler errorstringLists[0] = new ArrayList&lt;String&gt;(); // OK// An ArrayStoreException should be thrown, but the runtime can't detect it.stringLists[1] = new ArrayList&lt;Integer&gt;(); 数组在使用中，数组元素的类型必须一致，否则在运行时会报错 An ArrayStoreException is thrown，比如字符串数组 strings[1] = 100; 赋值一个整数导致运行时报错。同样，如果创建了泛型数组，虽然类型不一致，但是类型擦除后，无法确认具体的类型，运行时并不能检测到错误，所以泛型中禁止直接创建泛型数组。 通配符创建泛型数组12345678910111213// 不安全的向下转型 List&lt;String&gt; 是 List&lt;?&gt; 的子类// List&lt;String&gt;[] lsa = new List&lt;?&gt;[10]; // compiler error,// OK, array of unbounded wildcard type.List&lt;?&gt;[] lsa = new List&lt;?&gt;[10];Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(3);// Correct.oa[1] = li;// Run time error, but cast is explicit.String s = (String) lsa[1].get(0); The Java™ Tutorials: Generics ，官网教程给出使用通配符来创建泛型数组。这个示例在运行时，最后一句会抛出类型转换错误 Integer 不能直接转换为 String。 反射创建泛型数组123456789List&lt;String&gt;[] lsa = (List&lt;String&gt;[])Array.newInstance(ArrayList.class, 4);Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(3);// Correct.oa[1] = li;// Run time error, but cast is explicit.String s = lsa[1].get(0); 使用反射创建数组，并强制转换为泛型数组，此处会给出 Uncheck 警告，没有做类型检查。 显性转换不管是通配符还是反射创建的泛型数组，在都需要做一次显示的类型转换。通配符是在使用时做转换，反射是在创建时转换。 注意事项 Restrictions on GenericsJava 在泛型使用中有如下约束规则和限制，大都是类型擦除引起，参考Restrictions on Generics 不能使用基本数据类型定义类型参数泛型类型形参只能是类类型，不能是基本数据类型。 12Pair&lt;int, char&gt; p = new Pair&lt;&gt;(8, 'a'); // compile-time errorPair&lt;Integer, Character&gt; p = new Pair&lt;&gt;(8, 'a'); // OK! 不能使用类型参数创建实例不能使用类型参数来创建实例，但是可以通过反射调用 Class.newInstance 方法来构造泛型对象。 1234567891011121314// 1. Errorpublic static &lt;E&gt; void append(List&lt;E&gt; list) &#123; E elem = new E(); // compile-time error list.add(elem);&#125;// 类型擦除后为 Object，显然我们并不是希望实例化 Object// 2. Rightpublic static &lt;E&gt; void append(List&lt;E&gt; list, Class&lt;E&gt; cls) throws Exception &#123; E elem = cls.newInstance(); // OK list.add(elem);&#125;// 通过 cls.newInstance 来构造泛型对象，Class&lt;T&gt; 在实例化的时候，T 要替换成具体类// 此处不能使用 T.class.newInstance，还是因为泛型擦除会变成 Object 泛型类的静态上下文即在类上定义的泛型，不能在当前类的静态属性，静态方法，静态代码块，静态类中出现。因为 static 属于类的，只加载一次，在类型擦除后，无法转换为每个具体的类型实参。 12345678910public class MobileDevice&lt;T&gt; &#123; private static T os; // ...&#125;// os 将出现混淆？具体是哪种实际类型呢？MobileDevice&lt;Smartphone&gt; phone = new MobileDevice&lt;&gt;();MobileDevice&lt;Pager&gt; pager = new MobileDevice&lt;&gt;();MobileDevice&lt;TabletPC&gt; pc = new MobileDevice&lt;&gt;(); 根据上面示例，os 将出现混淆，无法确定具体的实际类型。所以泛型类中不允许出现在静态上下中。其他错误示例： 1234567891011121314public class GenericRestrictions&lt;Z&gt; &#123; private static Z z; // compile-time error public static Z get()&#123; // compile-time error return z; &#125; static class ZZ&#123; Z t; // compile-time error &#125; static &#123; Z z; // compile-time error &#125; 但是我们可以脱离静态上下文（也就是不使用类上定义的泛型），重新指定泛型，这样就可以出现在泛型方法和静态类中了： 123456789101112// 静态泛型方法public static &lt;TT&gt; TT getTT()&#123;...&#125;// 静态类public static class StaticInnerClassGeneric&lt;S&gt;&#123; S s; void set(S s)&#123; this.s = s; &#125; S get()&#123; return s; &#125;&#125; 泛型中类型转换 cast 和 instanceof cast因为泛型中只有类型参数是同一类型时，才可能存在继承关系；类型参数不同，泛型类没有任何关系。 1234567// 参数类型存在继承关系，泛型却没有任何关系List&lt;Integer&gt; li = new ArrayList&lt;&gt;();List&lt;Number&gt; ln = (List&lt;Number&gt;) li; // compile-time error// 参数类型必须一致 List&lt;String&gt; l1 = new ArrayList&lt;&gt;();ArrayList&lt;String&gt; l2 = (ArrayList&lt;String&gt;)l1; // OK instanceof类型擦除后，并不知道运行时参数类型具体是什么？ 12345public static &lt;E&gt; void rtti(List&lt;E&gt; list) &#123; if (list instanceof ArrayList&lt;Integer&gt;) &#123; // compile-time error // ... &#125;&#125; 方法 rtti 在运行时，传入的参数类型可能是这些：S={ArrayList&lt;Integer&gt;, ArrayList&lt;String&gt;, LinkedList&lt;Character&gt;...}，而根据泛型重要概念了解到只有参数类型完全一致才存在继承关系，所以 instanceof 中泛型并不允许直接使用类型实参。 123456public static void rtti(List&lt;?&gt; list) &#123; // instanceof requires a reifiable type if (list instanceof ArrayList&lt;?&gt;) &#123; // OK; // ... &#125;&#125; 即：instanceof 中只能使用通配符的泛型。 不能创建泛型数组正常的数组定义和使用中，如果类型不匹配会抛出异常： 12345678910Object[] strings = new String[2];strings[0] = "hi"; // OKstrings[1] = 100; // An ArrayStoreException is thrown.// 泛型Object[] stringLists = new List&lt;String&gt;[]; // compiler errorstringLists[0] = new ArrayList&lt;String&gt;(); // OKstringLists[1] = new ArrayList&lt;Integer&gt;(); // An ArrayStoreException should be thrown,// but the runtime can't detect it. 但是在泛型中，类型擦除后，并不能检查出 ArrayList&lt;Integer&gt;() 的错误，所以泛型禁止创建数组。 但是可以使用泛型数组？？？？？ 泛型异常 泛型类不能直接或间接继承 Throwable 12345// Extends Throwable indirectlyclass MathException&lt;T&gt; extends Exception &#123;&#125; //compile-time error// Extends Throwable directlyclass QueueFullException&lt;T&gt; extends Throwable &#123;&#125; //compile-time error 不能 catch 泛型实例 12345678public static &lt;T extends Exception, J&gt; void execute(List&lt;J&gt; jobs) &#123; try &#123; for (J job : jobs)&#123;&#125; // ... &#125; catch (T e) &#123; // compile-time error // ... &#125;&#125; 但是我们可以 throws 泛型实例。 12345class Parser&lt;T extends Exception&gt; &#123; public void parse(File file) throws T &#123; // OK // ... &#125;&#125; 泛型比较12345public final class Algorithm &#123; public static &lt;T&gt; T max(T x, T y) &#123; return x &gt; y ? x : y; // compile-time error &#125;&#125; 泛型不支持直接使用关系运算符 &gt;&lt; 等。通常限定类型变量边界为 Comparable 并通过 compareTo 来比较。 参考文档 Java 核心技术卷 1：第 12 章 泛型程序设计 深入理解 Java 虚拟机: JVM 高级特性与最佳实践 第 2 版 - 10.3.1 泛型与类型擦除 The Java™ Tutorials – Lesson: Generics The Java™ Tutorials – Lesson: Generics: advanced users Java 泛型重载 jdk 1.7 Java泛型的实现：泛型数组 Java泛型 - 桥方法 Java泛型: 泛型的内部原理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象的特征]]></title>
    <url>%2F2018%2F04%2F10%2F0074-java-oo%2F</url>
    <content type="text"><![CDATA[Java 面向对象的三大特征：封装、继承、多态；而封装和继承基本都是为多态而准备的。 封装封装 Encapsulation [ɛnˈkæpsəˌletʃən] ：在面向对象语言中，封装特性是由类来体现的，我们将现实生活中的一类实体定义成类，其中包括属性和方法。将对象的实现细节隐藏起来，通过一些公用方法来暴露该对象的功能。 继承继承 Inheritance[ɪnˈhɛrɪtəns] ：当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法。Java 的接口有多继承，而类没有多重继承，但是可以通过实现不同的接口或者多层次继承来体现多重继承。继承通过关键字 extends 来实现，实现继承的类称为子类，被继承的类称为父类，或者超类、基类。 super 和 this super代表父类对象，可以理解为是指向自己父类对象的一个引用，而这个父类指的是离自己最近的一个父类。 this代表对象本身，可以理解为指向对象本身的一个引用。 父类子类的初始化顺序父类和子类的初始化顺序如下： 父类类加载过程：静态成员变量，静态代码块 子类类加载过程：静态成员变量，静态代码块 父类类实例化过程：普通成员变量，构造代码块，最后父类的构造方法 子类类实例化过程：普通成员变量，构造代码块，最后子类的构造方法 static 的成员变量和方法是属于类的，所以只会在类加载时初始化或执行一次，类实例化时不会重复初始化。 代码执行顺序具体参考这篇博文：Java 代码执行顺序 属性和方法的继承子类继承父类后，可以继承父类的属性和方法。包含静态属性和方法，但是子类访问父类的属性和方法时受访问控制符限制。 多态多态 Polymorphism[ˌpɒlɪ&#39;mɔ:fɪzəm] ：子类对象直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，表现出多种行为的特征。 多态针对的是对象，而不是类。 向上转型和向下转型 规则父类引用指向子类对象，但是子类引用不能指向父类对象。 向上转型父类引用指向子类对象，也就是子类对象直接赋给父类引用，不用强制转换。子类对象会遗失父类中不同的方法，重写相同的方法。 向下转型子类对象的父类引用赋给子类引用，要强制转换。父类对象强制转换赋给子类引用，是不安全的向下转型，编译正常但运行过程中报错。 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 方法调用：分派参考《深入理解 Java 虚拟机：JVM 高级特性与最佳实践 第 2 版》 第 8.3.2 章：分派，这一章中介绍了分派的概念，以及静态分派和动态分派的含义，给出的结论是 Java 是一门静态多分派和动态单分派的语言。方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（具体调用哪个方法）。Class 文件的编译过程中不包含链接步骤，所有的方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。方法调用在类加载期间，甚至运行期间才能确定目标方法的入口地址（直接引用)。 变量静态类型和实际类型先看一段代码：Human man = new Man() 。 静态类型 Static Type其中 Human 称为变量的静态类型，或者叫外观类型 Apparent Type。静态类型仅仅在使用时有可能会出现改变，但在编译期能够明确最终的静态类型。也就是说，静态类型决定了变量拥有哪些成员属性和方法。 实际类型 Actual Type其中 Man 称为变量的实际类型。实际类型只能再运行期才能确定，编译器无法判定对象的实际类型是什么。也就是说，实际类型决定了变量只有在运行时才能确定具体执行哪个方法。 123456// 实际类型变化，运行时才能确定 Human man = new Man();man = new Woman();// 静态类型变化，使用时就确定了sr.sayHello((Man) man);sr.sayHello((Woman) man); 根据内存模型，man 是存储在虚拟栈中，属于局部变量表中的引用变量；而 new Man() 表示在堆中分配一块存储区，引用变量的值为指向这块堆的指针。 重载与重写方法的重载和重写是 Java 的多态性的不同表现。重写是父类和子类之间多态性的体现，重载是单个类中多态性的体现。 重载 overloading单个类中定义了多个同名的方法，它们有不同的参数类型或参数个数或参数次序，则该方法被重载。不能通过返回类型，访问权限，抛出异常等进行重载。编译器在编译阶段通过参数的静态类型来作为重载的判断依据。 12345public void sayHello(Human guy)&#123;...&#125;public void syaHello(Man guy)&#123;...&#125;// 根据静态类型的特点，调用的是 sayHello(Human)Human man = new Man();sayHello(man); 重写 Override子类中定义的方法和父类中有相同的名称和参数，则该方法被重写。只有在运行时根据实际类型，虚拟机才能确定调用哪个重写的方法。 12345678910111213class Man extends Human&#123; @Override void sayHello()&#123;...&#125;&#125;class Woman extends Human&#123; @Override void sayHello()&#123;...&#125;&#125;Human man = new Man();Human woman = new Woman();// 根据实际类型的特点，调用子类的方法man.sayHello();woman.sayHello(); 静态方法是类的方法，不存在重写这个说法（无法被 Override 注释），静态方法在编译期间根据静态类型进行了绑定。强烈建议直接使用类来调用静态变量和静态方法，而不是使用对象来调用，养成好习惯。（虽然 Java 语法通过对象来访问，但是这种方式会使得静态属性并不突出） 静态分派依赖静态类型来定位方法具体执行哪个版本（重载时），这个分派动作称为静态分派，典型应用为重载。在静态分派过程中，如果没有指定显示的静态类型，会发生类型的自动转换来匹配最可能的类型， 如：sayHello(&#39;a&#39;)，如果没有明确重载 sayHello(char c) 方法，会按照 ：char -&gt; int -&gt; long -&gt; float -&gt; double -&gt;Character -&gt;Serializable --&gt; Object 的顺序转型。其中： char 转为 int表示 a 除了代表字符串，还可以代表数字 97 。 char 转为它的封装类型 Character是一次自动装箱过程。 char 转为 Serializable是因为 Character 实现了序列化和可比较。但是如果同时重载了 sayHello(Serializable s) 和 sayHello(Comparable c) 会提示类型模糊，编译报错。 动态分派在运行期根据实际类型确定方法执行哪个版本（重写），这个分派过程称为动态分派，典型应用为重写。 单分派和多分派方法的接收者和方法的参数统称为方法的宗量。根据分派基于宗量多少，可以将分派分为单分派和多分派。经典示例： 12345678910111213141516171819202122232425262728293031323334353637public class TestDispatcher &#123; static class Apple &#123;&#125; static class Orange &#123;&#125; public static class Father &#123; public void eat(Apple apple) &#123; System.out.println("Father eat apple."); &#125; public void eat(Orange orange) &#123; System.out.println("Father eat orange."); &#125; &#125; public static class Son extends Father &#123; @Override public void eat(Apple apple) &#123; System.out.println("Son eat apple."); &#125; @Override public void eat(Orange orange) &#123; System.out.println("Son eat orange."); &#125; &#125; public static void main(String[] args) &#123; Father father = new Father(); Father son = new Son(); father.eat(new Apple()); son.eat(new Orange()); &#125;&#125;// ResultFather eat apple.Son eat orange. 这个经典示例中将重载和重写都体现出来了。 编译时编译时多态：即静态分派。编译时会确定下来，去执行 Father.eat(Apple) 和 Father.eat(Orange) ，也就是说即确定了方法的接收者 Father 又确定了参数 Apple/Orange。方法的接收者和参数两个宗量都参与了判断，所以静态分派是多分派类型。这种只基于两种宗量来判断的即为双分派。 运行时运行时多态：即动态分派。运行时，因为参数已经确定，所以只需要确定接受者是 Father 还是它的子类 Son？只需要方法接收者这一个宗量参与判断，所以动态分派是单分派类型。 至此，也验证了结论：Java 是一门静态多分派和动态单分派的语言。 向上转型注意事项特点向上转型：Human human = new Man()，根据父类子类初始化顺序可以得出：子类实例化时会先将父类实例化，也就是说子类能直接访问父类成员变量和方法（受访问控制符限制）。 成员变量成员变量 human 的静态类型为 Human，所以 human 当前只能访问 Human 的成员变量和方法。 成员方法分派成员变量 human 的实际类型为 Man，所以 human 在执行成员方法时会考虑到动态分派：是否被子类重写？如果重写了则执行子类 Man 重写后的方法。 静态方法无法重写，在编译期根据静态类型进行绑定，强烈建议静态方法使用类来调用而不是对象。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153// 1. Parentpublic class Human &#123; private String mHumanPrivateStr = "HumanPrivateStr"; String mHumanDefaultStr = "HumanDefaultStr"; protected String mHumanProtectedStr = "HumanProtectStr"; public String mHumanPublicStr = "HumanPublicStr"; public String mSameNameStr = "HumanSameNameStr"; private static String staticHumanPrivateStr = "StaticHumanPrivateStr"; public static String staticHumanPublicStr = "StaticHumanPublicStr"; &#123; System.out.println("Human normal code block."); &#125; static &#123; System.out.println("Human static code block."); &#125; public Human()&#123; System.out.println("Human Constructor."); &#125; private void privateMethod()&#123; System.out.println("Human: privateMethod."); &#125; public void publicMethod()&#123; System.out.println("Human: publicMethod."); &#125; public void publicNormalMethod()&#123; System.out.println("Human: publicNormalMethod."); &#125; private static void staticPrivateMethod()&#123; System.out.println("Human: staticPrivateMethod."); &#125; public static void staticPublicMethod()&#123; System.out.println("Human: staticPublicMethod."); &#125; public static void staticPublicNormalMethod()&#123; System.out.println("Human: staticPublicNormalMethod"); &#125;&#125;// 2. Subpublic class Man extends Human&#123; private String mManPrivateStr = "ManPrivateStr"; String mManDefaultStr = "ManDefaultStr"; protected String mManProtectedStr = "ManProtectStr"; public String mManPublicStr = "ManPublicStr"; public String mSameNameStr = "ManSameNameStr"; private static String staticManPrivateStr = "StaticManPrivateStr"; public static String staticManPublicStr = "StaticManPublicStr"; &#123; System.out.println("Man normal code block."); &#125; static &#123; System.out.println("Man static code block."); &#125; public Man() &#123; System.out.println("Man Constructor."); &#125; @Override public void publicMethod() &#123; System.out.println("Man: publicMethod"); &#125; private static void staticPrivateMethod()&#123; System.out.println("Man: staticPrivateMethod."); &#125; public static void staticPublicMethod()&#123; System.out.println("Man: staticPublicMethod."); &#125; public void testSuperAndThis()&#123; System.out.println("Man::testSuperAndThis, super.mSameNameStr = " + super.mSameNameStr); super.publicMethod(); System.out.println("Man::testSuperAndThis, this.mSameNameStr = " + this.mSameNameStr); this.publicMethod(); &#125;&#125;// 3. Testpublic class TestOO &#123; public static void main(String[] args) &#123; Human human = new Man(); System.out.println("mSameNameStr = " + human.mSameNameStr); System.out.println("staticHumanPublicStr = " + human.staticHumanPublicStr); // 不建议使用对象访问静态变量，当前只是用来演示 // System.out.println("staticHumanPublicStr = " + Human.staticHumanPublicStr); human.publicMethod(); human.staticPublicMethod(); // 不建议使用对象访问静态方法，当前只是用来演示不会重写 // Human.staticPublicMethod(); System.out.println("******The subclass can access the member and method of the parent.######"); Man man = new Man(); System.out.println("mHumanPublicStr = " + man.mHumanPublicStr); man.publicNormalMethod(); System.out.println("staticHumanPublicStr = " + man.staticHumanPublicStr); // 不建议使用对象访问静态变量，当前只是用来演示可以访问父类静态变量 // System.out.println("staticHumanPublicStr = " // + Human.staticHumanPublicStr); man.staticPublicNormalMethod(); // 不建议使用对象访问静态方法，当前只是用来演示可以访问父类静态方法 // Human.staticPublicNormalMethod(); System.out.println("*******Test super and this ###########"); man.testSuperAndThis(); &#125;&#125;// 4. ResultHuman static code block.Man static code block.Human normal code block.Human Constructor.Man normal code block.Man Constructor.mSameNameStr = HumanSameNameStrstaticHumanPublicStr = StaticHumanPublicStrMan: publicMethodHuman: staticPublicMethod.******The subclass can access the member and method of the parent.######Human normal code block.Human Constructor.Man normal code block.Man Constructor.mHumanPublicStr = HumanPublicStrHuman: publicNormalMethod.staticHumanPublicStr = StaticHumanPublicStrHuman: staticPublicNormalMethod*******Test super and this ###########Man::testSuperAndThis, super.mSameNameStr = HumanSameNameStrHuman: publicMethod.Man::testSuperAndThis, this.mSameNameStr = ManSameNameStrMan: publicMethod 示例演示了父类子类的初始化顺序，super, this 的使用，向上转型成员变量的访问，静态变量及静态方法的访问，普通方法的重写。 抽象类Java 中包含抽象类，抽象方法。抽象类表明这个类只能被继承，抽象方法表明这个方法必须由子类实现。 规则 抽象类和抽象方法必须使用 abstract 修饰 有抽象方法的类必须被定义为抽象类；但是反过来抽象类可以没有抽象方法 抽象类（即使不包含抽象方法）不能被实例化，即无法通过 new 来构造抽象类的实例 抽象类可以包含属性、方法（普通或者抽象方法）、构造器、初始化块、内部类、枚举类 6 种成分。抽象类的构造器不能用于创建实例，主要用于供子类调用 注意事项 抽象方法和空方法是两个不同的概念，抽象方法没有方法体（即花括弧 {}）；而空方法是指方法体内为空 abstract 不能修饰属性和构造器，即 Java 中没有抽象属性的说法，也没有抽象构造器 static 修饰的方法是属于类的，所以如果该方法同时被定义为 abstract 的会导致编译错误。即 abstract 不能和 static 同时修饰方法 private 访问控制符修饰的方法，子类无法访问，所以该方法如果被定义为 abstract 会导致子类无法实现。即 abstract 不能和 private 同时修饰方法 作用和意义抽象方法是定义一种或者一类事物必须有的一种技能，但是这种技能对于各个继承者的表现形式不一样，就把它定义为抽象方法。抽象类将事物的共性的东西提取出来，抽象成一个高层的类。如果一个类中没有包含足够的信息来描绘一个具体的对象，我们将这样的类定义为抽象类。抽象类往往用来表示对问题领域的抽象概念，看上去行为不同，但是本质上相同的具体概念的抽象。正是因为抽象的概念在问题领域没有对应的具体概念，所以用以表征抽象概念的抽象类是不能够实例化的。比如三角形、圆形、长方形等都属于形状。 接口接口 Interface 是一组抽象方法的集合。接口用于从多个相似类中抽象出规范。 规则 接口可以多重继承接口，但是不能继承类 接口因为定义的是规范，所以不能包含构造器和初始化块 接口可以包含属性、方法、内部类（包含内部接口、枚举类），它们默认且也只能是 public 访问权限 接口的属性变量都是常量（默认会自动添加 public static final），方法都是抽象方法（默认会自动添加 public abstract；Java 8 接口增强中已经支持非抽象的默认方法，使用 defualt 修饰） 注意事项 接口中都是抽象方法，所以不能使用 static 修饰（Java 8 接口增强中已经支持静态方法） 接口不能显示继承任何类 接口的实现类使用 implements 关键字 实现接口方法时，必须使用 public 修饰 作用和意义接口体现的是一种规范和实现分离的设计理念，可以很好的降低程序各模块之间的耦合，通常可以用于面向接口编程。 Java 8 接口增强Java 8 接口增强：支持默认方法和静态方法，其中默认方法需要增加 default 关键字修饰。 123456789interface MyInterface &#123; default void defaultMethod() &#123; System.out.println("default method invoked! "); &#125; static void staticMethod() &#123; System.out.println("static method invoked! "); &#125;&#125; 抽象类和接口的异同相同点：抽象类和接口都不能被实例化，只能由子类继承或者其他类实现。不同点： 抽象类可以包含静态方法和普通方法，接口不可以（但是 Java 8 接口增强后是可以的） 接口不包含构造器和初始化代码块 接口支持多重继承，抽象类只能单继承 常见问题继承时出现同名成员变量和方法 子类父类成员变量同名父类的成员变量会被屏蔽，子类访问该同名成员变量显示的是子类的，可以通过 super 来访问父类的同名成员变量。 子类父类成员方法同名子类会重写父类的同名方法，通过 super 访问父类同名成员方法。 如果出现同名成员变量和方法，父类的成员变量和方法会被子类屏蔽（重写），在子类中可以通过 super 来访问。 静态属性和静态方法是否可以被继承？是否可以被重写？ 子类继承父类后，参考子类初始化顺序可知，继承了父类所有属性和方法。但是子类访问父类属性和方法时，会受访问控制符限制 重写是指方法重写，多态针对的是对象而不是类。静态方法属于类，并不属于对象，所以不存在重写这一说。对象在调用静态方法时，会根据静态类型直接绑定 在实际编码中，强烈建议直接使用类来调用静态属性和静态方法，养成好习惯。 参考文档 深入理解 Java 虚拟机: JVM 高级特性与最佳实践 第 2 版 分派 Java中为什么静态方法不能被重写？ 图解Java继承内存分配 JAVA的多态直观的解释 Java的三大特性——多态 Java中为何要定义抽象类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 代码执行顺序]]></title>
    <url>%2F2018%2F04%2F10%2F0073-java-code-exec-sequence%2F</url>
    <content type="text"><![CDATA[Java 代码执行顺序：main 方法，类初始化过程，类实例化过程。 main 方法规则 如果当前类作为 Java 程序运行，则 main 是程序的入口方法 如果当前类仅仅作为类实例，则 main 方法和普通 static 方法一样，只有主动调用时才会执行 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1. 程序入口public class TestMajorMain &#123; public void major()&#123; System.out.println("TestMajorMain, major function."); &#125; public TestMajorMain()&#123; System.out.println("TestMajorMain, Constructor."); &#125; public static void main(String[] args) &#123; System.out.println("TestMajorMain, main."); TestMinorMain minorMain = new TestMinorMain(); minorMain.minor(); &#125;&#125;// 2. 仅作为类实例public class TestMinorMain &#123; public void minor()&#123; System.out.println("TestMinorMain, minor function."); &#125; public TestMinorMain()&#123; System.out.println("TestMinorMain, Constructor."); &#125; public static void main(String[] args) throws InterruptedException &#123; System.out.println("TestMinorMain, main."); Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true)&#123; &#125; &#125; &#125;); thread.start(); Thread.sleep(100); thread.join(); System.out.println("TestMinorMain, quit."); &#125;&#125;// 3. 执行 TestMajorMain 后的结果TestMajorMain, main.TestMinorMain, Constructor.TestMinorMain, minor function. Java 代码执行顺序执行顺序理论基础，参考：Java 类加载机制 规则 类初始化过程：静态成员，静态代码块 类实例化过程：即调用构造方法生成实例时 普通成员，构造块 然后构造方法 类初始化过程中，可能调用了实例化过程（因为 static 可以修饰方法，属性，代码块，内部类），此时则会暂停类初始化过程而先执行实例化过程（被打断），执行结束后再进行类初始化过程。 示例下面就是典型的暂停类初始化示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class TestExecSequence &#123; public static int k = 0; public static TestExecSequence t1 = new TestExecSequence("t1"); public static TestExecSequence t2 = new TestExecSequence("t2"); public static int i = print("i"); public static int n = 99; public int j = print("j"); &#123; print("constructor code block."); &#125; static &#123; print("static code block."); &#125; public TestExecSequence(String str) &#123; System.out.println("###### TestExecSequence Constructor *******"); System.out.println((++k) + ":" + " i=" + i + " n=" + n + " " + str); ++i; ++n; &#125; public static int print(String str) &#123; System.out.println((++k) + ":" + " i=" + i + " n=" + n + " " + str); ++n; return ++i; &#125; public static void main(String args[]) &#123; System.out.println("****** TestExecSequence main #####"); TestExecSequence t = new TestExecSequence("main t"); &#125;&#125;// Result1: i=0 n=0 j2: i=1 n=1 constructor code block.###### TestExecSequence Constructor *******3: i=2 n=2 t14: i=3 n=3 j5: i=4 n=4 constructor code block.###### TestExecSequence Constructor *******6: i=5 n=5 t27: i=6 n=6 i8: i=7 n=99 static code block.****** TestExecSequence main #####9: i=8 n=100 j10: i=9 n=101 constructor code block.###### TestExecSequence Constructor *******11: i=10 n=102 main t 所有成员变量在初始化前都是默认初始值。 代码解析： 成员变量默认值：k = i = n = j = 0 代码顺序执行，初始化 k = 0 出现类初始化暂停，t1 执行实例化过程 t1 实例化过程中，先执行成员变量初始化 j，再执行构造代码块，最后执行构造方法 t1 实例化完后，恢复类初始化过程，接着遇到了 t2 实例化，继续暂停类初始化，执行 t2 实例化过程 同 t1 实例化一样，依次初始化 j，构造代码块，构造方法 恢复类初始化，静态成员变量初始化 i 和 n = 99 继续类初始化，执行静态代码块 所有静态成员和静态代码块执行完后，进入程序 main 方法 在 main 中，实例化 t ，依次执行初始化 j，构造代码块，构造方法 子类实例化顺序规则子类实例化时会先实例化父类，代码执行顺序基本上参考上面的规则，但是父类先执行，具体如下： 父类类初始化过程：静态成员变量，静态代码块 子类类初始化过程：静态成员变量，静态代码块 父类类实例化过程：普通成员变量，构造代码块，最后父类的构造方法 子类类实例化过程：普通成员变量，构造代码块，最后子类的构造方法 static 静态成员变量和方法是属于类的，所以只会在类初始化时初始化或执行一次，类在多次实例化时不会重复执行。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 1. Fatherpublic class Father &#123; public static String staticFatherStr = "StaticFatherStr"; public String mNormalFatherStr = "NormalFatherStr"; static &#123; System.out.println("Father static code block, staticFatherStr = " + staticFatherStr); &#125; &#123; System.out.println("Father Constructor code block, mNormalFatherStr = " + mNormalFatherStr); &#125; public Father()&#123; System.out.println("Father Constructor"); &#125;&#125;// 2. Sonpublic class Son extends Father&#123; public static String staticSonStr = "StaticSonStr"; public String mNormalSonStr = "NormalSonStr"; static &#123; System.out.println("Son static code block, staticSonStr = " + staticSonStr); &#125; &#123; System.out.println("Son Constructor code block, mNormalSonStr = " + mNormalSonStr); &#125; public Son()&#123; System.out.println("Son Constructor"); &#125; public static void main(String[] args) &#123; Son son = new Son(); System.out.println("***** Second Instance.#####"); Son second = new Son(); &#125;&#125;// 3. ResultFather static code block, staticFatherStr = StaticFatherStrSon static code block, staticSonStr = StaticSonStrFather Constructor code block, mNormalFatherStr = NormalFatherStrFather ConstructorSon Constructor code block, mNormalSonStr = NormalSonStrSon Constructor***** Second Instance.#####Father Constructor code block, mNormalFatherStr = NormalFatherStrFather ConstructorSon Constructor code block, mNormalSonStr = NormalSonStrSon Constructor 参考文档 类的初始化与实例化 深入了解Java程序执行顺序 Java中父类和子类初始化顺序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Lambda 表达式]]></title>
    <url>%2F2018%2F04%2F04%2F0072-java-lambda%2F</url>
    <content type="text"><![CDATA[概念 Lambda大写 Λ，小写 λ。读音：lan b（m） da（兰木达）[&#39;læmdə]。 Lambda 表达式Lambda expression ：基于数学中的 λ 演算得名，直接对应于其中的 Lambda 抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数，在 Java 中又称为闭包或匿名函数。而 λ演算 是函数式编程的基础，所以 Lambda 表达式具有部分函数式语言的特征。特点就是简(省)单(代)优(码)雅。 重要特性Lambda 表达式的语法123(params) -&gt; expression(params) -&gt; statement(params) -&gt; &#123; statements &#125; 示例： 1234567891011// Java 8 之前匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Before Java8, too much code for too little to do"); &#125;&#125;).start();// Java 8 Lambdanew Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start(); 其他示例： 参数可以是零个或多个 参数类型可指定，可省略（根据表达式上下文推断） 参数包含在圆括号中，用逗号分隔 表达式主体可以是零条或多条语句,包含在花括号中 表达式主体只有一条语句时,花括号可省略 表达式主体有一条以上语句时，表达式的返回类型与代码块的返回类型一致 表达式只有一条语句时，表达式的返回类型与该语句的返回类型一致 1234567891011121314151617181920212223// 零个()-&gt; System.out.println("no argument"); // 一个x-&gt;x+1// 两个(x,y)-&gt;x+y// 省略参数类型View.OnClickListener oneArgument = view-&gt;Log.d(TAG,"one argument");// 指定参数类型View.OnClickListener oneArgument = (View view)-&gt;Log.d(TAG,"one argument");// 多行语句// 返回类型是代码块返回的 voidView.OnClickListener multiLine = (View view)-&gt;&#123; Log.d(TAG,"multi statements"); Log.d(TAG,"second line");&#125;// 返回类型是表达式主体，语句的返回类型 int(int x)-&gt;x+1 方法引用 Method Reference格式：类名::方法名。注意：只需要写方法名，不需要写括号。方法引用来简写 Lambda 表达式中已经存在的方法。示例： 123456789101112// Java 8 之前使用 for-each 遍历List features = Arrays.asList("Lambdas", "Default Method", "Stream API");for (String feature : features) &#123; System.out.println(feature);&#125;// Java 8 Lambda 表达式List features = Arrays.asList("Lambdas", "Default Method", "Stream API");features.forEach(n -&gt; System.out.println(n)); // 使用方法引用简化 Lambda 表达式features.forEach(System.out::println); 方法引用的四种形式： 引用静态方法ContainingClass::staticMethodName 引用某个类型的任意对象的实例方法ContainingType::methodName 引用构造方法ClassName::new 引用某个对象的实例方法containingObject::instanceMethodName 函数式接口 FI函数式接口：指仅含有一个抽象方法的接口。首先是一个接口，然后就是在这个接口里面只能有一个抽象方法。以 @Functionalnterface 标注，简称 FI 。但是加不加 @FunctionalInterface 对于接口是不是函数式接口没有影响，该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法。 1234// 首先是接口，其次只有一个抽象方法 interface OnClickListener &#123; void onClick(View v);&#125; 引申Java 8 中引入了新特性，向接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。也就是说新特性中，接口可以和抽象类一样，具有默认或静态的方法实现，如示例： 123456789101112131415161718文件：java.util.function.Predicate.java@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; // 只包含一个抽象方法，所以是函数式接口 boolean test(T t); ... // 默认方法，关键字 default default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) &#123; Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); &#125; // 静态方法，关键字 static static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123; return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); &#125;&#125; 以前如果接口中新增方法，需要修改所有的实现类增加方法的对应实现。 Java 8 的这个新特性就是主要解决这类问题的，放到接口中后，实现类不需要重写，确保老版本的代码能够兼容。 Lambda 实现函数式接口Lambda 通过该方式，大大简化了代码量，也是最基本的表达式之一。 12345678910// Java 8 之前匿名内部类button.setOnClickListener(new View.onOnClickListener()&#123; @Override public void onClick(View v)&#123; v.setText("abc"); &#125;&#125;);// Lambda 表达式简化函数式接口 button.setOnClickListener(v -&gt; v.setText("abc")); this 关键字Lambda 表达式即将正式取代 Java 代码中的匿名内部类，他们在关键字 this 上有很大不同：匿名类的 this 关键字指向匿名类，而 Lambda 表达式的 this 关键字指向包围 Lambda 表达式的类。 局部变量Lambda 表达式对局部变量有个限制，那就是只能引用 final 局部变量，这就是说不能在 Lambda 表达式内部修改定义在域外的变量。示例： 12345678910List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);int factor = 2;primes.forEach(element -&gt; &#123; factor++; &#125;);// 编译报错 Compile time error : "local variables referenced from a lambda expression must be final or effectively final"// 但是可以直接访问primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;); 集合的流式操作流式操作： JDK8 的 Stream 是一个受到函数式编程和多核时代影响而产生的东西。java.util.stream 包，实现了集合的流式操作，流式操作包括集合的过滤，排序，映射等功能。根据流的操作性，又可以分为串行流和并行流。根据操作返回的结果不同，流式操作又分为中间操作和最终操作。大大方便了我们对于集合的操作： 最终操作：返回一特定类型的结果 中间操作：返回流本身 Map 和 Reduce 应用Map 和 Reduce 操作是函数式编程的核心操作，map 将集合类（例如列表）元素进行转换，也就是将参数转换成想要的返回值；reduce 函数可以将所有值合并成一个，又被称为折叠操作。示例： 12345678910111213141516// Java 8 之前，为每个订单加上12% 的税List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double total = 0;for (Integer cost : costBeforeTax) &#123; double price = cost + .12*cost; total = total + price;&#125;System.out.println("Total : " + total); // Java 8 Lambda 表达式List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);double bill = costBeforeTax.stream() .map((cost) -&gt; cost + .12*cost) .reduce((sum, cost) -&gt; sum + cost) .get();System.out.println("Total : " + bill); 过滤器 filter过滤是在大规模集合上的一个常用操作，而使用 Lambda 表达式和流 API 过滤大规模数据集合非常简单。示例： 123456// 创建一个字符串列表，每个字符串长度大于 2List&lt;String&gt; filtered = strList.stream() .filter(x -&gt; x.length()&gt; 2) .collect(Collectors.toList());System.out.printf("Original List : %s, filtered list : %s %n", strList, filtered); 参考文档 傻瓜函数式编程 lambda表达式10个示例 深入理解Java 8 Lambda 30分钟入门lambda表达式 Java8之默认方法和静态接口方法 java8 集合流式操作]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式总结]]></title>
    <url>%2F2018%2F04%2F03%2F0071-design-patterns-summary-2%2F</url>
    <content type="text"><![CDATA[设计模式总结。 模式分类初步分类 细分 创建型模式创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。创建型模式在创建什么，由谁创建，何时创建等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 建造者模式建造者模式 Builder Pattern：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。通俗点讲：建造者模式类似同一条生产线，生产过程可以一样，但是放入的材料不一样生产出来的产品就不一样，比如放入纸就生产出纸碗，放入铁就生产出铁腕。又如个人电脑组装，组装步骤和顺序差不多，但是使用的显示器，显卡，内存，硬盘，操作系统都可以不一样，虽然最终都是组装出来电脑，但是配置完全不一样。 标准建造者模式类图 常用简化版模式类图 工厂方法模式工厂方法模式 Factory Method Pattern：定义一个用于创建对象的接口，让子类决定实现哪一个类。工厂方法使一个类的实例化延迟到其子类。用来生产同一等级结构中的固定产品。支持增加产品，只需增加对应的工厂实现类。 抽象工厂模式抽象工厂模式 Abstract Factory Pattern：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。用来生产不同配置的产品族，比如组装一台电脑，一辆车，他们通常由固定数量的零部件组成，但是每个零部件都会有多种配置。支持增加产品族，只需增加具体的工厂实现类，配置不同的产品类型。但是不支持增加产品，会修改抽象工厂及所有工厂实现类。 原型模式原型模式 Prototype[&#39;protəˌtaɪp] Pattern：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新对象。原型模式就是指 Clone 技术，以某个对象为原型，复制出一个新的对象。既然是 Clone 就会涉及到对象的深浅拷贝： 浅拷贝 shallow copy浅拷贝在拷贝对象时，并不会拷贝对象里的引用对象，也就是说不拷贝该对象的属性。 深拷贝 deep copy深拷贝在拷贝对象时，需要手动代码实现对引用对象的拷贝，也就是把该对象的所有属性也克隆出一份新的。 在 Java 中，原型模式的 Prototype 抽象类并不需要我们定义，Cloneable 接口实现了这个功能。在使用原型模式时，必须实现 Cloneable 接口，否则会抛出 CloneNotSupportedException 异常。并且 Object.clone 这个方法是直接从堆内存中以二进制流拷贝的，所以产生新对象时并不会调用类的构造方法。 单例模式单例模式 Singleton Pattern：保证一个类只产生唯一的一个实例，并提供一个访问它的全局访问点。单例模式一般用于某个类有且仅有一个对象，避免产生多个对象消耗过多资源，或者访问 IO 或数据库等资源时。单例模式的特点： 构造函数为 private 通过静态方法或者枚举返回单例类对象 确保单例类对象有且仅有一个，特别是多线程场景 单例类在反序列化时不会重构对象 单例模式在多线程中，有多种实现方式，常见有：饿汉模式，懒汉模式，经典双检锁，枚举实现等。从多线程角度来看，单元素枚举是实现单例模式最佳方法。详细分析参考：Java 多线程并发:单例模式多线程 结构型模式结构型模式总共有七种，简写为：ABCDFFP(Adapter, Bridge, Composite, Decorator, Façade, Flyweight, Proxy)，也就是对应的的适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式和代理模式。结构型模式主要用于描述如何组合类和对象以获得更大的结构。其中，结构型类模式采用继承机制来组合接口和实现，而结构型对象模式则采用组合/聚合方式来组合对象以实现新功能，因为它可以在运行时刻改变对象组合关系，所以对象组合方式具有更大的灵活性。结构型模式体现了优先使用对象组合，而不是类继承的原则。 适配器模式适配器模式 Adapter Pattern：将类的接口转换成客户希望的接口，使得原本由于接口不兼容的类可以一起工作。适配器模式使得接口不兼容的两个类能在一起工作，通俗易懂的例子就是电源适配器。但是 Java 不支持多重继承，也就是每次只能适配一个类。 桥接模式桥接模式 Bridge Pattern：*将抽象和其实现分离，具体的子类使用不同的方式去实现，从而可以独立的改变它们，体现了组合重用原则。实现独立出来各自变化，每次变化不会影响其他实现 *。通俗的解释：实现系统可能有多角度的分类，每一种分类都有可能变化，那么就把这种多角度分离出来让他们独立变化，减少他们之间的耦合。任何多维度变化类或者多个树状类，都可以通过桥接模式解耦。桥接模式的桥梁作用也是连接“抽象部分”和“实现部分”；或者是将不同角度的分类连接起来。比如咖啡从容量上可以分为大杯，小杯；从味道上可以分为甜，不甜等等。桥接模式最大的特点是将抽象部分与它的实现部分分离，使它们都可以独立地变化，也就是两种维度可以独自扩展。 组合模式组合模式 Composite Pattern：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。通常用于可以使用树状结构描述的场景，比如：公司的组织结构图，操作系统中的文件系统，常见的 UI 框架 View/ViewGroup 等等。根据 Composite 中定义的方法，可以分为： 安全组合模式Component 中并没有将管理子对象抽象出来，也就是不包含 add/remove 等，但是这会导致子对象和组合对象接口不一致。Android View/ViewGroup 就属于安全组合模式。 透明组合模式Component 中将管理子对象抽象到基类中，使得子对象和组合对象具有完全一致的行为接口，但是叶子类实际上并不需要这些管理行为。 从两个类图中可以看出，组合模式符合开闭原则：增加叶子或树干并不需要修改类库，在客户端就可以实现。但是违反了依赖倒置原则：叶子节点和组合类都是实现类，而不是抽象类。 装饰模式装饰模式 Decorator[ˈdɛkəˌretɚ] Pattern：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比直接修改子类更加灵活。装饰模式也称为包装模式 Wrapper Pattern，常见于给某个对象添加功能而不是整个类。装饰模式可以修改对象的功能，而不用修改子类代码。代码中如果看到 Wrapper 结尾的类，通常是用了装饰模式的设计思路。装饰模式通常用于动态和透明的扩展类的功能，特别是当系统维护中需要添加新功能，而这个功能是需要向旧类中添加新代码，而这个功能并不是旧类的主要职责或者核心功能。在这种场景下，使用装饰模式添加一个装饰类，在不破坏原有代码的基础上，动态的给对象添加或修改功能。 外观模式外观模式 Facade [fəˈsɑːd] Pattern：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式描述如何用单个对象表示整个子系统。为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口。体现了依赖倒转原则，典型场景： MVC 架构、基金对股票的封装等。 享元模式享元模式 Flyweight Pattern：运用共享技术有效的支持大量细粒度的对象。享元模式将对象划分为内部状态和外部状态，共享内部状态，通过共享池来减少对象的一种模式。 内部状态享元对象内部不会随环境改变而改变的共享部分，称为享元对象的内部状态。也就是说，内部状态是不变的部分。 外部状态受环境影响改变，不可共享的部分，称为享元对象的外部状态。也就是说，外部状态是变化的。 比如一堆衣服中有男女两个款式，如果需要请模特过来拍照展示，其中性别是无法改变的部分，即内部状态；而衣服款式是多变不一样的，所以款式是外部状态。在这个例子中，通过创建共享池共享性别对象。 享元模式主要使用了缓存来减少创建重复对象，能大大降低内存占用率。 代理模式代理模式 Proxy[ˈprɑ:ksi] Pattern：为其他对象提供一种代理以控制对这个对象的访问。代理模式也称为委托模式，控制对象使得只有确实需要这个对象时才创建和初始化。代理分为：静态代理和动态代理。静态代理：编译前所有的代码已经存在。动态代理：通过反射机制动态地生成代理对象，也就是代码编译中并不知道代理关系，动态代理将代理和被代理对象进行了解耦。另外，常见代理功能： 远程代理 Remote Proxy常见于 C/S 模式，为某个对象在不同的内存地址空间提供局部代理，使系统可以将 Server 部分实现隐藏，Client 像使用本地对象一样使用 Server。 虚拟代理 Virtural Proxy使用一个代理对象表示一个十分耗资源的对象，并在真正需要时才创建。比如图片代理：对大图浏览的控制，用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。 保护代理 Protection Proxy使用代理控制对原始对象的访问，这种模式常见于原始对象有不同的访问权限。 在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 行为型模式解释器模式解释器模式 Interpreter[ɪnˈtɜ:rprɪtə] Pattern：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。解释器模式主要用来按指定规则解析一串语句，如：解析歌谱，XML，算术运算，逆波兰表达式，机器人动作指令等等。 模板方法模式模板方法模式 Template Pattern：定义一个操作中的算法的框架，而将详细的步骤延迟到子类中。模板方法使得子类可以不改变算法的结构下重新定义算法的步骤。一个算法可以明确分割为几个关键步骤，这几个步骤的顺序是固定的，但是每个步骤的实现会随环境的改变而变化，对于这类问题常用模板方法来解决。 模板方法模式是把不变行为搬移到父类，去除子类的重复代码，帮助子类摆脱重复不变行为的纠缠。常见使用场景： 子类有共有方法，并且逻辑基本相同 用于代码重构，将公共方法抽取到父类中 在 Android 中，Activity/Fragmengt 等的生命周期是标准的模板方法，以及 AsyncTask 的执行步骤 onPreExecute --&gt; doInBackgroud --&gt; onPostExecute 等这些都是模板方法的体现。 责任链模式责任链模式 Chain of Responsibility[rɪˌspɑ:nsəˈbɪləti] Pattern：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将多个对象的请求连成一条链，并沿着这条链传递请求，直到有一个对象处理为止，避免请求的发送者和接收者之间耦合。责任链模式避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。也常用来替代各种分支和条件判断语句。 命令模式命令模式 Command Pattern：将请求封装为一个对象，从而可以将不同的请求作为参数来传递。对请求排队或记录日志，以及支持可撤销的操作。命令模式类似系统菜单，比如开机、关机、重启、注销等等，这些动作都封装成命令对象，作为参数记录并执行。命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求，这就是命令模式的模式动机。 迭代器模式迭代器模式 Iterator[ɪtə&#39;reɪtə] Pattern：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露对象内部表示。迭代器模式又称为游标 Cursor 模式，是非常古老的设计模式，主要用于对容器的遍历访问，当前高级面向对象语言基本上默认包含这个模式。 Java 语言已经包含了迭代器接口 Interator，在实际使用中仅仅需要实现 Collection 集合就能应用迭代器模式，其中 List, Map 等等都都是常见迭代器容器。 中介者模式中介者模式 Mediator[ˈmidiˌetɚ] Pattern：用一个中介对象来封装一系列的对象交互。使得各对象不用显式的相互引用，从而使其耦合松散，而且可以独立改变它们之间的交互。中介者模式又称为调停者模式，将多对多的相互作用转换为一对多的相互作用，减少对象间的复杂引用关系，使得成为一个松耦合系统。 中介者模式是迪米特原则的典型应用，体现了如果不需要直接通信的两个类可以使用第三方转发。中介者模式类似电脑的主板协调各个器件工作；系统的各个总线协调驱动程序运行；中介者模式能够将错综复杂的网状图优化成结构清晰的星型图，其中心就是中介者；MVC 架构中的 Control 就是典型的中介者。所有的 UI 交互系统，如 C#/Form, Android Activity 中的 UI 交互界面，都承担了中介者的角色，它会将 Button, TextView, EditText 等连接起来，这些控件的交互都是通过窗体来中转，响应并显示的。 备忘录模式备忘录模式 Memento[məˈmentoʊ] Pattern：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。后期可以直接将该对象恢复到原先保存的状态。备忘录模式常用于存档，编辑回退等场景，主要是保存某个对象当前的状态。 根据备忘录发起方 Originator 的可见性，可以将备忘录模式分为： 白箱模式备忘录完全可见，暴露给其他类，这种是最常见的备忘录模式，如上面的类图。 黑箱模式备忘录抽象一个空接口出来，而备忘录则以内部类的形式在 Originator 中实现对应功能，这样外部类在访问的时候，只能拿到空接口。 观察者模式观察者模式 Observer Pattern：定义一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。在主题对象在状态变化时会通知所有观察者对象，使它们自动更新。观察者模式又叫发布/订阅模式 Publish/Subscribe，最常用于 GUI 系统，订阅发布系统。 Java 语言规范中已经集成了标准的观察者模式 Observable/Observer，其中 Observable 即为主题或抽象通知者，Observer 为观察者。所以 Java 中实现观察者模式非常简单，主题继承 Observable ，观察者实现 Observer。 状态模式状态模式 State Pattern：当对象的内部状态改变时允许改变其行为，该对象看起来像是改变了其类。状态模式主要是解决当控制一个对象状态转移的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。 状态模式是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，可以使用状态模式。 策略模式策略模式 Strategy[ˈstrætədʒi] Pattern：定义一系列的算法，单独封装并使它们可以相互替换。这一模式可以使算法独立于使用它的客户而变化。策略模式定义一系列算法的方法，从概念上看，所有的这些算法完成的多是相同的工作，只是实现不同，他们可以使用相同的方法来调用算法，减少了类之间的耦合。 访问者模式访问者模式 Visitor Pattern：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义于作用于这些元素的新操作。访问者模式把数据处理和数据结构分离。在数据结构相对稳定时，访问者模式使得数据处理的算法修改或增加都变得非常容易。访问者模式使用两次动态单分派来间接实现伪动态双分派。 访问模式中的动态双分派体现在 accept 这个方法上： 第一次动态分派在 ObjectStructure.accept 中遍历执行 Element.accept 时，并不确定接受者具体是哪个 ConcreteVisitor1/ConcreteVisitor2，运行时确定。 第二次动态分派在 Element.accept 中，Visitor 并不确定参数具体是哪个 ConcreteElementA/ConcreteElementB，运行时确定。 组合实现了双分派，只有在运行时才能确定是哪个 Visitor 访问哪个 Element。 模式比对状态模式和责任链模式的异同策略模式，责任链模式，状态模式，这三种模式常用来替代各种分支和条件判断语句。 相同点都能解耦和优化大量的逻辑判断。 不同点状态模式每个子类能清楚的直到下个状态是谁或者哪个子类，相当于 if-else 分支判断；而责任链模式并不清楚整个链条中是哪个子类处理的，下个责任人也需要客户端来指定，更灵活，相当于 switch-case 分支判断。通俗来讲，状态模式的下一个状态是明确的，固定的；而责任链中下一个处理者并不固定，需要客户端动态指定。 状态模式与策略模式的异同 相同点策略模式也是为了消除或者简化条件语句，和责任链模式，状态模式很类似。所以类图结构上看起来几乎没有太大区别。 不同点状态模式中各个状态子类都必须知道它的下一个状态是什么，并且逻辑判断都转移到子类中，客户端并不了解状态的转换逻辑。而策略模式中各个子类是并级的，可以相互替换，他们并不存在状态转换的关系。策略模式是针对单一并行算法的替换，客户端需要提前了解各算法差异，并在策略模式中指定一种算法。 策略模式和责任链模式的异同 相同点在功能职责上都是用来简化或消除条件判断，客户端在使用时需要提前指定使用哪种策略，或者指定责任链模式中的下一个继任者。 不同点两者在类图上有区别，责任链模式需要持有下一个责任人的引用，策略模式多一个上下文类，由上下文类来持有具体的策略。责任链模式存在级差，每个子类拥有不同的责任权限；而策略模式子类都是并级的，客户端在选用时只需要选择一种策略。 代理模式和外观模式主要区别在于，代理对象代表一个单一对象而外观对象代表一个子系统。代理模式的客户端无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观模式中客户端可以直接访问子系统的各个对象，但通常由外观对象提供对子系统各个功能简化的、共同层次的调用接口。 适配器模式和外观模式外观模式通常是定义一个新的接口，为现存系统提供一个更为方便的访问接口；而适配器模式往往是适配一个原有的接口，使两个已有的接口协同工作。另外，适配器模式主要是匹配对象的，只匹配一个类，而外观模式匹配的是整个子系统。 装饰模式和桥接模式 类图结构有较大区别，从对比图中可以看出： 结构维度桥接模式是不同维度的分类，属于平行结构；装饰模式是继承结构，在继承的基础上修改功能。 是否继承桥接模式的两种维度没有继承关系，仅仅是组合关系（松耦合）；而装饰模式除了组合还必须是继承关系（紧耦合），也就是 Decorator 继承并组合了 Component。 方法名是否一致桥接模式仅仅需要组合，所以方法名一般不同；装饰模式因为带有继承关系，所以装饰时重写方法，方法名相同。 装饰模式和代理模式 类图结构基本一致 override 重写方法后的侧重点不一样装饰器模式关注于在一个对象上动态的添加或修改方法；代理模式关注于控制对对象的访问，对是否执行实现类有决定权。 12345678910111213141516// 1. 装饰器模式@Overridepublic void operation() &#123; impl.operation(); addBehavior();&#125;// 2. 代理模式 @Overridepublic void operation() &#123; if (hasOption())&#123; impl.operation(); &#125; else &#123; System.out.println("不符合选项。"); &#125;&#125; 装饰模式和代理模式非常非常像，唯一的区别在与侧重点不一样：装饰模式侧重于修改功能，代理模式侧重于控制访问。 模式在 Android 中的应用 建造者模式常见于 AlertDialog.Builder 及其他 Builder 类中。 原型模式在 Intent.clone 或者其他支持并重写了 Clone 方法的类。 装饰模式Android 中的 Context/ContextWraaper 就是经典的装饰模式。 责任链模式常见的责任链模式就是 View 按键事件分发机制。 迭代器模式Cursor 是典型的迭代器模式。 观察者模式所有 regeister 类型都是观察者模式，如 Android.BroadcastReceiver 广播，数据库更新通知等。 备忘录模式Activity.onSaveInstanceState, Activity.onRestoreInstanceState 保存或恢复当前状态，但并不是每次都会执行。 模板方法模式Activity/Fragmengt 等的生命周期是标准的模板方法，以及 AsyncTask 的执行步骤 onPreExecute --&gt; doInBackgroud --&gt; onPostExecute 等这些都是模板方法的体现。 中介者模式文件名包含 Mediator 关键字的类，都可能使用了中介者模式，如：KeyguardViewMediator。 代理模式整个 Binder 机制中都会使用到代理模式，所有服务注册相关都会对应一个代理。 组合模式View/ViewGroup 标准组合模式。 适配器模式ListView, RecyclerView 等在数据填充时会使用到 Adapter 。 还有 Java 语言中默认支持原型模式 Cloneable，迭代器模式 Interator，观察者模式 Observable/Observer。 参考文档 大话设计模式 Android 源码设计模式解析与实战 设计模式总结之模式分类 结构型模式总结 装饰模式和代理模式区别 责任链模式和状态模式对比 访问模式和双分派]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：访问者模式]]></title>
    <url>%2F2018%2F03%2F30%2F0070-design-patterns-visitor%2F</url>
    <content type="text"><![CDATA[访问者模式：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义于作用于这些元素的新操作。 分派参考《深入理解 Java 虚拟机：JVM 高级特性与最佳实践 第 2 版》 第 8.3.2 章：分派，这一章中介绍了分派的概念，以及静态分派和动态分派的含义，给出的结论是 Java 是一门静态多分派和动态单分派的语言。具体分析也可以参考：Java 面向对象的特征 – 方法调用：分派 访问者模式访问者模式 Visitor Pattern：把数据处理和数据结构分离。在数据结构相对稳定时，访问者模式使得数据处理的算法修改或增加都变得非常容易。访问者模式使用两次动态单分派来间接实现伪动态双分派，具体可以参考类图及代码分析。 类图结构 结构解析 Element抽象类，元素，定义一个 accept 方法，表示每个元素都能被访问者访问。 Visitor抽象类，访问者，定义对每一个元素访问的行为，它的参数就是可以访问的元素。虚方法个数理论上和元素子类个数是一致的，表示访问每一个元素。 ConcreteElement实现类，元素中 accept 的具体实现。实现格式很固定，就是调用 Visitor 中访问该具体元素的方法。充分利用双分派技术，实现数据处理和数据结构的分离。 ConcreteVisitor实现类，定义访问者访问某个元素时具体的行为。 ObjectStructure定义一个数据结构对象，管理元素的集合，并能够让访问者遍历访问每个元素。 Client客户端。 访问者模式中 ObjectStructure, Element, ConcreteElement 三者很像一个观察者模式。访问者模式的优势在与数据处理和数据结构的分离，其中数据结构即为 Element ，数据处理即为 Visitor。修改数据的处理方式非常简单，但是如果增加数据结构将会变得很麻烦。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 1. Elementpublic abstract class Element &#123; public abstract void accept(Visitor visitor);&#125;// 2. ConcreteElementpublic class ConcreteElementA extends Element&#123; @Override public void accept(Visitor visitor) &#123; // 实现第二次动态分派 visitor.visitConcreteElementA(this); &#125;&#125;public class ConcreteElementB extends Element&#123; @Override public void accept(Visitor visitor) &#123; // 实现第二次动态分派 visitor.visitConcreteElementB(this); &#125;&#125;// 3. Visitorpublic abstract class Visitor &#123; public abstract void visitConcreteElementA(ConcreteElementA elementA); public abstract void visitConcreteElementB(ConcreteElementB elementB);&#125;// 4. ConcreteVisitorpublic class ConcreteVisitor1 extends Visitor&#123; @Override public void visitConcreteElementA(ConcreteElementA elementA) &#123; System.out.println("ConcreteVisitor1 visit ConcreteElementA."); &#125; @Override public void visitConcreteElementB(ConcreteElementB elementB) &#123; System.out.println("ConcreteVisitor1 visit ConcreteElementB."); &#125;&#125;public class ConcreteVisitor2 extends Visitor&#123; @Override public void visitConcreteElementA(ConcreteElementA elementA) &#123; System.out.println("ConcreteVisitor2 visit ConcreteElementA."); &#125; @Override public void visitConcreteElementB(ConcreteElementB elementB) &#123; System.out.println("ConcreteVisitor2 visit ConcreteElementB."); &#125;&#125;// 5. ObjectStructurepublic class ObjectStructure &#123; List&lt;Element&gt; elements = new ArrayList&lt;&gt;(); public void add(Element element)&#123; elements.add(element); &#125; public void remove(Element element)&#123; elements.remove(element); &#125; public void accept(Visitor visitor)&#123; for (Element element : elements)&#123; // 第一次动态分派 element.accept(visitor); &#125; &#125;&#125;// 6. Testpublic class TestVisitor &#123; public static void main(String[] args) &#123; Element elementA = new ConcreteElementA(); Element elementB = new ConcreteElementB(); ObjectStructure objectStructure = new ObjectStructure(); objectStructure.add(elementA); objectStructure.add(elementB); Visitor visitor1 = new ConcreteVisitor1(); Visitor visitor2 = new ConcreteVisitor2(); objectStructure.accept(visitor1); objectStructure.accept(visitor2); &#125;&#125;// 7. ResultConcreteVisitor1 visit ConcreteElementA.ConcreteVisitor1 visit ConcreteElementB.ConcreteVisitor2 visit ConcreteElementA.ConcreteVisitor2 visit ConcreteElementB. 示例中可以看到，每次接收一个访问者，该访问者都会遍历所有的元素。 访问者模式和双分派双分派体现在 accept 这个方法上： 第一次动态分派在 ObjectStructure.accept 中遍历执行 Element.accept 时，并不确定接受者具体是哪个 ConcreteVisitor1/ConcreteVisitor2，运行时确定。 第二次动态分派在 Element.accept 中，Visitor 并不确定参数具体是哪个 ConcreteElementA/ConcreteElementB，运行时确定。 组合实现了双分派，只有在运行时才能确定是哪个 Visitor 访问哪个 Element。 总结访问者模式的几个特点： 把数据结构（Element）和作用于结构上的操作（Visitor）解耦合，使得操作集合可相对自由地演化 适用于数据结构相对稳定算法又易变化的系统，算法操作增加很容易 优点是增加操作很容易，其缺点就是增加新的元素会非常困难 参考文档 深入理解Java虚拟机:JVM高级特性与最佳实践 第2版 大话设计模式 Android 源码设计模式解析与实战 分派 访问模式和双分派]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：策略模式]]></title>
    <url>%2F2018%2F03%2F28%2F0069-design-patterns-strategy%2F</url>
    <content type="text"><![CDATA[策略模式：定义一系列的算法，单独封装并使它们可以相互替换。这一模式可以使算法独立于使用它的客户而变化。 策略模式策略模式 Strategy[ˈstrætədʒi] Pattern：定义一系列算法的方法，从概念上看，所有的这些算法完成的多是相同的工作，只是实现不同，他们可以使用相同的方法来调用算法，减少了类之间的耦合。 类图结构 结构解析 Strategy抽象类，策略类，定义算法。 ConcreteStrategy实现类，算法的具体实现。 Context环境类，上下文，持有当前策略的引用。客户端可以通过上下文动态切换算法。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1. Strategypublic abstract class Strategy &#123; public abstract void algorithm();&#125;// 2. ConcreteStrategypublic class ConcreteStrategy1 extends Strategy &#123; @Override public void algorithm() &#123; System.out.println("ConcreteStrategy1: Bubble sort."); &#125;&#125;public class ConcreteStrategy2 extends Strategy &#123; @Override public void algorithm() &#123; System.out.println("ConcreteStrategy2: Insertion sort."); &#125;&#125;// 3. Contextpublic class Context &#123; private Strategy strategy; public void setStrategy(Strategy strategy)&#123; this.strategy = strategy; &#125; public void algorithm()&#123; strategy.algorithm(); &#125;&#125;// 4. Testpublic class TestStrategy &#123; public static void main(String[] args) &#123; Strategy strategy = new ConcreteStrategy1(); Context context = new Context(); context.setStrategy(strategy); context.algorithm(); strategy = new ConcreteStrategy2(); context.setStrategy(strategy); context.algorithm(); &#125;&#125;// 5. ResultConcreteStrategy1: Bubble sort.ConcreteStrategy2: Insertion sort. 示例中，策略的选择由客户端来决定。 总结策略模式简化了单元测试，每个算法是一个独立的类，可以通过自己的接口单独测试。策略模式同时体现了开闭原则：策略模式把一系列的可变算法进行封装，从而定义了良好的程序结构，在出现新的算法的时候，可以很容易的将新的算法实现加入到已有的系统中，而已有的实现不需要修改。 状态模式与策略模式的异同 相同点策略模式也是为了消除或者简化条件语句，和责任链模式，状态模式很类似。所以类图结构上看起来几乎没有太大区别。 不同点状态模式中各个状态子类都必须知道它的下一个状态是什么，并且逻辑判断都转移到子类中，客户端并不了解状态的转换逻辑。而策略模式中各个子类是并级的，可以相互替换，他们并不存在状态转换的关系。策略模式是针对单一并行算法的替换，客户端需要提前了解各算法差异，并在策略模式中指定一种算法。 策略模式和责任链模式的异同 相同点在功能职责上都是用来简化或消除条件判断，客户端在使用时需要提前指定使用哪种策略，或者指定责任链模式中的下一个继任者。 不同点两者在类图上有区别，责任链模式需要持有下一个责任人的引用，策略模式多一个上下文类，由上下文类来持有具体的策略。责任链模式存在级差，每个子类拥有不同的责任权限；而策略模式子类都是并级的，客户端在选用时只需要选择一种策略。 参考文档 大话设计模式 Android 源码设计模式解析与实战 策略模式 深入解析策略模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：状态模式]]></title>
    <url>%2F2018%2F03%2F28%2F0068-design-patterns-state%2F</url>
    <content type="text"><![CDATA[状态模式：当对象的内部状态改变时允许改变其行为，该对象看起来像是改变了其类。 状态模式状态模式 State Pattern：主要是解决当控制一个对象状态转移的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。 类图结构 结构解析 State抽象类，状态接口，定义当前状态的行为。 ConcreteState实现类，实现当前状态的行为，并切换状态。 Context环境类，上下文，持有当前状态的引用，维护状态机的状态切换，响应客户端的请求，并转换为状态的具体行为。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 1. Statepublic abstract class State &#123; public abstract void handle(Context context);&#125;// 2. ConcreteStatepublic class ConcreteStateA extends State&#123; @Override public void handle(Context context) &#123; System.out.println("ConcreteStateA..."); context.setState(new ConcreteStateB()); &#125;&#125;public class ConcreteStateB extends State&#123; @Override public void handle(Context context) &#123; System.out.println("ConcreteStateB..."); context.setState(new ConcreteStateC()); &#125;&#125;public class ConcreteStateC extends State&#123; @Override public void handle(Context context) &#123; System.out.println("ConcreteStateC"); &#125;&#125;// 3. Contextpublic class Context &#123; private State state; public Context() &#123; state = new ConcreteStateA(); &#125; public void setState(State state)&#123; this.state = state; &#125; public void request()&#123; System.out.print("Context.request: "); state.handle(this); &#125;&#125;// 4. Testpublic class TestState &#123; public static void main(String[] args) &#123; Context context = new Context(); context.request(); context.request(); context.request(); &#125;&#125;// 5. ResultContext.request: ConcreteStateA...Context.request: ConcreteStateB...Context.request: ConcreteStateC 总结状态模式是将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为时，可以使用状态模式。状态模式通过把各种状态转移逻辑分别到各个 State 子类之间，来减少相互间的依赖。 状态模式与责任链模式的异同 相同点都能解耦和优化大量的逻辑判断。 不同点状态模式每个子类能清楚的直到下个状态是谁或者哪个子类，相当于 if-else 分支判断；而责任链模式并不清楚整个链条中是哪个子类处理的，下个责任人也需要客户端来指定，更灵活，相当于 switch-case 分支判断。通俗来讲，状态模式的下一个状态是明确的，固定的；而责任链中下一个处理者并不固定，需要客户端动态指定。 参考文档 大话设计模式 Android 源码设计模式解析与实战 状态模式 责任链模式和状态模式对比]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：观察者模式]]></title>
    <url>%2F2018%2F03%2F28%2F0067-design-patterns-observer%2F</url>
    <content type="text"><![CDATA[观察者模式：定义一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。在主题对象在状态变化时会通知所有观察者对象，使它们自动更新。 观察者模式观察者模式 Observer Pattern：又叫发布/订阅模式 Publish/Subscribe，最常用于 GUI 系统，订阅发布系统。 类图结构 结构解析 Subject抽象类，主题或者是抽象通知者，用于通知所有订阅了该主题的观察对象。 ConcreteSubject实现类，实现主题的具体方法。 Observer抽象类，观察者，订阅主题后，接收主题的通知并更新自己。 ConcreteObserver实现类，实现具体的更新。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 1. Observerpublic abstract class Observer &#123; public abstract void update(Subject subject, Object object);&#125;// 2. Subjectpublic abstract class Subject &#123; protected List&lt;Observer&gt; observers = new ArrayList&lt;&gt;(); public abstract void addObserver(Observer observer); public abstract void deleteObserver(Observer observer); public abstract void notify(Object object);&#125;// 3. ConcreteSubjectpublic class ConcreteSubject extends Subject &#123; @Override public void addObserver(Observer observer) &#123; observers.add(observer); &#125; @Override public void deleteObserver(Observer observer) &#123; observers.remove(observer); &#125; @Override public void notify(Object object) &#123; for (Observer observer: observers)&#123; observer.update(this, object); &#125; &#125;&#125;// 4. ConcreteObserverpublic class ConcreteObserver extends Observer&#123; @Override public void update(Subject subject, Object object) &#123; System.out.println("ConcreteObserver: object = " + object); &#125;&#125;// 5. Testpublic class TestObserver &#123; public static void main(String[] args) &#123; Observer observer = new ConcreteObserver(); Subject subject = new ConcreteSubject(); subject.addObserver(observer); subject.notify("Hello, Observer."); &#125;&#125;// 6. ResultConcreteObserver: object = Hello, Observer. Java 语言规范中已经集成了标准的观察者模式 Observable/Observer，其中 Observable 即为主题或抽象通知者，Observer 为观察者。所以 Java 中实现观察者模式非常简单，主题继承 Observable ，观察者实现 Observer。 总结观察者模式很好的将观察者和主题解耦，使他们的依赖变得很小。观察者模式实现了表示层和业务逻辑层的分离，并定义了消息更新机制，符合“开闭原则”。观察者模式实际运用中也非常常见，所有 regeister 类型都是观察者模式，如 Android.BroadcastReceiver 广播，数据库更新通知等, 以及第三方 RxJava 库等。 参考文档 大话设计模式 Android 源码设计模式解析与实战 观察者模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：备忘录模式]]></title>
    <url>%2F2018%2F03%2F27%2F0066-design-patterns-memento%2F</url>
    <content type="text"><![CDATA[备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。后期可以直接将该对象恢复到原先保存的状态。 备忘录模式备忘录模式 Memento[məˈmentoʊ] Pattern：常用于存档，编辑回退等场景，主要是保存某个对象当前的状态。 类图结构 结构解析 Originator[əˈrɪdʒəˌnetɚ]发起者，复杂类有多个属性。负责创建一个备忘录，用于记录当前内部状态，并可以使用备忘录恢复状态。Originator 来决定需要备忘录存储哪些状态或属性。 Memento备忘录，负责存储 Originator 指定的内部状态。只能通过 Originator 创建修改状态，其他类仅仅可以获取状态。 CareTaker管理类，负责存储管理保存好的备忘录列表，但是不能修改备忘录中保存的状态。 Originator 负责指定 Memento 保存自己的哪些内部状态，CareTaker 维护一个列表保存 Memento ，后期可以通过这个列表恢复到指定状态。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 1. Mementopublic class Memento &#123; private String state; public Memento(String state) &#123; this.state = state; &#125; public String getState() &#123; return state; &#125;&#125;// 2. Originatorpublic class Originator &#123; private String state; private String otherInfo; public Memento createMemento()&#123; return new Memento(state); &#125; public void restore(Memento memento)&#123; state = memento.getState(); &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public String getOtherInfo() &#123; return otherInfo; &#125; public void setOtherInfo(String otherInfo) &#123; this.otherInfo = otherInfo; &#125;&#125;// 3. CareTakerpublic class CareTaker &#123; private List&lt;Memento&gt; mementos = new ArrayList&lt;&gt;(); public void addMemento(Memento memento)&#123; mementos.add(memento); &#125; public Memento getMemento(int index)&#123; return mementos.get(index); &#125; public void removeMemento(Memento memento)&#123; mementos.remove(memento); &#125; public int size()&#123; return mementos.size(); &#125;&#125;// 4. Testpublic class TestMemento &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); originator.setState("first state"); originator.setOtherInfo("other info"); CareTaker careTaker = new CareTaker(); careTaker.addMemento(originator.createMemento()); originator.setState("second state"); originator.setState("third state"); careTaker.addMemento(originator.createMemento()); System.out.println("Originator current state: " + originator.getState()); if (careTaker.size() &gt; 0)&#123; originator.restore(careTaker.getMemento(0)); System.out.println("restore, Originator current state: " + originator.getState()); &#125; &#125;&#125;// 5. ResultOriginator current state: third staterestore, Originator current state: first state 总结按照 GOF 定义的备忘录模式，需要备忘录只能对发起方 Originator 可见，其他类无法获取其状态，这样根据备忘录的可见性，可以做如下分类： 白箱模式备忘录完全可见，暴露给其他类，这种是最常见的备忘录模式，上面的代码示例即为白箱模式。 黑箱模式备忘录抽象一个空接口出来，而备忘录则以内部类的形式在 Originator 中实现对应功能，这样外部类在访问的时候，只能拿到空接口。备忘录中的宽窄接口：接口类中提供比较完备的操作状态的方法，我们称它为宽接口；而只是一个标示或者空接口，我们称它为窄接口。备忘录角色在实现这两种接口类时，可以控制对于“备忘发起角色”采用宽接口进行访问，而对于其他的角色或者对象则采用窄接口进行访问。黑箱模式正是采用了这种方式来实现的。 参考文档 大话设计模式 Android 源码设计模式解析与实战 备忘录模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：中介者模式]]></title>
    <url>%2F2018%2F03%2F27%2F0065-design-patterns-mediator%2F</url>
    <content type="text"><![CDATA[中介者模式：用一个中介对象来封装一系列的对象交互。使得各对象不用显式的相互引用，从而使其耦合松散，而且可以独立改变它们之间的交互。 中介者模式中介者模式 Mediator[ˈmidiˌetɚ] Pattern：又称为调停者模式，将多对多的相互作用转换为一对多的相互作用，减少对象间的复杂引用关系，使得成为一个松耦合系统。 类图结构 结构解析 Mediator抽象类，定义中转调用时的方法。 ConcreteMediator实现类，实现中转调用的逻辑，持有所有需要被中转类的引用。 Colleague抽象类，仅仅持有一个抽象 Mediator 对象的引用，不定义抽象方法。 ConcreteColleague1/ConcreteColleague2实现类，定义需要中转的方法。两者并不需要有公共父类，如果需要也仅仅是引用相同的 Mediator 对象。 客户端会将 ConcreteColleague1, ConcreteColleague2, ConcreteMediator 三个对象连接起来，当 ConcreteColleague1 需要调用 ConcreteColleague2 的方法时，并不是直接调用，而是通过 ConcreteMediator.mediate 来中转调用。Colleague 这个角色并不一定需要，它的作用仅仅是将实现类和 Mediator 关联起来，持有 Mediator 的引用。所以实际使用中 ConcreteColleague1, ConcreteColleague2 也并不是拥有相同父类，只要将他们通过 Mediator 连接起来就行。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 1. Mediatorpublic abstract class Mediator &#123; public abstract void mediate();&#125;// 2. Colleaguepublic abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125;// 3. ConcreteColleaguepublic class ConcreteColleague1 extends Colleague &#123; public ConcreteColleague1(Mediator mediator) &#123; super(mediator); &#125; public void action1() &#123; System.out.println("ConcreteColleague1: Coding to implement " + "requirement. Please release Version."); mediator.mediate(); &#125;&#125;public class ConcreteColleague2 extends Colleague &#123; public ConcreteColleague2(Mediator mediator) &#123; super(mediator); &#125; public void action2()&#123; System.out.println("ConcreteColleague2: Make release version."); &#125;&#125;// 4. ConcreteMediatorpublic class ConcreteMediator extends Mediator&#123; private ConcreteColleague1 colleague1; private ConcreteColleague2 colleague2; @Override public void mediate() &#123; if (colleague2 != null)&#123; colleague2.action2(); &#125; &#125; public void setColleague1(ConcreteColleague1 colleague1)&#123; this.colleague1 = colleague1; &#125; public void setColleague2(ConcreteColleague2 colleague2) &#123; this.colleague2 = colleague2; &#125;&#125;// 5. Testpublic class TestMediator &#123; public static void main(String[] args) &#123; ConcreteMediator mediator = new ConcreteMediator(); ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator); ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator); mediator.setColleague1(colleague1); mediator.setColleague2(colleague2); colleague1.action1(); &#125;&#125;// 6. ResultConcreteColleague1: Coding to implement requirement. Please release Version.ConcreteColleague2: Make release version. 中介者模式中需要中转调用的两个类，并不一定需要有相同的父类。父类 Colleague 更多的是确保每个子类必须持有 Mediator 的引用。如上示例中 ConcreteColleague1.action1 对 ConcreteColleague2.action2 的调用，就是通过 ConcreteMediator.mediate 来实现的。 总结 中介者模式与迪米特原则迪米特原则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三者转发调用。该原则指一个对象应该对于其他对象有最少的了解，有效的降低类之间的耦合。中介者模式是迪米特原则的典型应用。 类比中介者模式，类似电脑的主板协调各个器件工作；系统的各个总线协调驱动程序运行；中介者模式能够将错综复杂的网状图优化成结构清晰的星型图，其中心就是中介者；MVC 架构中的 Control 就是典型的中介者。所有的 UI 交互系统，如 C#/Form, Android Activity 中的 UI 交互界面，都承担了中介者的角色，它会将 Button, TextView, EditText 等连接起来，这些控件的交互都是通过窗体来中转，响应并显示的。 参考文档 大话设计模式 Android 源码设计模式解析与实战 中介者模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：迭代器模式]]></title>
    <url>%2F2018%2F03%2F26%2F0064-design-patterns-iterator%2F</url>
    <content type="text"><![CDATA[迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露对象内部表示。 迭代器模式迭代器模式 Iterator[ɪtə&#39;reɪtə] Pattern：又称为游标 Cursor 模式，是非常古老的设计模式，主要用于对容器的遍历访问，当前高级面向对象语言基本上默认包含这个模式。 类图结构 结构解析 Iterator接口，定义迭代器的基本方法。 ConcreteIterator实现类，实现迭代器的方法。 Aggregate抽象类，容器类，存储数据并创建迭代器。 ConcreteAggregate实现类，容器的各个方法的实现，并完成具体迭代器的创建。 Client客户端。 ConcreteIterator 和 ConcreteAggregate 耦合性很高。ConcreteAggregate 创建了 ConcreteIterator 实例，而 ConcreteIterator 持有 ConcreteAggregate 的引用，用于遍历容器中的数据。迭代器模式结构图看起来很臃肿，使用起来并不方便，而分开的目的参考单一职责原理，Aggregate 负责容器中数据元素的维护，而 Iterator 负责遍历操作。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 1. Iteratorpublic interface Iterator &#123; Object next(); boolean hasNext();&#125;// 2. Aggregatepublic abstract class Aggregate &#123; public abstract Iterator createIterator(); public abstract void add(String string); public abstract void remove(String string); public abstract String get(int index); public abstract int size();&#125;// 3. ConcreteIteratorpublic class ConcreteIterator implements Iterator&#123; private Aggregate aggregate; private int index = 0; public ConcreteIterator(Aggregate aggregate)&#123; this.aggregate = aggregate; &#125; @Override public String next() &#123; String next = null; if (hasNext()) &#123; next = aggregate.get(index); index++; &#125; return next; &#125; @Override public boolean hasNext() &#123; return index &lt; aggregate.size(); &#125;&#125;// 4. ConcreteAggregatepublic class ConcreteAggregate extends Aggregate&#123; private List&lt;String&gt; list = new ArrayList&lt;&gt;(); @Override public Iterator createIterator() &#123; return new ConcreteIterator(this); &#125; @Override public void add(String string) &#123; list.add(string); &#125; @Override public void remove(String string) &#123; list.remove(string); &#125; @Override public String get(int index) &#123; return list.get(index); &#125; @Override public int size() &#123; return list.size(); &#125;&#125;// 5. Testpublic class TestIterator &#123; public static void main(String[] args) &#123; Aggregate aggregate = new ConcreteAggregate(); aggregate.add("this"); aggregate.add("is"); aggregate.add("iterator"); aggregate.add("pattern"); Iterator iterator = aggregate.createIterator(); while (iterator.hasNext())&#123; System.out.print(iterator.next() + " "); &#125; &#125;&#125;// 6. Resultthis is iterator pattern 使用 List 数据结构来存放数据，它本身就实现了 Iterator 模式，这里只是举例来说明迭代器使用方法。 总结Java 语言已经包含了迭代器接口 Interator，在实际使用中仅仅需要实现 Collection 集合就能应用迭代器模式，其中 List, Map 等等都都是常见迭代器容器。而 Android 中 Cursor 也是典型的迭代器模式。迭代器模式分离了集合对象的遍历行为，抽象一个迭代器类来负责遍历操作，这样既可以不用暴露集合内部的数据结构，又可以让外部代码非常透明的访问集合内部的数据。 参考文档 大话设计模式 Android 源码设计模式解析与实战 wiki-iterator]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：命令模式]]></title>
    <url>%2F2018%2F03%2F26%2F0063-design-patterns-command%2F</url>
    <content type="text"><![CDATA[命令模式：将请求封装为一个对象，从而可以将不同的请求作为参数来传递。对请求排队或记录日志，以及支持可撤销的操作。 命令模式命令模式 Command Pattern：类似系统菜单，比如开机、关机、重启、注销等等，这些动作都封装成命令对象，作为参数记录并执行。命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求，这就是命令模式的模式动机。 类图结构 结构解析 Command接口，定义所有的命令。 ConcreteCommand实现类，具体不同的命令。 Invoker请求者，也是命令发送者，记录命令并做出具体的命令请求。 Receiver接收者，接收命令并执行具体的命令。 Client客户端。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 1. Commandpublic interface Command &#123; void execute();&#125;// 2. ConcreteCommandpublic class FlipUpCommand implements Command &#123; private Receiver receiver; public FlipUpCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123; receiver.turnOn(); &#125;&#125;public class FlipDownCommand implements Command &#123; private Receiver receiver; public FlipDownCommand(Receiver receiver) &#123; this.receiver = receiver; &#125; @Override public void execute() &#123; receiver.turnOff(); &#125;&#125;// 3. Invokerpublic class Invoker &#123; private List&lt;Command&gt; commands = new ArrayList&lt;&gt;(); public void add(Command command)&#123; commands.add(command); &#125; public void execute(Command command)&#123; if (!commands.contains(command))&#123; add(command); &#125;else &#123; command.execute(); &#125; &#125; public void remove(Command command)&#123; commands.remove(command); &#125;&#125;// 4. Receiverpublic class Receiver &#123; public void turnOn()&#123; System.out.println("Receiver, Light: turn On."); &#125; public void turnOff()&#123; System.out.println("Receiver, Light: turn Off."); &#125;&#125;// 5. Clientpublic class TestCommand &#123; public static void main(String[] args) &#123; Receiver light = new Receiver(); FlipUpCommand upCommand = new FlipUpCommand(light); FlipDownCommand downCommand = new FlipDownCommand(light); Invoker invoker = new Invoker(); invoker.add(upCommand); invoker.add(downCommand); invoker.execute(upCommand); invoker.remove(downCommand); &#125;&#125;// 6. ResultReceiver, Light: turn On. 总结命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开，降低了系统耦合度，同时很容易增加新命令，但是会导致过多的具体命令类。 参考文档 大话设计模式 Android 源码设计模式解析与实战 命令模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：责任链模式]]></title>
    <url>%2F2018%2F03%2F26%2F0062-design-patterns-chain-of-responsibility%2F</url>
    <content type="text"><![CDATA[责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将多个对象的请求连成一条链，并沿着这条链传递请求，直到有一个对象处理为止，避免请求的发送者和接收者之间耦合。 责任链模式责任链模式 Chain of Responsibility[rɪˌspɑ:nsəˈbɪləti] Pattern：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。也常用来替代各种分支和条件判断语句。 类图结构 结构解析 Handler抽象类，申明一个请求处理的方法，并持有下一个处理对象的引用。 ConcreteHandler实现类，实现请求，如果无法处理转发给下一个继任者处理。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 1. Handlerpublic abstract class Handler &#123; protected Handler successor; public void setSuccessor(Handler successor)&#123; this.successor = successor; &#125; public abstract void handleRequest(int request);&#125;// 2. ConcreteHandlerpublic class ConcreteHandler1 extends Handler&#123; @Override public void handleRequest(int request) &#123; if (request &gt; 0 &amp;&amp; request &lt; 3)&#123; System.out.println("ConcreteHandler1: TeamLead approve: " + request + " days leave."); &#125;else if (successor != null)&#123; successor.handleRequest(request); &#125; &#125;&#125;public class ConcreteHandler2 extends Handler&#123; @Override public void handleRequest(int request) &#123; if (request &gt; 3 &amp;&amp; request &lt; 7)&#123; System.out.println("ConcreteHandler1: Manager approve: " + request + " days leave."); &#125;else if (successor != null)&#123; successor.handleRequest(request); &#125; &#125;&#125;public class ConcreteHandler3 extends Handler&#123; @Override public void handleRequest(int request) &#123; if (request &gt; 7)&#123; System.out.println("ConcreteHandler1: Boss approve: " + request + " days leave."); &#125; &#125;&#125;// 3. Testpublic class TestChainOfResponsibility &#123; public static void main(String[] args) &#123; Handler teamLead = new ConcreteHandler1(); Handler manager = new ConcreteHandler2(); Handler boss = new ConcreteHandler3(); teamLead.setSuccessor(manager); manager.setSuccessor(boss); teamLead.handleRequest(5); &#125;&#125;// 4. ResultConcreteHandler1: Manager approve: 5 days leave. 总结当客户提交一个请求时，请求时沿着链传递到一个具体的 ConcreteHandler 对象负责并处理它。在 Android 中常见的责任链模式就是 View 按键事件分发机制。 参考文档 大话设计模式 Android 源码设计模式解析与实战]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：模板方法模式]]></title>
    <url>%2F2018%2F03%2F26%2F0061-design-patterns-template-method%2F</url>
    <content type="text"><![CDATA[模板方法模式：定义一个操作中的算法的框架，而将详细的步骤延迟到子类中。模板方法使得子类可以不改变算法的结构下重新定义算法的步骤。 模板方法模式 Template Pattern一个算法可以明确分割为几个关键步骤，这几个步骤的顺序是固定的，但是每个步骤的实现会随环境的改变而变化，对于这类问题常用模板方法来解决。 类图结构 结构解析 AbstractClass抽象类，定义一套算法框架 templateMethod 。 ConcreteClass实现类，实现抽象方法，在同一个算法框架下，体现每个实现类的差异性。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 1. AbstractClasspublic abstract class AbstractClass &#123; public abstract void privateOperation1(); public abstract void privateOperation2(); public abstract void privateOperation3(); public void templateMethod()&#123; System.out.println("AbstractClass: Game Start..."); privateOperation1(); privateOperation2(); privateOperation3(); &#125;&#125;// 2. ConcreteClasspublic class ConcreteClassA extends AbstractClass&#123; @Override public void privateOperation1() &#123; System.out.println("ConcreteClassA, WangZheRongYao: log in."); &#125; @Override public void privateOperation2() &#123; System.out.println("ConcreteClassA, WangZheRongYao: DaGuaiShengJi."); &#125; @Override public void privateOperation3() &#123; System.out.println("ConcreteClassA, WangZheRongYao: log out."); &#125;&#125;public class ConcreteClassB extends AbstractClass&#123; @Override public void privateOperation1() &#123; System.out.println("ConcreteClassA, DouDiZhu: log in."); &#125; @Override public void privateOperation2() &#123; System.out.println("ConcreteClassA, DouDiZhu: QiangDiZhu."); &#125; @Override public void privateOperation3() &#123; System.out.println("ConcreteClassA, DouDiZhu: log out."); &#125;&#125;// 3. Testpublic class TestTemplateMethod &#123; public static void main(String[] args) &#123; AbstractClass abstractClass = new ConcreteClassA(); abstractClass.templateMethod(); abstractClass = new ConcreteClassB(); abstractClass.templateMethod(); &#125;&#125;// 4. ResultAbstractClass: Game Start...ConcreteClassA, WangZheRongYao: log in.ConcreteClassA, WangZheRongYao: DaGuaiShengJi.ConcreteClassA, WangZheRongYao: log out.AbstractClass: Game Start...ConcreteClassA, DouDiZhu: log in.ConcreteClassA, DouDiZhu: QiangDiZhu.ConcreteClassA, DouDiZhu: log out. 总结模板方法模式是把不变行为搬移到父类，去除子类的重复代码，帮助子类摆脱重复不变行为的纠缠。常见使用场景： 子类有共有方法，并且逻辑基本相同 用于代码重构，将公共方法抽取到父类中 在 Android 中，Activity/Fragmengt 等的生命周期是标准的模板方法，以及 AsyncTask 的执行步骤 onPreExecute --&gt; doInBackgroud --&gt; onPostExecute 等这些都是模板方法的体现。 参考文档 大话设计模式 Android 源码设计模式解析与实战]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--行为型：解释器模式]]></title>
    <url>%2F2018%2F03%2F22%2F0060-design-patterns-interpreter%2F</url>
    <content type="text"><![CDATA[解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 解释器模式 Interpreter解释器模式 Interpreter[ɪnˈtɜ:rprɪtə] Pattern：主要用来按指定规则解析一串语句，如：解析歌谱，XML，算术运算，机器人动作指令等等。 类图结构 结构解析 AbstractExpression解释器抽象类，定义抽象解析方法。接口中主要是一个 interpret() 方法，称为解释操作。 TerminalExpression实现类，表示终止符，即实际被解释的数据。如算术运算的数字，曲谱的音符等。 NonTerminalExpression实现类，表示如何解释。如算术运算的加减乘除，曲谱的音阶音速等。 Context上下文，全局信息，或者辅助类。将表达式分解出来，把数据和解释器分离并执行。 Client客户端。 示例逆波兰表达式逆波兰表达式 Reverse Polish Notation 又叫做后缀表达式。逆波兰表达式是一种十分有用的表达式，它将复杂表达式转换为可以依靠简单的操作得到计算结果的表达式。例如：(a+b)*(c+d) 转换为 ab+cd+* 。逆波兰表达式操作十分简单，入栈和出栈就可以解决任何普通表达式的运算。其运算方式如下：如果当前字符为变量或者为数字，则压栈，如果是运算符，则将栈顶两个元素弹出作相应运算，结果再入栈，最后当表达式扫描完后，栈里的就是结果。 12345a+b ---&gt; ab+a+(b-c) ---&gt; abc-+a+(b-c)*d ---&gt; abc-d*+a+d*(b-c) ---&gt; adbc-*+a=1+3 ---&gt; a13+= 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// 1. AbstractExpressionpublic abstract class AbstractExpression &#123; public abstract int interpreter(Context context);&#125;// 2. TerminalExpression public class Constant extends AbstractExpression&#123; private int value = 0; public Constant(int i)&#123; value = i; &#125; @Override public int interpreter(Context context) &#123; return value; &#125;&#125;// 3. NonTerminalExpressionpublic class Plus extends AbstractExpression&#123; private AbstractExpression left; private AbstractExpression right; public Plus(AbstractExpression left, AbstractExpression right) &#123; this.left = left; this.right = right; &#125; @Override public int interpreter(Context context) &#123; return left.interpreter(context) + right.interpreter(context); &#125;&#125;public class Minus extends AbstractExpression&#123; private AbstractExpression left; private AbstractExpression right; public Minus(AbstractExpression left, AbstractExpression right) &#123; this.left = left; this.right = right; &#125; @Override public int interpreter(Context context) &#123; return left.interpreter(context) - right.interpreter(context); &#125;&#125;public class Multiply extends AbstractExpression&#123; private AbstractExpression left; private AbstractExpression right; public Multiply(AbstractExpression left, AbstractExpression right) &#123; this.left = left; this.right = right; &#125; @Override public int interpreter(Context context) &#123; return left.interpreter(context) * right.interpreter(context); &#125;&#125;// 4. Context public class Context &#123; private Stack&lt;Integer&gt; mExpStack; private String mExpression; public Context(String expression)&#123; mExpression = expression; &#125; public int calculate()&#123; if (mExpression == null)&#123; mExpression = ""; &#125; mExpStack = new Stack&lt;&gt;(); int value = 0; Constant left, right; for (char c : mExpression.toCharArray())&#123; switch (c)&#123; case '+': right = new Constant(pop()); left = new Constant(pop()); Plus plus = new Plus(left, right); value = plus.interpreter(this); break; case '-': right = new Constant(pop()); left = new Constant(pop()); Minus minus = new Minus(left, right); value = minus.interpreter(this); break; case '*': right = new Constant(pop()); left = new Constant(pop()); Multiply multiply = new Multiply(left, right); value = multiply.interpreter(this); break; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': value = c - '0'; break; default: break; &#125; mExpStack.push(value); &#125; return pop(); &#125; public Integer pop()&#123; return mExpStack.pop(); &#125;&#125;// 5. Test public class TestInterpreter &#123; public static void main(String[] args) &#123; Context context = new Context("5364-*+"); int value = context.calculate(); System.out.println("value = " + value); &#125;&#125;// 6. Result// 5364-*+ --&gt; 5+3*(6-4)value = 11 总结解释器模式在实际中很少使用，它最显著的优点就是扩展性：若扩展语法只需要增加非终结符类就可以了。而缺点是执行效率较低：由于在解释器模式中使用了递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。同时对于复杂文法需要增加很多解释类。 参考文档 大话设计模式 Android 源码设计模式解析与实战 解释器模式 行为型模式—解释器模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Behavioral</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 内存泄露]]></title>
    <url>%2F2018%2F03%2F13%2F0059-android-memory-leak%2F</url>
    <content type="text"><![CDATA[内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。内存泄漏会使应用占用的内存，随着时间不断的增加而造成应用 OOM(Out Of Memory) 错误，使应用崩溃。 基础概念内存分配及垃圾回收 GC内存分配及垃圾回收的基础知识，参考：JVM 内存分配及垃圾回收-内存分配 小结： GC 回收的对象必须是不可达的，或者当前没有任何引用的对象 当对象在使用完成后（对我们而言已经是垃圾对象了），如果没有释放该对象的引用，会导致 GC 不能回收该对象而继续占用内存 垃圾对象持续占用内存，导致内存空间的浪费，就发生内存泄露了 大量的内存泄露导致有效内存减少，当再次合理申请不到足够内存时，则会出现内存溢出 内存泄露和内存溢出 内存泄露 垃圾对象依旧占据堆内存，没有得到正确的释放。水池的水在使用后需要将脏水排空，但是排水管修的太高，有一部分脏水占用了水池的空间。 内存溢出 内存占用达到最大值，当再需要时已经无法分配，这就是内存溢出。水池已经满了，这时再放水进来就会溢出。 内存的溢出是内存分配达到了最大值，而内存泄漏是无用内存充斥了内存堆；内存泄漏会占用内存堆导致可用内存太少，很容易出现内存溢出现象。 常见内存泄露场景静态变量与内存泄露Java 中静态变量在类加载时初始化，并存储在方法区是类变量，在类卸载的时候销毁并释放清空。下面简单介绍下类加载和卸载，参考java 静态变量及类的生命周期 。 类加载遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令时、反射调用时、子类初始化时、虚拟机启动 main 主类时等等，会触发类加载并初始化。 静态变量虚拟机在加载类的过程中为静态变量分配内存，static 变量在内存中只有一个，存放在方法区，属于类变量，被所有实例所共享。 类卸载方法区会回收两部分内容：废弃常量和无用的类。类被回收时才会卸载，但是方法区回收类时条件比较严格，只有同时满足以下三个条件，才会回收： 该类所有的实例都已经被回收（GC），也就是虚拟机中不存在该 Class 的任何实例 加载该类的 ClassLoader 已经被回收（GC） 该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问改类的方法静态变量在类没有被销毁，也没有置 null 的情况下，是不会被回收的（GC）。 安全可靠性Android 在资源不足的时候会杀掉一些进程，在资源足够时重启被杀掉的进程，这时可能会存在某些应用内存不足被杀后重启了。这会导致 Android 中的静态变量并不可靠，上次保存的静态数据可能没了，所以针对静态变量，必须保存一份到本地文件。另外，静态变量在进程退出时才会被销毁，所以在多账号的应用中，退出账号时上次保存的数据还在，需要手动重置那些与账户有关的静态数据，以免影响到另一个账户。 结论静态变量只有在类卸载（条件很苛刻），虚拟机关闭，进程被杀等情况下，才会被回收。通常我们可以简单理解，Android 的静态变量和整个应用的生命周期相同，所以静态变量引用了当前类中的变量，会引起当前类对象无法被及时销毁，导致内存泄露。 静态变量要尽量少用，在用完后必须置空，养成好习惯。 非静态内部类与内存泄露在 Java 中，非静态内部类都会持有外部类的引用，参考Java 内部类 。通过反编译非静态内部类对应的 class 文件，可以看出内部类在构造方法中，传入了外部类的引用 this$0，内部类在访问外部类的成员或方法时，都需要传递该参数 this.this$0，只有静态内部类例外。这也可看出为什么静态内部类在实例化时不需要外部类实例化，而其他内部类在实例化时必须先实例化外部类了。内部类虽然和外部类写在同一个文件中，但是编译完成后会生成各自的 class 文件，编译过程中： 编译器自动为非静态内部类添加一个成员变量，这个成员变量的类型和外部类的类型相同，这个成员变量就是指向外部类对象的引用 编译器自动为非静态内部类的构造方法添加一个参数，参数的类型是外部类的类型，这个参数为内部类中添加的成员变量赋值 在调用非静态内部类的构造函数初始化内部类对象时，会默认传入外部类的引用 换句话说：静态内部类不持有外部类对象的引用，而其他内部类都会持有。在 Android 中经常会使用成员内部类或者匿名内部类，特别是这些类开后台线程或者做耗时操作时，会引起外部类在退出时（仍然被非静态内部类持有引用）无法被释放，导致内存泄露。当然这种后台因为耗时任务引起的内存泄露，在耗时任务执行完后，会释放外部类的引用，从而再下次 GC 时，外部类可以被正常回收。如果后台任务为无限循环，则外部类会被持续持有。 尽量使用静态内部类，避免持有外部类的引用。 强弱软引用与内存泄露为了规避内存泄露，通常使用软引用或弱引用。参考：JVM 内存分配及垃圾回收-对象引用的四种分类 注册和取消注册监听系统服务，通常要将自己 Context 注册到系统中，这会导致服务持有了 Context 的引用，如果在 Activity 销毁的时没有注销这些监听器，会导致内存泄漏。所以注册和取消注册一定是成对出现的： 12registerListener();unregisterListener(); Bitmap 使用不当造成内存泄露和溢出Bitmap 非常容易导致内存溢出，通常 1200 万像素的手机拍下来的照片为 4048x3036 像素，如果默认配置为 ARGB_8888 （4 个字节存储），打开一张这样的图片大概需要 4048*3036*4/1024=48M 大小的内存，很容易导致应用内存溢出。所以 Bitmap 使用时需要非常小心并及时回收。参考 Android 官方文档：Handling Bitmaps ，Loading Large Bitmaps Efficiently ，Caching Bitmaps ，Managing Bitmap Memory 。 其他可能引起的内存泄露 资源性对象未关闭如 Cursor, File, Socket 等的使用，最后需要 close 并置空。 屏幕旋转导致的 Activity 重建反复旋转设备经常会导致应用泄漏 Activity, Context, View 对象，因为系统会重新创建 Activity，而如果在其他地方保持对这些对象之一的引用，系统将无法对其进行垃圾回收。 常见内存泄露示例 内存泄露的根本原因：长生命周期对象引用了短生命周期对象导致。当短生命周期对象结束后，而长生命周期仍然持有这个引用，导致短生命周期对象无法被释放。 静态变量根据上面分析，静态变量很容易引起内存泄露，应该尽量少用，用完后退出必须置空。如下为静态 Activity 变量和静态 View 引起的内存泄露示例。 错误示例1234567891011private static Activity sLeakActivity;private void staticActivityLeak()&#123; Log.d(TAG, "staticActivityLeak: "); sLeakActivity = this;&#125;private static View sLeakView;private void staticViewLeak(View view)&#123; Log.d(TAG, "staticViewLeak: "); sLeakView = view;&#125; 示例很简单，定义了两个静态变量分别保存当前 Activity 变量和某个 View 变量，而静态变量生命周期基本和应用生命周期相同，所以当前 Activity 退出时，因为静态变量持有它的引用，导致 Activity 实例无法被回收出现内存泄露。 正确示例123456789101112131415// 1. 使用非静态变量保存private Activity mSafeActivity;private void safeActivity()&#123; Log.d(TAG, "safeActivity: "); mSafeActivity = this;&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 2. 静态变量置空 if (mSafeView != null)&#123; mSafeView = null; &#125;&#125; 解决方法也很简单，不使用静态变量，或者在 Activity.onDestroy 时，将静态变量置空，断开引用链关系。 单例模式在 Android 中，单例的静态特性使得单例的生命周期和应用的生命周期一样长，而单例中引用了 Activity 对象。当该 Activity 退出时，因为单例还持有这个对象，导致该 Activity 无法被回收，导致内存泄露。 错误示例123456789101112131415161718192021222324public class MemLeakSample extends AppCompatActivity &#123; // 1. Singleton private static class SingletonLeak&#123; private static SingletonLeak sInstance; private Context mContext; private SingletonLeak(Context context)&#123; mContext = context; &#125; public static SingletonLeak getInstance(Context context)&#123; if (sInstance == null)&#123; // 构造方法，单例持有了 Activity 的引用 // 导致 Activity 退出时，无法被回收 sInstance = new SingletonLeak(context); &#125; return sInstance; &#125; &#125; // 2. 获取单例，传入了 Activity private void staticSingletonLeak()&#123; SingletonLeak.getInstance(this); &#125;&#125; 在这个示例中，MemLeakSample 中调用了单例 SingletonLeak，并将自身传递给单例，紧接着马上关闭退出。正常情况下 MemLeakSample 退出后，应当释放并回收，但是因为静态单例持有了 Context 的引用，导致其无法被回收，引起内存泄露。 正确示例12345678910111213141516171819202122// 1. Singletonprivate static class SafeSingleton&#123; private static SafeSingleton sInstance; private Context mContext; private SafeSingleton(Context context)&#123; mContext = context; &#125; public static SafeSingleton getInstance(Context context)&#123; if (sInstance == null)&#123; // 构造方法，单例持有的是应用的 Context // 和当前 Activity 无关，不影响 Activity 的回收 sInstance = new SafeSingleton(context.getApplicationContext()); &#125; return sInstance; &#125;&#125;// 2. 获取单例，传入 Activityprivate void safeStaticSingleton()&#123; SafeSingleton.getInstance(this);&#125; Context 赋值为整个应用的上下文 this.context = context.getApplicationContext();，这样单例 Context 就和应用的生命周期相同了，和具体的 Activity 无关，所以 MemLeakSample 退出后，直接释放并回收。 匿名内部类 - Thread/Runnable后台耗时任务的匿名内部类，可能出现内存泄露。 错误示例12345678910111213private void anonymousThreadLeak()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(30000); Log.d(TAG, "run: anonymousThreadLeak, runnable, exit."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start();&#125; 匿名 Runnable 在后台执行耗时任务，当前 Activity 退出，因为 Runnable 持有 Activity 的引用，导致出现内存泄露。但是当 Runnable 执行完后，会释放引用，下次 GC 时，Activity 能被正常回收。当然在编码时，更希望不要出现泄露的可能性。 正确示例12345678910111213141516// 使用静态内部类，避免持有外部类引用private static class MyRunnable implements Runnable&#123; @Override public void run() &#123; try &#123; Thread.sleep(30000); Log.d(TAG, "run: MyRunnable, exit."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;private void safeAnonymousThread()&#123; new Thread(new MyRunnable()).start();&#125; 使用静态内部类，避免持有外部类引用，从根本上避免内存泄露。和 Thread/Runnable 类似的还有 AsyncTask，如果异步任务没有执行完而 Activity 退出，就会导致内存泄露。 匿名内部类 - Handler所有 Message 都持有 Handler 的引用，而匿名内部类 Handler 会持有外部 Activity，形成引用链。 错误示例12345678910111213private Handler mLeakHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.d(TAG, "mLeakHandler.handleMessage: msg.what = " + msg.what); mTvNonStaticInnerClass.setTextColor(Color.RED); while (true)&#123;&#125; &#125;&#125;;private void anonymousHandlerLeak()&#123; mLeakHandler.sendEmptyMessageDelayed(MSG_LEAK, 30000);&#125; 匿名 Handler 在处理延时消息这段时间时，如果 Activity 退出，而匿名 Handler 持有它的引用，导致 Activity 无法被正常释放，引起内存泄露。 正确示例123456789101112131415161718192021public static class SafeHandler extends Handler&#123; private WeakReference&lt;MemLeakSample&gt; mActivity; public SafeHandler(MemLeakSample activity)&#123; mActivity = new WeakReference&lt;&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); Log.d(TAG, "mSafeHandler.handleMessage: msg.what = " + msg.what); //mActivity.get().mTvNonStaticInnerClass.setTextColor(Color.BLUE); &#125;&#125;;private SafeHandler mSafeHandler;private void safeAnonymousHandler()&#123; mSafeHandler = new SafeHandler(this); mSafeHandler.sendEmptyMessageDelayed(MSG_SAFE, 30000);&#125; 使用静态内部类继承 Handler，避免持有外部 Activity 的引用。但是 Handler 通常来更新 UI，如果使用静态内部类，则无法正常访问 Activity 的 UI 控件了，这里采用弱引用的方式，保存 Activity 的实例来更新 UI，确保在 GC 时，Activity 能被正常回收。 注册系统服务监听通过 Context.getSystemService(int name) 获取系统服务，这些服务工作在各自的进程中，如果需要使用这些服务，可以注册监听器，这会导致服务持有了 Context 的引用，如果在 Activity 销毁的时没有注销这些监听器，会导致内存泄漏。 错误示例1234567891011121314151617181920212223242526272829private SensorManager mSensorManager;private MySensorEventListener mySensorEventListener;private static class MySensorEventListener implements SensorEventListener&#123; @Override public void onSensorChanged(SensorEvent event) &#123; &#125; @Override public void onAccuracyChanged(Sensor sensor, int accuracy) &#123; &#125;&#125;private void registerSensor()&#123; mySensorEventListener = new MySensorEventListener(); mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); Sensor sensor = mSensorManager.getDefaultSensor(Sensor.TYPE_ALL); mSensorManager.registerListener(mySensorEventListener, sensor, SensorManager.SENSOR_DELAY_FASTEST);&#125;private void registerLeak()&#123; isRegisterSafe = false; registerSensor();&#125;private boolean isRegisterSafe; 正确示例12345678910111213141516private void safeRegister()&#123; isRegisterSafe = true; registerSensor();&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (isRegisterSafe &amp;&amp; mSensorManager != null &amp;&amp; mySensorEventListener != null)&#123; mSensorManager.unregisterListener(mySensorEventListener); mSensorManager = null; mySensorEventListener = null; &#125;&#125; 注册后，需要在 Activity.onDestroy 中取消注册，避免系统服务持有当前 Activity 的引用，从而规避内存泄露。 内存泄露检测工具Android Profiler[&#39;proʊfaɪlə(r)] 是 Android Studio 3.0 推出的一个监控工具，分为三大模块：CPU、内存 、网络。利用 Memory Profiler 来监控并分析当前应用内存的使用情况，官网地址：Android Profiler Memory Profiler 。Memory Profiler 可以识别导致应用卡顿、冻结甚至崩溃的内存泄漏和流失。能够显示应用内存使用量的实时图表，捕获堆转储、强制执行垃圾回收以及跟踪内存分配等功能。 简介打开方式：点击 View &gt; Tool Windows &gt; Android Profiler，或者点击工具栏中的 Android Profiler 图标打开 Android Profiler。然后点击 MEMORY 时间线中的任意位置可打开 Memory Profiler。 图片中 1-7 按钮分别表示： 用于强制执行垃圾回收的按钮（GC）。 用于捕获堆转储的按钮。 用于记录内存分配情况的按钮。此按钮仅在连接至运行 Android 7.1 或更低版本的设备时才会显示。 用于放大/缩小时间线的按钮。 用于跳转至实时内存数据的按钮。 Event 时间线，其显示 Activity 状态、用户输入 Event 和屏幕旋转 Event。 内存使用量时间线，其包含以下内容： 一个显示每个内存类别使用多少内存的堆叠图表，如左侧的 y 轴以及顶部的彩色键所示。 虚线表示分配的对象数，如右侧的 y 轴所示。 用于表示每个垃圾回收 Event 的图标。 如果遇到：Advanced profiling is unabailable for the selected process 这个问题，是因为在 Android 7.1 或更低版本的设备需要开启 Profiler 配置，Android 8.0 及以上不会存在。解决方案：Run -- Edit Configurations... 打开应用配置界面，选择应用并在右边的 tab 中勾选 Enable advanced profiling。 查看内存泄露点击 Memory Profiler 的堆转储按钮，捕获应用中象使用内存的当前状态。特别是在长时间的用户会话后，堆转储会显示那些不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄漏。堆转储中可以看到： 应用已分配哪些类型的对象，以及每个类型分配多少 每个对象正在使用多少内存 在代码中的何处仍在引用每个对象 在 Instance View 中，每个实例都包含以下信息： Depth从任意 GC 根到所选实例的最短 hop 数，如果不为 0 ，则表示无法回收（内存泄露可疑点）。 Shallow Size：此实例的大小 Retained Size：此实例支配的内存大小 从 Memory Profiler 中只能看出内存泄露产生了，主要是按包查看指定应用的实例引用数（Depth）是否为 0 。如果不为 0 ，基本可以确定存在内存泄露了，需要查看代码慢慢检查。如果为 0，下次 GC 时会回收这些对象。 分析 hprof 文件HPROF 文件是一种二进制堆转储格式文件，包含了内存相关信息，可以直接使用 AS 打开这类文件。 从图中可以看出，打开右上角的 Analyzer Tasks 页，点击开始按钮后，自动分析 hprof 文件中 Activity/String的内存泄露，通常我们用来看 Activity 的内存泄露。点击泄露的 Activity 后，在左下角能看到调用关系，可以很明确的得出具体是哪个变量引用没有释放。参考网页：HPROF文件查看和分析工具 其他检查工具 Leak Canary开源内存泄露检测库官网 ，能跟踪到内存泄露的代码具体位置，非常好用，内存泄露时会给出弹框提示。 MAT[Memory AnalysisTools]Eclipse 推出的内存泄露分析工具官网下载地址 ，可以独立运行。网上有相关分析介绍腾讯Bugly-Android内存泄漏MAT分析 。 dumpsys meminfo 命令命令格式：adb shell dumpsys meminfo package_name|pid [-d]。 [Android 官网指南] https://developer.android.google.cn/studio/command-line/dumpsys.html ，memory 参考文档 深入理解 Java 虚拟机: JVM 高级特性与最佳实践 第 2 版 Android内存泄漏查找和解决 腾讯Bugly-Android内存泄漏的简单检查与分析方法 腾讯Bugly-内存泄露从入门到精通三部曲之基础知识篇 腾讯Bugly-内存泄露从入门到精通三部曲之排查方法篇 腾讯Bugly-内存泄露从入门到精通三部曲之常见原因与用户实践 单例模式造成的内存泄漏 Memory Profiler Android Profiler内存泄漏检查 Android Profiler分析器 github LeakCanary 腾讯Bugly-Android内存泄漏MAT分析 HPROF文件查看和分析工具 java 静态变量及类的生命周期 深入理解Java中为什么内部类可以访问外部类的成员 Android内存泄漏的八种可能-上 Android内存泄漏的八种可能-下 Android 内存泄漏总结 内存泄露实例分析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：代理模式]]></title>
    <url>%2F2018%2F03%2F12%2F0058-design-patterns-proxy%2F</url>
    <content type="text"><![CDATA[代理模式：为其他对象提供一种代理以控制对这个对象的访问。 代理模式 Proxy代理模式 Proxy[ˈprɑ:ksi] Pattern：也称为委托模式，控制对象使得只有确实需要这个对象时才创建和初始化。 代理分类 静态代理编译前所有的代码已经存在。 动态代理通过反射机制动态地生成代理对象，也就是代码编译中并不知道代理关系，动态代理将代理和被代理对象进行了解耦。 常见代理功能 远程代理 Remote Proxy常见于 C/S 模式，为某个对象在不同的内存地址空间提供局部代理，使系统可以将 Server 部分实现隐藏，Client 像使用本地对象一样使用 Server。 虚拟代理 Virtural Proxy使用一个代理对象表示一个十分耗资源的对象，并在真正需要时才创建。 保护代理 Protection Proxy使用代理控制对原始对象的访问，这种模式常见于原始对象有不同的访问权限。 具体实例 图片代理对大图浏览的控制，用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。 静态代理类图结构 结构解析 Subject抽象类，申明公共接口。 RealSubject实现类，被代理类或者被委托类，表示真实对象。 Proxy实现类，代理类或者委托类，它持有真实对象的引用，所有方法中都是对真实对象对应的方法，起到代理作用。 示例12345678910111213141516171819202122232425262728293031323334353637// 1. Subjectpublic abstract class Subject &#123; public abstract void operation();&#125;// 2. RealSubjectpublic class RealSubject extends Subject&#123; @Override public void operation() &#123; System.out.println("RealSubject::operation."); &#125;&#125;// 3. Proxypublic class Proxy extends Subject&#123; private RealSubject realSubject; public Proxy() &#123; this.realSubject = new RealSubject(); &#125; @Override public void operation() &#123; realSubject.operation(); &#125;&#125;// 4. Testpublic class TestStaticProxy &#123; public static void main(String[] args) &#123; Proxy proxy = new Proxy(); proxy.operation(); &#125;&#125;// 5. ResultRealSubject::operation. 动态代理基本接口12345678910111213141516171819202122232425/* * 调用被代理对象的方法 * Object: 代理实例 * method：代理实例对应的方法 * args：传入的参数数组 */public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125;/* * 通过 Proxy 的 newProxyInstance 方法来创建代理对象 * ClassLoader: 代理对象的接口，它的 ClassLoader * Class&lt;?&gt;[]：代理对象的接口，生成的 Class 数组 * InvocationHandler：我们实现的动态代理对象 */public class Proxy implements Serializable &#123; public static Object newProxyInstance(ClassLoader var0, Class&lt;?&gt;[] var1, InvocationHandler var2) throws IllegalArgumentException &#123;...&#125; &#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243// 1. Subjectpublic interface Subject &#123; void operation();&#125;// 2. RealSubjectpublic class RealSubject implements Subject&#123; public void operation()&#123; System.out.println("RealSubject::operation."); &#125;&#125;// 3. DynamicProxypublic class DynamicProxy implements InvocationHandler&#123; private Object object; public DynamicProxy(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123; Object result = method.invoke(object, objects); return result; &#125;&#125;// 4. Testpublic class TestDynamicProxy &#123; public static void main(String[] args) &#123; RealSubject realSubject = new RealSubject(); InvocationHandler dynamicProxy = new DynamicProxy(realSubject); Subject subject = (Subject) Proxy.newProxyInstance( Subject.class.getClassLoader(), new Class[]&#123;Subject.class&#125;, dynamicProxy); subject.operation(); &#125;&#125;// 5. ResultRealSubject::operation. 总结在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 优点代理模式能够协调调用者和被调用者，降低了系统的耦合度；保护代理可以控制对真实对象的使用权限。 缺点于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 参考文档 大话设计模式 Android 源码设计模式解析与实战 代理模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：享元模式]]></title>
    <url>%2F2018%2F03%2F08%2F0057-design-patterns-flyweight%2F</url>
    <content type="text"><![CDATA[享元模式：运用共享技术有效的支持大量细粒度的对象。 享元模式 Flyweight享元模式：将对象划分为内部状态和外部状态，共享内部状态，通过共享池来减少对象的一种模式。 内部状态/外部状态 内部状态享元对象内部不会随环境改变而改变的共享部分，称为享元对象的内部状态。也就是说，内部状态是不变的部分。 外部状态受环境影响改变，不可共享的部分，称为享元对象的外部状态。也就是说，外部状态是变化的。 比如一堆衣服中有男女两个款式，如果需要请模特过来拍照展示，其中性别是无法改变的部分，即内部状态；而衣服款式是多变不一样的，所以款式是外部状态。在这个例子中，通过创建共享池共享性别对象。 类图结构 结构解析 Flyweight抽象类，享元类，表示可以共享的抽象类。 ConcreteFlyweight实现类，具体共享类。 UnsharedConcreteFlyweight实现类，具有共享能力，但是不强制该类共享。 FlyweightFactory享元工厂，创建并管理享元对象，通过共享池保存。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 1. Flyweightpublic abstract class Flyweight &#123; public abstract void operation(String extrinsicState);&#125;// 2. ConcreteFlyweightpublic class ConcreteFlyweight extends Flyweight&#123; @Override public void operation(String extrinsicState) &#123; System.out.println("ConcreteFlyweight::operation::extrinsicState = " + extrinsicState); &#125;&#125;// 3. UnsharedConcreteFlyweightpublic class UnsharedConcreteFlyweight extends Flyweight&#123; @Override public void operation(String extrinsicState) &#123; System.out.println("UnsharedConcreteFlyweight::operation::extrinsicState = " + extrinsicState); &#125;&#125;// 4. FlyweightFactorypublic class FlyweightFactory &#123; private static HashMap&lt;String, Flyweight&gt; flyweightMaps = new HashMap&lt;&gt;(); public static Flyweight getFlyweight(String key)&#123; if (flyweightMaps.containsKey(key))&#123; return flyweightMaps.get(key); &#125;else &#123; Flyweight flyweight = new ConcreteFlyweight(); flyweightMaps.put(key, flyweight); return flyweight; &#125; &#125;&#125;// 5. Testpublic class TestFlyweight &#123; public static void main(String[] args) &#123; String extrinsicState = "A"; Flyweight flyweight1 = FlyweightFactory.getFlyweight(extrinsicState); flyweight1.operation(extrinsicState); extrinsicState = "B"; Flyweight flyweight2 = FlyweightFactory.getFlyweight(extrinsicState); flyweight2.operation(extrinsicState); extrinsicState = "C"; Flyweight flyweight3 = new UnsharedConcreteFlyweight(); flyweight3.operation(extrinsicState); &#125;&#125;// 6. ResultConcreteFlyweight::operation::extrinsicState = AConcreteFlyweight::operation::extrinsicState = BUnsharedConcreteFlyweight::operation::extrinsicState = C 总结享元模式主要使用了缓存来减少创建重复对象，能大大降低内存占用率。 参考文档 大话设计模式 Android 源码设计模式解析与实战]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：外观模式]]></title>
    <url>%2F2018%2F03%2F07%2F0056-design-patterns-facade%2F</url>
    <content type="text"><![CDATA[外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式 Facade [fəˈsɑːd] ：描述如何用单个对象表示整个子系统。为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口。体现了依赖倒转原则，典型场景： MVC 架构、基金对股票的封装等。 外观模式 Facade类图结构 结构解析 Facade系统对外的统一接口。 SubSystem1/SubSystem2/SubSystem3子系统及对应的功能实现。 类图可以看出，所有的类关系都仅仅是简单关联，外观模式主要体现在对外接口的统一，以及对内整个系统的封装。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 1. SubSystempublic class SubSystem1 &#123; public void operation1()&#123; System.out.println("SubSystem1::operation1."); &#125;&#125;public class SubSystem2 &#123; public void operation2()&#123; System.out.println("SubSystem2::operation2."); &#125;&#125;public class SubSystem3 &#123; public void operation3()&#123; System.out.println("SubSystem3::operation3."); &#125;&#125;// 2. Facadepublic class Facade &#123; private SubSystem1 subSystem1; private SubSystem2 subSystem2; private SubSystem3 subSystem3; public Facade() &#123; subSystem1 = new SubSystem1(); subSystem2 = new SubSystem2(); subSystem3 = new SubSystem3(); &#125; public void method()&#123; System.out.println("Facade::method."); subSystem1.operation1(); subSystem2.operation2(); subSystem3.operation3(); &#125;&#125;// 3. Testpublic class TestFacade &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.method(); &#125;&#125;// 4. ResultFacade::method.SubSystem1::operation1.SubSystem2::operation2.SubSystem3::operation3. 总结外观模式隐藏了子系统的复杂性，通过高层次的结构提供统一的接口。在设计初期尽量使用外观模式来分层；开发过程中子系统越来越复杂时，外观模式提供一个统一简单的接口降低耦合性；项目后期可以通过外观类封装系统遗留代码，对外操作大大简化。 优点对客户隐藏子系统细节，简述客户端和子系统的耦合性；对子系统封装接口，使得系统易用。 缺点子系统所有的接口都通过外观类对外暴露，导致外观类功能过多；如果不引入抽象外观类，业务变更或者增加子系统时需要修改外观类或者客户端，不符合开闭原则。 参考文档 大话设计模式 Android 源码设计模式解析与实战 外观模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：装饰模式]]></title>
    <url>%2F2018%2F03%2F06%2F0055-design-patterns-decorator%2F</url>
    <content type="text"><![CDATA[装饰模式：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比直接修改子类更加灵活。 装饰模式 Decorator ：也称为包装模式 Wrapper Pattern，常见于给某个对象添加功能而不是整个类。装饰模式可以修改对象的功能，而不用修改子类代码。代码中如果看到 Wrapper 结尾的类，通常是用了装饰模式的设计思路。装饰模式通常用于动态和透明的扩展类的功能，特别是当系统维护中需要添加新功能，而这个功能是需要向旧类中添加新代码，而这个功能并不是旧类的主要职责或者核心功能。在这种场景下，使用装饰模式添加一个装饰类，在不破坏原有代码的基础上，动态的给对象添加或修改功能。 装饰模式 Decorator类图结构 结构解析 Component抽象类，定义公共方法。 ConcreteComponent实现类，实现该方法。 Decorator抽象类，也是装饰类，类内部会指向一个 Component 实现类，形成组合关系，具体的 operation 都是传入的 Component 来实现的。 ConcreteDecorator实现类，除了调用 ConcreteComponent 对应的方法，通常会修改或增加功能。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 1. Componentpublic abstract class Component &#123; public abstract void operation();&#125;// 2. ConcreteComponentpublic class ConcreteComponent extends Component&#123; @Override public void operation() &#123; System.out.println("ConcreteComponent::operation."); &#125;&#125;// 3. Decoratorpublic abstract class Decorator extends Component&#123; Component component; public Decorator(Component component)&#123; this.component = component; &#125; @Override public void operation() &#123; component.operation(); &#125;&#125;// 4. ConcreteDecoratorpublic class ConcreteDecorator extends Decorator&#123; public ConcreteDecorator(Component component) &#123; super(component); &#125; @Override public void operation() &#123; super.operation(); addBehavior(); &#125; private void addBehavior()&#123; System.out.println("ConcreteDecorator::addBehavior."); &#125;&#125;// 5. Testpublic class TestDecorator &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); Component decorator = new ConcreteDecorator(component); component.operation(); System.out.println("##Decorator Pattern: add extra function for component.##"); decorator.operation(); &#125;&#125;// 6. ResultConcreteComponent::operation.##Decorator Pattern: add extra function for component.##ConcreteComponent::operation.ConcreteDecorator::addBehavior. Android 中经典的装饰模式Android 中的 Context/ContextWraaper 就是经典的装饰模式。 类图结构 类图解析 Context抽象类，定义了所有的公共方法。 ContextImpl实现类，实现了所有的方法。 ContextWrapper包装类，也是抽象类，使用组合结构引用了 ContextImpl。 Activity包装类实现类，Activity, Service, Application 都继承了 ContextWrapper，这些子类动态添加或修改了 ContextImpl 的部分方法。 总结装饰模式很容易和桥接模式、代理模式混淆，我们看下他们之间的区别以及装饰模式的优缺点。 装饰模式和桥接模式的区别 类图结构有较大区别，从对比图中可以看出： 结构维度桥接模式是不同维度的分类，属于平行结构；装饰模式是继承结构，在继承的基础上修改功能。 是否继承桥接模式的两种维度没有继承关系，仅仅是组合关系（松耦合）；而装饰模式除了组合还必须是继承关系（紧耦合），也就是 Decorator 继承并组合了 Component。 方法名是否一致桥接模式仅仅需要组合，所以方法名一般不同；装饰模式因为带有继承关系，所以装饰时重写方法，方法名相同。 装饰模式和代理模式的区别 类图结构基本一致 override 重写方法后的侧重点不一样装饰器模式关注于在一个对象上动态的添加或修改方法；代理模式关注于控制对对象的访问，对是否执行实现类有决定权。 12345678910111213141516// 1. 装饰器模式@Overridepublic void operation() &#123; impl.operation(); addBehavior();&#125;// 2. 代理模式 @Overridepublic void operation() &#123; if (hasOption())&#123; impl.operation(); &#125; else &#123; System.out.println("不符合选项。"); &#125;&#125; 装饰模式和代理模式非常非常像，唯一的区别在与侧重点不一样：装饰模式侧重于修改功能，代理模式侧重于控制访问。 装饰模式优缺点 优点可以通过一种动态的方式来扩展一个对象的功能，具体构件类与具体装饰类可以独立变化，原有代码无须改变，符合“开闭原则”。 缺点使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，同时还将产生很多具体装饰类。 参考文档 大话设计模式 Android 源码设计模式解析与实战 装饰模式和代理模式区别 装饰模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：组合模式]]></title>
    <url>%2F2018%2F03%2F06%2F0054-design-patterns-composite%2F</url>
    <content type="text"><![CDATA[组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式 Composite ：通常用于可以使用树状结构描述的场景，比如： 公司的组织结构图公司包含多个部门：行政部，研发部，生产部，以及多个子公司，每个子公司又会有各自的行政部，研发部等，典型的树状结构。 操作系统中的文件系统文件系统包含：文件和文件夹，每个文件夹目录下又可以包含多个子目录及文件。 常见的 UI 框架比如 Android 的 UI 框架中：View 和 ViewGroup 的关系。View 为叶子节点，ViewGroup 为容器，可以包含 View 以及子 ViewGroup。 组合模式有两种结构： 安全组合模式 透明组合模式 安全组合模式类图结构 结构解析 Component抽象类，定义组合模式中对象的公共接口。 Leaf叶子节点，实现组合模式中的抽象方法。 Composite枝干节点，包含多个叶子节点。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 1. Componentpublic abstract class Component &#123; public abstract void operation();&#125;// 2. Leafpublic class Leaf extends Component&#123; @Override public void operation() &#123; System.out.println("Leaf::operation."); &#125;&#125;// 3. Compositepublic class Composite extends Component&#123; private List&lt;Component&gt; componentList = new ArrayList&lt;&gt;(); public void add(Component component)&#123; componentList.add(component); &#125; public void remove(Component component)&#123; componentList.remove(component); &#125; public Component getChild(int index)&#123; return componentList.get(index); &#125; @Override public void operation() &#123; System.out.println("Composite::operation."); for (Component component : componentList)&#123; component.operation(); &#125; &#125;&#125;// 4. Testpublic class TestCompositeTypeSafety &#123; public static void main(String[] args) &#123; Composite branch = new Composite(); Leaf branch_leaf1 = new Leaf(); Leaf branch_leaf2 = new Leaf(); branch.add(branch_leaf1); branch.add(branch_leaf2); Composite root = new Composite(); Leaf leaf = new Leaf(); root.add(leaf); root.add(branch); root.operation(); &#125;&#125;// 5. ResultComposite::operation.Leaf::operation.Composite::operation.Leaf::operation.Leaf::operation. 透明组合模式类图结构 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// 1. Componentpublic abstract class Component &#123; public abstract void add(Component component); public abstract void remove(Component component); public abstract Component getChild(int index); public abstract void operation();&#125;// 2. Leafpublic class Leaf extends Component&#123; @Override public void add(Component component) &#123; throw new UnsupportedOperationException("Cannot add to a leaf."); &#125; @Override public void remove(Component component) &#123; throw new UnsupportedOperationException("Cannot remove from a leaf."); &#125; @Override public Component getChild(int index) &#123; throw new UnsupportedOperationException("Cannot getchildfrom a leaf."); &#125; @Override public void operation() &#123; System.out.println("Leaf::operation."); &#125;&#125;// 3. Compositepublic class Composite extends Component&#123; private List&lt;Component&gt; componentList = new ArrayList&lt;&gt;(); @Override public void add(Component component) &#123; componentList.add(component); &#125; @Override public void remove(Component component) &#123; componentList.remove(component); &#125; @Override public Component getChild(int index) &#123; return componentList.get(index); &#125; @Override public void operation() &#123; System.out.println("Composite::operation."); for (Component component : componentList)&#123; component.operation(); &#125; &#125;&#125;// 4. Testpublic class TestCompositeUniformity &#123; public static void main(String[] args) &#123; Component branch = new Composite(); Component branch_leaf1 = new Leaf(); Component branch_leaf2 = new Leaf(); branch.add(branch_leaf1); branch.add(branch_leaf2); Component root = new Composite(); Component leaf = new Leaf(); root.add(leaf); root.add(branch); root.operation(); &#125;&#125;// 5. ResultComposite::operation.Leaf::operation.Composite::operation.Leaf::operation.Leaf::operation. 总结从两种组合模式的类图结构和示例中，可以看出他们最大的不同在与 Component： 安全组合模式Component 中并没有将管理子对象抽象出来，也就是不包含 add/remove 等，但是这会导致子对象和组合对象接口不一致。Android View/ViewGroup 就属于安全组合模式。 透明组合模式Component 中将管理子对象抽象到基类中，使得子对象和组合对象具有完全一致的行为接口，但是叶子类实际上并不需要这些管理行为。 优缺点： 优点组合模式可以清楚的定义分层次的复杂对象，高层模块可以忽略层次的差异，调用简单。增加叶子或者树干，不需要修改类库，在客户端就可以实现，符合开闭原则。 缺点组合模式的叶子节点和组合类都是实现类，违反了依赖倒置原则。 参考文档 大话设计模式 Android 源码设计模式解析与实战]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：桥接模式]]></title>
    <url>%2F2018%2F03%2F05%2F0053-design-patterns-bridge%2F</url>
    <content type="text"><![CDATA[桥接模式：*将抽象和其实现分离，具体的子类使用不同的方式去实现，从而可以独立的改变它们。体现了组合重用原则。实现独立出来各自变化，每次变化不会影响其他实现 *。 桥接模式 Bridge通俗的解释：实现系统可能有多角度的分类，每一种分类都有可能变化，那么就把这种多角度分离出来让他们独立变化，减少他们之间的耦合。任何多维度变化类或者多个树状类，都可以通过桥接模式解耦。桥接模式的桥梁作用也是连接“抽象部分”和“实现部分”；或者是将不同角度的分类连接起来。 类图结构 结构解析 Abstraction抽象类，定义了抽象接口，该类持有 Implement 对象的引用。 RefinedAbstraction抽象类的具体实现，同时会对抽象方法进行完善和扩展。 Implementor抽象类，实现部分的抽象类。实现 Abstraction 中的抽象方法。 ConcreteImplementor实现部分的具体实现类。 示例标准示例按照标准类图结构实现的桥接模式。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 1. Implementorpublic abstract class Implementor &#123; public abstract void operationImpl();&#125;// 2. ConcreteImplementorpublic class ConcreteImplementor extends Implementor&#123; @Override public void operationImpl() &#123; System.out.println("ConcreteImplementor::operationImpl"); &#125;&#125;// 3. Abstractionpublic abstract class Abstraction &#123; protected Implementor implementor; public Abstraction(Implementor implementor)&#123; this.implementor = implementor; &#125; public abstract void operation();&#125;// 4. RefinedAbstraction public class RefinedAbstraction extends Abstraction&#123; public RefinedAbstraction(Implementor implementor) &#123; super(implementor); &#125; @Override public void operation() &#123; implementor.operationImpl(); System.out.println("RefinedAbstraction::operation::Extends!"); &#125;&#125;// 5. Test public class TestStandardBridge &#123; public static void main(String[] args) &#123; Implementor implementor = new ConcreteImplementor(); Abstraction abstraction = new RefinedAbstraction(implementor); abstraction.operation(); &#125;&#125;// 6. ResultConcreteImplementor::operationImplRefinedAbstraction::operation::Extends! 咖啡咖啡可以有多种分类方式，比如大杯小杯，有糖无糖等等，典型的多角度分类，可以桥接模式来实现客户拿到的咖啡。这种分类方式还有：不同形状涂不同颜色的图形；不同系统使用不同通讯录，短信等软件的手机；不同操作系统播放不同格式视频的播放器等等，这些都可以使用桥接模式来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 1. Flavourpublic abstract class Flavour &#123; public abstract void addFlavor();&#125;// 2. ConcreteFlavourpublic class Sugar extends Flavour &#123; @Override public void addFlavor() &#123; System.out.println("Sugar"); &#125;&#125;public class SugarFree extends Flavour&#123; @Override public void addFlavor() &#123; System.out.println("SugarFree"); &#125;&#125;// 3. Coffeepublic abstract class Coffee &#123; protected Flavour flavour; public Coffee(Flavour flavour)&#123; this.flavour = flavour; &#125; public abstract void makeCoffee();&#125;// 4. ConcreteCoffeepublic class LargeCoffee extends Coffee &#123; public LargeCoffee(Flavour flavour) &#123; super(flavour); &#125; @Override public void makeCoffee() &#123; System.out.printf("Large Cup Coffee "); flavour.addFlavor(); &#125;&#125;public class SmallCoffee extends Coffee&#123; public SmallCoffee(Flavour flavour) &#123; super(flavour); &#125; @Override public void makeCoffee() &#123; System.out.printf("Small Cup Coffee "); flavour.addFlavor(); &#125;&#125;// 5. Testpublic class TestCoffee &#123; public static void main(String[] args) &#123; Flavour flavour1 = new Sugar(); Flavour flavour2 = new SugarFree(); Coffee coffeeA = new LargeCoffee(flavour1); Coffee coffeeB = new SmallCoffee(flavour2); coffeeA.makeCoffee(); coffeeB.makeCoffee(); &#125;&#125;// 6. ResultLarge Cup Coffee SugarSmall Cup Coffee SugarFree 总结 优点分离抽象接口及其实现部分，提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 缺点桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 桥接模式最大的特点是将抽象部分与它的实现部分分离，使它们都可以独立地变化，也就是两种维度可以独自扩展。 参考文档 大话设计模式 Android 源码设计模式解析与实战 桥接模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--结构型：适配器模式]]></title>
    <url>%2F2018%2F03%2F05%2F0052-design-patterns-adpater%2F</url>
    <content type="text"><![CDATA[适配器模式：将类的接口转换成客户希望的接口，使得原本由于接口不兼容的类可以一起工作。。 适配器模式 Adapter适配器模式使得接口不兼容的两个类能在一起工作，通俗易懂的例子就是电源适配器。 系统中已经存在的类（遗留代码，或者没有源码等），接口并不符合当前需求，使用适配器适配，最大程度上保持代码重用 需要统一的输出接口，但是输入类型不可知 类图结构 结构解析 Target客户端期望的接口类。 Adaptee原有的类，或者被适配的类。 Adapter适配器模式，适配类，用来将 Adaptee 转换为 Target 期望的接口。 Client客户端，接口调用者。 示例12345678910111213141516171819202122232425262728293031323334// 1. Targetpublic class Target &#123; public void request()&#123; System.out.println("Target::Request!"); &#125;&#125;// 2. Adaptee public class Adaptee &#123; public void specificRequest()&#123; System.out.println("Adaptee::SpecificRequest!"); &#125;&#125;// 3. Adapter public class Adapter extends Target &#123; private Adaptee adaptee = new Adaptee(); @Override public void request() &#123; adaptee.specificRequest(); &#125;&#125;// 4. Test, Client public class TestAdapter &#123; public static void main(String[] args) &#123; Target target = new Adapter(); target.request(); &#125;&#125;// 5. Result.Adaptee::SpecificRequest! 总结 优点可以将目标类和被适配类解耦，引入适配器类并重用代码；增加了类的透明性和复用性。 缺点Java 不支持多重继承，也就是每次只能适配一个类。 参考文档 大话设计模式 Android 源码设计模式解析与实战 适配器模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Structural</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--创建型：单例模式]]></title>
    <url>%2F2018%2F03%2F01%2F0051-design-patterns-singleton%2F</url>
    <content type="text"><![CDATA[单例模式：保证一个类只产生唯一的一个实例，并提供一个访问它的全局访问点。 单例模式 Singleton单例模式一般用于某个类有且仅有一个对象，避免产生多个对象消耗过多资源，或者访问 IO 或数据库等资源时。 类图结构 结构解析只有一个 Singleton 单例类，这个类有几个关键特点： 构造函数为 private 通过静态方法或者枚举返回单例类对象 确保单例类对象有且仅有一个，特别是多线程场景 单例类在反序列化时不会重构对象 示例如下是单例模式的经典用法，饿汉式单例： 1234567// 饿汉式，static，定义时直接初始化private static MyObject myObject = new MyObject();// 使用时，因为在类加载过程中就已经实例化，并发调用安全public static MyObject getInstance()&#123; return myObject;&#125; 多线程中的应用单例模式在多线程中，有多种实现方式，常见有：饿汉模式，懒汉模式，经典双检锁，枚举实现等。从多线程角度来看，单元素枚举是实现单例模式最佳方法。详细分析参考：Java 多线程并发:单例模式多线程 总结 优点单例类封装了它的唯一实例，在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 缺点单例模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则”。单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法。 创建型设计模式总结创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。创建型模式在创建什么，由谁创建，何时创建等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 参考文档 大话设计模式 Android 源码设计模式解析与实战 创建型模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Creational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--创建型：原型模式]]></title>
    <url>%2F2018%2F02%2F28%2F0050-design-patterns-prototype%2F</url>
    <content type="text"><![CDATA[原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新对象。 原型模式 Prototype所谓原型模式 Prototype[&#39;protəˌtaɪp]，就是指 clone 技术，以某个对象为原型，复制出一个新的对象。 类图结构 结构解析 Prototype抽象类，原型类申明一个 clone 自身的接口。 ConcretePrototype实现类，实现一个克隆自身的操作。 client客户端持有原型类实例。 Java 中的原型模式Cloneable 接口在 Java 中，原型模式的 Prototype 抽象类并不需要我们定义，Cloneable 接口实现了这个功能。先看看这个接口的定义： 12345678910111213/** * A class implements the &lt;code&gt;Cloneable&lt;/code&gt; interface to * indicate to the &#123;@link java.lang.Object#clone()&#125; method that it * is legal for that method to make a * field-for-field copy of instances of that class. * &lt;p&gt; * Invoking Object's clone method on an instance that does not implement the * &lt;code&gt;Cloneable&lt;/code&gt; interface results in the exception * &lt;code&gt;CloneNotSupportedException&lt;/code&gt; being thrown. * &lt;p&gt; */public interface Cloneable &#123;&#125; 源码中 Cloneable 是一个空接口，仅用来标记对象，并没有定义 clone 方法。但是 Java 中所有对象都继承了 Object 类，而 clone() 正是它的标准方法之一。 1234567891011121314151617public class Object &#123; ... protected Object clone() throws CloneNotSupportedException &#123; if (!(this instanceof Cloneable)) &#123; throw new CloneNotSupportedException("Class "+getClass().getName()+ "doesn't implement Cloneable"); &#125; return internalClone(); &#125; /* * Native helper method for cloning. */ private native Object internalClone(); ...&#125; 实现 Cloneable 接口从源码中可以看出，如果要使用 Object.clone 则必须实现 Cloneable 接口，否则会抛出 CloneNotSupportedException 异常。 clone 新对象时不会调用构造函数clone 方法最终调用了 native 的 internalClone 方法，而这个方法是直接从堆内存中以二进制流拷贝的，所以产生新对象时并不会调用类的构造方法。 深/浅拷贝深/浅拷贝主要区别在对类中引用对象的处理： 浅拷贝 shallow copy浅拷贝在拷贝对象时，并不会拷贝对象里的引用对象，也就是说不拷贝该对象的属性。 深拷贝 deep copy深拷贝在拷贝对象时，需要手动代码实现对引用对象的拷贝，也就是把该对象的所有属性也克隆出一份新的。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 1. Prototype// It's Cloneable in Java. // 2. ConcretePrototypepublic class ConcretePrototypeShallowCopy implements Cloneable&#123; private String type; private TestObject testObject; public ConcretePrototypeShallowCopy(String type, TestObject testObject) &#123; this.type = type; this.testObject = testObject; &#125; @Override protected ConcretePrototypeShallowCopy clone() throws CloneNotSupportedException &#123; return (ConcretePrototypeShallowCopy)super.clone(); &#125; public void show()&#123; System.out.println(type + ": " + testObject.getName()); &#125;&#125;public class ConcretePrototypeDeepCopy implements Cloneable &#123; private String type; private TestObject testObject; public ConcretePrototypeDeepCopy(String type, TestObject testObject) &#123; this.type = type; this.testObject = testObject; &#125; @Override protected ConcretePrototypeDeepCopy clone() throws CloneNotSupportedException &#123; ConcretePrototypeDeepCopy deepCopy = (ConcretePrototypeDeepCopy)super.clone(); deepCopy.testObject = new TestObject(testObject.getName()); return deepCopy; &#125; public void show()&#123; System.out.println(type + ": " + testObject.getName()); &#125;&#125;// 3. Test public class TestObject &#123; private String name; public TestObject(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;public class TestPrototype &#123; public static void main(String[] args) throws Exception&#123; TestObject testObject = new TestObject("TestObject"); ConcretePrototypeShallowCopy shallowCopy = new ConcretePrototypeShallowCopy("ShallowCopy", testObject); ConcretePrototypeShallowCopy shallowCopyClone = shallowCopy.clone(); shallowCopy.show(); shallowCopyClone.show(); ConcretePrototypeDeepCopy deepCopy = new ConcretePrototypeDeepCopy("DeepCopy", testObject); ConcretePrototypeDeepCopy deepCopyClone = deepCopy.clone(); deepCopy.show(); deepCopyClone.show(); testObject.setName("newTestObject"); System.out.println("####TestObject change name.####"); shallowCopyClone.show(); deepCopyClone.show(); &#125;&#125;// 4. ResultShallowCopy: TestObjectShallowCopy: TestObjectDeepCopy: TestObjectDeepCopy: TestObject####TestObject change name.####ShallowCopy: newTestObjectDeepCopy: TestObject 在测试用例中，修改 TestObject 对象的值后，两种拷贝表现出来的结果不一样： 浅拷贝因为引用对象并没有克隆，指向的是同一个地址空间，所以 TestObject 对象修改后，浅拷贝生成的新对象会跟着变化。 深拷贝深拷贝克隆了所有的引用对象，也就是在新地址中拷贝了引用对象的值，源 TestObject 对象的修改不会对深拷贝产生影响。 总结原型模式适合在什么场景使用？ 类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等 初始化时需要非常繁琐的数据准备或访问权限，则可以使用原型模式 一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用 在实际项目中，原型模式通常和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。 参考文档 大话设计模式 Android 源码设计模式解析与实战 原型模式(深/浅拷贝) 原型模式详解 原型模式 原型模式介绍]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Creational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--创建型：简单工厂、工厂方法模式、抽象工厂模式]]></title>
    <url>%2F2018%2F02%2F26%2F0049-design-patterns-factory%2F</url>
    <content type="text"><![CDATA[工厂模式有三种：简单工厂，工厂方法模式，抽象工厂模式。 简单工厂 Simple Factory简单工厂模式，又称为静态工厂模式（Static Factory Method），并不属于 23 种 GOF 设计模式之一。简单工厂模式的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。 类图结构 结构解析 Factory简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。 Product抽象类，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。 Concrete Product是简单工厂模式的创建目标，具体实现类。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1. Productpublic abstract class Product &#123; public abstract void function();&#125;// 2. ConcreteProductpublic class ProductA extends Product&#123; @Override public void function() &#123; System.out.println("Product A can fly."); &#125;&#125;public class ProductB extends Product &#123; @Override public void function() &#123; System.out.println("Product B can run."); &#125;&#125;// 3. Factorypublic class ProductFactory &#123; public static final int SPEC_FLY = 1; public static final int SPEC_RUN = 2; public static Product createProduct(int spec)&#123; Product product = null; switch (spec) &#123; case SPEC_FLY: product = new ProductA(); break; case SPEC_RUN: default: product = new ProductB(); break; &#125; return product; &#125;&#125;// 4. Testpublic class TestSimpleFactory &#123; public static void main(String[] args) &#123; Product product=ProductFactory.createProduct(ProductFactory.SPEC_FLY); product.function(); product = ProductFactory.createProduct(ProductFactory.SPEC_RUN); product.function(); &#125;&#125;// 5. ResultProduct A can fly.Product B can run. 小结由于工厂类集中了所有实例的创建逻辑，违反了开闭原则。将全部创建逻辑集中到了一个工厂类中，它所能创建的类只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，对系统的维护和扩展非常不利，这些缺点在工厂方法模式中得到了一定的克服。因此工厂类一般在很简单情况下使用：负责创建的对象比较少，客户只需要知道传入工厂类的参数，对于如何创建对象（逻辑）不关心。 工厂方法模式 Factory Method工厂方法模式 Factory Method：定义一个用于创建对象的接口，让子类决定实现哪一个类。工厂方法使一个类的实例化延迟到其子类。 类图结构 结构解析 Product抽象类，定义工厂方法创建的对象。 ConcreteProduct实现类，具体的产品。 Creator抽象类，产品创建抽象类。必须包含工厂方法，该方法是抽象方法，并且返回抽象产品。public abstract Product factoryMethod(); ConcreteCreator实现类，实现工厂方法，创建具体的产品。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1. Productpublic abstract class Product &#123; public abstract void method();&#125;// 2. ConcreteProductpublic class ProductA extends Product&#123; @Override public void method() &#123; System.out.println("Product A is sweet."); &#125;&#125;public class ProductB extends Product&#123; @Override public void method() &#123; System.out.println("Product B is salty."); &#125;&#125;// 3. Creatorpublic abstract class Creator &#123; public abstract Product factoryMethod();&#125;// 4. ConcreteCreatorpublic class ProductACreator extends Creator &#123; @Override public Product factoryMethod() &#123; return new ProductA(); &#125;&#125;public class ProductBCreator extends Creator &#123; @Override public Product factoryMethod() &#123; return new ProductB(); &#125;&#125;// 5. Testpublic class TestFactoryMethod &#123; public static void main(String[] args) &#123; Creator productACreator = new ProductACreator(); Product productA = productACreator.factoryMethod(); productA.method(); Creator productBCreator = new ProductBCreator(); Product productB = productBCreator.factoryMethod(); productB.method(); &#125;&#125;// 6. ResultProduct A is sweet.Product B is salty. 小结工厂方法模式中的 FactoryMethod 的特点：抽象，new 一个新产品并返回。工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现开闭原则，实现了可扩展；缺点是会增加很多类，加大了代码量。 抽象工厂模式 Abstract Factory抽象工厂模式 Abstract Factory：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。 类图结构 结构解析 AbstractProduct抽象类，抽象产品。表示某一类型产品，比如 CPU 系列，内存系列等。 ConcreteProduct实现类，具体的产品，比如具体的 AMD 或者 Intel 型号的 CPU；大小为 2G/4G 的内存。 AbstractFactory抽象类，抽象工厂，表示组装一个产品集合时，必须生产哪些产品类型。比如必须生产 CPU 以及内存。 ConcreteFactory实现类，工厂的具体实现。明确该工厂生产具体的产品，比如生产 AMD CPU 和大小为 2G 的内存。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// 1. AbstractProductpublic abstract class AbstractProductA &#123; public abstract String toString();&#125;public abstract class AbstractProductB &#123; public abstract String toString();&#125;// 2. AbstractFactorypublic abstract class AbstractFactory &#123; public abstract AbstractProductA createProductA(); public abstract AbstractProductB createProductB();&#125;// 3. ConcreteProductpublic class ConcreteProductA1 extends AbstractProductA&#123; @Override public String toString() &#123; return "AMD CPU "; &#125;&#125;public class ConcreteProductA2 extends AbstractProductA&#123; @Override public String toString() &#123; return "Intel CPU "; &#125;&#125;public class ConcreteProductB1 extends AbstractProductB&#123; @Override public String toString() &#123; return "2G RAM "; &#125;&#125;public class ConcreteProductB2 extends AbstractProductB&#123; @Override public String toString() &#123; return "4G RAM"; &#125;&#125;// 4. ConcreteFactorypublic class ConcreteFactory1 extends AbstractFactory &#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductA1(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductB1(); &#125;&#125;public class ConcreteFactory2 extends AbstractFactory&#123; @Override public AbstractProductA createProductA() &#123; return new ConcreteProductA2(); &#125; @Override public AbstractProductB createProductB() &#123; return new ConcreteProductB2(); &#125;&#125;// 5. Testpublic class TestAbstractFactory &#123; public static void main(String[] args) &#123; AbstractFactory abstractFactory1 = new ConcreteFactory1(); AbstractProductA abstractProductA1 =abstractFactory1.createProductA(); AbstractProductB abstractProductB1 =abstractFactory1.createProductB(); System.out.println("Computer config: " + abstractProductA1.toString() + abstractProductB1.toString()); AbstractFactory abstractFactory2 = new ConcreteFactory2(); AbstractProductA abstractProductA2 =abstractFactory2.createProductA(); AbstractProductB abstractProductB2 =abstractFactory2.createProductB(); System.out.println("Computer config: " + abstractProductA2.toString() + abstractProductB2.toString()); &#125;&#125;// 6. ResultComputer config: AMD CPU 2G RAM Computer config: Intel CPU 4G RAM 小结抽象工厂模式主要用来创建产品集合，比如组装一台电脑，一辆车，他们通常由固定数量的零部件组成，但是每个零部件都会有多种配置。每一个具体的工厂，都会产生具体配置的产品集合，如果需要生产其他不同配置，只需要添加一个类继承抽象工厂就行，符合开闭原则。而且客户端只需要依赖抽象产品类，并不需要关心具体产品，符合依赖倒转原则。抽象工厂模式的缺点也很明显：一是会导致增加很多相关类，二是如果工厂的流水线并不固定，增加了一个抽象产品类，则需要添加产品实现类，并且修改抽象工厂类，以及所有的工厂实现类。 总结 简单工厂用来生产同一等级结构中的任意产品。不支持增加产品，违反开闭原则。 工厂方法用来生产同一等级结构中的固定产品。支持增加产品，只需增加对应的工厂实现类。 抽象工厂用来生产不同配置的产品族。支持增加产品族，只需增加具体的工厂实现类，配置不同的产品类型。但是不支持增加产品，会修改抽象工厂及所有工厂实现类。 参考文档 大话设计模式 Android 源码设计模式解析与实战 简单工厂、工厂方法、抽象工厂之小结区别]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Creational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内部类]]></title>
    <url>%2F2018%2F02%2F07%2F0048-java-inner-class%2F</url>
    <content type="text"><![CDATA[内部类：将一个类定义置入另一个类定义中。 Java 顶级类类名必须与文件名相同（大小写也必须一样），并且顶级类只能使用 public 或者不用访问控制符（default，包内可见）。在顶级类中新定义的类，都是内部类。Java 内部类分四种：成员内部类、局部内部类、匿名内部类和静态内部类。 成员内部类定义定义在一个类的内部，但是没有 static 关键字修饰，像成员变量一样定义的类，即为成员内部类。 作用域成员内部类作用域是整个外部类，类似成员变量。 访问范围 成员内部类能够访问外部类的所有属性及方法（包含外部类的 private 成员） 外部类对内部类实例化对象后（不能直接使用），通过该对象能够访问成员内部类的所有成员和方法（包含成员内部类的 private 成员） 实例化成员内部类的实例化，必须先实例化外部类。通过外部类的对象，new 一个成员内部类对象。 12OuterClass outerClass = new OuterClass();OuterClass.InnerClass inner = outerClass.new InnerClass(); 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 1. 成员内部类public class OuterClass &#123; // 外部类私有成员变量 private String outerPrivateStr = "outerPrivateStr"; // 外部类私有方法 private void show()&#123; // 外部类不能直接访问内部类的成员 // InnerClass.this.innerPublicStr; //! Won't compile. System.out.println("OuterClass show."); &#125; public void accessInnerClassMemberNeedInstantiation()&#123; // 需要实例化后，外部类才能访问内部类的所有成员变量 InnerClass innerClass = new InnerClass(); System.out.println("OuterClass::access**MemberNeedInstantiation: " + innerClass.innerPrivateStr); &#125; public class InnerClass&#123; public String innerPublicStr = "innerPublicStr"; private String innerPrivateStr = "innerPrivateStr"; public InnerClass()&#123; // Constructor. &#125; public void show()&#123; // 成员内部类能够直接访问外部类的所有成员变量和方法 // 使用 OuterClass.this.outerPrivateStr // 或者直接使用 outerPrivateStr System.out.println("InnerClass show: " + OuterClass.this.outerPrivateStr); OuterClass.this.show(); &#125; &#125;&#125;// 2. 测试public class TestInnerClass &#123; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); // 成员内部类的实例化，必须先实例化外部类 // 通过外部类的对象，new 一个成员内部类对象 OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.show(); outerClass.accessInnerClassMemberNeedInstantiation(); &#125;&#125;// 3. 结果InnerClass show: outerPrivateStrOuterClass show.OuterClass::accessInnerClassMemberNeedInstantiation: innerPrivateStr 局部内部类定义局部内部类指的是定义在一个方法或代码块中的类。因为在方法或代码块内部，所以和局部变量一样，不能有任何访问控制修饰符（public 也不行）来修饰局部内部类。 作用域局部内部类的作用域为方法或代码块内部，类似方法内的局部变量。 访问范围 局部内部类在方法或代码块外是不可见的。所以只能在当前方法或代码块中对局部内部类实例化对象，并可以访问局部内部类所有的成员和方法（private 类型也可以） 局部内部类可以访问外部类所有成员和方法 局部内部类访问方法或代码块内的成员变量时，只能访问 final 类型变量（语法检查，jdk 1.8 及以上不必指定 final） 在局部内部类内部，可以使用访问控制符修饰变量或方法，但是局部内部类整个作用域都在方法或代码块内，而这个范围是可以访问局部内部类所有成员和方法的，所以使用访问控制符没有任何意义。 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class OuterMethodLocalClass &#123; private String outPrivateStr = "outPrivateStr"; public void showMethodLocalInnerClass()&#123; String cannotShow = "cannotShow"; final String finalStringShow = "finalStringShow"; // 定义局部内部类 class MethodLocalInnerClass&#123; // 使用访问控制符没有任何意义 private String methodLocalInnerClassPrivateStr = "methodLocalInnerClassPrivateStr"; public MethodLocalInnerClass()&#123; // Constructor. &#125; public void show()&#123; // 不能访问非 final 变量 // cannotShow. //Won't compile. System.out.println("MethodLocalInnerClass: " + OuterMethodLocalClass.this.outPrivateStr); System.out.println("MethodLocalInnerClass: " + finalStringShow); &#125; &#125; // 实例化局部内部类，并能访问所有成员和方法 MethodLocalInnerClass methodLocalInnerClass = new MethodLocalInnerClass(); methodLocalInnerClass.show(); System.out.println("OuterMethodLocalClass::show**InnerClass: " + methodLocalInnerClass.methodLocalInnerClassPrivateStr); &#125; &#123; // 代码块中，局部内部类 class CodeBlockInnerClass&#123; // &#125; &#125;&#125;// 2. Testpublic class TestMethodLocalInnerClass &#123; public static void main(String[] args) &#123; OuterMethodLocalClass outerMethodLocalClass = new OuterMethodLocalClass(); outerMethodLocalClass.showMethodLocalInnerClass(); &#125;&#125;// 3. 结果MethodLocalInnerClass: outPrivateStrMethodLocalInnerClass: finalStringShowOuterMethodLocalClass::show**InnerClass: methodLocalInnerClassPrivateStr 匿名内部类定义没有类名的，特殊的局部内部类，隐式的继承一个父类或者是实现某个接口。所谓匿名内部类就是在 new 一个对象时，改变类的方法。Java 抽象类和接口（特殊的抽象类）是不能实例化的，但是抽象类或接口对象是可以指向实现类对象实例，最常见的方式就是使用匿名内部类充当这个实现类。 作用域匿名内部类的作用域，它是一次性使用，用完即走。 访问范围因匿名内部类为特殊的局部内部类，所以局部内部类的所有限制都对其生效。 特点 注意事项：匿名内部类不能有构造方法 实例化对象的格式 123new 类名或接口名()&#123; 重写方法;&#125;； //注意分号 匿名内部类，new 出来一个对象，该对象可以直接调用匿名内部类的方法。 作用 重写或实现方法当仅仅需要重写类方法，或者实现抽象类/接口的方法时，使用匿名内部类使代码变得很简洁。 重新定义新方法，调用外部类的 protected 方法 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class OuterAnonymousClass &#123; public void show(Showable showable)&#123; showable.show(); &#125; protected void protectedMethod()&#123; System.out.println("OuterAnonymousClass::protectedMethod"); //mRunnable.run(); &#125; // 使用匿名内部类，作为接口或者抽象类的实现类 // new 一个匿名内部类的标准格式 private Runnable mRunnable = new Runnable() &#123; // 匿名内部类中的成员变量毫无用处 private String anonymousInnerClassPrivateStr = "anonymousInnerClassPrivateStr"; @Override public void run() &#123; // 可以访问外部类所有成员和方法 System.out.println("OuterAnonymousClass::AnonymousInnerClass " + OuterAnonymousClass.this.OuterPrivateStr); &#125; &#125;;&#125;// 2. Testpublic class TestAnonymousClass &#123; public static void main(String[] args) &#123; // Function 1: 匿名内部类 // 1. new 一个 OuterAnonymousClass 实例，调用 show 方法 // 2. new 一个 Showable 实例，并实现该接口的 show 方法 new OuterAnonymousClass().show(new Showable() &#123; @Override public void show() &#123; System.out.println("TestAnonymousClass::OuterAnonymousClass ::Showable::show"); &#125; &#125;); // Function 2: 匿名内部类调用 protected 方法 new OuterAnonymousClass()&#123; // 重新定义新方法，调用类的 protected 方法 public void callParentProtectedMethod()&#123; super.protectedMethod(); &#125; // 定义的新方法，只能这个匿名类实例调用 &#125;.callParentProtectedMethod(); &#125;&#125;// 3. 结果TestAnonymousClass::OuterAnonymousClass::Showable::showOuterAnonymousClass::protectedMethod 静态内部类定义必须以 static 关键字标注类名，只能修饰成员内部类。 作用域静态内部类作用域为全局，并不依赖外部类实例，可以直接访问和使用。 特点 嵌套类静态内部类在 oracle 中被定义为 static nested classes，即嵌套类；而其他为内部类 inner classes，是平行类。 创建对象创建嵌套类对象，并不需要外部类实例化对象，静态类直接使用可以将其看成静态成员。 访问范围 只能访问外部类中的静态的成员变量或者是静态的方法 外部类访问静态内部类成员变量不受限制 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class OuterStaticNestedClass &#123; public String outPublicStr = "outPublicStr"; private static String outPrivateStaticStr = "outPrivateStaticStr"; public static class StaticNestedClass&#123; private String staticNestedClassPrivateStr = "staticNestedClassPrivateStr"; public String staticNestedClassPublicStr = "staticNestedClassPublicStr"; public static String staticNestedClassPublicStaticStr = "staticNestedClassPublicStaticStr"; public StaticNestedClass()&#123; //Constructor. &#125; public void showNormalMethod()&#123; // outPublicStr //!Won't compile. System.out.println("*::StaticNestedClass::showNormalMethod " + outPrivateStaticStr); &#125; public static void showStaticMethod()&#123; System.out.println("*::StaticNestedClass::showStaticMethod " + outPrivateStaticStr); System.out.println("*::StaticNestedClass::showStaticMethod " + staticNestedClassPublicStaticStr); &#125; &#125; public void showStaticNestedClassAccessControl()&#123; StaticNestedClass staticNestedClass = new StaticNestedClass(); System.out.println("*::showStatic*AccessControl::StaticNestedClass " + staticNestedClass.staticNestedClassPrivateStr); System.out.println("*::showStatic*AccessControl::StaticNestedClass " + staticNestedClass.staticNestedClassPublicStr); System.out.println("*::showStatic*AccessControl::StaticNestedClass " + StaticNestedClass.staticNestedClassPublicStaticStr); &#125;&#125;// 2. Testpublic class TestStaticNestedClass &#123; public static void main(String[] args) &#123; // 1. StaticNestedClass: object. OuterStaticNestedClass.StaticNestedClass staticInnerClass = new OuterStaticNestedClass.StaticNestedClass(); staticInnerClass.showNormalMethod(); // 2. StaticNestedClass: static method. OuterStaticNestedClass.StaticNestedClass.showStaticMethod(); // 3. OuterStaticNestedClass: object. OuterStaticNestedClass outerStaticNestedClass = new OuterStaticNestedClass(); outerStaticNestedClass.showStaticNestedClassAccessControl(); &#125;&#125;// 3.结果 *::StaticNestedClass::showNormalMethod outPrivateStaticStr*::StaticNestedClass::showStaticMethod outPrivateStaticStr*::StaticNestedClass::showStaticMethod staticNestedClassPublicStaticStr*::showStatic*AccessControl::StaticNestedClass staticNestedClassPrivateStr*::showStatic*AccessControl::StaticNestedClass staticNestedClassPublicStr*::showStatic*AccessControl::StaticNestedClass staticNested*PublicStaticStr 内部类持有外部类的引用反编译内部类 成员内部类 12345678910111213public class OuterClass$InnerClass&#123; ... // 持有外部类引用 public OuterClass$InnerClass(OuterClass this$0) &#123;&#125; public void show() &#123; System.out.println("InnerClass show: " + OuterClass.access$100(this.this$0)); OuterClass.access$200(this.this$0); &#125;&#125; 局部内部类 1234567891011121314class OuterMethodLocalClass$1MethodLocalInnerClass&#123; ... // 持有外部类引用 public OuterMethodLocalClass$1MethodLocalInnerClass( OuterMethodLocalClass this$0) &#123;&#125; public void show() &#123; System.out.println("MethodLocalInnerClass: " + OuterMethodLocalClass.access$000(this.this$0)); System.out.println("MethodLocalInnerClass: finalStringShow"); &#125;&#125; 匿名内部类 12345678910111213class OuterAnonymousClass$1 implements Runnable&#123; ... // 持有外部类引用 OuterAnonymousClass$1(OuterAnonymousClass this$0) &#123;&#125; public void run() &#123; System.out.println("OuterAnonymousClass::AnonymousInnerClass " + OuterAnonymousClass.access$000(this.this$0)); &#125;&#125; 静态内部类 1234567891011121314151617181920212223public class OuterStaticNestedClass$StaticNestedClass&#123; private String staticNestedClassPrivateStr = "staticNestedClassPrivateStr"; public String staticNestedClassPublicStr = "staticNestedClassPublicStr"; public static String staticNestedClassPublicStaticStr = "staticNestedClassPublicStaticStr"; public void showNormalMethod() &#123; System.out.println("OuterStaticNestedClass::StaticNestedClass ::showNormalMethod " + OuterStaticNestedClass.access$000()); &#125; public static void showStaticMethod() &#123; System.out.println("OuterStaticNestedClass::StaticNestedClass ::showStaticMethod " + OuterStaticNestedClass.access$000()); System.out.println("OuterStaticNestedClass::StaticNestedClass ::showStaticMethod " + staticNestedClassPublicStaticStr); &#125;&#125; 小结通过反编译内部类对应的 class 文件，可以看出内部类在构造方法中，传入了外部类的引用 this$0，内部类在访问外部类的成员或方法时，都需要传递该参数 this.this$0，只有静态内部类例外。这也可看出为什么静态内部类在实例化时不需要外部类实例化，而其他内部类在实例化时必须先实例化外部类了。换句话说：静态内部类不持有外部类对象的引用，而其他内部类都会持有。 内部类虽然和外部类写在同一个文件中，但是编译完成后会生成各自的 class 文件，编译过程中： 编译器自动为非静态内部类添加一个成员变量，这个成员变量的类型和外部类的类型相同，这个成员变量就是指向外部类对象的引用 编译器自动为非静态内部类的构造方法添加一个参数，参数的类型是外部类的类型，这个参数为内部类中添加的成员变量赋值 在调用非静态内部类的构造函数初始化内部类对象时，会默认传入外部类的引用 总结 作用域四种内部类作用域不同，根据作用域范围大小：静态内部类 &gt; 成员内部类 &gt; 局部内部类 &gt; 匿名内部类。通常我们可以根据需求（作用域）来选择使用哪种内部类。 访问范围在外部类整个类内部这个范围内，是不受访问控制符限制的，即 private 变量外部类和内部类是可以相互直接访问到的。所以内部类中通常会省略访问控制符。 生成的 class 文件内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两个类。每个类编译后都会生成一个 .class 文件，内部类生成的对应文件格式为：外部类$内部类.class，例如：OuterClass$Inner.class。 static 关键字static 关键字只能出现在静态内部类，不能出现在其他内部类中，除非是常量 static final。非静态内部类需要引用外部类的对象，如果有 static 成员，意味着外部类不需要创建实例对象，所以这是不允许的。 引用外部类的成员格式：OuterClass.this.***，*** 表示成员变量，或者直接使用 ***。 内部类的作用 内部类能很好的聚合代码 内部类可以很好的实现隐藏，通过访问控制符控制是否能被外部类访问 内部类可以隐藏接口的实现细节，而只需对外提供这个接口就行 实现多重继承，使用多个内部类分别继承，达到多重继承的目的 静态内部类的设计意图首先它是内部类，所以拥有内部类的一些便捷性，外部类可以访问静态内部类的所有成员变量和方法。但是因为静态属性，静态内部类不持有外部类引用，和外部类平级。由静态内部类的角度看外部类，可以认为是独立的两个类。静态内部类适合于当做内部类使用但是又不依赖外部类。 闭包和局部内部类闭包：是指可以包含自由（未绑定到特定对象）变量的代码块；这些自由变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。闭包是动态语言中的概念，并不适合 Java 这种静态语言。闭包允许将一些行为封装，将它像一个对象一样传来递去，而且它依然能够访问到原来第一次声明时的上下文。闭包允许我们创建函数指针，并把它们作为参数传递（在 JAVA 中，闭包是通过“接口+内部类”实现）。参考上面局部内部类中的示例： 1234567891011121314151617// OuterMethodLocalClass.javapublic void showMethodLocalInnerClass()&#123; String cannotShow = "cannotShow"; final String finalStringShow = "finalStringShow"; // 定义局部内部类 class MethodLocalInnerClass&#123; ... public void show()&#123; // 不能访问非 final 变量 // cannotShow. //Won't compile. ... System.out.println("MethodLocalInnerClass: " + finalStringShow); &#125; &#125; ...&#125; 其中：内部类 MethodLocalInnerClass 使用了局部变量 finalStringShow，这个就是闭包的例子。同时根据注释也可以看出，这个局部变量必须是 final 的，否则会编译不过（Java 8 支持这个语法糖可以编过，8 以下都无法编译）。也就是说，Java 中实现闭包的概念需要使用 final 来修饰自由变量。 参考文档 Nested Classes java内部类及四种内部类的实现方式 Java内部类详解 深入理解Java中为什么内部类可以访问外部类的成员 内部类的作用 为什么Java内部类要设计成静态和非静态两种 为什么说Java匿名内部类是残缺的闭包 Java和JavaScript的闭包原理区别？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 访问控制符]]></title>
    <url>%2F2018%2F02%2F06%2F0047-java-access-control%2F</url>
    <content type="text"><![CDATA[访问控制符指定了类之间的访问范围。 分类 public表示对外公开，所有类都可以访问。 default没有修饰符，表示同一个包内公开，也可以理解为包内私有。即同一个包内的类可以访问。 protected不管是包内还是包外的子类，以及同一个包内的类公开。即同一个包内和所有子类能访问。 private只有当前类内部可以访问。 访问范围 Modifier Class Package Subclass World public Y Y Y Y protected Y Y Y N no modifier Y Y N N private Y N N N 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 1. BaseBeanpackage com.***.inner;public class BaseBean &#123; private class InnerClass&#123; private String innerPrivateStr; String innerDefaultStr; protected String innerProtectedStr; public String innerPublicStr; public InnerClass()&#123; innerPrivateStr = "innerPrivateStr"; innerDefaultStr = "innerDefaultStr"; innerProtectedStr = "innerProtectedStr"; innerPublicStr = "innerPublicStr"; &#125; &#125; private String privateStr; String defaultStr; protected String protectedStr; public String publicStr; public BaseBean()&#123; privateStr = "privateStr"; defaultStr = "defaultStr"; protectedStr = "protectedStr"; publicStr = "publicStr"; &#125; public void show()&#123; InnerClass innerClass = new InnerClass(); System.out.println("BaseBean:InnerClass: " + innerClass.innerPrivateStr); System.out.println("BaseBean:InnerClass: " + innerClass.innerDefaultStr); System.out.println("BaseBean:InnerClass: " + innerClass.innerProtectedStr); System.out.println("BaseBean:InnerClass: " + innerClass.innerPublicStr); System.out.println("BaseBean: " + privateStr); System.out.println("BaseBean: " + defaultStr); System.out.println("BaseBean: " + protectedStr); System.out.println("BaseBean: " + publicStr); &#125;&#125;// 2. SubBean in the same package.package com.***.inner;public class SubBean extends BaseBean &#123; public void show()&#123; System.out.println("SubBean: " + defaultStr); System.out.println("SubBean: " + protectedStr); System.out.println("SubBean: " + publicStr); &#125;&#125;// 3. SubBean in the other package.package com.***.outer;public class OuterPackageSubBean extends BaseBean&#123; public void show()&#123; System.out.println("OuterPackageSubBean: " + protectedStr); System.out.println("OuterPackageSubBean: " + publicStr); &#125;&#125;// 4. Test. package com.***.test;public class TestAccessControl &#123; BaseBean baseBean; SubBean subBean; OuterPackageSubBean outerPackageSubBean; public TestAccessControl()&#123; baseBean = new BaseBean(); subBean = new SubBean(); outerPackageSubBean = new OuterPackageSubBean(); &#125; public void show()&#123; System.out.println("********The Same Class.########"); baseBean.show(); System.out.println("********The Sub Class in the same package.########"); subBean.show(); System.out.println("********The Sub Class in other packages.########"); outerPackageSubBean.show(); System.out.println("********The World.########"); System.out.println("TestAccessControl: baseBean " + baseBean.publicStr); System.out.println("TestAccessControl: subBean " + subBean.publicStr); System.out.println("TestAccessControl: outerPackageSubBean " + outerPackageSubBean.publicStr); &#125; public static void main(String[] args) &#123; TestAccessControl testAccessControl = new TestAccessControl(); testAccessControl.show(); &#125;&#125; 特点 方法内部的局部变量是不存在访问控制符的概念的，不能使用访问控制符修饰 在外部类整个类内部这个范围内，是不受访问控制符限制的，即 private 变量外部类和内部类是可以相互直接访问到的。所以内部类中通常会省略访问控制符。 接口会默认将所有成员设置为 public 参考文档 Controlling Access to Members of a Class]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML - 类图]]></title>
    <url>%2F2018%2F02%2F03%2F0046-uml-java%2F</url>
    <content type="text"><![CDATA[UML 类图有如下关系：继承（泛化）、实现、依赖、关联、聚合、组合。 关联 Association定义表示一个类中拥有另外一个类的实例，可以用直线，单箭头，双向箭头表示。 多重度多重度有：1, 1..*, 0..*, 0..1，对应表示一个类的实例能够与另一个类的多少个实例相关联。 0..1表示拥有 0 或者 1 个实例。 0..* 或者 *表示没有实例个数限制：0 个或多个。 1表示仅仅拥有 1 个实例。 1..*表示至少拥有 1 个实例。 n..m表示拥有 n 到 m 个实例。 类图 Customer 拥有多个 Car 的实例，类图关系通常使用单箭头表示。 Java 示例1234567891011121314151617181920212223242526272829303132public class Car &#123; private String brand; public Car(String brands)&#123; this.brand = brands; &#125; public Car() &#123; &#125; public String getBrand() &#123; return brand; &#125; public void setBrand(String brand) &#123; this.brand = brand; &#125;&#125;public class Customer &#123; private Car[] vehicles; ArrayList&lt;Car&gt; carList = new ArrayList&lt;Car&gt;(); public Customer()&#123; vehicles = new Car[2]; vehicles[0] = new Car("Audi"); vehicles[1] = new Car("Mercedes"); carList.add(new Car("BMW")); carList.add(new Car("Chevy")); &#125;&#125; 聚合 Aggregation其中菱形表示整体对象，箭头表示部分对象。 定义比关联的关系更进一步，通常聚合有包含（has-a）的意思，表示整体对象包含部分对象，而关联中的两个类是平级关系。整体对象不存在时，部分对象可以独立存在。使用空心菱形和箭头表示。 类图结构 Car 包含一个 Engine，但是 Engine 可以独立存在。 Java 示例1234567891011public class Engine&#123;&#125;public class Car&#123; private Engine engine; public void setEngine(Engine engine)&#123; this.engine = engine; &#125;&#125; 组合 Composition其中菱形表示整体对象，箭头表示部分对象。 定义组合可以理解为特殊的聚合，整体对象和部分对象关系非常密切不能缺失，通常是强烈包含（contains-a）的意思。整体对象与部分对象具有同一生命周期，整体对象控制着部分对象的创建和销毁。当整体对象不存在时，部分对象也不存在。使用实心菱形和箭头表示。 类图结构 Head 是 Bird 身体的一部分，不能独立存在。Head 实例是在 Bird 中创建的，由 Bird 控制它的生命周期。 Java 示例12345678910public class Head &#123;&#125;public class Bird &#123; private Head head; public Bird()&#123; head = new Head(); &#125;&#125; 继承（泛化） Generalization定义表示类的继承，子类和父类是 is-a 关系。使用空心三角实直线表示。 类图结构 Tiger 是 Animal 的子类，都有吃的动作。 Java 示例12345678910public class Animal&#123; public void eat()&#123; &#125;&#125;public class Tiger extends Animal&#123; @Override public void eat()&#123; &#125;&#125; 实现 Realization定义表示接口的实现，使用空心三角虚直线表示。 类图结构 ArrayList 实现了 List，完善所有的方法。 Java 示例12345678public interface List&#123; int size();&#125;public class ArrayList implements List&#123; int size()&#123; &#125;&#125; 依赖 Dependency定义主要体现某个类的方法使用了另外一个类的对象，两个类之间不存在拥有，包含等关联关系。使用虚线箭头表示。 类图结构 Person 在计算时使用了 Computer 去计算。 Java 示例12345678910public class Computer&#123; public void calculator()&#123; &#125;&#125;public class Person&#123; public void calculator(Computer computer)&#123; computer.calculator(); &#125;&#125; 小结各种关系的强弱顺序：泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖。 关联的两个对象之间一般是平等的 聚合和组合都是关联关系，但是强弱有区别。聚合关系是 has-a 关系，组合关系是 contains-a 关系 网上有一个比较全的例子，体现类图的所有关系： 工具本文画类图的工具为：StarUML 。工具箱中的功能基本满足常见类图需求，常用使用技巧： 接口实现使用 Composite Structure --&gt; Realization 来表示，默认的 Interface Realization 是一条直线。 注释换行使用 shift + Enter 实现换行。 内部类在右边的 Model Explorer 中，直接将类 Builder 拖入类 Product，就可以表示内部类。将 Builder 拖入类图中后，会多一个 from Product 的标识。 参考文档 UML2 Class Diagram in Java java_UML：类关系的联系与区别 UML类图与类的关系详解 uml-class-diagram-tutorial]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ClassDiagram</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式--创建型：建造者模式]]></title>
    <url>%2F2018%2F01%2F22%2F0044-design-patterns-builder%2F</url>
    <content type="text"><![CDATA[建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 通俗点讲：建造者模式类似同一条生产线，生产过程可以一样，但是放入的材料不一样生产出来的产品就不一样，比如放入纸就生产出纸碗，放入铁就生产出铁腕。又如个人电脑组装，组装步骤和顺序差不多，但是使用的显示器，显卡，内存，硬盘，操作系统都可以不一样，虽然最终都是组装出来电脑，但是配置完全不一样。 标准 Builder 模式类图结构 结构解析 Director指挥者，使用 Builder 接口构建一个对象。Director 隔离了客户和产品的组装过程，客户并不需要关心产品的组装。 Builder为创建一个 Product 对象的各个部件指定的抽象接口。 ConcreteBuilder具体的构建者，实现 Builder 接口，构建和装配各个部件或配置，生成最终的产品。 Product具体产品。构造方法，属性设置都被设置为 default ，客户无法实例化或设置属性，只能通过 Builder 模式来构造。 Builder 模式就是设计一个流程，指定哪些步骤必须执行，抽象到接口中去，子类必须实现这些接口。Director 组装产品实现统一的组装过程；不同的 ConcreteBuilder 对应产品不同的表现形式，每个 ConcreteBuilder 会生成具体的产品。也就是说客户并不需要关心产品的组装过程和构造，只需要通过 ConcreteBuilder 获取最终的产品就行。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 1. Product.public class VehicleProduct &#123; // 隐藏属性及构造方法 private String type; private String engine; private String wheels; private String doors; VehicleProduct(String type)&#123; this.type = type; &#125; // 隐藏属性设置 void setEngine(String engine)&#123; this.engine = engine; &#125; void setWheels(String wheels) &#123; this.wheels = wheels; &#125; void setDoors(String doors) &#123; this.doors = doors; &#125; public void show()&#123; System.out.println(type + ".engine = " + engine); System.out.println(type + ".wheels = " + wheels); System.out.println(type + ".doors = " + doors); &#125;&#125;// 2.Builderpublic abstract class VehicleBuilder &#123; public abstract void buildEngine(); public abstract void buildWheels(); public abstract void buildDoors(); public abstract VehicleProduct getProduct();&#125;// 3.Director.public class ShopDirector &#123; private VehicleBuilder mBuilder; public ShopDirector(VehicleBuilder builder)&#123; mBuilder = builder; &#125; public void construct()&#123; mBuilder.buildEngine(); mBuilder.buildWheels(); mBuilder.buildDoors(); &#125;&#125;// 4.ConcreteBuilderpublic class CarBuilder extends VehicleBuilder&#123; private VehicleProduct vehicle = new VehicleProduct("car"); @Override public void buildEngine() &#123; vehicle.setEngine("oil"); &#125; @Override public void buildWheels() &#123; vehicle.setWheels("four"); &#125; @Override public void buildDoors() &#123; vehicle.setDoors("four"); &#125; @Override public VehicleProduct getProduct() &#123; return vehicle; &#125;&#125;// 5.ConcreteBuilderpublic class MotorCycleBuilder extends VehicleBuilder&#123; private VehicleProduct vehicle = new VehicleProduct("motor"); @Override public void buildEngine() &#123; vehicle.setEngine("electric"); &#125; @Override public void buildWheels() &#123; vehicle.setWheels("two"); &#125; @Override public void buildDoors() &#123; vehicle.setDoors("no"); &#125; @Override public VehicleProduct getProduct() &#123; return vehicle; &#125;&#125;// 6.Testpublic class TestStandardBuilder &#123; public static void main(String[] args) &#123; CarBuilder carBuilder = new CarBuilder(); ShopDirector carDirector = new ShopDirector(carBuilder); carDirector.construct(); VehicleProduct car = carBuilder.getProduct(); car.show(); MotorCycleBuilder motorCycleBuilder = new MotorCycleBuilder(); ShopDirector motorDirector = new ShopDirector(motorCycleBuilder); motorDirector.construct(); VehicleProduct motor = motorCycleBuilder.getProduct(); motor.show(); &#125;&#125;// 7. resultcar.engine = oilcar.wheels = fourcar.doors = fourmotor.engine = electricmotor.wheels = twomotor.doors = no 小结创建一个复杂对象，这些对象的内部构建顺序通常是固定的，但是对象的内部构造通常面临复杂的变化。建造者模式的好处就是使得建造代码与表示代码分离，建造者隐藏了产品的建造过程，如果需要改变产品的内部表示，重新定义一个具体的建造者就可以了。标准 Builder 模式，当需要构建一个不同属性的产品时，只需要继承 Builder 重新实现即可。比如需要新增一个小型摩托车产品，实现 ScooterBuilder 来创建它。标准模式的整个架构非常方便扩展，但是会增加很多类。 常用简化 Builder 模式标准模式中扩展时会增加很多类，通常我们都会简化这个模式，只需要两个类就可以实现。Director 和抽象 Builder 两个角色通常被省略，而具体类 Builder 代表了指挥者和建造者双重角色，同时被设计为链式调用，即每个方法都返回 this。比如：new Product.Builder().setA().setB().build() 类图结构 结构解析 Product具体产品。构造方法和属性设置被设置为 default，只能通过 Builder 来构造。 BuilderProduct 的内部类，用来构造 Product， 构造前设置各种属性。 Product 的构造和属性设置都放到 Builder 中，通过 Builder.build 构造出需要的产品。 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1.Productpublic class Product &#123; // 隐藏属性以及构造方法 private String name; private int num; Product(String name, int num)&#123; this.name = name; this.num = num; &#125; public void show()&#123; System.out.println("name = " + name); System.out.println("num = " + num); &#125; public static final class Builder&#123; private String name; private int num; public Builder setName(String name) &#123; this.name = name; return this; &#125; public Builder setNum(int num) &#123; this.num = num; return this; &#125; // Builder 中构建产品，设置属性 public Product build()&#123; return new Product(name, num); &#125; &#125;&#125;// 2.Testpublic class TestSimpleBuilder &#123; public static void main(String[] args) &#123; Product product = new Product.Builder() .setName("Bike") .setNum(1) .build(); product.show(); &#125;&#125;// 3.resultname = Bikenum = 1 小结简化型的 Builder 模式中：Builder 类非常关键，封装了产品的构建过程，产品不同的表现形式也是通过 Builder.set 来改变的。 总结不管是标准型还是简化型，复杂对象的构建以及属性的设置都被隐藏了，使得复杂对象只能通过 Builder 模式来创建。创建型设计模式的统一特点：对象一旦被创建，所有的行为或表示就固定下来了，所有的变化都体现在创建的过程中。 参考文档 大话设计模式 Android 源码设计模式解析与实战 Builder wiki 建造者模式]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>DesignPatterns</tag>
        <tag>UML</tag>
        <tag>Creational</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Ashmem 机制]]></title>
    <url>%2F2018%2F01%2F17%2F0043-android-ashmem%2F</url>
    <content type="text"><![CDATA[Ashmem: Anonymous Shared Memory 是 Android 提供的一种共享内存的机制，它基于 mmap 系统调用，不同进程可以将同一段物理内存映射到各自的虚拟地址控制实现共享，因此进程间不需要再拷贝数据。 特点Android 系统提供了独特的匿名共享内存子系统 Ashmem，它以驱动程序的形式实现在内核空间中，有两个典型特点： 能够辅助内存管理系统来有效地管理不再使用的内存块 通过 Binder 进程间通信机制来实现进程间的内存共享 Linux 共享内存通信效率非常高，进程间不需要传递数据，便可以直接访问，缺点也很明显，Linux 共享内存没有提供同步的机制，在使用时要借助其他的手段来处理进程间同步。所以在 Android 系统中实现的匿名共享内存 Ashmem 驱动中添加了互斥锁，另外通过传递文件描述符来实现共享内存的传递。 源码速查表12345678910111213141516171819202122232425Framework: frameworks/base/core/java/android/os/MemoryFile.java frameworks/base/core/jni/android_os_MemoryFile.cppNative: frameworks/native/include/binder/IMemory.h frameworks/native/libs/binder/IMemory.cpp frameworks/native/include/binder/MemoryHeapBase.h frameworks/native/libs/binder/MemoryHeapBase.cpp frameworks/native/include/binder/MemoryBase.h frameworks/native/libs/binder/MemoryBase.cpp frameworks/native/include/binder/MemoryDealer.h frameworks/native/libs/binder/MemoryDealer.cppSystem: system/core/libcutils/ashmem-host.c 用户空间 API 仿真 system/core/libcutils/ashmem-dev.c 真实实现 system/core/include/utils/ashmem.h system/core/include/cutils/ashmem.hDriver: kernel/msm-3.18/drivers/staging/android/ashmem.c kernel/msm-3.18/drivers/staging/android/ashmem.h kernel/msm-3.18/include/uapi/linux/ashmem.h kernel/msm-3.18/include/linux/ashmem.h System 层函数列表Ashmem 匿名共享内存，全都是通过 System 层和 Driver 层交互的。函数列表： 1234567891011// ashmem.h// 根据名称和大小，创建 ashmem 区域，返回文件描述符int ashmem_create_region(const char *name, size_t size);// 设置 ashmem 访问保护位int ashmem_set_prot_region(int fd, int prot);// ashmem 锁定int ashmem_pin_region(int fd, size_t offset, size_t len);// ashmem 解锁int ashmem_unpin_region(int fd, size_t offset, size_t len);// ashmem 区域的大小int ashmem_get_size_region(int fd); 使用到的宏函数列表中值使用到了这些 ioctl 命令宏： 1234567#define __ASHMEMIOC 0x77#define ASHMEM_SET_NAME _IOW(__ASHMEMIOC, 1, char[ASHMEM_NAME_LEN])#define ASHMEM_SET_SIZE _IOW(__ASHMEMIOC, 3, size_t)#define ASHMEM_GET_SIZE _IO(__ASHMEMIOC, 4)#define ASHMEM_SET_PROT_MASK _IOW(__ASHMEMIOC, 5, unsigned long)#define ASHMEM_PIN _IO(__ASHMEMIOC, 7)#define ASHMEM_UNPIN _IO(__ASHMEMIOC, 8) 驱动文件路径1234./drivers/staging/android/ashmem.c./drivers/staging/android/ashmem.h./include/uapi/linux/ashmem.h./include/linux/ashmem.h Ashmem 结构体1234567891011121314151617/* * The lifecycle of this structure is from our parent file's open() until * its release(). It is also protected by 'ashmem_mutex' * Warning: Mappings do NOT pin this structure; It dies on close() */struct ashmem_area &#123; char name[ASHMEM_FULL_NAME_LEN]; /* optional name in /proc/pid/maps */ struct list_head unpinned_list; /* list of all ashmem areas */ struct file *file; /* the shmem-based backing file */ size_t size; /* size of the mapping, in bytes */ unsigned long vm_start; /* Start address of vm_area * which maps this ashmem */ unsigned long prot_mask; /* allowed prot bits, as vm_flags */&#125;;// 匿名共享设备名#define ASHMEM_DEVICE "/dev/ashmem" name表示这块共享内存的名字，这个名字会显示 /proc/&lt;pid&gt;/maps 文件中，&lt;pid&gt; 表示打开这个共享内存文件的进程 ID。 unpinned_list是一个列表头，它把这块共享内存中所有被解锁的内存块连接在一起，和内存块的锁定和解锁操作有关。 file表示这个共享内存在临时文件系统 tmpfs 中对应的文件，在内核决定要把这块共享内存对应的物理页面回收时，就会把它的内容交换到这个临时文件中去。 size表示这块共享内存的大小。 prot_mask表示这块共享内存的访问保护位。 关键函数123456789101112131415161718192021// 打开 Ashmem 设备static int ashmem_open(struct inode *inode, struct file *file) &#123;...&#125;;// 响应 ioctl 相关命令static long ashmem_ioctl(struct file *file, unsigned int cmd, unsigned long arg)&#123; ... switch (cmd) &#123; case ASHMEM_SET_NAME: ret = set_name(asma, (void __user *) arg); break; case ASHMEM_GET_NAME: ret = get_name(asma, (void __user *) arg); break; case ASHMEM_SET_SIZE: ...&#125;// mmap 系统调用，内存映射，起始地址保存到 vm_start 中static int ashmem_mmap(struct file *file, struct vm_area_struct *vma); 匿名共享内存文件进行内存映射操作，对匿名内存文件内容的读写操作就像访问内存变量一样，驱动不用参与到读写操作中。 pin/unpin 锁定和解锁内存区12345678910111213141516171819202122232425262728293031323334struct ashmem_pin &#123; __u32 offset; /* offset into region, in bytes, page-aligned */ __u32 len; /* length forward from offset, in bytes, page-aligned */&#125;;/** * struct ashmem_range - A range of unpinned/evictable pages * @lru: The entry in the LRU list * @unpinned: The entry in its area's unpinned list * @asma: The associated anonymous shared memory area. * @pgstart: The starting page (inclusive) * @pgend: The ending page (inclusive) * @purged: The purge status (ASHMEM_NOT or ASHMEM_WAS_PURGED) * * The lifecycle of this structure is from unpin to pin. * It is protected by 'ashmem_mutex' */struct ashmem_range &#123; struct list_head lru; struct list_head unpinned; struct ashmem_area *asma; size_t pgstart; size_t pgend; unsigned int purged;&#125;;static int ashmem_pin_unpin(struct ashmem_area *asma, unsigned long cmd, void __user *p);// pin the given ashmem region, returning whether it wasstatic int ashmem_pin(struct ashmem_area *asma, size_t pgstart, size_t pgend);// unpin the given range of pages. Returns zero on success.static int ashmem_unpin(struct ashmem_area *asma,size_t pgstart,size_t pgend); 匿名共享内存的锁定和解锁操作，表示哪些内存块是正在使用的，需要锁定（pin）；哪些内存是不需要使用了，解除锁定（unpin）。创建匿名共享内存时，默认所有的内存都是 pinned 状态的，用户先告诉 Ashmem 驱动程序要解锁某一块内存，内核可以将它对应的物理页面回收；因为 unpin 操作并不会改变已经 mmap 的地址空间，所以之后用户可以再告诉驱动程序要重新锁定某一块之前被解锁过的内块，从而修改这块内存的状态。也就是说，执行锁定前，目标对象必须是一块当前处于解锁状态的内存块。匿名共享内存 Ashmem 机制是建立在 Linux 内核实现的共享内存的基础上的。同时它又向 Linux 内存管理系统的内存回收算法注册接口，系统内存不足时，会回收 Ashmem 区域中状态是 unpin 的对象内存块，如果不希望对象被回收，可以通过 pin 来保护它。 Java 层接口及应用MemoryFile所有 Java 代码都是通过 MemoryFile 来使用匿名共享内存 Ashmem 的，它是唯一的入口。不过在 Andoid O 开始匿名共享内存推荐使用 SharedMemory。Api： Applications should generally prefer to use SharedMemory which offers more flexible access &amp; control over the shared memory region than MemoryFile does. 重要字段： 1234private FileDescriptor mFD; // ashmem file descriptor// mAddress存了驱动中 ashmem_open 返回虚拟地址空间的起始地址 private long mAddress; // address of ashmem memoryprivate int mLength; // total length of our ashmem region 调用流程App --&gt; (Framework) MemoryFile.java --&gt; (Native) android_os_MemoryFile.cpp --&gt; (System) ashmem-dev.c --&gt; (Driver)ashmem.c 序列图中可以看到，Java 接口文件直接通过 JNI 调用了系统 System 的函数，通过它来和驱动做数据交互。 如何使用思路：通过 Binder 机制，传递匿名共享机制文件描述符，通过该描述符实现进程间的数据共享。在 Linux 系统中，文件描述符其实就是一个整数。每一个进程在内核空间都有一个打开文件的数组，这个文件描述符的整数值就是用来索引这个数组的，而且这个文件描述符只是在本进程内有效，也就是说，在不同的进程中，相同的文件描述符的值，代表的可能是不同的打开文件。因此在进程间传输文件描述符时，并不是简要把一个文件描述符从一个进程传给另外一个进程，中间通过 Binder 机制做过转换，映射了相同的地址空间，使得它和源进程的文件描述符所对应的打开文件是一致的，这样才能保证共享。文件描述符进程间转换图： AIDL 文件通过 Binder 机制，传递匿名共享机制文件描述符。 123interface IAshmemFd &#123; ParcelFileDescriptor getParcelFileDescriptor();&#125; Server 服务端利用 Ashmem 机制，创建 MemoryFile 文件后，写入数据。注意：这里需要使用反射机制调用 getFileDescriptor 因为它是 @hide 的，也就是说，Android 系统并不推荐这种使用方式。 123456789101112131415161718192021222324private ParcelFileDescriptor getParcelFileDescriptor()&#123; Log.d(TAG, "getParcelFileDescriptor: "); ParcelFileDescriptor pfd = null; try &#123; // method 1: Ashmem: MemoryFile. MemoryFile file =new MemoryFile(ASHMEM_FILENAME,ASHMEM_LENGTH); file.getOutputStream().write(testData); Method method = MemoryFile.class .getDeclaredMethod("getFileDescriptor"); FileDescriptor des = (FileDescriptor) method.invoke(file); pfd = ParcelFileDescriptor.dup(des); &#125; catch (Exception e)&#123; Log.e(TAG, "getParcelFileDescriptor: ", e); &#125; return pfd;&#125;private IBinder mBinder = new IAshmemFd.Stub() &#123; @Override public ParcelFileDescriptor getParcelFileDescriptor() throws RemoteException &#123; return AshmemService.this.getParcelFileDescriptor(); &#125;&#125;; Client 客户端客户端通过 Binder 拿到 ParcelFileDescriptor 文件描述符后，读取 MemoryFile 文件的内容并打印。 1234567891011ParcelFileDescriptor pfd = mIAshmemFd.getParcelFileDescriptor();FileInputStream fileInputStream = new FileInputStream(pfd.getFileDescriptor());byte[] content = new byte[10];fileInputStream.read(content);StringBuilder builder = new StringBuilder();for (byte b : content)&#123; builder.append(b);&#125;String value = builder.toString();Log.d(TAG, "getData: value = " + value); 总结Android O 之后推荐使用 SharedMemory，之前的版本也几乎没有看到 MemoryFile 的应用。网上搜到的案例是 AIDL 传递文件描述符 ParcelFileDescriptor，而仅仅传递它其实并不需要使用 Ashmem，因为 ParcelFileDescriptor 中推荐直接使用 createPipe 创建管道。Server 服务端使用管道实现的示例： 123456789// method 2: PipeParcelFileDescriptor[] pfds = ParcelFileDescriptor.createPipe();// 第二个为写管道OutputStream outputStream = new ParcelFileDescriptor.AutoCloseOutputStream(pfds[1]);outputStream.write(testData);// 第一个为读管道pfd = pfds[0];// 将读管道文件描述符传递给客户端 Native 层接口及应用类图结构1234IMemory.h: IMemoryHeap, BnMemoryHeap, IMemory, BnMemoryIMemory.cpp: BpMemoryHeap, BpMemoryMemoryBase.h: MemoryBaseMemoryHeapBase.h: MemoryHeapBase 可以看出，Native 层的 Ashmem 本身就是基于 Binder 机制的。 MemoryHeapBase用于在进程间共享一个完整的匿名共享内存块。 MemoryBase用于在进程间共享一个匿名共享内存块中其中的一部分。 MemoryBase 接口是建立在 MemoryHeapBase 接口的基础上面的，它们都可以作为一个 Binder 对象来在进程间传输。 IMemoryHeap 定义的重要方法123456// 获得匿名共享内存块的文件描述符virtual int getHeapID() const = 0;// 获得匿名共享内存块的基地址virtual void* getBase() const = 0;// 获得匿名共享内存块的大小virtual size_t getSize() const = 0; MemoryHeapBase 服务端MemoryHeapBase 继承了 BnMemoryHeap，是 IMemoryHeap 的本地实现类，实现了具体的函数功能，用于服务端。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556MemoryHeapBase::MemoryHeapBase(size_t size, uint32_t flags, char const * name) : mFD(-1), mSize(0), mBase(MAP_FAILED), mFlags(flags), mDevice(0), mNeedUnmap(false), mOffset(0)&#123; const size_t pagesize = getpagesize(); size = ((size + pagesize-1) &amp; ~(pagesize-1)); // 1. 创建匿名共享内存区域 int fd = ashmem_create_region(name == NULL ? "MemoryHeapBase" : name, size); ALOGE_IF(fd&lt;0, "error creating ashmem region: %s", strerror(errno)); if (fd &gt;= 0) &#123; // 映射地址空间 if (mapfd(fd, size) == NO_ERROR) &#123; if (flags &amp; READ_ONLY) &#123; // 设置保护区 ashmem_set_prot_region(fd, PROT_READ); &#125; &#125; &#125;&#125;// 映射 mFD, mBase, mSizestatus_t MemoryHeapBase::mapfd(int fd, size_t size, uint32_t offset)&#123; if (size == 0) &#123; // try to figure out the size automatically struct stat sb; if (fstat(fd, &amp;sb) == 0) size = sb.st_size; // if it didn't work, let mmap() fail. &#125; if ((mFlags &amp; DONT_MAP_LOCALLY) == 0) &#123; void* base = (uint8_t*)mmap(0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, offset); ... mBase = base; mNeedUnmap = true; &#125; else &#123; mBase = 0; // not MAP_FAILED mNeedUnmap = false; &#125; mFD = fd; mSize = size; mOffset = offset; return NO_ERROR;&#125;int MemoryHeapBase::getHeapID() const &#123; return mFD;&#125;void* MemoryHeapBase::getBase() const &#123; return mBase;&#125;size_t MemoryHeapBase::getSize() const &#123; return mSize;&#125; mFD：匿名共享内存文件描述符 mBase：匿名共享内存起始地址 mSize：匿名共享内存的大小 HeapCache 缓存HeapCache 继承了 IBinder::DeathRecipient，维护生命周期。 123456789101112131415161718192021class HeapCache : public IBinder::DeathRecipient&#123;public: ... virtual void binderDied(const wp&lt;IBinder&gt;&amp; who); sp&lt;IMemoryHeap&gt; find_heap(const sp&lt;IBinder&gt;&amp; binder); sp&lt;IMemoryHeap&gt; get_heap(const sp&lt;IBinder&gt;&amp; binder); void free_heap(const sp&lt;IBinder&gt;&amp; binder); ...private: // For IMemory.cpp struct heap_info_t &#123; sp&lt;IMemoryHeap&gt; heap; int32_t count; &#125;; ... KeyedVector&lt; wp&lt;IBinder&gt;, heap_info_t &gt; mHeapCache;&#125;;static sp&lt;HeapCache&gt; gHeapCache = new HeapCache(); heap_info_t 结构体heap 保存了 BpMemoryHeap 对象；count 引用计数，表示被引用了多少次，只有在等于 1 时，才能被释放。 mHeapCache 缓存KeyedVector 容器类型，存储了以 IBinder 和 heap_info_t 的键值对。 find_heap 查找在 mHeapCache 中查找，如果找不到则添加到 mHeapCache 中。 get_heap 获取在 mHeapCache 中查找，如果找不到则直接将 IBinder 转换，并没有加入 mHeapCache 中。 gHeapCache 全局实例gHeapCache 全局实例，维护了本进程中所有的 BpMemoryHeap 引用对象。 BpMemoryHeap 客户端BpMemoryHeap 是 IMemoryHeap 的代理类，用于客户端。Binder 机制中客户端通过代理类访问服务端的具体实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778virtual int getHeapID() const;virtual void* getBase() const;virtual size_t getSize() const;// 匿名共享内存文件描述符 mutable volatile int32_t mHeapId;mutable void* mBase;mutable size_t mSize;int BpMemoryHeap::getHeapID() const &#123; assertMapped(); return mHeapId;&#125;void* BpMemoryHeap::getBase() const &#123; assertMapped(); return mBase;&#125;size_t BpMemoryHeap::getSize() const &#123; assertMapped(); return mSize;&#125;// 在获取匿名共享内存前，都会先确保映射成功void BpMemoryHeap::assertMapped() const&#123; if (mHeapId == -1) &#123; sp&lt;IBinder&gt; binder(IInterface::asBinder(const_cast&lt;BpMemoryHeap*&gt;(this))); sp&lt;BpMemoryHeap&gt; heap(static_cast&lt;BpMemoryHeap*&gt;(find_heap(binder).get())); heap-&gt;assertReallyMapped(); if (heap-&gt;mBase != MAP_FAILED) &#123; Mutex::Autolock _l(mLock); if (mHeapId == -1) &#123; mBase = heap-&gt;mBase; mSize = heap-&gt;mSize; mOffset = heap-&gt;mOffset; android_atomic_write( dup( heap-&gt;mHeapId ), &amp;mHeapId ); &#125; &#125; else &#123; // something went wrong free_heap(binder); &#125; &#125;&#125;void BpMemoryHeap::assertReallyMapped() const&#123; if (mHeapId == -1) &#123; ... // Binder 调用，从 MemoryHeapBase 中拿到匿名共享内存相关信息 Parcel data, reply; data.writeInterfaceToken(IMemoryHeap::getInterfaceDescriptor()); status_t err = remote()-&gt;transact(HEAP_ID, data, &amp;reply); int parcel_fd = reply.readFileDescriptor(); ssize_t size = reply.readInt32(); uint32_t flags = reply.readInt32(); uint32_t offset = reply.readInt32(); ... if (mHeapId == -1) &#123; int fd = dup( parcel_fd ); ... mRealHeap = true; // 将服务端的匿名共享内存映射到当前进程，并设置基地址 mBase = mmap(0, size, access, MAP_SHARED, fd, offset); if (mBase == MAP_FAILED) &#123; ALOGE("cannot map BpMemoryHeap (binder=%p), size=%zd, fd=%d (%s)", IInterface::asBinder(this).get(), size, fd, strerror(errno)); close(fd); &#125; else &#123; // 赋值匿名共享内存大小，文件描述符 mSize = size; mFlags = flags; mOffset = offset; android_atomic_write(fd, &amp;mHeapId); &#125; &#125; &#125;&#125; 在获取当前匿名共享内存信息时，都会先执行 assertMapped/assertReallyMapped 断言函数，确保获取到服务端的匿名共享内存信息后并映射到了当前进程。 IMemory 的定义IMemory 是用来管理进程间匿名共享内存块 IMemoryHeap 中的一部分，所以这个类中保存了 IMemoryHeap 代理实例，以及被管理的匿名共享内存这部分的基地址，大小，在整个 Ashmem 中的偏移量。 头文件定义 1234567891011121314class IMemory : public IInterface&#123;public: ... // 获取匿名共享内存客户端代理实例 BpMemoryHeap virtual sp&lt;IMemoryHeap&gt; getMemory(ssize_t* offset=0, size_t* size=0) const = 0; void* fastPointer(const sp&lt;IBinder&gt;&amp; heap, ssize_t offset) const; // 获取匿名共享内存的基地址 void* pointer() const; // 获取匿名共享内存的大小 size_t size() const; // 维护的这部分共享内存，在整个匿名共享内存中的偏移量 ssize_t offset() const;&#125;; 具体实现 123456789101112131415161718192021222324252627282930// 从缓存中快速获取被管理的 Ashmem 基地址：MemoryHeap的基地址 + 偏移量void* IMemory::fastPointer(const sp&lt;IBinder&gt;&amp; binder, ssize_t offset) const&#123; sp&lt;IMemoryHeap&gt; realHeap = BpMemoryHeap::get_heap(binder); void* const base = realHeap-&gt;base(); if (base == MAP_FAILED) return 0; return static_cast&lt;char*&gt;(base) + offset;&#125;// 从具体实现类中获取被管理的 Ashmem 基地址：MemoryHeap的基地址 + 偏移量void* IMemory::pointer() const &#123; ssize_t offset; sp&lt;IMemoryHeap&gt; heap = getMemory(&amp;offset); void* const base = heap!=0 ? heap-&gt;base() : MAP_FAILED; if (base == MAP_FAILED) return 0; return static_cast&lt;char*&gt;(base) + offset;&#125;// 被管理 Ashmem 的大小size_t IMemory::size() const &#123; size_t size; getMemory(NULL, &amp;size); return size;&#125;// 被管理 Ashmem 的偏移量ssize_t IMemory::offset() const &#123; ssize_t offset; getMemory(&amp;offset); return offset;&#125; MemoryBase 服务端MemoryBase 继承 BpMemory，是 IMemory 的本地实现类，用于服务端。 123456789101112MemoryBase::MemoryBase(const sp&lt;IMemoryHeap&gt;&amp; heap, ssize_t offset, size_t size) : mSize(size), mOffset(offset), mHeap(heap)&#123;&#125;// 更新偏移量，大小，并返回 mHeapsp&lt;IMemoryHeap&gt; MemoryBase::getMemory(ssize_t* offset, size_t* size) const&#123; if (offset) *offset = mOffset; if (size) *size = mSize; return mHeap;&#125; MemoryBase 类非常简单，构造函数中传入了匿名共享内存的具体实现 MemoryHeapBase 对象，以及被管理部分的偏移量和大小。getMemory 简单的返回了整个匿名共享内存对象及对应的偏移量和大小，所以可以理解 MemoryBase 是 MemoryHeapBase 的简单封装。 BpMemory 客户端123456789101112131415161718192021222324252627282930313233sp&lt;IMemoryHeap&gt; BpMemory::getMemory(ssize_t* offset, size_t* size) const&#123; if (mHeap == 0) &#123; Parcel data, reply; data.writeInterfaceToken(IMemory::getInterfaceDescriptor()); if (remote()-&gt;transact(GET_MEMORY, data, &amp;reply) == NO_ERROR) &#123; sp&lt;IBinder&gt; heap = reply.readStrongBinder(); ssize_t o = reply.readInt32(); size_t s = reply.readInt32(); if (heap != 0) &#123; mHeap = interface_cast&lt;IMemoryHeap&gt;(heap); if (mHeap != 0) &#123; size_t heapSize = mHeap-&gt;getSize(); if (s &lt;= heapSize &amp;&amp; o &gt;= 0 &amp;&amp; (static_cast&lt;size_t&gt;(o) &lt;= heapSize - s)) &#123; mOffset = o; mSize = s; &#125; else &#123; // Hm. android_errorWriteWithInfoLog(0x534e4554, "26877992", -1, NULL, 0); mOffset = 0; mSize = 0; &#125; &#125; &#125; &#125; &#125; if (offset) *offset = mOffset; if (size) *size = mSize; return (mSize &gt; 0) ? mHeap : 0;&#125; 通过 Binder 机制，从服务端读取偏移量，大小，并返回 BpMemory 代理实例（mHeap）。 Ashmem 总结 文件描述符在形式上是一个非负整数，实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 进程间共享原理Ashmem 进程间共享原理：两个在不同进程中的文件描述符对应同一个指向设备文件 /dev/ashmem 的文件结构体。Binder 机制在数据交互时大小不能超过 1M，可以通过传递匿名共享内存（Ashmem）的文件描述符或者 IBinder 对象（IMemoryHeap/IMemory），来实现大数据的共享。 优缺点匿名共享内存不会占用 Heap，不会导致 OOM，但是如果肆意使用，会导致系统资源不足性能下降。 应用场景在 camera.preview 预览，SurfaceFlinger 绘制等，可以看到匿名共享内存的应用。 参考文档 老罗Android系统匿名共享内存Ashmem 老罗Android系统匿名共享内存C++接口 Android匿名共享内存 Ashmem驱动 如何偷Android的内存]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>Ashmem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java HashMap 简介]]></title>
    <url>%2F2018%2F01%2F15%2F0042-java-hashmap%2F</url>
    <content type="text"><![CDATA[存储一个键值对（key-value），根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null ，允许多条记录的值为 null 。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以使用 ConcurrentHashMap 。 基本概念Hash：译作“散列”，“哈希”。将任意长度的数据映射为固定长度的数据，这个过程的返回值被叫做散列值、哈希值、哈希码，这个过程就叫哈希/散列。散列值的空间通常远远小于输入的空间，不同的输入可能会被散列成相同的输出，因此不能从散列值来唯一的确定输入值。一个使用场景就是哈希表，哈希表被广泛用于快速搜索数据。 哈希表哈希表是一种能实现关联数组的抽象数据结构，能把很多「键」映射到很多「值」上。哈希表使用哈希函数来计算索引，一个索引对应一个值。 槽 Slot哈希表中的一个位置称为一个桶。 装填/负载因子 load_factor装填因子 = 表中记录个数/散列表长度。 冲突/碰撞 Collision通常关键码的集合比哈希地址集合大得多，因而经过哈希函数变换后，可能将不同的关键码映射到同一个哈希地址上，这种现象称为冲突/碰撞。 哈希函数实现哈希过程的函数就是哈希函数，一种将任意长度的消息压缩到某一固定长度的消息摘要函数。 构造原则 定义域包含全部需要存储的关键字，值域依赖于散列表大小 尽可能等概率，均匀分布到整个地址空间，降低冲突发生几率 散列函数计算应尽量简单 常用方法 直接定址法：取关键字的线性函数值Hash(key)=a*key+b：不会冲突，但当关键字分布不连续时，空位很多。 除留余数法：最简单常用的方法散列表长度是 m，选取一个不大于 m 但最接近或等于 m 的质数 p：Hash(key)=key % p，可能会有冲突。 数字分析法假设关键字是以 r 为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。共 r 个数码（0~r-1），所选的位应是各种符号在该位上出现的频率大致相同。 平方取中法取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。 折叠法将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。 处理冲突的方法 开放定址法如果选择的一个其它位置仍有冲突，则再选下一个，直到找到没有冲突的位置。 链地址法/拉链法以每个哈希地址作为一个指针，指向一个链，即分配指针数组，将所有关键字为相同的记录存储在同一线性链表中。 HashMap 的实现原理利用 key 的 hashCode 重新 hash 计算出当前对象的元素在数组中的下标： 存储时如果出现 hash 值相同的 key，则覆盖原始值；如果 key 不同，则将当前的 key-value 放入链表中。 获取时直接找到 hash 值对应的下标，在进一步判断 key 是否相同，如果相同从链表中找到对应值。 存储结构HashMap 核心就是使用了数组+链表的存储方式，然后将冲突的 key 的对象放入链表中（也就是使用拉链法解决冲突），Java 1.8 中链表长度大于 8 时，链表转换为红黑树结构。 Node 本质是就是一个映射（键值对），源码定义： 1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;...&#125; public final K getKey() &#123;...&#125; public final V getValue() &#123;...&#125; public final String toString() &#123;...&#125; public final int hashCode() &#123;...&#125; public final V setValue(V newValue) &#123;...&#125; public final boolean equals(Object o) &#123;...&#125;&#125; 关键字段123456789101112131415161718192021// 默认容量大小为 16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16// 最大值 2 ^ 30static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 装载因子 0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;// 链表转换为红黑树的门限值static final int TREEIFY_THRESHOLD = 8;// static final int UNTREEIFY_THRESHOLD = 6;// static final int MIN_TREEIFY_CAPACITY = 64;// 存储 key-value 的表，是一个数组transient Node&lt;K,V&gt;[] table;// 当前 key-value 对的数量transient int size;// 门限值，超过后将调整容量int threshold;// 负载因子final float loadFactor; table 索引对应的键值对叫做“桶”（bucket），它存储了链表的第一个元素。key 的 hashcode() 方法用来找到对象所在的桶，如果两个 key 有相同的 hash 值，他们会被放在 table 数组的同一个桶里面，以链表的形式保存。 loadFactor负载因子 = 表中记录个数/散列表长度。默认的负载因子 0.75 是对空间和时间效率的一个平衡选择。如果内存空间很多而又对时间效率要求很高，可以降低负载因子的值；相反如果内存空间紧张而对时间效率要求不高，可以增加负载因子值，这个值可以大于 1 。 threshold门限值，HashMap 中 Node(键值对)个数超过门限值后，将重新调整容量。threshold = table.length * LoadFactor，也就是说在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。 HashMap 中数组 table.length 必须为 2 ^ n 次方。 哈希函数及索引1234567891011121314static final int hash(Object key) &#123; int h; // 1. h = key.hashCode() 获取 key 的 hashCode // 2. 确保 h 的高 16 位和低 16 位都能参与异或运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// jdk1.7 的源码，jdk1.8 没有这个方法 // 但是计算索引值（数组下标）时都是这个思路// 可以在 put, resize 中看到索引计算static int indexFor(int h, int length) &#123; // 3. 实现取模运算，实现均匀散列 return h &amp; (length - 1);&#125; 索引值计算如果 indexFor 返回值相同，表示出现冲突。前面提到 table.length 必须为 2 的 N 次方，换句话说 length - 1 的值换成二进制永远是全部为 1，正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。而哈希函数混合原始哈希码的高位和低位，以此来加大低位的随机性。而且混合后的低位掺杂了高位的部分特征，这样高位的信息也被变相保留下来，所以 indexFor 能实现均匀的散列值。根据数学规律，就是如果 length 是 2 的 N 次方，那么模运算和按位与运算是等价的，也就是 h%length &lt;=&gt; h&amp;(length-1)。 数组的扩容机制再次强调，数组的长度是 2 的幂。如果当前数量大于门限值（size &gt; threshold），或者说表中填满了 loadFactor （75%） 后，数组就需要自动扩容了（直接扩容到当前容量 2 倍大小）。当然 Java 里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657final Node&lt;K,V&gt;[] resize() &#123; // 旧表，旧容量，旧门限值 Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; // 新容量，新门限值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 已经超过最大容量，不再扩充。新来的数据加入链表中 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 扩容，2 的幂 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults // 第一次初始化 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) // 新建扩容后的数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 将旧的数据转移到扩容后数组中 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 只有一个节点 if (e.next == null) // 计算索引值 newTab[e.hash &amp; (newCap - 1)] = e; // 红黑树 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); // 普通链表 else &#123; // preserve order ... &#125; &#125; &#125; &#125; return newTab;&#125; 添加或修改键值对1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 第一次初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 如果该索引对应的桶为空，直接新建节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 找到了桶，则为修改键值对 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 如果是红黑树，插入新节点到红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 普通链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); // 如果长度超过门限 8，链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 修改键值对 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 表中键值对超过门限值，扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 删除键值对12345678910111213141516171819202122232425262728293031323334353637383940414243444546final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; // 确定键值对存在 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; // 红黑树 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); // 普通链表 else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; // 红黑树删除键值对 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); // 链表根节点 else if (node == p) tab[index] = node.next; // 普通链表其他节点 else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; 获取键值对12345678910111213141516171819202122final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 找到指定键值对 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 红黑树中查找并返回 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 普通链表查找 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 红黑树二叉查找树也称有序二叉树（ordered binary tree），或已排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值 任意节点的左、右子树也分别为二叉查找树 没有键值相等的节点（no duplicate nodes） 红黑树基本特点是一个二叉查找树，接近平衡。红黑树的 5 个性质： 每个结点要么是红的要么是黑的 根结点是黑的 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的 如果一个结点是红的，那么它的两个儿子都是黑的 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点 红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为 O(log n)。 HashMap 中的应用即使负载因子和哈希函数设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。于是在 JDK1.8 版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过 8 ）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高 HashMap 的性能，其中会用到红黑树的插入、删除、查找等算法。 并发在多线程使用场景中，应该尽量避免使用线程不安全的 HashMap，而使用线程安全的 ConcurrentHashMap。那么为什么说 HashMap 是线程不安全的，当重新调整 HashMap 大小的时候，确实存在条件竞争（race condition）。因为如果两个线程都同时试着调整大小时，Java 1.7 中会将存储在链表中的元素的次序会反过来，如果条件竞争发生了，那么就会出现死循环。在 Java 1.8 中并没有反序，但是在调整容量大小时，依次在末端添加新元素，可能会出现数据丢失的现象。 总结HashMap 使用了数组 + 链表的存储方式，存储的节点元素包含 key-value，每个数组元素中放的是链表的第一个对象，这个链表长度大于 8 时会转换为红黑树。 扩容是一个特别耗性能的操作，所以在使用 HashMap 时尽量估算 map 的大小，初始化的时候给一个合理的数值，避免频繁扩容 负载因子是可以修改的，也可以大于 1，但是建议不要轻易修改，除非情况非常特殊 HashMap 是线程不安全的，并发环境中使用 ConcurrentHashMap 参考文档 Java 8系列HashMap]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
        <tag>RedBlackTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Binder 机制]]></title>
    <url>%2F2017%2F12%2F21%2F0041-android-binder%2F</url>
    <content type="text"><![CDATA[Binder 是 Android 系统进程间通信（IPC）方式之一，它是基于开源的 OpenBinder 实现的。 基础Binder 架构简图 所谓 Binder 通信机制：进程 A 和进程 B 分别直接和 Binder Driver 交互，Driver 来负责数据转发，从而间接实现进程 A 和进程 B 之间的数据交互。Binder 架构中通信过程包含四个角色: Client, Server, ServiceManager, Driver。可以从图中看到 Client, Server, ServiceManager 与 Driver 之间都是实线，他们通过 ioctl 直接交互。而 Client, Server, ServiceManager 分属于三个不同的进程，三者交互都是虚线，它们之间是通过 Binder Driver 串起来实现通信的，也就是使用了 Binder 的通信机制。 ServiceManager中间人，对应一个 service_manager 开启的守护进程，维护所有服务的列表。 Server服务端进程通过 ServiceManager 注册服务。服务端进程将服务名和 IBinder 写入到 ServiceManager 守护进程维护的服务列表中，是一次进程间通信。 Client客户端进程通过 ServiceManager 查询服务，即 Client 进程和 ServiceManager 守护进程间的通信。查询服务拿到服务端 IBinder 后，实现 Client/Server 进程间通信。 Driver实现数据转发。上面三次进程间通信都是 Binder 通信机制实现的，也就是三个进程都直接和 Driver 交互，来实现数据转发。 Binder 详细架构图 ServiceManager具有双重属性，细分为 ServiceManager/service_manager。ServiceManager 在和 Client/Server 交互时作为服务端；在和 service_manager 交互时作为客户端，此时 service_manager 守护进程为服务端，维护着一个服务链表。 Server服务端通过 Java 或者 CPP 代码形式都可以注册。不管什么方式，都是通过的 Native 中 BBinder 向 service_manager 守护进程注册的，并写入守护进程维护的服务列表。 Client客户端也可以通过 Java 或者 CPP 代码形式查询服务，最终都是通过 Native 中 BpBinder 从 service_manager 守护进程查询，并返回 IBinder。 DriverServer, Client, ServiceManager 运行于用户空间，Driver 属于内核空间，他们都是通过 IBinder 来通信的。Driver 的作用就是用来转发数据：A：Client 持有 IBinder ，通过它来实现和 Driver 通信B：Server 本身就是 IBinder，直接和 Driver 通信C：service_manager 守护进程可以直接下发 ioctl 和 Driver 通信；这四个角色的关系和互联网类比：Server 是服务器，Client 是客户终端，ServiceManager 是域名服务器（DNS），Driver 是路由器。 Binder 机制特点 service_manager 维护一个链表，用来添加或查询服务 Binder Driver 实现进程间的数据交互 Android Binder 机制在 Android 系统中江湖地位非常之高。在 Zygote 孵化出 system_server 进程后，system_server 进程会初始化支撑整个 Android Framework 的各种各样的 Service，另外在 init.rc 中也会启动很多 Service，这些服务几乎都是基于 Binder IPC 机制。 三个基本概念 IBinder表示拥有被跨进程传输的能力。IBinder 是远程对象的基本接口，定义了与远程对象交互的协议。IBinder 是一种传输方式（类比 Socket），代表 Binder 通信机制，只有它的对象才能通过 Binder 机制跨进程通信；也可以认为 IBinder 是一个数据类型（类比 Object, String 等），它能被写入 Parcel 中。 IInterface定义远程接口，表示服务端拥有什么能力，能提供哪些服务，并提供了转换为 IBinder 的方法。 Parcel是一个缓冲区，除了存储基本数据类型，Parcelable 数据类型等，还可以传递 IBinder 对象。区别于 Java 中 Serializable 可以将数据保存到存储介质上，Parcel 仅存储在内存中，属于轻量级序列化机制。 Binder 通信机制跨进程传输的数据，是存储在 Parcel 中的。 Client/Server 两个角色在使用过程中并不用关心 Binder 的通信过程，这些是 Android 系统已经实现了的。Client/Server 只需要按照 Binder 机制中规定实现相应的 IBinder/IInterface，系统将完成这个通信过程。 源码目录结构速查表整个 Binder 框架目录结构12345frameworks/base/core/java/ (Java)frameworks/base/core/jni/ (JNI)frameworks/native/libs/binder (Native)frameworks/native/cmds/servicemanager/ (Native)kernel/drivers/staging/android (Driver) Java Framework1234567891011121314frameworks/base/core/java/android/os/ - IInterface.java - IBinder.java - Parcel.java - IServiceManager.java - ServiceManager.java - ServiceManagerNative.java - Binder.java frameworks/base/core/jni/ - android_os_Parcel.cpp - AndroidRuntime.cpp - android_util_Binder.cpp (核心类) Native Framework1234567891011121314frameworks/native/libs/binder - IServiceManager.cpp - BpBinder.cpp - Binder.cpp - IPCThreadState.cpp (核心类) - ProcessState.cpp (核心类)frameworks/native/include/binder/ - IServiceManager.h - IInterface.hframeworks/native/cmds/servicemanager/ - service_manager.c - binder.c kernel Driver123kernel/drivers/staging/android/ - binder.c - uapi/binder.h Binder Java 类图 通常来讲，对于 Server 进程，Binder 指的是 Binder 本地对象；对于 Client 进程，Binder 指的是 BinderProxy 对象，它只是 Binder 本地对象的一个远程代理。对 BinderProxy 对象的操作，会通过驱动最终转发到 Binder 本地对象上去完成。对于一个拥有 Binder 对象的使用者而言，它无须关心这是一个 BinderProxy 对象还是 Binder 本地对象，对于代理对象的操作和对本地对象的操作对它来说没有区别。在驱动中，Binder 本地对象的代表是一个叫做 binder_node 的数据结构，BinderProxy 对象是用 binder_ref 代表的。有的地方把 Binder 本地对象直接称作 Binder 实体，把 BinderProxy 对象直接称作 Binder 引用（句柄），其实指的是 Binder 对象在驱动里面的表现形式。 类和接口对应文件12345IInterface.java: IInterfaceIBinder.java: IBinder, DeathRecipientBinder.java: Binder, BinderProxyBinderInternal.java: BinderInternal, GcWatcherICustomAIDLInterface.java(AIDL 自动生成): ICustomAIDLInterface, Stub, Proxy BinderProxyClient 持有，也可以理解为远程端，下发命令。 transact 发送命令 mObject 保存 BpBinder 的引用 BinderServer 持有，也可以理解为本地服务端，响应命令。 Binder.onTransact 响应命令并处理 mObject 保存 JavaBBinderHolder 的引用 AIDL 文件自定义的 AIDL 文件，编译时会自动生成对应的 ICustomAIDLInterface.java 文件，这个文件包含 ICustomAIDLInterface, Stub, Proxy 三个类或接口。 Stub 和 Proxy 都实现了 ICustomAIDLInterface Client 拥有 ICustomAIDLInterface 对象，实际是 Proxy Server 拥有 Stub 对象，并实现 CustomAIDLInterface 抽象方法 使用模板： 123456789// ClientICustomAIDLInterface mAIDLService = ICustomAIDLInterface.Stub.asInterface(IBinder);// Serverprivate ICustomAIDLInterface.Stub mBinder = new ICustomAIDLInterface.Stub() &#123; @Override public void customMethod() &#123;...&#125; 没有 ServiceManager 的参与，是因为所有的动作都是在 ActivityManager 中实现的。而 ActivityManager 完成了服务的注册和查询，它也是一次 Binder 通信。 Stub客户辅助对象，常译为“桩”。它是 ICustomAIDLInterface 的内部抽象类。 和 IBinder 的关系是 is-a，继承了 Binder asBinder 返回的是 this，即 Binder 对象 asInterface 返回是 Proxy，引用了 BinderProxy 对象 Stub 同时实现了 IInterface 和 IBinder，所以它是整个 Binder Java 框架的中转站，通过 asInterface/asBinder 转换为需要的接口。 ProxyStub 的私有内部类。 和 IBinder 的关系是 has-a，引用了 BinderProxy 对象 mRemote 指向 BinderProxy 对象 asBinder() 返回 mRemote IInterface123public interface IInterface &#123; public IBinder asBinder();&#125; 该接口只包含一个方法：asBinder，即将 IInterface 转换为 IBinder。客户端只有 IInterface 实例，需要转换为 IBinder 后才能跨进程通信。 IBinder FLAG_ONEWAYBinder 机制中客户端和服务端通信默认是阻塞式的，但如果设置了 FLAG_ONEWAY，将成为非阻塞的调用，客户端能立即返回，服务端采用回调方式来通知客户端完成情况。 DeathDecipient死亡通知，是一个回调接口。当进程不再持有 IBinder 时，会通过这个回调来通知。IBinder 通过 linkToDeath/unlinkToDeath 来绑定和解绑。 BinderInternal getContextObject静态方法：BinderInternal.getContextObject()，返回 IBinder，专供 ServiceManager 拿到 IServiceManager 的引用。 GcWatcher内部类，用于处理和调试与 Binder 相关的垃圾回收。 Binder CPP 类图 Client 端持有 ICustomServiceInterface，实际对应的是 BpCustomServiceInterface，它会通过 BpRefBase.mRemote 指向的 BpBinder 拿到 mHandle，而这个 mHandle 句柄指向 BBinder。也就是 mHandle 将 Client端和 Server 端连接起来。Server 端继承 BnCustomServiceInterface，它继承 BBinder，直接注册服务。 类和接口对应文件12345IBinder.h: IBinderBpBinder.h/BpBinder.cpp: BpBinder, ObjectManager, Binder.h/Binder.cpp: BBinder, BpRefBaseIInterface.h/IInterface.cpp: IInterface, BnInterface, BpInterface android_util_Binder.cpp: JavaBBinder, JavaBBinderHolder, JavaDeathRecipient 命名规则 Bp***Binder proxy 表示代理，是客户端持有的一个代理对象。 Bn***Binder native 与 Bp 相对表示本地，是本地对象。但 BBinder 是一个特例，有点命名混乱的感觉。 BpBinder transact客户端持有后，BpBinder.transact() 用于发送命令。 mHandle在构造函数中初始化，表示连接的 BBinder 的句柄（句柄：操作系统在进程的地址空间会存储一张句柄表，每个编号内都存储一个地址，这个地址指向实际的对象，而句柄就是这个编号。这么做系统不用暴露对象的实际地址给其他进程，可以认为句柄为指针的指针，但是句柄只能由系统来解析）。所以 mHandle 是 Driver 生成的，仅在 Driver 中有用。 Binder Driver 转发数据时，通过它能找到 BpBinder/BBinder 对象。 BpBinder* remoteBinder();实现该方法，返回 this。 BBinder onTransact本地服务端，BBinder.onTransact() 用于响应命令并处理。 BBinder* localBinder();实现该方法，返回 this。 IBinder 通过 remoteBinder/localBinder 来区分具体是代理还是实体实例。 BpRefBasemRemote 指针指向 IBinder，具体是 BpBinder 对象。 IInterface 及重要的宏 asBinder返回 IBinder 的强指针。 BpInterface模板类，同时继承了 ICustomServiceInterface 和 BpRefBase。onAsBinder 返回 mRemote，它指向了 BpBinder。 BnInterface模板类，同时继承了 ICustomServiceInterface 和 BBinder。onAsBinder 返回 this，即 BBinder 本身。 DECLARE_META_INTERFACE 宏定义了 asInterface 和 getInterfaceDescriptor，以及构造和析构函数，在 ICustomServiceInterface.h 文件中调用。 IMPLEMENT_META_INTERFACE 宏实现了 asInterface 和 getInterfaceDescriptor，以及构造和析构函数，在 ICustomServiceInterface.cpp 文件中调用。 asInterface即上面两个宏实现的函数，将 IBinder(BpBinder) 转换为 BpCustomServiceInterface。 interface_cast模板函数，调用了上面宏定义的 asInterface，即将 IBinder 转换为 ICustomServiceInterface。 ICustomServiceInterface客户自定义的接口类，继承了 IInterface。注意：需要在 .h 文件中调用宏 DECLARE_META_INTERFACE，在 cpp 文件中调用宏 IMPLEMENT_META_INTERFACE，实现 asInterface 函数。 BpCustomServiceInterfaceBpInterface 的具体实现，功能对应 Java 中的 Proxy，在 cpp 文件中定义，实现接口文件中的具体方法，通过 BpBinder.transact 下发命令。 BnCustomServiceInterfaceBnInterface 的具体实现，功能对应 Java 中的 Stub，在 h 文件中定义，申明 onTransact 响应并处理命令。 BnCustomServiceInterface 同时继承了 IInterface 和 IBinder，同理它是 Binder CPP 的中转站，通过 onAsBinder/asInterface 来转换。 Binder Java/CPP 转换对应类图 Binder Java 最终都会转换为 Binder CPP 来实现整个 Binder 通信机制。 JavaBBinderHolder用来管理 JavaBBinder 的实例，使用弱指针指向了该实例。 JavaBinder mObject保存了服务端注册服务时的 IBinder 引用，也就是说实际指向的是 ICustomAIDLInterface.Stub（可以查看 server_init 序列图）。 android_util_Binder.cppJava/CPP 衔接文件：android_util_Binder.cpp: JavaBBinder, JavaBBinderHolder, JavaDeathRecipient，仅在通过 Java 代码注册服务时才会使用到。Android Runtime 在开启时，注册了 REG_JNI(register_android_os_Binder)，而 android_util_Binder::register_android_os_Binder 实现了对 Binder Java/CPP 的关联，即对相关 mObject 赋值，以及 Java native 代码的映射。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// android_util_Binder.cppint register_android_os_Binder(JNIEnv* env)&#123; if (int_register_android_os_Binder(env) &lt; 0) return -1; if (int_register_android_os_BinderInternal(env) &lt; 0) return -1; if (int_register_android_os_BinderProxy(env) &lt; 0) return -1; ...&#125;// BinderProxy.mObject 赋值jobject javaObjectForIBinder(JNIEnv* env, const sp&lt;IBinder&gt;&amp; val)&#123; ... object = env-&gt;NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor); if (object != NULL) &#123; LOGDEATH("objectForBinder %p: created new proxy %p !\n", val.get(), object); // The proxy holds a reference to the native object. env-&gt;SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get()); val-&gt;incStrong((void*)javaObjectForIBinder); // The native object needs to hold a weak reference back to the // proxy, so we can retrieve the same proxy if it is still active. jobject refObject = env-&gt;NewGlobalRef( env-&gt;GetObjectField(object, gBinderProxyOffsets.mSelf)); val-&gt;attachObject(&amp;gBinderProxyOffsets, refObject, jnienv_to_javavm(env), proxy_cleanup); // Also remember the death recipients registered on this proxy sp&lt;DeathRecipientList&gt; drl = new DeathRecipientList; drl-&gt;incStrong((void*)javaObjectForIBinder); env-&gt;SetLongField(object, gBinderProxyOffsets.mOrgue, reinterpret_cast&lt;jlong&gt;(drl.get())); ... &#125; return object;&#125;// Binder.mObject 指向 JavaBBinderHolderstatic void android_os_Binder_init(JNIEnv* env, jobject obj)&#123; JavaBBinderHolder* jbh = new JavaBBinderHolder(); ... env-&gt;SetLongField(obj, gBinderOffsets.mObject, (jlong)jbh);&#125; Binder 机制中的设计模式代理模式 先看代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。代理模式中，代理和被代理对象继承相同的接口，实现相同的方法。控制被代理对象的访问权限或者隐藏被代理对象的远程操作等等。代理模式类似经纪人角色，可以起到保护明星的功能。整个 Binder 通信机制都是基于代理模式，远程代理就好比“远程对象的本地代表”，所以跨进程交互或者说 C/S 结构，非常适合使用代理模式。因为是跨进程通信，客户端进程并不能直接拿到服务端的实例对象，只能通过远程代理（BpBinder）来访问服务端（BBinder），这样相互通信看起来像是两个本地对象在交互，而远程代理在幕后默默的和服务端通信，客户端并不清楚这个过程。另外，通过代理模式，Binder 机制能够控制访问权限，大大提供安全性。 单例模式ProcessState, IPCThreadState, IServiceManager 都是使用的单例模式。 1234567891011121314151617181920212223242526272829303132333435363738394041// ProcessState.cppsp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != NULL) &#123; return gProcess; &#125; gProcess = new ProcessState; return gProcess;&#125;// IPCThreadState.cppIPCThreadState* IPCThreadState::self()&#123; if (gHaveTLS) &#123;restart: const pthread_key_t k = gTLS; IPCThreadState* st = (IPCThreadState*)pthread_getspecific(k); if (st) return st; return new IPCThreadState; &#125; ...&#125;// IServiceManager.cppsp&lt;IServiceManager&gt; defaultServiceManager()&#123; if (gDefaultServiceManager != NULL) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); while (gDefaultServiceManager == NULL) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); if (gDefaultServiceManager == NULL) sleep(1); &#125; &#125; return gDefaultServiceManager;&#125; 桥接模式 桥接模式连接着不同分类的两端，比如 Proxy 连接了 IInterface, IBinder。 12345678910111213141516171819202122private static class Proxy implements com.***.ICustomAIDLInterface &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; ... @Override public void customMethod(int anInt) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeInt(anInt); mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; &#125;&#125; Parcel 在 Binder 机制中的作用定义先看一段 Parcel.java 中的注释： 1234567* Container for a message (data and object references) that can* be sent through an IBinder. A Parcel can contain both flattened data* that will be unflattened on the other side of the IPC (using the various* methods here for writing specific types, or the general* &#123;@link Parcelable&#125; interface), and references to live &#123;@link IBinder&#125;* objects that will result in the other side receiving a proxy IBinder* connected with the original IBinder in the Parcel. Parcel 是一个容器包含了数据或对象的引用，它能够通过 IBinder 来传输。Parcel 能够包含序列化的数据，这些数据可以被 IPC 通信的另一端反序列化（通过各种 write 方法或者 Parcelable 接口）；并且可以包含一个 IBinder 对象的引用，这个引用会让对方接受到一个和该 IBinder 对象已经连接好的代理。Parcel 是整个 Binder 机制中，数据传输的载体，存储了所有需要跨进程通信的数据，包含 IBinder 也可存储到 Parcel 中。这个读写都是基于内存的，所以效率会比 Java Serializable 基于外部存储的要高。 文件路径123frameworks/base/core/java/android/os/Parcel.javaframeworks/base/core/jni/android_os_Parcel.cppframeworks/native/libs/binder/Parcel.cpp 通过 jni 实现 native 的方法，jni 是在 AndroidRuntime 运行时初始化。 Binder 相关 API1234567891011121314151617181920212223242526272829303132333435363738394041// Parcel.javapublic final IBinder[] createBinderArray() &#123;...&#125;public final void readBinderArray(IBinder[] val) &#123;...&#125;public final void readBinderList(List&lt;IBinder&gt; list) &#123;...&#125;public final void writeBinderArray(IBinder[] val) &#123;...&#125;public final void writeBinderList(List&lt;IBinder&gt; val) &#123;...&#125;public final ArrayList&lt;IBinder&gt; createBinderArrayList() &#123;...&#125;/** * Write an object into the parcel at the current dataPosition(), * growing dataCapacity() if needed. */public final void writeStrongBinder(IBinder val) &#123; nativeWriteStrongBinder(mNativePtr, val);&#125;/** * Read an object from the parcel at the current dataPosition(). */public final IBinder readStrongBinder() &#123; return nativeReadStrongBinder(mNativePtr);&#125;/** * Store or read an IBinder interface token in the parcel at the current * &#123;@link #dataPosition&#125;. This is used to validate that the marshalled * transaction is intended for the target interface. */public final void writeInterfaceToken(String interfaceName) &#123; nativeWriteInterfaceToken(mNativePtr, interfaceName);&#125;public final void enforceInterface(String interfaceName) &#123; nativeEnforceInterface(mNativePtr, interfaceName);&#125;/** * Write an object into the parcel at the current dataPosition(), * growing dataCapacity() if needed. */public final void writeStrongInterface(IInterface val) &#123; writeStrongBinder(val == null ? null : val.asBinder());&#125; Parcel 数据模型 Parcel 的数据区域分两个部分：mData 和 mObjects，所有的数据不管是基础数据类型还是对象实体，全都追加到 mData 里，mObjects 是一个偏移量数组，记录所有存放在 mData 中的 flat_binder_object 实体的偏移量。 offsets_size, data.offsets 两个成员是 Binder 通信有别于其它 IPC 的地方。Binder 采用面向对象的设计思想，一个 Binder 实体可以发送给其它进程从而建立许多跨进程的引用；另外这些引用也可以在进程之间传递，就象 Java 里将一个引用赋给另一个引用一样。为 Binder 在不同进程中建立引用必须有驱动的参与，由驱动在内核创建并注册相关的数据结构后接收方才能使用该引用。而且这些引用可以是强类型，需要驱动为其维护引用计数。然而这些跨进程传递的 Binder 混杂在应用程序发送的数据包里，数据格式由用户定义，如果不把它们一一标记出来告知驱动，驱动将无法从数据中将它们提取出来。于是就使用数组 data.offsets 存放用户数据中每个 Binder 相对 data.buffer 的偏移量，用 offsets_size 表示这个数组的大小。驱动在发送数据包时会根据 data.offsets 和 offset_size 将散落于 data.buffer 中的 Binder 找出来并一一为它们创建相关的数据结构。在数据包中传输的 Binder 是类型为 struct flat_binder_object 的结构体。对于接收方来说，该结构只相当于一个定长的消息头，真正的用户数据存放在 data.buffer 所指向的缓存区中。如果发送方在数据中内嵌了一个或多个 Binder ，接收到的数据包中同样会用 data.offsets, offset_size 指出每个 Binder 的位置和总个数。不过通常接收方可以忽略这些信息，因为接收方是知道数据格式的，参考双方约定的格式定义就能知道这些 Binder 在什么位置。 Binder 进程和线程管理文件路径12frameworks/native/libs/binder/ProcessState.cppframework/native/libs/binder/IPCThreadState.cpp 概述Android 系统特别为程序进程使用 Binder 机制封装了两个实现类，即 ProcessState/IPCThreadState。 ProcessState是进程相关的，负责打开 Binder 驱动设备，进行 mmap() 等准备工作。 IPCThreadState是线程相关的，负责与 Binder 驱动进行具体的命令通信。 ProcessState.cpp 单例模式特性只能通过单例模式获取 ProcessState 对象，用于创建 Binder 线程：sp&lt;ProcessState&gt; proc = ProcessState::self();。而构造函数中会打开 Binder 设备，单例模式的设计可以确保每个进程的 Binder 设备只会被打开一次。 1234567891011// 单例模式sp&lt;ProcessState&gt; ProcessState::self()&#123; Mutex::Autolock _l(gProcessMutex); if (gProcess != NULL) &#123; return gProcess; &#125; // gProcess在 Static.cpp 中定义的全局变量 gProcess = new ProcessState; return gProcess;&#125; 线程数每个 APP 在启动时都会创建名称为 Binder_X 的线程，最少会创建 2 个（Binder 主线程和当前加入的线程），最多会创建 15 个，可以通过命令查看：命令：adb shell; ps -t | grep -irs &quot;binder*&quot; 123456789101112#define DEFAULT_MAX_BINDER_THREADS 15static int open_driver()&#123; int fd = open("/dev/binder", O_RDWR | O_CLOEXEC); if (fd &gt;= 0) &#123; ... size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); ... &#125; return fd;&#125; 创建线程使用 ProcessState 来创建线程池，并且确保每个进程的线程池只会被创建一次，并且会创建第一个 PoolThread 主线程。 1234567891011121314151617181920proc-&gt;startThreadPool(); //或者ProcessState::self()-&gt;startThreadPool();void ProcessState::startThreadPool()&#123; AutoMutex _l(mLock); if (!mThreadPoolStarted) &#123; mThreadPoolStarted = true; spawnPooledThread(true); &#125;&#125;void ProcessState::spawnPooledThread(bool isMain)&#123; if (mThreadPoolStarted) &#123; String8 name = makeBinderThreadName(); ALOGV("Spawning new pooled thread, name=%s\n", name.string()); sp&lt;Thread&gt; t = new PoolThread(isMain); t-&gt;run(name.string()); &#125;&#125; PoolThread线程池在开启时，会创建一个主线程 PoolThread。这个类很简单，仅仅是作为主线程加入了线程池：IPCThreadState::self()-&gt;joinThreadPool(mIsMain);。 1234567891011121314151617class PoolThread : public Thread&#123;public: PoolThread(bool isMain) : mIsMain(isMain) &#123; &#125; protected: virtual bool threadLoop() &#123; IPCThreadState::self()-&gt;joinThreadPool(mIsMain); return false; &#125; const bool mIsMain;&#125;; Binder 进程大小不超过 1MBinder 是轻量级进程间通信机制，传输的数据大小不能超过 1M。 1234567891011121314// ProcessState.cpp// Binder 虚拟机默认大小为 1M - 8K 大小的内存#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))ProcessState::ProcessState() : mDriverFD(open_driver()) ,...&#123; ... if (mDriverFD &gt;= 0) &#123; // 采用内存映射函数mmap，给binder分配一块虚拟地址空间,用来接收事务 mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); ...&#125; ProcessState 常用 API12345678910// 单例，获取对象sp&lt;ProcessState&gt; ProcessState::self()// 开启线程池ProcessState::self()-&gt;startThreadPool();// 获取 handle 为 0 的 IBinder，handle 为 0 表示是 service_manager 守护进程ProcessState::self()-&gt;getContextObject(NULL)// ProcessState::self()-&gt;getContextObject(const String16&amp; name, const sp&lt;IBinder&gt;&amp; caller);// 设置为上下文管理员bool ProcessState::becomeContextManager(context_check_func checkFunc, void* userData) IPCThreadState.cpp 万众归一 joinThreadPool可以看到不管是 ProcessState 创建的线程，还是其他应用线程，最终都是通过 joinThreadPool 来加入 Binder 线程池的。 1234567891011121314151617181920212223// 头文件定义，默认为 truevoid joinThreadPool(bool isMain = true);void IPCThreadState::joinThreadPool(bool isMain)&#123; ... // 主线程和其他线程 BC 码不一样 mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER); ... // 如果是主线程将进入无限循环，处理请求信息 do &#123; processPendingDerefs(); // now get the next command to be processed, waiting if necessary result = getAndExecuteCommand(); ... if(result == TIMED_OUT &amp;&amp; !isMain) &#123; break; &#125; &#125; while (result != -ECONNREFUSED &amp;&amp; result != -EBADF); ... mOut.writeInt32(BC_EXIT_LOOPER); talkWithDriver(false);&#125; 两个重要数据存储mIn, mOut：mIn 用来接收来自 Binder Driver 的数据，mOut 用来存储发往 Binder Driver 的数据。 请求码和响应码BINDER_COMMAND_PROTOCOL：请求码，以 BC_ 开头，简称 BC 码，请求命令用于用户空间向内核空间发出请求。BINDER_RETURN_PROTOCOL：响应码，以 BR_ 开头，简称 BR 码，用于响应返回命令，内核空间向用户空间返回响应。 向驱动发送请求码IPCThreadState 各个 API 会将请求码写入 mOut，最终都会通过 talkWithDriver 写入 Binder Driver。 处理驱动返回的响应码响应信息都会通过 mIn 传递回 Native 层。 123status_t IPCThreadState::executeCommand(int32_t cmd)status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult) AIDL 中的 oneway 关键字处理AIDL 中是否定义 oneway 关键字，主要是在传递的过程中会体现： 1234// 没有使用 onewaymRemote.transact(***, _data, null, 0);// 使用了 onewaymRemote.transact(***, _data, null, android.os.IBinder.FLAG_ONEWAY); 而这个标记最终会在这里解析： 123456789101112131415161718192021222324252627282930313233343536373839404142status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; ... // 没有设置 oneway if ((flags &amp; TF_ONE_WAY) == 0) &#123; ... if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; ... // 设置 oneway &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125;status_t IPCThreadState::executeCommand(int32_t cmd)&#123; ... case BR_TRANSACTION: &#123; ... // 没有设置 oneway，发送回执 if ((tr.flags &amp; TF_ONE_WAY) == 0) &#123; LOG_ONEWAY("Sending reply to %d!", mCallingPid); if (error &lt; NO_ERROR) reply.setError(error); sendReply(reply, 0); // 设置 oneway，忽略 &#125; else &#123; LOG_ONEWAY("NOT sending reply to %d!", mCallingPid); &#125; ... &#125; ...&#125; 代码中可以看到，oneway 关键字决定了是否阻塞等待 waitForResponse 以及响应时是否发送回执 sendReply。 Binder 机制驱动交互真正与 Binder Driver 交互的地方是 talkWithDriver 中的 ioctl()，通过它 BINDER_WRITE_READ 命令写入 Binder Driver。 12345678910111213141516171819202122232425262728293031status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; ... binder_write_read bwr; ... bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); // This is what we&apos;ll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); bwr.read_buffer = (uintptr_t)mIn.data(); &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; ... bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; IF_LOG_COMMANDS() &#123; alog &lt;&lt; &quot;About to read/write, write size = &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl; &#125;#if defined(__ANDROID__) if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) err = NO_ERROR; ... &#125; while (err == -EINTR); ...&#125; IPCThreadState 常用 API12// 加入 Binder 线程池IPCThreadState::self()-&gt;joinThreadPool(); 至少 2 个 Binder 线程在所有使用 Binder 机制的示例中，都能看到初始化时至少会执行如下两句： 123456int main(...)&#123; ... ProcessState::self()-&gt;startThreadPool(); // Binde_1 主线程 IPCThreadState::self()-&gt;joinThreadPool(); // 当前主线程变成 Binder 线程 ...&#125; 从前面的分析可以看到： ProcessState::self()-&gt;startThreadPool();开启线程池，也就是新建一个 Binder 主线程，名称为 Binder_1。 IPCThreadState::self()-&gt;joinThreadPool();当前线程加入线程池，也就是将当前线程变为 Binder 线程。 我们在分析 startThreadPool() 时可以看到，新建了一个 PoolThread 异步调用 joinThreadPool()，同时应用主线程同步调用了 joinThreadPool，阻塞等待。代码中可以看出，这两个都是 Binder 主线程，但是线程名不一样，同步调用 joinThreadPool() 的目的之一是确保 startThreadPool 异步产生的线程不会因为执行到了 main 函数结尾而被迫退出；目的之二可能是为了提高 Binder 线程处理的吞吐量，都可以等待并处理请求。 Binder 线程总结Binder 系统中可分为 3 类线程： Binder 主线程ProcessState::self()-&gt;startThreadPool(); 创建 Binder 主线程。编号从 1 开始，即主线程名为 Binder_1，并且主线程是不会退出的。 Binder 普通线程由 Binder Driver 来决定是否创建 Binder 线程，发回消息 BR_SPAWN_LOOPER 后回调 spawnPooledThread(false) 创建普通线程，该线程名格式为 Binder_X。 Binder 其他线程其他线程是指并没有调用 spawnPooledThread 方法，而是直接调用 IPCThreadState::self()-&gt;joinThreadPool，将当前线程直接加入 Binder 线程队列。 ServiceManager双重属性ServiceManager 它既是客户端也是服务端。 作为服务端IServiceManager.java/IServiceManager.cpp：其他进程都是通过它们来查询或注册服务的。不过在 Java 代码中，ServiceManager.java 是对 IServiceManager.java 的一个封装，同时保存了一个 Cache，即 Java 层通常是通过 ServiceManager.java 来访问的，而不是直接调用 IServiceManager.java。 作为客户端service_manager.c：手机开机时 init.rc 会开启一个名称是小写的 servicemanager 服务，它是由 service_manager.c 实现的守护进程，为了做区分本文将守护进程服务命名重命名为 service_manager。守护进程开启后会进入无限循环，只有两个功能：注册服务和查询服务。IServiceManager.cpp 和 service_manager.c 是一个完整的 Binder 通信流程。ServiceManager 可以看做客户端，service_manager 守护进程可以看做是服务端。这部分的通信过程是系统实现的，可以认为对用户透明，所以通常将 ServiceManager 和 service_manager 合二为一，统称为 ServiceManager。 ServiceManager 存在的意义在 Android 系统中，所有 Service 都需要加入到 ServiceManager 来集中管理。这样客户端可以很方便的通过服务名称从系统查询服务，同时 ServiceManager 会向客户端提供服务端的 IBinder，用于客户端和服务端的 Binder 通信。而且这个过程都是系统自动完成，系统屏蔽了整个通信机制，只开放两个接口： 12public static void addService(String name, IBinder service) &#123;...&#125;public static IBinder getService(String name) &#123;...&#125; C/S 模型 注册服务 addServiceServer 进程向 ServiceManager 注册服务。该过程：Server 是客户端，ServiceManager 是服务端。 获取服务 getServiceClient 进程向 ServiceManager 获取相应的服务。该过程：Client 是客户端，ServiceManager 是服务端。 使用服务Client 得到服务的 IBinder 与 Server 进程通信，然后就可以通过 Binder Driver 交互数据。该过程：Client 是客户端，Server 是服务端。 Java 层的类图 ServiceManagerProxy其成员变量 mRemote 指向 BinderProxy 对象，ServiceManagerProxy:addService, getService 方法最终是交由 mRemote 来完成。 ServiceManager通过 getIServiceManager 方法获取的是 ServiceManagerProxy 对象。ServiceManager:addService, getService 实际工作都交由 ServiceManagerProxy 的相应方法来处理。 ServiceManagerNativeasInterface() 返回的是 ServiceManagerProxy 对象，ServiceManager 是通过 ServiceManagerNative 类来找到 ServiceManagerProxy 的。 CPP 层的类图 BpServiceManager同时继承了 IServiceManager, BpInterface，其中 BpInterface 继承 BpRefBase，而 BpRefBase.mRemote 指向了 BpBinder。BpBinder.mHandle 为指向 BBinder 的句柄，通过这个句柄实现 Binder 间的通信。 IServiceManager单例模式 IServiceManager::defaultServiceManager 获取到 BpServiceManager 实例。 对比 Binder_CPP 核心类图，缺失了 BnServiceManager 这个类。那谁来充当 onTransact 的调度工作呢？它就是 service_manager.c 守护进程！ IServiceManager::defaultServiceManager从类图中可以看到，IServiceManager 并没有对应的注册服务，只提供了查询即 defaultServiceManager。得到 handle 句柄为 0 的 BpBinder，而 0 号句柄对应的 BBinder 实际为 service_manager 守护进程。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Static.cpp 中定义sp&lt;IServiceManager&gt; gDefaultServiceManager;// IServiceManager.cpp，单例模式获取sp&lt;IServiceManager&gt; defaultServiceManager()&#123; if (gDefaultServiceManager != NULL) return gDefaultServiceManager; &#123; AutoMutex _l(gDefaultServiceManagerLock); while (gDefaultServiceManager == NULL) &#123; gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;( ProcessState::self()-&gt;getContextObject(NULL)); if (gDefaultServiceManager == NULL) sleep(1); &#125; &#125; return gDefaultServiceManager;&#125;// ProcessState.cpp// 句柄为 0 时，先去 ping 一下看是否准备好sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; ... if (e != NULL) &#123; // We need to create a new BpBinder if there isn't currently one, OR we // are unable to acquire a weak reference on this current one. See comment // in getWeakProxyForHandle() for more info about this. IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; if (handle == 0) &#123; // Special case for context manager... // The context manager is the only object for which we create // a BpBinder proxy without already holding a reference. // Perform a dummy transaction to ensure the context manager // is registered before we create the first local reference // to it (which will occur when creating the BpBinder). // If a local reference is created for the BpBinder when the // context manager is not present, the driver will fail to // provide a reference to the context manager, but the // driver API does not return status. // // Note that this is not race-free if the context manager // dies while this code runs. // // TODO: add a driver API to wait for context manager, or // stop special casing handle 0 for context manager and add // a driver API to get a handle to the context manager with // proper reference counting. Parcel data; status_t status = IPCThreadState::self()-&gt;transact( 0, IBinder::PING_TRANSACTION, data, NULL, 0); if (status == DEAD_OBJECT) return NULL; &#125; b = new BpBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; ... return result;&#125; 时序图： 总结： defaultServiceManager 等价于 new BpServiceManager(new BpBinder(0)); handle 为 0 的句柄，代表 ServiceManager 所对应的 BBinder 示例： 1234567891011//获取service manager引用sp &lt; IServiceManager &gt; sm = defaultServiceManager();//注册名为&quot;service.myservice&quot;的服务到service managersm-&gt;addService(String16(&quot;service.myservice&quot;), new BnMyService());//获取service manager引用sp &lt; IServiceManager &gt; sm = defaultServiceManager();//获取名为&quot;service.myservice&quot;的binder接口sp &lt; IBinder &gt; binder = sm-&gt;getService(String16(&quot;service.myservice&quot;));//将biner对象转换为强引用类型的IMyServicesp&lt;IMyService&gt; cs = interface_cast &lt; IMyService &gt; (binder); service_manager 守护进程文件路径123frameworks/native/cmds/servicemanager/servicemanager.rcframeworks/native/cmds/servicemanager/service_manager.cframeworks/native/cmds/servicemanager/binder.c 守护进程由 init.rc 开启的守护进程，对应 service_manager.c 文件。 123456789101112131415// 对应 rc 文件：Servicemanager.rcservice servicemanager /system/bin/servicemanager class core user system group system readproc critical onrestart restart healthd onrestart restart zygote onrestart restart audioserver onrestart restart media onrestart restart surfaceflinger onrestart restart inputflinger onrestart restart drm onrestart restart cameraserver writepid /dev/cpuset/system-background/tasks 主程序1234567891011121314151617// service_manager.cint main()&#123; ... // 开启 Binder 驱动 bs = binder_open(128*1024); ... // 成为 Binder 服务的大管家 if (binder_become_context_manager(bs)) &#123; ALOGE("cannot become context manager (%s)\n", strerror(errno)); return -1; &#125; ... // 进入无限循环，处理客户端请求 binder_loop(bs, svcmgr_handler); ...&#125; 主程序逻辑很简单： 打开 Binder Driver，申请 128k 字节大小的内存空间 注册成为 Binder 服务的大管家，也就是对应 BBinder 句柄为 0 进入无限循环，处理客户端发来的请求 服务链表无论调用 Java/CPP API，每个服务最终加入 svclist 单向链表中保存。我们也可以看到 svcinfo 这个结构体实际只保存了服务的名称和句柄（这个句柄就是 BpBinder.mHandle）。 查看系统已经注册了的所有服务：adb shell service list 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct svcinfo&#123; struct svcinfo *next; uint32_t handle; struct binder_death death; int allow_isolated; size_t len; uint16_t name[0];&#125;;struct svcinfo *svclist = NULL;// 注册和查询服务入口 int svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn, struct binder_io *msg, struct binder_io *reply)&#123; ... uint32_t handle; ... switch(txn-&gt;code) &#123; case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;len); if (s == NULL) &#123; return -1; &#125; handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid); if (!handle) break; bio_put_ref(reply, handle); return 0; case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); if (s == NULL) &#123; return -1; &#125; handle = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, txn-&gt;sender_pid)) return -1; break; ...&#125; 守护进程注册为大管家binder_become_context_manager 在 Native 层，很简单仅仅是下发了 BINDER_SET_CONTEXT_MGR 的 ioctl 命令，具体见 Driver 部分分析。 1234int binder_become_context_manager(struct binder_state *bs)&#123; return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);&#125; 这个命令在驱动中实现了如下功能： 告诉驱动，当前进程即 Binder 上下文管理者 新建对应于 Context Manager 的 binder_node（即 BBinder 对应的驱动结构体） 新建 binder_ref，设置句柄为 0，并设置引用地址为上面这个 Binder 实体 核心工作service_manager 会无限循环读取和处理：服务注册或查询请求（由 IServiceManager 发出），和 IPCThreadState::talkWithDriver 一样，向驱动下发 BINDER_WRITE_READ 命令，读取并解析驱动返回的信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void binder_loop(struct binder_state *bs, binder_handler func)&#123; int res; struct binder_write_read bwr; uint32_t readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(uint32_t)); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (uintptr_t) readbuf; // 和 IPCThreadState::talkWithDriver 一样，下发 BINDER_WRITE_READ 命令。 res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... // 解析驱动返回信息 res = binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func); ... &#125;&#125;// func 即为 svcmgr_handler， 用于查询和注册int binder_parse(struct binder_state *bs, struct binder_io *bio, uintptr_t ptr, size_t size, binder_handler func)&#123; ... switch(cmd) &#123; ... case BR_TRANSACTION: &#123; struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr; ... if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); // 调用 svcmgr_handler res = func(bs, txn, &amp;msg, &amp;reply); if (txn-&gt;flags &amp; TF_ONE_WAY) &#123; binder_free_buffer(bs, txn-&gt;data.ptr.buffer); &#125; else &#123; binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; &#125; ptr += sizeof(*txn); break; &#125; ...&#125; 服务注册系统所有服务，最终会在这里实现注册。从 svcmgr_handler 可以看到，服务注册调用的是 do_add_service，新建一个 svcinfo 保存基本的名称和句柄，并加入链表。句柄是驱动创建 Binder 实体对象时生成，同时还会生成一个 Binder 引用对象指向它。 1234567891011121314151617181920212223242526272829int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle, uid_t uid, int allow_isolated, pid_t spid)&#123; struct svcinfo *si; ... if (!handle || (len == 0) || (len &gt; 127)) return -1; ... &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); ... si-&gt;handle = handle; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\0'; si-&gt;death.func = (void*) svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, handle); binder_link_to_death(bs, handle, &amp;si-&gt;death); return 0;&#125; 服务查询系统中查询对应的服务，从 svcmgr_handler 可以看到，服务查询和检查都是调用的 do_find_service，通过服务的名称来匹配，并返回句柄。为什么只需要返回句柄就可以了？从后面的驱动分析中可以了解到，驱动通过句柄可以找到相应的 Binder 引用对象，而 Binder 引用对象的结构体中保存了 Binder 实体对象。也就是说通过句柄能同时找到 Binder 的引用和实体对象。 12345678910111213141516171819uint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)&#123; struct svcinfo *si = find_svc(s, len); ... return si-&gt;handle;&#125;struct svcinfo *find_svc(const uint16_t *s16, size_t len)&#123; struct svcinfo *si; for (si = svclist; si; si = si-&gt;next) &#123; if ((len == si-&gt;len) &amp;&amp; !memcmp(s16, si-&gt;name, len * sizeof(uint16_t))) &#123; return si; &#125; &#125; return NULL;&#125; IServiceManager.cpp/service_manager.c 通信流程在前面的分析中，IServiceManager.cpp 只对应生成了 BpServiceManager类，而没有 BnServiceManager 类的存在，也就是说在 IServiceManager 中并没有注册服务，只提供了查询服务 defaultServiceManager。而守护进程 service_manager.c 只注册成为了上下文大管家，并在驱动中新建了 binder_node 并赋值给变量 binder_context_mgr_node。IServiceManager.cpp/service_manager.c 之间是如果串起来的呢？也就是 service_manager.c 如何完成了 BnServiceManager 的功能？这些都是在 Binder Driver 中实现的，下面先做个简要分析。在 Binder 通信机制中，BpBinder.mHandle 找到对应的 BBinder，是在 Binder Driver 的 binder_transaction 中实现的。路由逻辑是：如果 handle 为真，则通过 handle 在红黑树中找到 bind_ref（即 Native 层中的 BpBinder），而这个结构体中保存了通信对应的 binder_node（即 Native 层中的 BBinder）；如果 handle 不为真，即句柄为 0，则返回 binder_context_mgr_node。也就是说句柄为 0 时，对应的就是和 service_manager 通信，而 IServiceManager::defaultServiceManager 查询服务时，也就明白为什么要直接赋值句柄为 0 了。 123456789101112131415161718192021222324252627driver: binder.cstatic void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; ... struct binder_node *target_node = NULL; ... if (tr-&gt;target.handle) &#123; struct binder_ref *ref; ref = binder_get_ref(proc, tr-&gt;target.handle, true); if (ref == NULL) &#123; binder_user_error("%d:%d got transaction to invalid handle\n", proc-&gt;pid, thread-&gt;pid); return_error = BR_FAILED_REPLY; goto err_invalid_target_handle; &#125; target_node = ref-&gt;node; &#125; else &#123; target_node = binder_context_mgr_node; if (target_node == NULL) &#123; return_error = BR_DEAD_REPLY; goto err_no_context_mgr_node; &#125; &#125; ...&#125; Binder Driver 驱动Binder Driver 是整个 Binder 通信机制的核心，它工作于内核态，负责进程之间通信的建立，数据在进程之间转换和传递，每个进程中最大线程数为 15 个。 文件路径1234./drivers/staging/android/binder.h./drivers/staging/android/binder.c./drivers/staging/android/uapi/binder.h./drivers/staging/android/binder_trace.h 在 kernel 3.19 之后，默认已经合入到 kernel master 分支中了。 master 分支123456./drivers/android/binder_alloc.h./drivers/android/binder_alloc.c./drivers/android/binder.c./drivers/android/binder_trace.h./drivers/android/binder_alloc_selftest.c./include/uapi/linux/android/binder.h 数据结构 binder_proc：Binder 进程对应于用户空间的 ProcessState，每个进程调用 open() 打开 Binder 驱动都会创建该结构体，用于管理 IPC 所需的各种信息。 binder_thread：Binder 线程对应于上层的 Binder 线程。 binder_node：Binder 实体对应于 BBinder 对象，记录 BBinder 的进程、指针、引用计数等。 binder_ref：Binder 引用binder_node 实体对象的引用，对应于 BpBinder 对象，记录 BpBinder 的引用计数、死亡通知、BBinder 指针等。 binder_ref_death：Binder 死亡引用记录 Binder 死亡的引用信息。 flat_binder_object：IBinder 扁平对象IBinder 对象在两个进程间传递的扁平结构。 Binder 对象之间的引用关系 BBinder 被 binder_node 引用 binder_node 被 binder_ref 引用 binder_ref 被 BpBinder 引用 BBinder 和 BpBinder 运行在用户空间 binder_node 和 binder_ref 运行在内核空间 调用顺序：Client -&gt; handle -&gt; binder_ref -&gt; binder_node -&gt; Service。 Binder 通信机制高效原理 用户空间和内核空间简介Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能简单地使用指针传递数据，因为 Linux 使用的虚拟内存机制，用户空间的数据可能被换出，当内核空间使用用户空间指针时，对应的数据可能不在内存中。用户空间的内存映射采用段页式，而内核空间有自己的规则。 虚拟进程空间通常 32 位 Linux 内核虚拟地址空间总共为 4G：划分 03G 为用户空间，34G 为内核空间(注意，内核可以使用的线性地址只有 1G)。注意这里是 32 位内核地址空间划分，64 位内核地址空间划分是不同的。也就是说每个进程可以使用 4G 的虚拟内存，但是实际物理内存可能只用了几兆。 内核和用户虚拟内存空间映射首先在内核虚拟地址空间，申请一块与用户虚拟内存相同大小的内存；然后申请 1 个页大小的物理内存，再将同一块物理内存分别映射到内核虚拟地址空间和用户虚拟内存空间，从而实现了用户空间的和内核空间的 Buffer 同步操作的功能。而这种同时映射的方法，使得用户空间和内核空间将不需要做数据拷贝了。就是 Binder 进程间通信机制的精髓所在了，Server 进程内核空间会将 Client 进程的数据从用户空间拷贝到内核空间，进程间仅仅需要一次数据拷贝，大大提高了通信效率。 1234567891011// ProcessState.cpp// `Binder` 进程大小不超过 `1M` 中分析，构造函数中调用了 mmap// driver binder.c// 最终会调用驱动的 binder_mmapstatic int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; ... // 进程 4M 保护，实际用户空间只会申请 1M if ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M) vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M; ... handle 句柄的生成服务注册时（addService），在驱动中生成对应的 binder_node 实体对象，以及 binder_ref 引用对象，此时会根据红黑树来生成对应的 handle 值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 用户调用到驱动的流程// ioctl -&gt; binder_ioctl -&gt; binder_ioctl_write_read -&gt; // binder_thread_write -&gt; binder_transactionstatic void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; ... switch (fp-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; // 定义实体和引用对象 struct binder_ref *ref; struct binder_node *node = binder_get_node(proc, fp-&gt;binder); if (node == NULL) &#123; // 创建一个 Binder 实体对象 node node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); ... &#125; ... // 创建一个 Binder 引用对象 ref = binder_get_ref_for_node(target_proc, node); ... if (fp-&gt;type == BINDER_TYPE_BINDER) // 修改结构体fp的类型 // 当驱动将进程间数据传递到目标进程时，进程间通信 // 数据中的 Binder 实体对象就变成了Binder引用对象 fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; fp-&gt;binder = 0; // 句柄赋值 fp-&gt;handle = ref-&gt;desc; fp-&gt;cookie = 0; ... &#125; break; ...&#125;// 创建引用对象static struct binder_ref *binder_get_ref_for_node(struct binder_proc *proc, struct binder_node *node)&#123; ... // 首先判断是否已经在目标进程 proc 中为 Binder 实体对象 // 创建过一个 Binder 引用对象 while (*p) &#123; parent = *p; ref = rb_entry(parent, struct binder_ref, rb_node_node); if (node &lt; ref-&gt;node) p = &amp;(*p)-&gt;rb_left; else if (node &gt; ref-&gt;node) p = &amp;(*p)-&gt;rb_right; else return ref; &#125; // 为 proc 创建一个 Binder 引用对象 new_ref new_ref = kzalloc(sizeof(*ref), GFP_KERNEL); ... // 指向 Binder 实体对象 new_ref-&gt;node = node; ... // 为新创建的 Binder 引用对象 new_ref 分配句柄值 // 检查是否引用了 service manager 的 Binder 实体对象 binder_context_mgr_node new_ref-&gt;desc = (node == binder_context_mgr_node) ? 0 : 1; for (n = rb_first(&amp;proc-&gt;refs_by_desc); n != NULL; n = rb_next(n)) &#123; // 在 proc 中找到一个未使用的最小句柄值 // 作为新创建的 Binder 引用对象 new_ref 的句柄值 ref = rb_entry(n, struct binder_ref, rb_node_desc); if (ref-&gt;desc &gt; new_ref-&gt;desc) break; new_ref-&gt;desc = ref-&gt;desc + 1; &#125; // 至此句柄创建完毕！ ... return new_ref;&#125; 这里我们也可以看到，当 binder_node 节点为上下文大管家对象 binder_context_mgr_node 时，句柄赋值为 0 时。也就解释了为什么 IServiceManager::defaultServiceManager 对应 0 的问题了。 查询服务时（getService），得到的是句柄，在 IServiceManager::defaultServiceManager 的分析中，可以看到 ProcessState::getStrongProxyForHandle 会通过句柄初始化一个 BpBinder 返回给客户端。 参考文档 设计篇 Android深入浅出之Binder机制 深入理解Binder机制 老罗Binder机制 Binder机制系统介绍 红茶一杯话Binder Binder机制常见问题 Android Binder 进程间通讯机制 Binder学习指南 Binder框架 – 用户空间和驱动的交互 Parcel数据打包 Parcel数据传输 Android - Binder驱动]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket NIO]]></title>
    <url>%2F2017%2F12%2F18%2F0040-java-socket-nio%2F</url>
    <content type="text"><![CDATA[基础NIO:Non-Blocking IO 非阻塞 IO，主要用于网络连接中非阻塞的读写，提供多路非阻塞式的高伸缩性网络 I/O 。异步 I/O 的一个优势在于，可以同时根据大量的输入和输出执行 I/O。同步程序常常需要轮询，或者创建很多线程处理大量的连接。使用异步 I/O，可以监听任何数量的通道上的事件，不用轮询也不用额外的线程。 Selector选择器：是 Java NIO 中能够检测一到多个 NIO 通道，是多路复用器，能够监听通道是否为读写事件做好准备。因此一个单独的线程可以管理多个通道，从而管理多个网络连接。Selector 用来支持异步 I/O 操作（非阻塞I/O操作），Channel 必须处于非阻塞模式下（因此 FileChannel, Selector 不能一起使用）。Selector 是非阻塞 I/O 的核心，所有希望采用非阻塞 I/O 进行通信的通道，都应该注册到 Selector 对象。 SelectionKeySelectionKey 包含监听的不同类型事件： OP_READ OP_WRITE OP_CONNECT OP_ACCEPT 常用 API 1234567891011121314151617181920212223 public abstract class SelectionKey &#123; // 获取 channel public abstract SelectableChannel channel(); // 获取 Selector public abstract Selector selector(); // 获取注册的监听事件集合 public abstract int interestOps(); // 更换监听事件 public abstract SelectionKey interestOps(int ops); // 获取已经 ready 了的事件集合 public abstract int readyOps(); // 取消监听的事件 public abstract void cancel(); // 判断事件 public final boolean isReadable() &#123;...&#125; public final boolean isWritable() &#123;...&#125; public final boolean isConnectable() &#123;...&#125; public final boolean isAcceptable() &#123;...&#125; // 添加附加对象 public final Object attach(Object ob) &#123;...&#125; // 获取附件对象 public final Object attachment() &#123;...&#125;&#125; 常用 API123456789101112131415161718192021 public abstract class Selector implements Closeable &#123; // 创建 Selector public static Selector open() throws IOException &#123;...&#125; public abstract boolean isOpen(); // 返回所有的注册事件集 public abstract Set&lt;SelectionKey&gt; keys(); // 返回 select 已经就绪的注册事件集 public abstract Set&lt;SelectionKey&gt; selectedKeys(); // 非阻塞，如果监听事件没准备好立即返回 0 public abstract int selectNow() throws IOException; // 阻塞等待直到注册事件准备好，返回监听的事件 public abstract int select(long timeout) throws IOException; public abstract int select() throws IOException; // 如果 select 阻塞了，直接唤醒 select 立马返回 public abstract Selector wakeup(); // 关闭 public abstract void close() throws IOException;&#125; SelectableChannel 支持选择器的通道表示可以支持多路复用的通道，支持阻塞和非阻塞模式。（默认情况下，所有的 Channel 都是阻塞的），需要设置为非阻塞模式，才能使用 NIO 特性。 123456789101112131415161718public abstract class SelectableChannel extends AbstractInterruptibleChannel implements Channel &#123; // false 表示设置为非阻塞模式 public abstract SelectableChannel configureBlocking(boolean block) throws IOException; // 判断是否为阻塞模式 public abstract boolean isBlocking(); // 注册选择器 public abstract SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException; public final SelectionKey register(Selector sel, int ops) throws ClosedChannelException &#123;...&#125; // 通道是否注册一个或多个选择器 public abstract boolean isRegistered(); // 返回通道和该选择器的注册关系 public abstract SelectionKey keyFor(Selector sel);&#125; 注册通道通道必须处于非阻塞模式，可以监听多个事件。 12345channel.configureBlocking(false);SelectionKey key = channel.register(selector, Selectionkey.OP_READ);// 监听多个事件int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;SelectionKey key = channel.register(selector, interestSet); 参考示例12345678910111213141516171819202122Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) &#123; int readyChannels = selector.select(); if(readyChannels == 0) continue; Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove(); &#125;&#125; SocketChannel对应于 java.net.Socket 类。 创建 SocketChannel默认创建一个阻塞 SocketChannel，两种方法的差异： open()后续还需要手动配置为非阻塞后，监听连接事件。 open(SocketAddress remote)创建并同步等待连接 remote，直到连接成功后返回。不需要再手动连接。 支持的非阻塞事件 OP_CONNECT OP_READ OP_WRITE 不支持 Accept 事件 常见 API1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel &#123; // 创建 SocketChannel public static SocketChannel open() throws IOException &#123;...&#125; // 创建 SocketChannel ，同步等待连接 remote public static SocketChannel open(SocketAddress remote) throws IOException; // 绑定 public abstract SocketChannel bind(SocketAddress local) throws IOException; // 连接，非阻塞模式会直接返回连接结果；阻塞模式会等待直到连接成功 public abstract boolean connect(SocketAddress remote) throws IOException; // 完成连接，非阻塞模式直接返回连接是否完成；阻塞模式会等待直到连接完成 public abstract boolean finishConnect() throws IOException; // 当前通道是否已经连接 public abstract boolean isConnected(); // 当前通道是否正在连接，一般是第一次连接后调用 // 用来判断是否正在连接，并接着调用 finishConnect public abstract boolean isConnectionPending(); // 设置 socket 选项 public abstract &lt;T&gt; SocketChannel setOption(SocketOption&lt;T&gt; name, T value) throws IOException; // 获取当前 socket public abstract Socket socket(); // 获取源地址和端口，目标地址和端口 public abstract SocketAddress getRemoteAddress() throws IOException; public abstract SocketAddress getLocalAddress() throws IOException; // 通道读写缓存 public abstract int read(ByteBuffer dst) throws IOException; public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException; public final long read(ByteBuffer[] dsts) throws IOException &#123;...&#125; public abstract int write(ByteBuffer src) throws IOException; public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException; public final long write(ByteBuffer[] srcs) throws IOException &#123;...&#125; // 返回支持的 SelectionKey 事件 public final int validOps() &#123;...&#125; // 关闭通道的读功能 public abstract SocketChannel shutdownInput() throws IOException; // 关闭通道的写功能 public abstract SocketChannel shutdownOutput() throws IOException;&#125; ServerSocketChannel对应于 java.net.ServerSocket 类。 创建 ServerSocketChannel创建 ServerSocketChannel 也很简单：ServerSocketChannel server = ServerSocketChannel.open(); 支持的非阻塞事件仅支持 OP_ACCEPT 事件。 常见 API12345678910111213141516171819202122public abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel &#123; // 创建 ServerSocketChannel public static ServerSocketChannel open() throws IOException &#123;...&#125; // 返回支持的事件 public final int validOps() &#123;...&#125; // 绑定 public final ServerSocketChannel bind(SocketAddress local) throws IOException&#123;...&#125; public abstract ServerSocketChannel bind(SocketAddress local, int backlog) throws IOException; // 设置 socket 选项 public abstract &lt;T&gt; ServerSocketChannel setOption(SocketOption&lt;T&gt; name, T value) throws IOException; // 获取当前 socket public abstract ServerSocket socket(); // 监听连接，非阻塞模式下立即返回 public abstract SocketChannel accept() throws IOException; // 获取源地址和端口 public abstract SocketAddress getLocalAddress() throws IOException;&#125; 客户端和服务端 TCP 通信流程整个通信流程参考 TCP 通信流程，只是实现方式不一样。本例实现一个聊天室功能。 服务端初始化 创建 Selectorpublic static Selector open() throws IOException;，创建选择器。 创建 ServerSocketChannelpublic static ServerSocketChannel open() throws IOException;，创建服务端通道，并配置为非阻塞。 绑定 bindpublic final ServerSocketChannel bind(SocketAddress local){...}，绑定指定地址和端口。 注册 Accept 事件serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);，注册后服务端选择器开始监听客户端的连接。 服务端轮询监听并处理事件selector.select()，阻塞等待。监听客户端的连接及输入，从这里可以看出 nio 并不完全是异步，还是会有阻塞。 客户端初始化 创建 Selectorpublic static Selector open() throws IOException;，创建选择器。 创建 SocketChannelpublic static SocketChannel open() throws IOException;，创建客户端通道，并配置为非阻塞。 注册 Connect 事件socketChannel.register(selector, SelectionKey.OP_CONNECT);，注册事件后准备连接。 连接 connectpublic abstract boolean connect(SocketAddress remote) throws IOException;，连接服务器。 客户端轮询监听并处理事件selector.select()，阻塞等待。监听服务端反馈和输入。 数据通信 服务端接受连接后监听客户端写入服务端接受客户端连接后，拿到客户端 SocketChannel，并同步注册 Read 事件，监听客户端输入。通过该通道读写缓冲区实现数据通信。 客户端监听服务端发送的消息客户端接受到服务端连接响应后，客户端 SocketChannel 注册 Read 事件，监听该通道来自服务端的输入。 服务端和客户端关闭客户端和服务端分别关闭 Selector, ServerSocketChannel, SocketChannel。 服务端存在的问题：客户端的 SocketChannel 关闭后，服务端此通道并没有断开连接，并且该通道注册到选择器的读事件，会被反复触发。也就是说服务端 select 一直都会返回 OP_READ，但是通道中读入缓冲区的数据实际总是为 -1，即并没有数据。为什么会反复触发？ 123456789101112// 服务端打印信息，服务端 10000，客户端 62676client: java.nio.channels.SocketChannel[connected local=/127.0.0.1:10000 remote=/127.0.0.1:62676]client.isOpen(): trueclient.isConnected(): trueclient.isConnectionPending(): falseclient.isRegistered(): true// 1 表示为 OP_READ 事件client.keyFor(selector).interestOps(): 1client.keyFor(selector).readyOps(): 1// 通道读入缓冲区实际值为 -1，即没有数据count: -1 TCP 通信示例本例实现一个聊天室功能。 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145public class TestNIOTCPServer &#123; // private static final String HOST_NAME = "127.0.0.1"; private static final int PORT = 10000; private static final int BUFF_CAP = 1024; private Selector selector = null; private ServerSocketChannel serverSocketChannel = null; // 输入信息编解码器 private Charset charset = Charset.forName("UTF-8"); // 接收信息缓冲区 private ByteBuffer rBuffer = ByteBuffer.allocate(BUFF_CAP); /** * 服务端通道和选择器初始化，绑定端口，配置为非阻塞，并开启监听连接 * @throws IOException */ private void init() throws IOException&#123; selector = Selector.open(); serverSocketChannel = ServerSocketChannel.open(); InetSocketAddress localAddress = new InetSocketAddress(PORT); serverSocketChannel.bind(localAddress); serverSocketChannel.configureBlocking(false); serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); System.out.println("server start on port: " + PORT); &#125; /** * 服务器轮询监听通道，select 会阻塞直到监听到事件 */ private void listen()&#123; System.out.println("listen..."); try &#123; while (selector.select() &gt; 0)&#123; for (SelectionKey selectionKey : selector.selectedKeys())&#123; handleSelectorKey(selectionKey); &#125; // 清空已经处理的事件 selector.selectedKeys().clear(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocketChannel != null) &#123; serverSocketChannel.close(); &#125; if (selector != null)&#123; selector.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 处理接收到的事件 * @param selectionKey: 接收到的事件 * @throws IOException */ private void handleSelectorKey (SelectionKey selectionKey) throws IOException &#123; System.out.println("handleSelectorKey, key = " + selectionKey.readyOps()); if (selectionKey.isAcceptable())&#123; // 选择器监听到客户端连接 SocketChannel client = serverSocketChannel.accept(); client.configureBlocking(false); // 接收客户端连接后，客户端注册通道读事件 client.register(selector, SelectionKey.OP_READ); System.out.println(client.getRemoteAddress() + " connected."); &#125; if (selectionKey.isReadable())&#123; // 选择器监听到客户端通道写入 SocketChannel client = (SocketChannel) selectionKey.channel(); StringBuilder builder = new StringBuilder(); rBuffer.clear(); int count = 0;// System.out.println("client: " + client.toString());// System.out.println("opened: " + client.isOpen());// System.out.println("connected: " + client.isConnected());// System.out.println("connectionPending: " + client.isConnectionPending());// System.out.println("isRegistered: " + client.isRegistered());// System.out.println("interest keys: " + client.keyFor(selector).interestOps());// System.out.println("ready keys: " + client.keyFor(selector).readyOps()); try &#123; // 通道读入缓冲区 while ((count = client.read(rBuffer)) &gt; 0)&#123; rBuffer.flip(); builder.append(charset.decode(rBuffer)); &#125; System.out.println(client.toString() + ":" + builder); if (count &lt; 0)&#123; // 当客户端退出时，服务端的 socket 通道仍然打开并处于连接状态 // 服务端的 select 一直会被触发，但是读取的结果一直是 -1 // 所以可以认为此时客户端已经断开，读取结束后关闭通道，使 key 失效 System.out.println(client.toString() + " has been closed."); selectionKey.cancel(); if (client != null)&#123; client.close(); &#125; &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); // 读取异常，可能是客户端已经断开连接，关闭该通道 System.out.println(client.toString() + " disconnected."); selectionKey.cancel(); if (client != null)&#123; client.close(); &#125; &#125; if (builder.length() &gt; 0)&#123; dispatchInfoToAllClient(client, builder.toString()); &#125; &#125; &#125; /** * 当前客户端输入信息，广播到其他客户端 * @param client: 接收到输入信息的当前客户端 * @param info: 接收到的信息 * @throws IOException: 其他客户端写入异常 */ private void dispatchInfoToAllClient(SocketChannel client, String info) throws IOException &#123; // System.out.println("dispatchInfoToAllClient, info = " + info); String name = "[" + client.getRemoteAddress() + "-" + client.hashCode() + "]"; for (SelectionKey key : selector.keys())&#123; Channel targetChannel = key.channel(); if (targetChannel instanceof SocketChannel)&#123; SocketChannel dest = (SocketChannel) targetChannel; if (!client.equals(dest)) &#123; // 通道写入缓冲区 dest.write(charset.encode(name + ":" + info)); &#125; &#125; &#125; &#125; public static void main(String[] args) throws IOException &#123; TestNIOTCPServer server = new TestNIOTCPServer(); server.init(); server.listen(); &#125;&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public class TestNIOTCPClient &#123; private static final String HOST_NAME = "127.0.0.1";// private static final String HOST_NAME = "10.20.6.25"; private static final int PORT = 10000; private static final int BUFF_CAP = 1024; private Selector selector = null; private SocketChannel client = null; // 通道读写信息编解码器 private Charset charset = Charset.forName("UTF-8"); // 缓冲区，读取服务端写入的信息 ByteBuffer rBuffer = ByteBuffer.allocate(BUFF_CAP); private volatile boolean isQuit = false; /** * 客户端通道，选择器初始化，连接到指定服务器，并监听连接事件 * 开启后台线程读取屏幕输入信息，写入服务器 * @throws IOException */ private void init() throws IOException &#123; selector = Selector.open(); client = SocketChannel.open(); client.configureBlocking(false); client.register(selector, SelectionKey.OP_CONNECT); InetSocketAddress remote = new InetSocketAddress(HOST_NAME, PORT); client.connect(remote); // 开启线程读取客户端输入 ReadThread readThread = new ReadThread(); readThread.setDaemon(true); readThread.start(); &#125; /** * 客户端轮询监听通道，当事件到达后处理事件 * 如果输入 exit/quit ，客户端退出 */ private void listen()&#123; try &#123; while (selector.select() &gt; 0 &amp;&amp; !isQuit)&#123; for (SelectionKey selectionKey : selector.selectedKeys())&#123; handleSelectionKey(selectionKey); &#125; selector.selectedKeys().clear(); &#125; System.out.println("listen: quit..."); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (selector != null)&#123; System.out.println("close selector"); selector.close(); &#125; if (client != null)&#123; System.out.println("close client"); client.close(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; /** * 处理监听到的事件 * @param selectionKey * @throws IOException */ private void handleSelectionKey(SelectionKey selectionKey) throws IOException &#123; if (selectionKey.isConnectable())&#123; // SocketChannel client = (SocketChannel) selectionKey.channel(); System.out.println("connected: " + client.isConnected()); System.out.println("connectionPending: " + client.isConnectionPending()); if (client.isConnectionPending())&#123; client.finishConnect(); System.out.println("connected: " + client.getRemoteAddress()); // 客户端连接成功后，注册通道读事件，读取从服务端写入的数据 client.register(selector, SelectionKey.OP_READ); &#125; &#125; if (selectionKey.isReadable())&#123; // 选择器监听到服务端写入事件，读取后显示在客户端 //SocketChannel client = (SocketChannel) selectionKey.channel(); StringBuilder builder = new StringBuilder(); rBuffer.clear(); while (client.read(rBuffer) &gt; 0)&#123; rBuffer.flip(); builder.append(charset.decode(rBuffer)); &#125; System.out.println(builder); &#125; &#125; /** * 读取屏幕输入的线程 */ private class ReadThread extends Thread&#123; @Override public void run() &#123; Scanner scanner = new Scanner(System.in); try &#123; while (scanner.hasNextLine()) &#123; String line = scanner.nextLine(); if (isQuited(line)) &#123; scanner.close(); isQuit = true; selector.wakeup(); break; &#125; else &#123; client.write(charset.encode(line)); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 判断是否退出 * @param value * @return */ private boolean isQuited(String value) &#123; value = value.trim(); return value.equalsIgnoreCase("quit") || value.equalsIgnoreCase("exit"); &#125; public static void main(String[] args) throws IOException &#123; TestNIOTCPClient client = new TestNIOTCPClient(); client.init(); client.listen(); &#125;&#125; DatagramChannel[todo]http://ifeve.com/datagram-channel/http://blog.csdn.net/foart/article/details/47608475http://www.365mini.com/page/java-nio-course-27.htm网络编程第四版-425 参考文档 Java NIO系列教程 java nio SocketChannel 服务器端与多客户端信息交互（聊天功能） 疯狂 Java 讲义]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Net</tag>
        <tag>Socket</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO 基础]]></title>
    <url>%2F2017%2F12%2F15%2F0039-java-nio-basic%2F</url>
    <content type="text"><![CDATA[NIO: Non-blocking IO，是指 jdk1.4 及以上版本里提供的 New IO。NIO 弥补了原来的 I/O 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O，所有数据都是用缓冲区处理的。 基本概念NIO 将最耗时的 I/O 操作（即填充和提取缓冲区）转移回操作系统，因而可以极大地提高速度。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 流和块的区别 流 I/O面向流的 I/O 系统一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。但是面向流的 I/O 通常相当慢。 块 I/O面向块的 I/O 系统以块的形式处理数据。每一个操作都在异步中产生或者消费一个数据块。按块处理数据比按（流式的）字节处理数据要快得多。但是面向块的操作较复杂。 NIO 的核心对象 Channel通道：是对原 I/O 包中的流的模拟。Channel 是一个对象，所有数据必须通过它读取和写入。默认是阻塞模式。 Buffer缓冲区：实质上是一个容器对象，所有的 NIO 数据都是通过它来处理的。发送给一个通道的所有对象都必须首先放到缓冲区中；同样从通道中读取的任何数据都要读到缓冲区中。 Channel数据交互永远不会将字节直接写入通道，或者直接从通道中读字节。通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。 通道类型通道与流的不同之处在于通道是双向的，而流是单向的（一个流必须是 InputStream 或者 OutputStream 的子类）。通道可以用于读、写或者同时用于读写。因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。 常用 Channel FileChannel从文件中读写数据，无法设置为非阻塞模式，它总是运行在阻塞模式下。 DatagramChannel通过 UDP 读写网络中的数据。 SocketChannel通过 TCP 读写网络中的数据。 ServerSocketChannel服务端，可以监听新进来的 TCP 连接。 分散/聚集 Scatter/Gather I/O分散/聚集 Scatter/Gather I/O：用于描述从通道中读取或者写入到通道的操作，但是使用多个而不是单个缓冲区来保存数据的读写方法。一个分散的读取就像一个常规通道读取，只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中。同样地，一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据。分散/聚集 I/O 对于将数据流划分为单独的部分很有用，这有助于实现复杂的数据格式。 12345678910111213public interface ScatteringByteChannel extends ReadableByteChannel &#123; public long read(ByteBuffer[] dsts, int offset, int length) throws IOException; public long read(ByteBuffer[] dsts) throws IOException;&#125;public interface GatheringByteChannel extends WritableByteChannel &#123; public long write(ByteBuffer[] srcs, int offset, int length) throws IOException; public long write(ByteBuffer[] srcs) throws IOException;&#125; 分散读分散读取会自动找到有空间接受数据的第一个缓冲区，在这个缓冲区填满后，才能移动到下一个缓冲区。在实际运用中，适合消息长度固定的例子。如网络应用程序中，每一个消息被划分为固定长度的头部和固定长度的正文。可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区。使用分散读取来向它们读入消息时，头部和正文将整齐地划分到这两个缓冲区中。 聚集写聚集写对于把一组单独的缓冲区中组成单个数据流写入同一个通道。将数据写入到通道中时，注意缓冲区只有 position 和 limit之间的数据才会被写入，所以在实际运用中，可以写入长度不固定的消息。为了与上面的消息例子保持一致，可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流，以便跨越网络传输消息。 Buffer缓冲区实质上是一个数组，通常它是一个字节数组，也可以使用其他类型的数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。本质上是读写数据的这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。最常用的缓冲区类型是 ByteBuffer，可以在其底层字节数组上进行字节的获取和设置 get/set。每一种基本 Java 类型（除了 Boolean ）都有一种缓冲区类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 状态变量状态变量是每一个读/写操作后，记录缓冲区的状态。通过记录和跟踪这些变化，缓冲区能够内部地管理自己的资源。缓冲区有两种模式：读模式和写模式。如下三个变量，记录了缓冲区在这两个模式下的状态： capacity可以储存在缓冲区中的最大数据容量。 position写模式：表示当前位置，初始化为 0，最大值为 capacity - 1。读模式：从该位置开始读，在缓冲区从写模式切换到读模式时被重置为 0。 limit写模式：表示最多能往缓冲区写入多少数据，写模式下 limit = capacity。读模式：表示最多能读到多少数据。写模式切换为读模式时，limit 被设置为写模式下的 position，而 position 会被重置为 0，即能读到之前写入的所有数据。 其中：position &lt;= limit &lt;= capacity。读写模式切换方法 flip() 的源码： 123456public final Buffer flip() &#123; limit = position; position = 0; mark = -1; return this;&#125; 缓冲区使用的基本步骤 写入数据到 Buffer 调用 flip() 方法，切换到读模式 从 Buffer 中读取数据 调用 clear() 方法或者 compact() 方法，切换到写模式 1234567891011121314151617RandomAccessFile aFile = new RandomAccessFile("nio-data.txt", "rw");FileChannel inChannel = aFile.getChannel();//create buffer with capacity of 48 bytesByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = inChannel.read(buf); //read into buffer.System.out.println("bytesRead = " + bytesRead);while (bytesRead != -1) &#123; buf.flip(); //make buffer ready for read while (buf.hasRemaining()) &#123; System.out.print((char) buf.get()); // read 1 byte at a time &#125; buf.clear(); //make buffer ready for writing bytesRead = inChannel.read(buf);&#125;aFile.close(); 常见 API123456789101112131415161718192021222324252627282930// 缓冲区写模式切换到读模式public Buffer flip()&#123;...&#125;// 清空缓冲区public Buffer clear()&#123;...&#125;// 清除已经读过的数据，任何未读的数据都被移到缓冲区的起始处// 新写入的数据将放到缓冲区未读数据的后面public abstract ByteBuffer compact();// 读取数据public abstract byte get();public abstract byte get(int index);public ByteBuffer get(byte[] dst, int offset, int length) &#123;...&#125;public ByteBuffer get(byte[] dst) &#123;...&#125;// 写入数据public abstract ByteBuffer put(byte b);public abstract ByteBuffer put(int index, byte b);public ByteBuffer put(ByteBuffer src) &#123;...&#125;public ByteBuffer put(byte[] src, int offset, int length) &#123;...&#125;public final ByteBuffer put(byte[] src) &#123;...&#125;// 重读缓冲区public final Buffer rewind() &#123;...&#125;// 标记及重置回标记处public final Buffer mark() &#123;...&#125;public final Buffer reset() &#123;...&#125;// 判断相等public boolean equals(Object ob) &#123;...&#125;// 比较剩余元素public int compareTo(ByteBuffer that) &#123;...&#125;// 将缓冲区转换为只读，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)// 只不过它是只读的，不能将只读的缓冲区转换为可写的缓冲区 public abstract ByteBuffer asReadOnlyBuffer(); 分片片：是缓冲区的子缓冲区，根据现有的缓冲区，从当前位置创建一个子缓冲区，这个新创建的缓冲区与原来的缓冲区共享同一个底层数据数组。public abstract ByteBuffer slice(); 读写示例读和写是 I/O 的基本过程。从一个通道中读取很简单：只需创建一个缓冲区，然后让通道将数据读到这个缓冲区中；写入也相当简单：创建一个缓冲区，用数据填充它，然后让通道用这些数据来执行写入操作。在 NIO 系统中，任何时候执行一个读写操作，都是通道和缓冲区的读写交互。 读 从 FileInputStream 获取 Channel 创建 Buffer 将数据从 Channel 读到 Buffer 中 我们不需要告诉通道要读多少数据到缓冲区中，每一个缓冲区都有内部统计机制，它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据。 写 从 FileOutputStream 获取 Channel 创建 Buffer，并填充被写的数据 将数据从 Buffer 写入 Channel 这里同样不需要告诉通道要写入多数据，缓冲区的内部统计机制会跟踪它包含多少数据以及还有多少数据要写入。 示例1234567891011121314FileInputStream fin = new FileInputStream( "readandshow.txt" );FileChannel fc = fin.getChannel();ByteBuffer buffer = ByteBuffer.allocate( 1024 );fc.read( buffer );FileOutputStream fout = new FileOutputStream( "writesomebytes.txt" );FileChannel fc = fout.getChannel();ByteBuffer buffer = ByteBuffer.allocate( 1024 ); for (int i=0; i&lt;message.length; ++i) &#123; buffer.put( message[i] );&#125;buffer.flip();fc.write( buffer ); FileChannelFileChannel 是一个连接到文件的通道，可以通过文件通道读写文件。一般情况下，无法直接打开一个 FileChannel，需要通过使用 InputStream, OutputStream, RandomAccessFile 来获取 FileChannel 实例。 12345678FileInputStream fin = new FileInputStream( "readandshow.txt" );FileChannel fc = fin.getChannel();FileOutputStream fout = new FileOutputStream( "writesomebytes.txt" );FileChannel fc = fout.getChannel();RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");FileChannel inChannel = aFile.getChannel(); 常见 API123456789101112131415161718192021222324// 读写public abstract int read(ByteBuffer dst) throws IOException;public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException;public final long read(ByteBuffer[] dsts) throws IOException &#123;...&#125;public abstract int write(ByteBuffer src) throws IOException;public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException;public final long write(ByteBuffer[] srcs) throws IOException &#123;...&#125;// 关闭通道public final void close() throws IOException &#123;...&#125;// 通道当前 position，在特定位置读写 public abstract long position() throws IOException;public abstract FileChannel position(long newPosition) throws IOException; public abstract int read(ByteBuffer dst, long position) throws IOException;public abstract int write(ByteBuffer src, long position) throws IOException;// 通道文件的大小public abstract long size() throws IOException;// 截取文件public abstract FileChannel truncate(long size) throws IOException;// 将通道里尚未写入磁盘的数据，强制写到磁盘上public abstract void force(boolean metaData) throws IOException; 通道之间数据传输如果两个通道中有一个是 FileChannel，那你可以直接将数据从一个通道中传输到另外一个通道。 1234public abstract long transferTo(long position, long count, WritableByteChannel target) throws IOException;public abstract long transferFrom(ReadableByteChannel src, long position, long count) throws IOException; 参数解析： WritableByteChannel可写通道，即目标通道，将当前通道数据传输到目标通道。 ReadableByteChannel可读通道，即源通道，源通道数据传输到当前通道。 position文件传输开始的位置。 count传输的最大字节数。 示例： 1234567891011RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw");FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile("toFile.txt", "rw");FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();toChannel.transferFrom(position, count, fromChannel);// 或者使用 transferTo// fromChannel.transferTo(position, count, toChannel); 文件锁文件锁定是一个复杂的操作，特别不同的操作系统是以不同的方式来实现锁的，为了尽可能保持代码的可移植性： 只使用排它锁 将所有的锁视为劝告式的 12345678910111213141516171819// 文件锁，只能通过 FileChannel.java 来获取// 阻塞锁，shared 为 true 表示共享锁，为 false 表示排他锁public abstract FileLock lock(long position, long size, boolean shared) throws IOException;// 获取排他锁public final FileLock lock() throws IOException &#123;...&#125;// 非阻塞锁public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException;// 排他锁public final FileLock tryLock() throws IOException &#123;...&#125;// 文件锁public abstract class FileLock implements AutoCloseable &#123; // 释放锁 public abstract void release() throws IOException; public final void close() throws IOException &#123;...&#125; ...&#125; 将文件映射到内存内存映射文件，是由一个文件到一块内存的映射。使用内存映射文件处理存储于磁盘上的文件时，将不必再对文件执行 I/O 操作，使得内存映射文件在处理大数据量的文件时能有很高的性能。 123456789101112131415161718public static class MapMode &#123; // Mode for a read-only mapping. public static final MapMode READ_ONLY = new MapMode("READ_ONLY"); // Mode for a read/write mapping. public static final MapMode READ_WRITE = new MapMode("READ_WRITE"); // Mode for a private (copy-on-write) mapping. public static final MapMode PRIVATE = new MapMode("PRIVATE"); ...&#125;// 返回一个缓冲区，可以高性能的读写这块区域public abstract MappedByteBuffer map(MapMode mode, long position, long size) throws IOException; 字符集字符集用来把 Unicode 字符编码和其它字符编码互转。Charset 是十六位 Unicode 字符序列与字节序列之间的一个命名的映射。要读和写文本，我们要分别使用 CharsetDecoder 和 CharsetEncoder，即编码器和解码器。CharsetDecoder 用于将逐位表示的一串字符转换为具体的 char 值，而 CharsetEncoder 用于将字符转换回位。Java 实现都要求对以下字符编码提供完全的支持： US-ASCII ISO-8859-1 UTF-8 UTF-16BE UTF-16LE UTF-16 PipeNIO 管道是 2 个线程之间的单向数据连接。Pipe 有两个通道： source 通道：数据从该通道读取 sink 通道：数据从该通道写入 源码1234567891011121314151617public static abstract class SourceChannel extends AbstractSelectableChannel implements ReadableByteChannel, ScatteringByteChannel&#123;...&#125; public static abstract class SinkChannel extends AbstractSelectableChannel implements WritableByteChannel, GatheringByteChannel&#123;...&#125;// 打开一个管道public static Pipe open() throws IOException &#123;...&#125;// 获取 source 通道public abstract SourceChannel source();// 获取 sink 通道public abstract SinkChannel sink();&#125; 示例12345678910111213141516Pipe pipe = Pipe.open();Pipe.SinkChannel sinkChannel = pipe.sink();String newData = "New String to write to file..." + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();while(buf.hasRemaining()) &#123; sinkChannel.write(buf);&#125;Pipe.SourceChannel sourceChannel = pipe.source();ByteBuffer buf = ByteBuffer.allocate(48);int bytesRead = sourceChannel.read(buf); NIO 与 IO 的比较简述 IO：面向流，阻塞 NIO：面向缓冲区块操作，非阻塞 面向流和面向缓存区 面向流面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。也不能前后移动流中的数据，如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 面向缓冲区数据读取到缓冲区中，并可在缓冲区中前后移动，但是维护好缓冲区的状态变量。 阻塞和非阻塞 阻塞流是阻塞的，在 read, write 时线程被阻塞，直到有一些数据被读取或数据完全写入，该线程在此期间不能再干任何事情。 非阻塞线程从通道读取或写入数据，但是当数据没准备好时直接返回不会阻塞。所以直至数据可用前，线程同时可以去做别的事情。线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道。 选择器选择器允许单个线程监视多个通道，但是解析数据时会更复杂。常见应用为多连接但是传输少量数据，如聊天系统；或者少量连接大量数据用来做服务器。 参考文档 Java 源码 NIO 入门 Java NIO系列教程]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket 编程]]></title>
    <url>%2F2017%2F12%2F08%2F0038-java-socket%2F</url>
    <content type="text"><![CDATA[基础所谓 socket 通常也称作”套接字”，用于描述 IP 地址和端口，是一个通信链的句柄。网络上具有唯一标识的 IP 地址和端口组合在一起才能构成唯一能识别的标识符套接字，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。 几个常见类 InetAddress用于标识网络上的硬件资源，主要表示 IP 地址。 SocketAddress表示 Sokcet 地址，不包含使用的具体协议，是一个抽象类。 InetSocketAddress继承了 SocketAddress，包含主机名，IP 地址和端口（hostname, InetAddress, port）。 Socket客户端 Socket，默认采用的传输层协议为 TCP。 ServerSocket服务器 Socket，默认采用的传输层协议为 TCP。等待客户端请求，并基于这些请求执行操作返回一个结果。 SocketImpl通用抽象类，用来创建客户端和服务端具体的 Socket。Socket 通信流程的所有方法都是通过该类和子类实现的。 DatagramPacket表示存放数据的数据报。 DatagramSocket实现了一个发送和接收数据报的 socket，传输层协议使用 UDP。客户端和服务端都使用该套接字来实现通信。 传输协议 TCP:Tranfer Control Protocol是一种面向连接的保证可靠传输的协议，通过 TCP 协议传输，得到的是一个顺序的无差错的数据流。发送方和接收方的成对的两个 socket 之间必须建立连接，以便在 TCP 协议的基础上进行通信，当一个 server socket 等待建立连接 accept 时，客户端 socket 可以要求进行连接。一旦连接起来后，它们就可以进行双向数据传输，双方都可以进行发送或接收数据。 UDP:User Datagram Protocol是一种无连接的协议，每个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。传输数据时数据报大小必须限定在 64KB 之内。 端口区分一台主机的多个不同应用程序，端口号范围为 0-65535，其中 0-1023 位为系统保留。如：HTTP：80 FTP：21 Telnet：23。 五元组通信术语，通常是指：源 IP 地址，源端口，目的 IP 地址，目的端口和传输层协议，两台计算机通信必须要明确指定五元组的值。 地址和端口Socket 中包含了源和目标的 IP 地址，端口。 传输协议类型Socket 表示 TCP 协议；DatagramSocket 表示 UDP 协议。 输入输出流读写Soket 数据连接是全双工的，一旦建立连接可以得到 Socket 的输入流和输出流，主机可以使用这两个流同时发送和接受数据。流是同步的，也就是说当请求流读/写一段数据时，阻塞等待直到有数据。Java 还支持使用通道和缓冲区的非阻塞 I/O（NIO），暂不讨论。 socket.getInputStream()获取输入流，通过输入流读取数据。 socket.getOutputStream()获取输出流，通过输出流写入数据。 ？？关闭一个流也会也会关闭一个 Sokcet 连接。？？对于同一个 Socket，如果关闭了输出流，则与该输出流关联的 Socket 也会被关闭，所以一般不用关闭流，直接关闭 Socket 即可。 Socket 原理机制 通信的两端都有 Socket 网络通信其实就是 Socket 间的通信 数据在两个 Socket 间通过 IO 传输 四种常见异常以下四种类型异常都是继承于 IOException，所以很多之后直接弹出 IOException 即可。 UnkownHostException：主机名字或 IP 错误 ConnectException：服务器拒绝连接、服务器没有启动、超出队列数，拒绝连接等 SocketTimeoutException：连接超时 BindException：Socket 对象无法与指定的本地 IP 地址或端口绑定 Socket构造方法123456Socket(String host, int port)throws UnknownHostException, IOExceptionSocket(InetAddress address, int port) throws IOExceptionSocket(String host, int port, InetAddress localAddr, int localPort) throws IOExceptionSocket(InetAddress address, int port, InetAddress localAddr, int localPort) throws IOException...private Socket(SocketAddress address, SocketAddress localAddr, boolean stream) throws IOException Socket 有多个构造方法，但是最终调用的是最后一个。至少需要指定目的主机名 host 或者 IP 地址，以及端口号 port。参数解析： address远程即服务端，包含目标 IP 地址，主机名，端口。不能为空，否则会抛出异常。 localAddr本地即客户端，包含源 IP 地址，主机名，端口。如果为空，表示系统自动分配。 stream为 true 表示使用流式连接即 TCP 方式；为 false 表示使用数据报即 UDP 方式。默认为 true。 关闭在 try - finally 块中采用 close-if-not-null 来关闭 Socket 连接。 Socket 选项 TCP_NODELAY设置为 true 可以保证无论包的大小都会尽快发送，不用缓冲到足够大的数据包。 SO_LINGER指定 Socket 关闭时，还没有发送的数据包如何处理。默认情况下 close 方法会立即返回，但系统会尝试发送剩余的数据。如果延迟时间设置为 0，所有未发送数据都会被丢弃。如果设置了事件，close 会阻塞到指定时间，等待数据接收和确认，如果超出时间，剩余数据将会被丢弃。 SO_TIMEOUTSocket 在读取数据时，read() 会阻塞尽可能长的时间。如果设置后，阻塞时间不会超过指定时间，否则会抛出异常，但是 Socket 仍然是处于连接状态，下次可以继续读。 SO_RCVBUFTCP 使用缓冲区提升性能，参数为设置接受缓冲区大小。 SO_SNDBUF设置发送缓冲区大小。 SO_KEEPALIVE默认值为 false，如果打开，在 Sokcet 没有数据传输时，每两个小时客户端会发送一个数据包确保服务器是正常的。 SO_OOBINLINE参数被设置时，TCP 会发送一个紧急数据包，接受方收到后会优先处理。 SO_REUSEADDR设置 Socket 是否可以重复使用端口，默认是也可以的。 IP_TOS设置数据拥堵时的处理策略。 常见 API socket.getRemoteSocketAddress()获取目的 IP 地址，主机名，端口。 socket.getInetAddress()获取目的 IP 地址，主机名。 socket.getPort()获取目的端口。 socket.getLocalSocketAddress()获取源 IP 地址，主机名，端口。 socket.getLocalAddress()获取源 IP 地址，主机名。 socket.getLocalPort()获取源端口。 SocketServer构造方法1234public ServerSocket() throws IOException public ServerSocket(int port) throws IOException public ServerSocket(int port, int backlog) throws IOException public ServerSocket(int port, int backlog, InetAddress bindAddr) throws IOException 参数解析： port服务器端口号，0 表示自动分配的端口。 backlog请求链接队列的最大长度。 bindAddr服务器将绑定的本地地址 InetAddress 关闭在 try - finally 块中采用 close-if-not-null 来关闭 SocketServer 连接。 Socket 选项 SO_TIMEOUT设置 Socket 阻塞的时间，如：accept, read, receive。 SO_REUSEADDR设置 Socket 是否可以重复使用端口，默认是也可以的。 SO_RCVBUF设置 Socket 接受数据缓冲区大小。 日志 log服务器需要形成记录日志的习惯，来记录客户端访问信息，出现的错误等等。 多线程设计通常服务端会有多个客户端访问，所以可以设置一个线程池来处理每个客户端的请求，避免阻塞。 常见 API serverSocket.getLocalSocketAddress()获取本地 IP 地址，主机名，端口。典型值为 0.0.0.0/0.0.0.0:***。 serverSocket.getInetAddress()获取本地 IP 地址，典型值为 0.0.0.0/0.0.0.0，即自动分配的本地地址。 serverSocket.getLocalPort获取本地端口，即 Socket 通信服务端中的目的端口。 客户端和服务端的 TCP 通信步骤通信流程图 大概流程如下： 服务端 SocketServer 初始化 服务端等待并接受客户端的连接 accept 客户端 Socket 初始化 数据通信 关闭输入输出流，再关闭 Socket/SocketServer 服务端 SocketServer 初始化 创建 SocketSocketImpl.java: protected abstract void create(boolean stream) throws IOException;，创建服务端 Socket。 绑定 bindSocketImpl.java: protected abstract void bind(InetAddress host, int port) throws IOException;，显示指定或者系统自动分配本地 IP 地址及空闲端口，绑定后形成目的 IP 地址和端口。 监听 listenSocketImpl.java: protected abstract void listen(int backlog) throws IOException;，设置请求连接队列的最大值。 这三步都在 ServerSocket 的构造方法中实现，不用显示调用。 服务端等待接受连接 accept12SocketServer.java: public Socket accept() throws IOException;SocketImpl.java: protected abstract void accept(SocketImpl s) throws IOException; 阻塞等待，监听和接受客户端的 Socket 连接，并返回服务端的 Socket，最终会调用 SocketImpl 的方法接受连接。 客户端 Socket 初始化 创建 SocketSocketImpl.java: protected abstract void create(boolean stream) throws IOException;，创建客户端 Socket。 绑定 bindSocketImpl.java: protected abstract void bind(InetAddress host, int port) throws IOException;，显示指定或者系统自动分配本地 IP 地址及空闲端口，绑定后形成源 IP 地址和端口。 连接 connect 12345Socket.java: public void connect(SocketAddress endpoint) throws IOExceptionSocket.java: public void connect(SocketAddress endpoint, int timeout) throws IOExceptionSocketImpl.java: protected abstract void connect(String host, int port) throws IOException;SocketImpl.java: protected abstract void connect(InetAddress address, int port) throws IOException;SocketImpl.java: protected abstract void connect(SocketAddress address, int timeout) throws IOException; SocketAddress 包含目标 IP 地址和端口，在指定时间内连接服务端的 Socket。如果 timeout 为 0，表示不限时。 这三步都在 Socket 的构造方法中实现，不用显示调用。也就是说客户端在 TCP 协议的 Socket 编程中，非常简单，只需要指定目的 SocketAddress，就可以直接获取输入输出流来读写数据。 数据通信 服务端建立连接后通过输入流读取客户端发送的请求信息；通过输出流向客户端发送响应信息。 客户端建立连接后通过输出流向服务器端发送请求信息；通过输入流读取服务端响应的信息。 关闭输入输出流，再关闭 SocketServerSocket 和 Socket 没有先后关闭的必然顺序。ServerSocket 先关闭，并不会影响当前已经连接的 Sokcet TCP 通信示例流程图 服务端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157public class TestTCPSocketServer &#123; private static final String QUIT = "quit"; private static final String EXIT = "exit"; private volatile boolean isQuited = false; private ServerSocket ss = null; private Socket socket = null; private Thread listenQuit; private ListenRunnable listenRunnable; private ExecutorService threadPool; private class ListenRunnable implements Runnable&#123; private ServerSocket ss; public ListenRunnable(ServerSocket ss)&#123; this.ss = ss; &#125; @Override public void run() &#123; try &#123; // server exit. BufferedReader ssRead = new BufferedReader( new InputStreamReader(System.in)); System.out.println(Thread.currentThread().getName() + " listen server input..."); String ssInput = ssRead.readLine(); System.out.println(ssInput); if (willQuit(ssInput)) &#123; ssRead.close(); isQuited = true; &#125; &#125; catch (IOException e)&#123; System.err.println(e); &#125; finally &#123; if (isQuited) &#123; // 服务端退出时关闭线程池 if (threadPool != null &amp;&amp; !threadPool.isShutdown()) &#123; threadPool.shutdown(); &#125; closeServerSocket(ss); &#125; &#125; &#125; &#125; private class ClientCallable implements Callable&lt;Void&gt;&#123; private Socket socket; public ClientCallable(Socket socket)&#123; this.socket = socket; &#125; @Override public Void call() &#123; try &#123; String origHost = socket.getInetAddress().toString(); BufferedReader in = new BufferedReader( new InputStreamReader(socket.getInputStream())); //PrintWriter out = new PrintWriter( // socket.getOutputStream(), true); String line = in.readLine(); while (line != null &amp;&amp; !willQuit(line)) &#123; System.out.println(origHost + ", you input is : " + line); line = in.readLine(); &#125; //out.println("you input is :" + line); //out.close(); in.close(); &#125; catch (IOException e)&#123; System.err.println(e); &#125; finally &#123; closeSocket(socket); &#125; return null; &#125; &#125; private void closeSocket(Socket socket)&#123; if (socket == null) return; try &#123; System.out.println(socket.getInetAddress().toString() + " closed."); socket.close(); &#125; catch (IOException e)&#123; System.err.println(e); &#125; &#125; private void closeServerSocket(ServerSocket ss)&#123; if (ss == null) return; try &#123; System.out.println("Server closed"); ss.close(); &#125; catch (IOException e)&#123; System.err.println(e); &#125; &#125; // 客户端和服务端，接受到 exit/quit 表示退出 private boolean willQuit(String str)&#123; return str != null &amp;&amp; (str.equalsIgnoreCase(QUIT) || str.equalsIgnoreCase(EXIT)); &#125; private void startServerDaemon(ServerSocket ss)&#123; listenRunnable = new ListenRunnable(ss); listenQuit = new Thread(listenRunnable); listenQuit.setDaemon(true); listenQuit.start(); &#125; private void run()&#123; try &#123; // 2. 初始化 ServerSocket，并绑定端口 ss = new ServerSocket(10000); // 3. 启动后台线程监听服务端终端输入 startServerDaemon(ss); System.out.println("serverSocket.getInetAddress: " + ss.getInetAddress()); System.out.println("serverSocket.getLocalSocketAddress: " + ss.getLocalSocketAddress()); System.out.println("serverSocket.getLocalPort: " + ss.getLocalPort()); System.out.println("The server is waiting you connect and input..."); while (!isQuited) &#123; // 4. 循环等待客户端连接 socket = ss.accept(); System.out.println("Socket: " + socket + " connected."); // 5. 线程池为每个客户端连接分配一个线程独立处理双方通信 Callable&lt;Void&gt; client = new ClientCallable(socket); threadPool.submit(client); System.out.println("ReAccept..."); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; closeSocket(socket); closeServerSocket(ss); &#125; &#125; public TestTCPSocketServer() &#123; // 1. 初始化线程池 threadPool = Executors.newFixedThreadPool(20); &#125; public static void main(String[] args) &#123; TestTCPSocketServer server = new TestTCPSocketServer(); server.run(); &#125;&#125; 大致思路： 初始化线程池，用于接受并执行客户端的请求任务 创建 ServerSocket 对象，绑定监听端口 开启后台线程，监听终端输入 exit/quit 循环调用 accept() 方法，监听客户端请求 接收到请求后，为每个客户端创建 Socket 专线连接 线程池为每个客户端提供一个单独线程用于 Socket 通信 服务器端继续等待新的客户端连接 独立线程中，通过输入流读取客户端发送的请求信息，通过输出流向客户端发送响应信息 客户端断开连接后，关闭相关资源，并关闭该 Socket，释放当前线程 服务端接收到终端输入退出指令后，关闭线程池并关闭 ServerSocket 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class TestTCPSocketClient &#123; private static final String QUIT = "quit"; private static final String EXIT = "exit"; Socket socket = null; public TestTCPSocketClient() &#123; try &#123; socket = new Socket("127.0.0.1", 10000); //socket = new Socket("10.20.6.25", 10000); System.out.println("Socket: " + socket); System.out.println("socket.getRemoteSocketAddress: " + socket.getRemoteSocketAddress()); System.out.println("socket.getInetAddress: " + socket.getInetAddress()); System.out.println("socket.getPort: " + socket.getPort()); System.out.println("socket.getLocalSocketAddress: " + socket.getLocalSocketAddress()); System.out.println("socket.getLocalAddress: " + socket.getLocalAddress()); System.out.println("socket.getLocalPort: " + socket.getLocalPort()); // in = new BufferedReader(new InputStreamReader( // socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream() , true); BufferedReader line = new BufferedReader( new InputStreamReader(System.in)); System.out.println("read line! block..."); String read = line.readLine(); while (!willQuit(read)) &#123; out.println(read); read = line.readLine(); &#125; System.out.println("read over!"); line.close(); out.close(); //in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e)&#123; System.err.println(e); &#125; &#125; &#125; &#125; private boolean willQuit(String str)&#123; return str != null &amp;&amp; (str.equalsIgnoreCase(QUIT) || str.equalsIgnoreCase(EXIT)); &#125; public static void main(String[] args) &#123; new TestTCPSocketClient(); &#125;&#125; 大致思路： 创建 Socket 对象，指明需要连接的服务器的地址和端口号 连接建立后，从终端读取输入信息 通过输出流向服务器端发送读取到的信息 通过输入流获取服务器响应的信息 关闭相关资源，关闭 Socket DatagramPacket数据报（Datagram）：将数据填充到 UDP 包中。数据报存放到 DatagramPacket 中，而 DatagramSocket 用来收发数据报。数据报的所有信息都包含在这个包中（包括发往的目标地址），Socket 只需要了解端口监听和发送。UDP 这种模式并没有像 TCP 那样两台主机有唯一连接的概念，一个 Socket 会收发所有指定端口的数据，而不会关心对方是哪个主机。 DatagramSocket 可以从多个独立主机收发数据，与 TCP 不同，这个 Socket 并不会专用于某个连接。TCP 中 Socket 把网络连接看作是一个流，通过输入输出流来收发数据。但是 UDP 处理的总是单个数据报包，填充在数据报包中的所有数据会以一个包的形式发送，这些数据要么全部接受，要么全部丢弃。一个包与另一个包并不一定相关，而且无法确认先后顺序。对于流必须提供数据的有序队列，而数据报会尽可能快的发送到接收方。 UDP 服务端通常不需要使用多线程，不会阻塞等待客户端的响应，除非为了应对大量耗时工作才会使用多线程。 UDP 数据报是基于 IP 数据报建立的，只向其底层 IP 数据添加了很少的内容（8 个字节的首部信息）。UDP 包中数据的理论长度为 65507 个字节，但实际上很多平台限制往往是 8KB （8192 字节），大多数情况下更大的包会被简单的截取为 8KB。并且为了保证安全性，UDP 包的数据部分应该尽量少于 512 字节。 构造方法12345678910// 接受数据报public DatagramPacket(byte buf[], int offset, int length) &#123;...&#125;public DatagramPacket(byte buf[], int length) &#123;...&#125;// 发送数据报public DatagramPacket(byte buf[], int offset, int length, InetAddress address, int port) &#123;...&#125;public DatagramPacket(byte buf[], int offset, int length, SocketAddress address) &#123;...&#125;public DatagramPacket(byte buf[], int length, InetAddress address, int port) &#123;...&#125;public DatagramPacket(byte buf[], int length, SocketAddress address) &#123;...&#125; 注意：DatagramPacket 虽然都是构造方法，但是有 2 个是接收数据报的构造方法，剩余 4 个是发送数据报的构造方法。普通情况下构造方法主要用于不同对象提供不同的类型信息，而不是像数据报这样提供不同的功能对象。 参数解析： buf[]保存接收或发送数据的数组，也就是不管是发送还是接受拿到的都是字节数组。 length数组中用于接受或发送数据的长度。 offset数组的偏移量，默认为 0。 InetAddress发送数据时接收方的 IP 地址。 port发送数据时接收方的端口。 SocketAddress发送数据时接收方的地址和端口 get 方法get 方法可以获取构造方法中传进来的所有参数信息。 12345678910// 获取 IP 地址和端口public synchronized InetAddress getAddress() &#123;...&#125;public synchronized int getPort()&#123;...&#125;public synchronized SocketAddress getSocketAddress() &#123;...&#125;// 获取数据数组public synchronized byte[] getData() &#123;...&#125;// 数组偏移量public synchronized int getOffset() &#123;...&#125;// 数组长度public synchronized int getLength() &#123;...&#125; set 方法set 方法可以在构造方法创建数据报后，改变所有的数据报信息，相当于重新创建了一个数据报。因为 DatagramPacket 对象的重复创建和垃圾回收影响性能，所以重用对象比构造对象快的多。 12345678// 设置 IP 地址和端口public synchronized void setAddress(InetAddress iaddr) &#123;...&#125;public synchronized void setPort(int iport) &#123;...&#125;public synchronized void setSocketAddress(SocketAddress address) &#123;...&#125;// 设置数据数组，偏移量，长度public synchronized void setData(byte[] buf) &#123;...&#125;public synchronized void setData(byte[] buf, int offset, int length) &#123;...&#125;public synchronized void setLength(int length) &#123;...&#125; 注意：所有的 set 方法都加了同步锁。 DatagramSocket要收发数据报，需要先打开一个 DatagramSocket，而所有的 DatagramSocket 必须绑定一个本地端口，这个端口用来监听收发的数据，并写入数据报的首部。DatagramSocket 只存储本地地址和端口，所有的远程地址和端口都在 DatagramPacket 中，所以 DatagramSocket 可以同时和多台主机收发数据（只要 DatagramPacket 不同就可以了）。 构造方法123456public class DatagramSocket implements java.io.Closeable &#123; public DatagramSocket() throws SocketException &#123;...&#125; public DatagramSocket(int port) throws SocketException &#123;...&#125; public DatagramSocket(int port, InetAddress laddr) throws SocketException &#123;...&#125; public DatagramSocket(SocketAddress bindaddr) throws SocketException &#123;...&#125;&#125; 收发数据报12public void send(DatagramPacket p) throws IOException &#123;...&#125;public synchronized void receive(DatagramPacket p) throws IOException &#123;...&#125; send 用来发送数据报；receive 加了同步锁，并且会阻塞当前线程，直到有数据到达，接收一个数据报。 常见 API1234567891011// 关闭 socketpublic void close() &#123;...&#125;// 获取源 IP 和端口public SocketAddress getLocalSocketAddress() &#123;...&#125;public InetAddress getLocalAddress() &#123;...&#125;public int getLocalPort() &#123;...&#125;// 连接指定地址和端口，仅能和这台主机通信，其他主机将断开 public void connect(SocketAddress addr) throws SocketException &#123;...&#125;public void connect(InetAddress address, int port) &#123;...&#125;// 断开连接，恢复可以和多台主机收发数据public void disconnect() &#123;...&#125; Socket 选项 SO_TIMEOUTSocket 在接收数据时，receive() 会阻塞尽可能长的时间。如果设置后，阻塞时间不会超过指定时间，否则会抛出异常。设置为 0 表示永不超时。 SO_RCVBUFUDP 设置网络接收缓冲区大小，与 TCP 对比，UDP 应该设置足够大的缓冲区。 SO_SNDBUF建议发送缓冲区大小，但是操作系统可以忽略这个建议。 SO_REUSEADDR和 TCP Socket 的意义不同，设置后表示是否允许多个数据报同时绑定到相同的端口和地址。重用端口通常会用于 UDP 组播。 SO_BROADCAST控制是否允许一个 Socket 向广播地址收发包，默认是打开的。UDP 广播通常用于 DHCP 协议，路由器和网关一般不转发广播消息，但仍然会在本地网络中带来大量业务流。 IP_TOS设置数据拥堵时的处理策略。 UDP 通信示例流程图 服务端12345678910111213141516171819202122232425262728293031323334public class TestDayTimeUDPServer &#123; private static final int PORT = 13; private static final int CAPACITY = 1024; private static final Logger audit = Logger.getLogger("requests"); private static final Logger errors = Logger.getLogger("errors"); public static void main(String[] args) &#123; DatagramSocket datagramSocket = null; try &#123; datagramSocket = new DatagramSocket(PORT); System.out.println("Source: " + datagramSocket.getLocalSocketAddress()); while (true)&#123; try &#123; DatagramPacket request = new DatagramPacket( new byte[CAPACITY], CAPACITY); datagramSocket.receive(request); String dayTime = new Date().toString(); byte[] data = dayTime.getBytes("US-ASCII"); DatagramPacket response = new DatagramPacket(data, data.length, request.getAddress(), request.getPort()); datagramSocket.send(response); System.out.println("Destination: " + request.getSocketAddress()); audit.info(dayTime + " " + request.getAddress()); &#125; catch (IOException e)&#123; errors.log(Level.SEVERE, e.getMessage(), e); &#125; &#125; &#125; catch (IOException e)&#123; errors.log(Level.SEVERE, e.getMessage(), e); &#125; &#125;&#125; 大致思路： 创建 DatagramSocket，绑定端口号 创建 DatagramPacket，指定目标地址和端口 阻塞等待接收客户端发送的数据 向客户端发送响应数据 客户端12345678910111213141516171819202122232425262728293031323334public class TestUDPGetDayTime &#123; // private static final String HOSTNAME = "time.nist.gov"; // private static final String HOSTNAME = "129.6.15.28"; private static final String HOSTNAME = "127.0.0.1"; private static final int PORT = 38910; private static final int DELAY_TIME = 10000; private static final int CAPACITY = 1024; public static void main(String[] args) &#123; DatagramSocket datagramSocket = null; try &#123; datagramSocket = new DatagramSocket(); datagramSocket.setSoTimeout(DELAY_TIME); InetAddress host = InetAddress.getByName(HOSTNAME); DatagramPacket request = new DatagramPacket(new byte[1], 1, host, PORT); DatagramPacket response = new DatagramPacket(new byte[CAPACITY], CAPACITY); datagramSocket.send(request); System.out.println("Source: " + datagramSocket.getLocalSocketAddress()); System.out.println("Destination: " + request.getSocketAddress()); // block. datagramSocket.receive(response); String dayTime = new String(response.getData(), 0, response.getLength(), "US-ASCII"); System.out.println(dayTime); &#125; catch (IOException e)&#123; System.err.println(e); &#125; finally &#123; if (datagramSocket != null) &#123; datagramSocket.close(); &#125; &#125; &#125;&#125; 大致思路： 定义发送信息，并存储到数组中 创建 DatagramPacket，指定目标地址和端口，数据数组 创建 DatagramSocket，绑定本地端口 向服务端请求数据 从服务端获取响应数据 参考文档 Java Socket编程 Socket和ServerSocket学习笔记 Java网络socket编程详解 TCP数据段格式+UDP数据段格式详解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Net</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java I/O 流]]></title>
    <url>%2F2017%2F12%2F07%2F0037-java-io-stream%2F</url>
    <content type="text"><![CDATA[流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。Java 的 I/O 是建立在流（Stream）之上的，输入流读取数据，输出流写入数据。流是同步的，也就是说当请求流读一段数据时，阻塞等待直到有数据。Java 还支持使用通道和缓冲区的非阻塞 I/O（NIO），暂不讨论。 流的分类按流向分类 输入流: 程序可以从中读取数据的流 输出流: 程序能向其中写入数据的流 按数据传输单位分类 字节流以字节（8 位二进制）为单位进行处理。主要用于读写诸如图像或声音的二进制数据。 字符流字符流中的对象融合了编码表，以字符为单位，根据码表映射字符，一次可能读多个字节，字符流只能处理字符文本类型的数据。字符流是对字节流进行了封装，方便操作，在最底层所有的输入输出都是字节形式的。后缀是 Stream 是字节流，而后缀是 Reader, Writer 是字符流。 按功能分类 节点流从特定的地方读写的流类，如磁盘或者一块内存区域，直接与数据源相连读入或读出。 处理流使用节点流作为输入或输出，处理流是使用一个已经存在的输入流或者输出流连接创建的。 流操作的类或接口基本类和接口 File：文件类 RandomAccessFile：随机存取文件类 InputStream：字节输入流 OutputStream：字节输出流 Reader：字符输入流 Writer：字符输出流 流类的结构图 各个类基本介绍： 文件操作FileInputStream, FileOutputStream, FileReader, FileWriter 管道操作PipedInputStream, PipedOutStream, PipedReader, PipedWriter，PipedInputStream 的实例必须要和 PipedOutputStream 的实例共同使用，共同完成管道的读取写入操作，主要用于线程操作。 字节/字符数组ByteArrayInputStream, ByteArrayOutputStream, CharArrayReader, CharArrayWriter，在内存中开辟了一个字节或字符数组。 缓冲流BufferedInputStream, BufferedOutputStream, BufferedReader, BufferedWriter，是带缓冲区的处理流。缓冲区的作用的主要目的是：避免每次和硬盘打交道，提高数据访问的效率。 转化流InputStreamReader, OutputStreamWriter，把字节转化成字符。 过滤流FilterInputStream, FileOutputStream，装饰模式，用来装饰基本流。 数据流DataInputStream, DataOutputStream，字节流只能单字节的输出，但是 long 类型（8 字节）或 float 类型（4 字节）是多字节的，需要逐字节或者转换为字符串输出，数据流提供了这个解决方案。数据流可以用二进制格式读写 Java 的基本数据类型和字符串。 打印流PrintStream, PrintWriter，一般是打印到控制台。 对象流ObjectInputStream, ObjectOutputStream，把封装的对象直接输出，而不是一个个在转换成字符串再输出。 序列化流SequenceInputStream，把对象序列化，直接转换成二进制，写入介质中。 流分类表格 Java IO 是采用的是装饰模式，即采用处理流来包装节点流的方式，来达到代码通用性 处理流和节点流的区分方法，节点流在新建时需要一个数据源（文件、网络）作为参数，而处理流需要一个节点流作为参数 处理流的作用就是提高代码通用性，编写代码的便捷性，提高性能 节点流都是对应抽象基类的实现类，它们都实现了抽象基类的基础读写方法 常见输入输出流Java 提供的基本输入输出流中，字节流类为 java.io.InputStream/OutputStream，字符流类为 java.io.Reader/Writer，它们都是抽象类，提供了读写数据需要的基本方法。 字节流1234567891011121314151617181920212223public abstract class InputStream implements Closeable &#123; // 从流中读取数据，返回值为读取的长度，-1 表示结束 // read() 默认是读取一个字节 public abstract int read() throws IOException; public int read(byte b[]) throws IOException &#123;...&#125; public int read(byte b[], int off, int len) throws IOException &#123;...&#125; // 跳过指定长度数据，返回真实跳过长度 public long skip(long n) throws IOException &#123;...&#125; // 返回流中数据长度的估计值，不会阻塞 public int available() throws IOException; // 关闭流 public void close() throws IOException;public abstract class OutputStream implements Closeable, Flushable &#123; // 向流中写入数据，write() 默认是写入一个字节 public abstract void write(int b) throws IOException; public void write(byte b[]) throws IOException &#123;...&#125; public void write(byte b[], int off, int len) throws IOException &#123;...&#125; // 如果是带有缓存数据的流，刷新才能发出缓存数据 public void flush() throws IOException; // 关闭流 public void close() throws IOException;&#125; 字符流123456789101112131415161718192021222324252627282930313233public abstract class Reader implements Readable, Closeable &#123; // 阻塞读字符 public int read(java.nio.CharBuffer target) throws IOException &#123;...&#125; public int read() throws IOException &#123;...&#125; public int read(char cbuf[]) throws IOException &#123;...&#125; abstract public int read(char cbuf[], int off, int len) throws IOException; // 跳过指定长度字符，返回实际跳过长度 public long skip(long n) throws IOException &#123;...&#125; // 流是否已经准备好可以读 public boolean ready() throws IOException &#123;...&#125; // 关闭流 abstract public void close() throws IOException; ...&#125;public abstract class Writer implements Appendable, Closeable, Flushable &#123; // 写字符 public void write(int c) throws IOException &#123;...&#125; public void write(char cbuf[]) throws IOException &#123;...&#125; abstract public void write(char cbuf[], int off, int len) throws IOException; public void write(String str) throws IOException &#123;...&#125; public void write(String str, int off, int len) throws IOException &#123;...&#125; // 追加字符到当前流中并写入 public Writer append(CharSequence csq) throws IOException &#123; public Writer append(CharSequence csq, int start, int end) throws IOException &#123;...&#125; public Writer append(char c) throws IOException &#123;...&#125; // 刷新写入流 abstract public void flush() throws IOException; // 关闭流 abstract public void close() throws IOException; ...&#125; 字节字符转换流12345678910111213141516171819public class InputStreamReader extends Reader &#123; public InputStreamReader(InputStream in) &#123;...&#125; public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException&#123;...&#125; public InputStreamReader(InputStream in, Charset cs) &#123;...&#125; public InputStreamReader(InputStream in, CharsetDecoder dec) &#123;...&#125; // 返回流的编码类型 public String getEncoding() &#123;...&#125;&#125;public class OutputStreamWriter extends Writer &#123; public OutputStreamWriter(OutputStream out, String charsetName) throws UnsupportedEncodingException&#123;...&#125; public OutputStreamWriter(OutputStream out) &#123;...&#125; public OutputStreamWriter(OutputStream out, Charset cs) &#123;...&#125; public OutputStreamWriter(OutputStream out, CharsetEncoder enc) &#123;...&#125; // 返回流的编码类型 public String getEncoding() &#123;...&#125;&#125; 字节字符转换，需要在构造方法中指定编解码类型，如果不指定使用平台默认。 InputStreamReader可对读取到的字节数据经过指定编码转换成字符。 OutputStreamWriter可对读取到的字符数据经过指定编码转换成字节。 过滤流过滤流是装饰模式中的装饰者，基本输入输出流是被装饰者，过滤流用来装饰其他基本流。过滤器流以链的形式进行连接，通过构造方法把流绑定，这种连接是永久的，过滤器无法无法与流断开连接。链中除了最后一个过滤器外，不能从中间流读取数据。 1234567891011121314151617181920212223public class FilterInputStream extends InputStream &#123; /** * The input stream to be filtered. */ protected volatile InputStream in; public int read() throws IOException &#123; return in.read(); &#125; ...&#125;public class FilterOutputStream extends OutputStream &#123; /** * The underlying output stream to be filtered. */ protected OutputStream out; public void write(int b) throws IOException &#123; out.write(b); &#125; ...&#125; 缓冲流不带缓冲的操作，每读一个字节就要写入一个字节。由于涉及磁盘的 IO 操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，速度就会提高很多！缓冲流将写入的数据存储在缓冲区中，直到缓冲区满或者刷新输出流，然后将数据一次全部写入低层输出流。 123456789101112131415161718192021public class BufferedInputStream extends FilterInputStream &#123; public BufferedInputStream(InputStream in) &#123;...&#125; public BufferedInputStream(InputStream in, int size) &#123;...&#125; ...&#125;public class BufferedOutputStream extends FilterOutputStream &#123; public BufferedOutputStream(OutputStream out) &#123;...&#125; public BufferedOutputStream(OutputStream out, int size) &#123;...&#125; ...&#125;public class BufferedReader extends Reader &#123; public BufferedReader(Reader in) &#123;...&#125; public BufferedReader(Reader in, int sz) &#123;...&#125;&#125;public class BufferedWriter extends Writer &#123; public BufferedWriter(Writer out) &#123;...&#125; public BufferedWriter(Writer out, int sz) &#123;...&#125;&#125; 参数解析： InputStream/OutputStream/Reader/Writer底层字节/字符流，可以从中读取或写入未缓冲的数据。字符缓冲流中的参数，通常会使用字节字符转换流作为参数 InputStreamReader/OutputStreamWriter。 size缓冲区的大小，默认为 8192 个字节。 参考文档 Java 源码 Java IO流学习总结 Java IO流分析整理]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>I/O</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 使用 DOM 操作 XML 文件]]></title>
    <url>%2F2017%2F11%2F30%2F0036-java-xml-dom-md%2F</url>
    <content type="text"><![CDATA[XML 简介XML(EXtensible Markup Language) 指可扩展标记语言，是一种标记语言类似 HTML。设计宗旨是传输数据，而非显示数据，是 W3C 的推荐标准。 树结构 对应的标准 XML 文件为： 123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bookstore&gt; &lt;book category="COOKING"&gt; &lt;title lang="en"&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt; &lt;book category="CHILDREN"&gt; &lt;title lang="en"&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book category="WEB"&gt; &lt;title lang="en"&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 名称解释 声明第一行为 XML 的声明，包含 XML 的版本 version ，字符编码集 encoding，是否独立 standalone。注意：这三个声明顺序不能颠倒。 version版本，基本上都是 1.0 版本。 encoding编码，常用编码 utf-8 standalone表示该 XML 是不是独立的，如果是 yes，则表示这个 XML 文档是独立的，不能引用外部的 DTD 规范文件；如果是 no，则该 XML 文档不是独立的，表示可以用外部的 DTD 规范文档。一般情况下不设置。 根元素bookstore：表示根元素。 元素 elementbook：表示为元素，可以并列多个。title, author, year, price：也是元素，它们是 book 的子元素。只是 book 元素没有值，而 title 它们每个元素有一个对应值。 文本 text&lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt;：元素 title 的文本为 Everyday Italian。 属性 attributecategory, lang：表示为元素的属性，每个元素可以有多个属性，用空格分开。Android 中布局文件就是典型的多属性无文本方案。 属性的名称和值属性：lang=&quot;en&quot;。属性的名称为：lang，对应的值为：en。 DOM 简介XML DOM (XML Document Object Model) 定义了访问和操作 XML 文档的标准方法，是 W3C（万维网联盟） 的推荐标准。DOM 把 XML 文档作为树结构来查看。能够通过 DOM 树来访问所有元素。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。 名称解释 - 节点XML 文档中的每个成分都是一个节点（Node），DOM 是这样规定的： 整个文档是一个文档节点 每个 XML 标签是一个元素节点 包含在 XML 元素中的文本是文本节点 每一个 XML 属性是一个属性节点 注释属于注释节点 在上面的 XML 中，根节点是 &lt;bookstore&gt;，文档中的所有其他节点都被包含在 &lt;bookstore&gt; 中。根节点有四个 &lt;book&gt; 节点，第一个 &lt;book&gt; 节点有四个节点：&lt;title&gt;, &lt;author&gt;, &lt;year&gt;, &lt;price&gt;，其中每个节点都包含一个文本节点：&quot;Harry Potter&quot;, &quot;J K. Rowling&quot;, &quot;2005&quot;, &quot;29.99&quot;。 注意：在 DOM 处理中一个普遍的错误是，认为元素节点包含文本。实际上元素是一个节点，文本是另外一个节点；只不过，元素节点的文本是存储在文本节点中的。 在这个例子中：&lt;year&gt;2005&lt;/year&gt;，元素节点 &lt;year&gt;，拥有一个值为 &quot;2005&quot; 的文本节点。所以 &quot;2005&quot; 不是 &lt;year&gt; 元素节点的值！ 节点树XML DOM 把 XML 文档视为一种树结构，这种树结构被称为节点树 (node-tree)。可通过这棵树访问所有节点，可以修改或删除它们的内容，也可以创建新的元素。节点树中的节点彼此之间都有等级关系，父、子和同级节点用于描述这种关系。父节点拥有子节点，位于相同层级上的子节点称为同级节点（兄弟或姐妹）。 在节点树中，顶端的节点成为根节点 根节点之外的每个节点都有一个父节点 节点可以有任何数量的子节点 叶子是没有子节点的节点 同级节点是拥有相同父节点的节点 因为 XML 数据是按照树的形式进行构造的，所以可以在不了解树的确切结构且不了解其中包含的数据类型的情况下，对其进行遍历。 节点信息nodeName 属性nodeName 属性规定节点的名称： nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document nodeValue 属性nodeValue 属性规定节点的值： 元素节点的 nodeValue 是 undefined 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 常见 nodeName 和 nodeValue 的对应关系： 节点类型 nodeName 的返回值 nodeValue 的返回值 Document #document null Element element name null Attr 属性名称 属性值 Comment #comment 注释文本 Text #text 节点内容 表中可以看出，基本只有属性节点的 nodeValue 有意义。 nodeType 属性nodeType 属性规定节点的类型： nodeType 是只读的 常见节点类型： 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 常见 API node.getNodeType()：获取节点的类型 node.getNodeName()：获取节点的名称 node.getTextContent()：获取节点的文本 node.getNodeValue()：常用于属性节点获取属性值 node.getNextSibling()：获取同级下一个节点 node.getPreviousSibling()：获取同级上一个节点 node.getParentNode()：获取父节点 DOM 对 XML 文件增删改查源文件12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources this="root" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item app:state_enabled="false" app:color="?unknown_attr_ref: 1010038" app:alpha="?unknown_attr_ref: 1010033" /&gt; &lt;item app:color="?attr/colorAccent" /&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;2&lt;/integer&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;1&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;220&lt;/integer&gt; &lt;style name="Base.TextAppearance.AppCompat.Inverse"&gt; &lt;item my="hello"&gt;my style&lt;/item&gt; &lt;item&gt;?unknown_attr_ref: 1010039&lt;/item&gt; &lt;item&gt;?unknown_attr_ref: 101003f&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 读1234567String filePath = "***\***.xml";// 1. 获取工厂DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();// 2. 产生解析器DocumentBuilder builder = factory.newDocumentBuilder();// 3. 解析 xml 文档，得到代表文档的 document 对象Document document = builder.parse(new File(filePath)); 查找123456789101112131415161718192021222324/** * 查找节点 * @param root: 当前元素 * @param tagName: 元素名称 * @param attributeName: 元素属性名称 * @param attributeValue: 元素属性值 * @return 匹配的节点 */private Node findNodeByAttribute(Node root, String tagName, String attributeName, String attributeValue)&#123; if (root instanceof Element) &#123; NodeList nodeList = ((Element) root).getElementsByTagName(tagName); if (nodeList != null) &#123; for (int i = 0; i &lt; nodeList.getLength(); i++)&#123; Element child = (Element) nodeList.item(i); String value = child.getAttribute(attributeName); if (value != null &amp;&amp; value.equals(attributeValue))&#123; return child; &#125; &#125; &#125; &#125; return null;&#125; 添加1234567891011// 找到 &lt;item app:color="?attr/colorAccent"/&gt;，在它后面添加新元素Node addedNode = findNodeByAttribute(root, "item", "app:color", "?attr/colorAccent");if (addedNode != null) &#123; Element newElement = document.createElement("code-add"); newElement.setAttribute("attribute1", "value1"); newElement.setAttribute("attribute2", "value2"); newElement.setTextContent("text-content"); //addedNode.appendChild(newElement); root.insertBefore(newElement, addedNode.getNextSibling());&#125; 注意：写入时需要设置缩进字符，否则新加节点不会缩进。 ts.setOutputProperty(&quot;{http://xml.apache.org/xslt}indent-amount&quot;, &quot;4&quot;); 修改1234567// 将名称为 integer, 属性为 name="abc_config_activityDefaultDur" // 的元素，对应文本修改为 110Node updateNode = findNodeByAttribute(root, "integer", "name", "abc_config_activityDefaultDur");if (updateNode != null)&#123; updateNode.setTextContent("110");&#125; 删除123456// 将 &lt;integer name="design_snackbar_text_max_lines"&gt; 第一个匹配的元素删掉Node deleteNode = findNodeByAttribute(root, "integer", "name", "design_snackbar_text_max_lines");if (deleteNode != null)&#123; root.removeChild(deleteNode);&#125; 写1234567891011121314String filePath = "***\***.xml";// 将内存中修改后的 doucement 写回 xml 文档//1. 获取工厂TransformerFactory tf = TransformerFactory.newInstance();//2. 获取转换器Transformer ts = tf.newTransformer();//3. 处理缩进，并设置缩进为 4 个空格ts.setOutputProperty(OutputKeys.INDENT, "yes");ts.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "4");//4. 去掉standalonets.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "yes");document.setXmlStandalone(true);//5. 将 document 写回 xml 文档ts.transform(new DOMSource(document), new StreamResult(filePath)); 增删改查后的 XML 文件1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources xmlns:app="http://schemas.android.com/apk/res-auto" this="root"&gt; &lt;item app:alpha="?unknown_attr_ref: 1010033" app:color="?unknown_attr_ref: 1010038" app:state_enabled="false"/&gt; &lt;item app:color="?attr/colorAccent"/&gt; &lt;code-add attribute1="value1" attribute2="value2"&gt;text-content&lt;/code-add&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;1&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;110&lt;/integer&gt; &lt;style name="Base.TextAppearance.AppCompat.Inverse"&gt; &lt;item my="hello"&gt;my style&lt;/item&gt; &lt;item&gt;?unknown_attr_ref: 1010039&lt;/item&gt; &lt;item&gt;?unknown_attr_ref: 101003f&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 遍历 XML 所有节点123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 获取根节点，遍历所有节点Node root = document.getFirstChild();showNodeInfo(root, false);traverseNodeTree(root);private void traverseNodeTree(final Node node)&#123; NodeList childLists = node.getChildNodes(); for (int i = 0; i &lt; childLists.getLength(); i++)&#123; Node child = childLists.item(i); // only show element node info. if (child.getNodeType() == Node.ELEMENT_NODE)&#123; int length = child.getChildNodes().getLength(); if (length &gt; 1)&#123; // length &gt; 1, there is more than one text content. // It's mean there are some child element nodes. showNodeInfo(child, false); traverseNodeTree(child); &#125;else &#123; // length == 0, there is no text content. // length == 1, there is one text content showNodeInfo(child, true); &#125; &#125; &#125;&#125;/** * 显示节点对应的元素，属性，文本 * @param node：节点 */private void showNodeInfo(final Node node, boolean showTextContent)&#123; String name = node.getNodeName(); StringBuilder attributes = new StringBuilder(""); NamedNodeMap namedNodeMap = node.getAttributes(); if (namedNodeMap != null &amp;&amp; namedNodeMap.getLength() &gt; 0)&#123; for (int i = 0; i &lt; namedNodeMap.getLength(); i++) &#123; Node attributeNode = namedNodeMap.item(i); attributes.append(attributeNode.toString()); attributes.append(" "); // show attribute name and value, eg: // app:color="?unknown_attr_ref: 1010038" // attribute name is -&gt; app:color // attribute value is -&gt; ?unknown_attr_ref: 1010038 // System.out.println("attribute.name = " + attributeNode.getNodeName() // + ", attribute.value = " + attributeNode.getNodeValue()); &#125; &#125; String textContent = node.getTextContent(); StringBuilder info = new StringBuilder(); info.append("name-&gt; " + name); if (!attributes.toString().isEmpty())&#123; info.append("| attributes-&gt; " + attributes); &#125; if (showTextContent &amp;&amp; textContent != null &amp;&amp; !textContent.isEmpty())&#123; info.append("| textContent-&gt; " + textContent); &#125; System.out.println(info);&#125;/** * 显示 XML 文件的声明：版本，编码，standalone 三个信息 * @param document: 文档节点 */private void showDocumentInfo(final Document document)&#123; System.out.println("version = " + document.getXmlVersion()); System.out.println("encoding = " + document.getXmlEncoding()); System.out.println("standalone = " + document.getXmlStandalone()); //System.out.println("node.name = " + document.getNodeName() // + ", node.value = " + document.getNodeValue() + ", node.type = " + document.getNodeType());&#125; 流程简析： 获取根节点 document.getFirstChild();，并打印根节点名称和属性 递归遍历所有节点 traverseNodeTree 只关心是元素的节点，所以先做节点类型判断 node.getNodeType() == Node.ELEMENT_NODE 获取元素节点的名称 node.getNodeName()，元素节点的文本 node.getNodeValue() 获取元素节点的所有属性 node.getAttributes() 属性节点获取名称 node.getNodeName()，获取属性值 node.getNodeValue() standalone 和 indent 的问题在写 xml 文件时遇到了如下问题，源文件： 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;2&lt;/integer&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;1&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;220&lt;/integer&gt;&lt;/resources&gt; 出现 standalone 以及第一行不缩进12345&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;resources&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;2&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;220&lt;/integer&gt;&lt;/resources&gt; 解决缩进，但是还是存在 standalone缩进解决方案：ts.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);，生成结果为： 123456&lt;?xml version="1.0" encoding="utf-8" standalone="no"?&gt;&lt;resources&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;2&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;220&lt;/integer&gt;&lt;/resources&gt; 果然有效！再来去掉 standalone 去掉 standalone 后缩进失效去掉 standalone 解决方案，生成 DOMSource 前加入 document.setXmlStandalone(true);，生成结果为： 12345&lt;?xml version="1.0" encoding="utf-8"&gt;&lt;resources&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;2&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;220&lt;/integer&gt;&lt;/resources&gt; 第一行缩进失效？？？且看下面的终极方案。 同时去掉 standalone 和解决缩进终极方案（XML Indent and no standalone）： 1234ts.setOutputProperty(OutputKeys.INDENT, "yes");ts.setOutputProperty("&#123;http://xml.apache.org/xslt&#125;indent-amount", "4");ts.setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, "yes");document.setXmlStandalone(true); 生成结果为： 123456&lt;?xml version="1.0" encoding="utf-8"&gt;&lt;resources&gt; &lt;integer name="design_snackbar_text_max_lines"&gt;2&lt;/integer&gt; &lt;integer name="abc_config_activityDefaultDur"&gt;220&lt;/integer&gt;&lt;/resources&gt; 参考文档 XML 教程 W3school XML DOM 教程 XML Indent and no standalone 解决xml缩进和添加节点的问题]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DOM</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL 详解]]></title>
    <url>%2F2017%2F11%2F29%2F0035-aidl%2F</url>
    <content type="text"><![CDATA[概念全称：AIDL: Android Interface Definition Language ，它是 Android 接口定义语言。用它定义客户端与服务使用进程间通信 ( IPC ) 进行相互通信时都认可的编程接口。Android 中一个进程通常无法访问另一个进程的内存，进程需要将其对象分解成操作系统能够识别的原语，并将对象编组成跨越边界的对象。 AIDL 接口的调用是直接函数调用（同步的），执行进程取决于调用来自本地进程还是远程进程中的线程： 来自本地进程的调用在发起调用的同一线程内执行如果该线程是 UI 主线程，则该线程继续在 AIDL 接口中执行；如果该线程是其他线程，则其在其他中线程执行。但是这种情况根本不应该使用 AIDL，而是应该通过实现本地 Binder 类创建接口 来自远程进程的调用，平台分派给当前应用自有进程内部维护的线程池必须为来自未知线程的多次并发传入调用做好准备，即 AIDL 接口的实现必须是完全线程安全实现。 AIDL 接口首次发布后对其进行的任何更改都必须保持向后兼容性，以避免中断其他应用对服务的使用。因为必须将 .aidl 文件复制到其他应用，才能让这些应用访问服务的接口，因此必须保留对原始接口的支持。 注意：如下介绍都是针对跨进程 AIDL 的用法。如果是在相同进程中，AIDL 相当于直接调用，和本地扩展 Binder 用法一样，具体原因参看 asInterface 的返回值。 语法格式每个 .aidl 文件都必须定义单个接口，并且需要包含接口声明和方法，不支持定义字段。 支持的数据类型 基本数据类型byte, int , short, long, boolean, char, float, double, String, CharSequence 等。 集合类型List 中的数据类型必须是基本类型或者 Parcelable 类型。可选择将 List 用作“通用”类（例如，List&lt;String&gt;）。另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口。Map 支持的数据类型和 List 相同，但是不支持通用 Map 类（即不支持 Map&lt;String,Integer&gt; 这种格式）。另一端实际接收的具体类始终是 HashMap ，但生成的方法使用的只能是 Map 接口。示例： void ListAndMapTypes(inout List&lt;String&gt; list, inout Map map); 自定义 Parcelable 类型必须为这些类型加入一个 import 语句，即使这些类型是和接口相同的软件包中定义。 数据走向标记在 AIDL 进程传递数据时，都有一个数据拆包和打包的过程，这是一个很耗系统内存的。AIDL 作为参数不需要指定，基本数据类型（int, Long, String...）默认且只能为 in，所有其他非基本数据类型都需要指定数据走向的方向标记。 1234567891011121314interface IMyIPCAidlInterface &#123; // 1. AIDL 作为参数，不需要指定 void registerCallback(IMyAidlInterfaceCallback cb); void unregisterCallback(IMyAidlInterfaceCallback cb); // 2. 基本数据类型，默认且只能为 in void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); // 3. 非基本数据类型，必须指定具体的方向 void testListAndMapTypes(inout List&lt;String&gt; list, inout Map map); MyDataParcelable updateBookOut(out MyDataParcelable myDataParcelable); ...&#125; 举例客户端数据传递到服务端，走向标记解析： in类似值传递，形参只拷贝了数据内容到服务器端，服务器端的修改不会影响到客户端的实参。 out 传递空对象，但是服务端的修改会同步写入客户端实参，相当于只传递了参数类型。形参传递时服务器端并没有直接使用，而是重新 new 了一个空对象；客户端的参数是无法传递进服务端的，在服务端对空对象填充完数据后，会同步写入客户端的实参，即服务端的修改会同步到客户端。 inout类似引用传递，形参拷贝了数据内容到服务器端，但是服务器端的修改会重新写回客户端，所以客户端的实参跟着被修改了，也就是服务端的修改会同步影响客户端。 根据后文的源码分析，非基本数据类型不管是哪种走向标记，客户端和服务端在跨进程通信时，对象都不是直接传递的，而是在 Studb.Proxy 中通过 Parcel 重建了数据做中转，中转的过程中模拟了值传递或者引用传递的效果。示例： 注意：走向标记仅仅在跨进程时才有上面的含义。如果都是在相同进程中执行，不管如何标记都是引用传递，即相当于直接调用，并没有使用代理，具体参考 asInterface 的返回值。 oneway 关键字表示用户请求相应功能时不需要等待响应可直接调用返回，非阻塞效果。该关键字可以用来声明接口或者声明方法，如果接口声明中用到了 oneway 关键字，则该接口声明的所有方法都采用 oneway 方式 。通过这种方式，服务端在回调客户端的方法时，可以同时通知所有客户端，而不必等待客户端执行完毕。 通俗来讲oneway 修饰方法 F，在包含了 F 的这段程序会先执行完了，才执行 F 方法。如果没有 oneway 关键字定义，即正常流程，程序先等待 F 方法调用完才会继续执行。参看代码示例： 1234567891011121314Log.d(TAG, "handleMessage: MSG_UPDATE_DATA");MyDataParcelable data = RandomData.genMyDataParcelable();// Broadcast to all clients the new value.final int N = mCallbacks.beginBroadcast();for (int i=0; i&lt;N; i++) &#123; try &#123; mCallbacks.getBroadcastItem(i).updateData(data); &#125; catch (RemoteException e) &#123; // The RemoteCallbackList will take care of removing // the dead object for us. &#125;&#125;mCallbacks.finishBroadcast();Log.d(TAG, "handleMessage: MSG_UPDATE_DATA, Callback Done!"); 有没有 oneway 关键字定义的前后对比 Log ： 123456789101112// oneway 关键字定义 updateData，不会阻塞原有程序 handleMessage，执行完后才调用 updateData// 服务端可以同时通知所有的客户端，不必等待客户端执行完毕11:58:10.236 18798-18798/*:aidl D/:MyAIDLService:: handleMessage: MSG_UPDATE_DATA11:58:10.236 18798-18798/*:aidl D/:MyAIDLService:: handleMessage: MSG_UPDATE_DATA, Callback Done!11:58:10.237 18706-18726/* D/:ShowIPCActivity:: updateData: 11:58:13.237 18706-18726/* D/:ShowIPCActivity:: updateData: done!// 没有 oneway，所有执行按照正常流程，直到 updateData 执行完才继续向前11:59:44.920 19822-19822/*:aidl D/:MyAIDLService:: handleMessage: MSG_UPDATE_DATA11:59:44.921 19713-19734/* D/:ShowIPCActivity:: updateData: 11:59:47.921 19713-19734/* D/:ShowIPCActivity:: updateData: done!11:59:47.922 19822-19822/*:aidl D/:MyAIDLService:: handleMessage: MSG_UPDATE_DATA, Callback Done! oneway 关键字最终是在 Binder 机制中解析的，具体为 IPCThreadState.cpp::transact 中判断是否阻塞执行，具体参考Android Binder 机制 。 自定义 Parcelable 数据在 IPC 中传递实现 Parcelable 自定义类在做进程间通信时，自定义的 Parcelabel 类除了完成默认的实现，还需要多增加两个方法（具体需求可以参见后面的源码分析）： 空的构造函数out 走向时，需要重新 new 一个空对象，就是调用的该构造函数： 123public MyDataParcelable()&#123;&#125; 从 Parcel 中读取数据Parcelable 数据 clone 时，需要通过该方法中转： 123public void readFromParcel(Parcel in)&#123; ...&#125; 创建同名 AIDL 文件申明自己凡是自定义的 Parcelabel 类，在 AIDL 中使用时，必须要先定义自己，并用 parcelable 关键字做声明： 1234567// MyDataParcelable.aidl// 1. 包名package ***.ipc;// 2. parcelable 关键字做声明// Declare MyDataParcelable so AIDL can find it and knows that // it implements the parcelable protocol.parcelable MyDataParcelable; 如果不定义，在使用过程中编译时会抛出异常：couldn&#39;t find import for class ***.ipc.MyDataParcelable AIDL 实现双向通信及示例服务端创建 AIDL 文件服务端创建 IMyIPCAidlInterface.aidl 文件，供客户端调用： 123456789101112131415161718192021222324// IMyIPCAidlInterface.aidlpackage com.ymzs.androidbasicknowledge.ipc;// Declare any non-default types here with import statementsimport com.ymzs.androidbasicknowledge.ipc.MyDataParcelable;import com.ymzs.androidbasicknowledge.ipc.IMyAidlInterfaceCallback;interface IMyIPCAidlInterface &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); void testListAndMapTypes(inout List&lt;String&gt; list, inout Map map); MyDataParcelable updateBookIn(in MyDataParcelable myDataParcelable); MyDataParcelable updateBookOut(out MyDataParcelable myDataParcelable); MyDataParcelable updateBookInOut(inout MyDataParcelable myDataParcelable); void registerCallback(IMyAidlInterfaceCallback cb); void unregisterCallback(IMyAidlInterfaceCallback cb);&#125; 服务端 创建 IMyIPCAidlInterface.Stub 实例，并实现接口函数private IMyIPCAidlInterface.Stub mBinder = new IMyIPCAidlInterface.Stub() {...} onBind 返回该实例返回 IMyIPCAidlInterface.Stub 的实例： 12345@Overridepublic IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind: "); return mBinder;&#125; 创建回调列表以及注册和取消 12345private final RemoteCallbackList&lt;IMyAidlInterfaceCallback&gt; mCallbacks = new RemoteCallbackList&lt;IMyAidlInterfaceCallback&gt;();...if(cb != null) mCallbacks.register(cb);if(cb != null) mCallbacks.unregister(cb); 回调客户端方法这里可以通过 oneway 关键字定义回调是否阻塞。 123456789101112// Broadcast to all clients the new value.final int N = mCallbacks.beginBroadcast();for (int i=0; i&lt;N; i++) &#123; try &#123; // 逐个回调客户端 mCallbacks.getBroadcastItem(i).updateData(data); &#125; catch (RemoteException e) &#123; // The RemoteCallbackList will take care of removing // the dead object for us. &#125;&#125;mCallbacks.finishBroadcast(); 客户端创建 AIDL 文件用于回调客户端创建 IMyIPCAidlInterfaceCallback.aidl 文件，供服务端调用： 1234567891011121314// IMyAidlInterfaceCallback.aidlpackage com.ymzs.androidbasicknowledge.ipc;// Declare any non-default types here with import statementsimport com.ymzs.androidbasicknowledge.ipc.MyDataParcelable;/** * Example of a callback interface used by IMyAidlInterfaceCallback to send * synchronous notifications back to its clients. Note that this is a * one-way interface so the server does not block waiting for the client. */oneway interface IMyAidlInterfaceCallback &#123; void updateData(in MyDataParcelable myDataParcelable);&#125; 客户端 创建 IMyIPCAidlInterface 实例private IMyIPCAidlInterface mAIDLService = null; 绑定服务并初始化必须使用 IMyIPCAidlInterface.Stub.asInterface(IBinder); 来初始化实例： 12345678910private boolean mAIDLIsBound = false;private ServiceConnection mAIDLServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected: "); mAIDLService = IMyIPCAidlInterface.Stub.asInterface(service); mAIDLIsBound = true; &#125; ...&#125;; 创建 IMyAidlInterfaceCallback 实例private final IMyAidlInterfaceCallback mCallback = new IMyAidlInterfaceCallback.Stub(){...} Callback 注册和取消注册 12mAIDLService.registerCallback(mCallback);mAIDLService.unregisterCallback(mCallback); 源码分析编译器会根据 AIDL 自动生成对应的 Java 文件，根据服务端的 IMyIPCAidlInterface.aidl 文件生成的代码做源码分析。 文件路径及基本内容app/build/generated/source/aidl/debug/***/ipc/IMyIPCAidlInterface.java 文件的类结构： 123456789101112131415161718/* * This file is auto-generated. DO NOT MODIFY. * Original file: ***\\ipc\\IMyIPCAidlInterface.aidl */package ***.ipc;public interface IMyIPCAidlInterface extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements ***.ipc.IMyIPCAidlInterface &#123; private static final java.lang.String DESCRIPTOR = "***.ipc.IMyIPCAidlInterface"; ... private static class Proxy implements ***.ipc.IMyIPCAidlInterface &#123; .... &#125; &#125;&#125; 其中，DESCRIPTOR 是 Binder 的唯一表标识，一般用类名表示。 asInterface 的返回值将服务端的 Binder 对象转成客户端的所需的 AIDL 对象： 12345678910public static ***.ipc.IMyIPCAidlInterface asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof ***.ipc.IMyIPCAidlInterface))) &#123; return ((***.ipc.IMyIPCAidlInterface) iin); &#125; return new ***.ipc.IMyIPCAidlInterface.Stub.Proxy(obj);&#125; 从上面的源码可以看出，如果客户端和服务端： 在相同进程下返回 Stub 对象本身。因为此时根本不需要跨进称通信。那么直接调用 Stub 对象的接口就可以了，返回的实现就是服务端的 Stub 实现，也就是客户端直接调用了服务端的代码。 跨进程返回 Stub.Proxy对象。该对象持有着远程的 Binder 引用，因为现在需要跨进程通信，所以如果调用 Stub.Proxy 的接口的话，那么它们都将是 IPC 调用，它会通过调用 transact 方法去与服务端通信。 in 走向标记分析in 模式下，对象从客户端传递到服务端后，不会被服务端修改： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; ... case TRANSACTION_updateBookIn: &#123; data.enforceInterface(DESCRIPTOR); ***.ipc.MyDataParcelable _arg0; if ((0 != data.readInt())) &#123; // 根据形参传入的数据，重新生成 _arg0 对象 _arg0 = ***.ipc.MyDataParcelable.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; // 也就是客户端传递的参数在这作了中转，并没有直接传递给服务端 // 而是根据客户端传递参数，新建了一个_arg0 对象传递给服务端 ***.ipc.MyDataParcelable _result = this.updateBookIn(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); // 服务端的返回值对象也不是直接传递的，也是通过 parcel 中转的 _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; &#125;&#125;@Overridepublic ***.ipc.MyDataParcelable updateBookIn(***.ipc.MyDataParcelable myDataParcelable) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); ***.ipc.MyDataParcelable _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((myDataParcelable != null)) &#123; _data.writeInt(1); // 形参数据写入 _data myDataParcelable.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; // IPC 通信，将参数通过 parcel 传递进去 mRemote.transact(Stub.TRANSACTION_updateBookIn, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; // 服务端的修改 _reply 重新生成 _result 并返回 _result = ***.ipc.MyDataParcelable.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; // in 标记类型，形参的修改不会影响实参 return _result;&#125; out 走向标记分析out 模式下，对象无法从客户端传递到服务端，Stub.Proxy 在中转时新建了一个空对象传递给服务端。服务端针对该空对象填充数据后，Stub.Proxy 在中转时将空对象填充的数据，重新写回客户端对象，所以服务器端的修改会同步到客户端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455case TRANSACTION_updateBookOut: &#123; data.enforceInterface(DESCRIPTOR); ***.ipc.MyDataParcelable _arg0; // out 模式下，new 了一个空对象 // 所以自定义 Parcelable 时，必须实现空构造函数 _arg0 = new ***.ipc.MyDataParcelable(); // 根据传递的空对象，调用服务端的具体实现 ***.ipc.MyDataParcelable _result = this.updateBookOut(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); // 服务端的返回结果写入 reply _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; if ((_arg0 != null)) &#123; reply.writeInt(1); // 服务端对空对象 _arg0 的修改，同步写入 reply _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true;&#125;@Overridepublic ***.ipc.MyDataParcelable updateBookOut(***.ipc.MyDataParcelable myDataParcelable) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); ***.ipc.MyDataParcelable _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); // 客户端传递进来的对象，并没有传递给服务端，_data 和 _reply 都是空的 Parcel mRemote.transact(Stub.TRANSACTION_updateBookOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; // 根据服务端的返回结果，生成一个对象作为返回值 _result = ***.ipc.MyDataParcelable.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; if ((0 != _reply.readInt())) &#123; // 如果服务端对传进去的空对象填充了数据，该数据写回客户端 // 即服务端的修改会同步影响到客户端 // 自定义 Parcelable 时，必须实现 readFromParcel，这里会读取 myDataParcelable.readFromParcel(_reply); &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; inout 走向标记分析inout 走向类似引用传递，对象从客户端传递到服务端，服务端的修改同步会影响到客户端 ，综合了 in 和 out 的功能： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263case TRANSACTION_updateBookInOut: &#123; data.enforceInterface(DESCRIPTOR); ***.ipc.MyDataParcelable _arg0; if ((0 != data.readInt())) &#123; // 根据形参传入的数据，重新生成 _arg0 对象 _arg0 = ***.ipc.MyDataParcelable.CREATOR.createFromParcel(data); &#125; else &#123; _arg0 = null; &#125; ***.ipc.MyDataParcelable _result = this.updateBookInOut(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); // 服务端的返回值对象通过 parcel 中转 _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; if ((_arg0 != null)) &#123; reply.writeInt(1); // 服务端对对象 _arg0 的修改，同步写入 reply _arg0.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true;&#125;@Overridepublic ***.ipc.MyDataParcelable updateBookInOut(***.ipc.MyDataParcelable myDataParcelable) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); ***.ipc.MyDataParcelable _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); if ((myDataParcelable != null)) &#123; _data.writeInt(1); // inout 模式下，形参数据写入 _data myDataParcelable.writeToParcel(_data, 0); &#125; else &#123; _data.writeInt(0); &#125; // IPC 通信，将参数通过 parcel 传递进去 mRemote.transact(Stub.TRANSACTION_updateBookInOut, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; // 服务端的返回值重新生成 _result 并返回 _result = ***.ipc.MyDataParcelable.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; if ((0 != _reply.readInt())) &#123; // 服务端对传进去对象做修改，同步写回客户端 // 即服务端的修改会同步影响到客户端 myDataParcelable.readFromParcel(_reply); &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; AIDL 作为参数不需要指定走向IMyAidlInterfaceCallback 也是一个 AIDL，它作为参数时不需要指定走向，参数传递类似对象的引用传递（IMyAidlInterfaceCallback 直接写入 Parcel，并通过 Parcel 来传递），并不涉及到对象的转存。 12345678910111213141516171819202122232425case TRANSACTION_registerCallback: &#123; data.enforceInterface(DESCRIPTOR); com.ymzs.androidbasicknowledge.ipc.IMyAidlInterfaceCallback _arg0; _arg0 = com.ymzs.androidbasicknowledge.ipc.IMyAidlInterfaceCallback .Stub.asInterface(data.readStrongBinder()); this.registerCallback(_arg0); reply.writeNoException(); return true;&#125;@Overridepublic void registerCallback(com.ymzs.androidbasicknowledge.ipc.IMyAidlInterfaceCallback cb) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeStrongBinder((((cb != null)) ? (cb.asBinder()) : (null))); mRemote.transact(Stub.TRANSACTION_registerCallback, _data, _reply, 0); _reply.readException(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125;&#125; 示例及 Log 分析示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// 客户端代码// test updateBookInMyDataParcelable inData = RandomData.genMyDataParcelable();Log.d(TAG, "updateMyParcelableData: inData = " + inData.toString());MyDataParcelable aidlInData = mAIDLService.updateBookIn(inData);Log.d(TAG, "updateMyParcelableData: 2 : inData = " + inData.toString());Log.d(TAG, "updateMyParcelableData: aidlInData = " + aidlInData.toString());// test updateBookOutMyDataParcelable outData = RandomData.genMyDataParcelable();Log.d(TAG, "updateMyParcelableData: outData = " + outData);MyDataParcelable aidlOutData = mAIDLService.updateBookOut(outData);Log.d(TAG, "updateMyParcelableData: 2 : outData = " + outData);Log.d(TAG, "updateMyParcelableData: aidlOutData = " + aidlOutData.toString());// test updateBookInOutMyDataParcelable inOutData = RandomData.genMyDataParcelable();Log.d(TAG, "updateMyParcelableData: inOutData = " + inOutData.toString());MyDataParcelable aidlInOutData = mAIDLService.updateBookInOut(inOutData);Log.d(TAG, "updateMyParcelableData: 2: inOutData = " + inOutData.toString());Log.d(TAG, "updateMyParcelableData: aidlInOutData = " + aidlInOutData.toString());// test ListAndMapTypesList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();stringList.add("This ");stringList.add("is ");stringList.add("String ");stringList.add("list!");Map&lt;String, Integer&gt; stringIntegerMap = new HashMap&lt;String, Integer&gt;();stringIntegerMap.put("key1", 1);stringIntegerMap.put("key2", 2);stringIntegerMap.put("key3", 3);Log.d(TAG, "updateMyParcelableData: stringList = " + Utils.printList(stringList));Log.d(TAG, "updateMyParcelableData: stringIntegerMap = " + Utils.printMap(stringIntegerMap));mAIDLService.testListAndMapTypes(stringList, stringIntegerMap);Log.d(TAG, "updateMyParcelableData: update: stringList = " + Utils.printList(stringList));Log.d(TAG, "updateMyParcelableData: update: stringIntegerMap = " + Utils.printMap(stringIntegerMap));// 服务端代码private MyDataParcelable updateBookIn(MyDataParcelable myDataParcelable)&#123; Log.d(TAG, "updateBookIn: myDataParcelable = " + myDataParcelable); String randomStr = RandomData.genRandomString(3); Log.d(TAG, "updateBookIn: randomStr = " + randomStr); myDataParcelable.setName(randomStr); Log.d(TAG, "updateBookIn: myDataParcelable = " + myDataParcelable); // 测试回调 sendCallbackMsg(); return myDataParcelable;&#125;private MyDataParcelable updateBookOut(MyDataParcelable myDataParcelable)&#123; if(myDataParcelable.getName() == null)&#123; Log.d(TAG, "updateBookOut: It is AIDL type out! Parameter is null!"); //myDataParcelable = RandomData.genMyDataParcelable(); myDataParcelable.setName("aaa"); MyDataParcelable.Book book = new MyDataParcelable.Book( RandomData.genRandomString(3), RandomData.genRandomNumber(100)); List&lt;MyDataParcelable.Book&gt; list = new ArrayList&lt;MyDataParcelable.Book&gt;(); list.add(book); myDataParcelable.setBookList(list); &#125; Log.d(TAG, "updateBookOut: myDataParcelable = " + myDataParcelable); return myDataParcelable;&#125;private MyDataParcelable updateBookInOut(MyDataParcelable myDataParcelable)&#123; Log.d(TAG, "updateBookInOut: myDataParcelable = " + myDataParcelable); String randomStr = RandomData.genRandomString(3); Log.d(TAG, "updateBookInOut: randomStr = " + randomStr); myDataParcelable.setName(randomStr); Log.d(TAG, "updateBookInOut: myDataParcelable = " + myDataParcelable); return myDataParcelable;&#125;private void testListAndMapTypes(List&lt;String&gt; list, Map&lt;String, Integer&gt; map)&#123; Log.d(TAG, "testListAndMapTypes: list = " + Utils.printList(list)); Log.d(TAG, "testListAndMapTypes: map = " + Utils.printMap(map)); list.add("Server!"); map.put("key4", 4); Log.d(TAG, "testListAndMapTypes: update: list = " + Utils.printList(list)); Log.d(TAG, "testListAndMapTypes: update: map = " + Utils.printMap(map));&#125;// 服务端回调Log.d(TAG, "handleMessage: MSG_UPDATE_DATA");MyDataParcelable data = RandomData.genMyDataParcelable();// Broadcast to all clients the new value.final int N = mCallbacks.beginBroadcast();for (int i=0; i&lt;N; i++) &#123; try &#123; mCallbacks.getBroadcastItem(i).updateData(data); &#125; catch (RemoteException e) &#123; // The RemoteCallbackList will take care of removing // the dead object for us. &#125;&#125;mCallbacks.finishBroadcast();Log.d(TAG, "handleMessage: MSG_UPDATE_DATA, Callback Done!"); Log 分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// Activity 绑定服务18:44:51.019 25369-25369/* D/:ShowIPCActivity:: onClick: button.onClick = Bind AIDL18:44:51.019 25369-25369/* D/:ShowIPCActivity:: bindAIDLService: mAIDLIsBound = false// 服务启动18:44:51.145 25521-25521/*:aidl D/:MyAIDLService:: onCreate: 18:44:51.145 25521-25521/*:aidl D/:MyAIDLService:: onBind: // 连接服务18:44:51.149 25369-25369/* D/:ShowIPCActivity:: onServiceConnected: // 注册 Activity 回调函数18:44:51.153 25521-25542/*:aidl D/:MyAIDLService:: registerCallback: // 点击 Button，调用服务的几个测试函数18:44:52.808 25369-25369/* D/:ShowIPCActivity:: onClick: button.onClick = UpdateMyParcelableData18:44:52.808 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: // 初始化实参并传递给服务端18:44:52.811 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: inData = name: bbf, arrays: 1 2 3 , book.name: ehfid, book.price: 47// 传递数据类型标记为 in，形参数据被传递到服务端18:44:52.816 25521-25541/*:aidl D/:MyAIDLService:: updateBookIn: myDataParcelable = name: bbf, arrays: 1 2 3 , book.name: ehfid, book.price: 47// 服务端修改该对象18:44:52.816 25521-25541/*:aidl D/:MyAIDLService:: updateBookIn: randomStr = eec18:44:52.816 25521-25541/*:aidl D/:MyAIDLService:: updateBookIn: myDataParcelable = name: eec, arrays: 1 2 3 , book.name: ehfid, book.price: 47// 发送消息，准备回调客户端18:44:52.816 25521-25541/*:aidl D/:MyAIDLService:: sendCallbackMsg: MSG_UPDATE_DATA// in 模式下客户端对象并不会因为服务端修改而受影响18:44:52.818 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: 2 : inData = name: bbf, arrays: 1 2 3 , book.name: ehfid, book.price: 47// 服务端返回值18:44:52.818 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: aidlInData = name: eec, arrays: 1 2 3 , book.name: ehfid, book.price: 47// 重新初始化实参传递给服务端18:44:52.818 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: outData = name: dab, arrays: 1 2 3 , book.name: cbefi, book.price: 36// 传递数据类型标记为 out，客户端对象无法传递到服务端，只传了一个空对象18:44:52.819 25521-25542/*:aidl D/:MyAIDLService:: updateBookOut: It is AIDL type out! Parameter is null!// 服务端为该空对象填充数据18:44:52.819 25521-25542/*:aidl D/:MyAIDLService:: updateBookOut: myDataParcelable = name: aaa, arrays: 0 0 0 , book.name: fhi, book.price: 92// out 模式下，服务端的修改会同步写回客户端18:44:52.820 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: 2 : outData = name: aaa, arrays: 0 0 0 , book.name: fhi, book.price: 92// 服务端返回值18:44:52.820 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: aidlOutData = name: aaa, arrays: 0 0 0 , book.name: fhi, book.price: 92// 重新初始化实参传递给服务端18:44:52.820 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: inOutData = name: igf, arrays: 1 2 3 , book.name: gdbaa, book.price: 30// 传递数据类型标记为 inout，形参数据被传递到服务端18:44:52.820 25521-25541/*:aidl D/:MyAIDLService:: updateBookInOut: myDataParcelable = name: igf, arrays: 1 2 3 , book.name: gdbaa, book.price: 30// 服务端修改该对象18:44:52.820 25521-25541/*:aidl D/:MyAIDLService:: updateBookInOut: randomStr = hcb// 服务端返回值18:44:52.821 25521-25541/*:aidl D/:MyAIDLService:: updateBookInOut: myDataParcelable = name: hcb, arrays: 1 2 3 , book.name: gdbaa, book.price: 30// inout 模式下，服务端的修改会同步写回客户端18:44:52.821 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: 2: inOutData = name: hcb, arrays: 1 2 3 , book.name: gdbaa, book.price: 3018:44:52.821 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: aidlInOutData = name: hcb, arrays: 1 2 3 , book.name: gdbaa, book.price: 30// 测试集合类型 List 和 Map，并标记为 inout 类型18:44:52.822 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: stringList = This is String list!18:44:52.822 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: stringIntegerMap = key2:2 key1:1 key3:3 18:44:52.823 25521-25542/*:aidl D/:MyAIDLService:: testListAndMapTypes: list = This is String list!18:44:52.823 25521-25542/*:aidl D/:MyAIDLService:: testListAndMapTypes: map = key2:2 key1:1 key3:3 18:44:52.823 25521-25542/*:aidl D/:MyAIDLService:: testListAndMapTypes: update: list = This is String list!Server!18:44:52.824 25521-25542/*:aidl D/:MyAIDLService:: testListAndMapTypes: update: map = key2:2 key4:4 key1:1 key3:3 // 服务端的修改会同步写回客户端18:44:52.824 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: update: stringList = This is String list!Server!18:44:52.824 25369-25369/* D/:ShowIPCActivity:: updateMyParcelableData: update: stringIntegerMap = key2:2 key4:4 key1:1 key3:3 // 收到消息，服务端回调所有客户端，回调函数被 oneway 关键字定义，程序不会阻塞18:44:54.817 25521-25521/*:aidl D/:MyAIDLService:: handleMessage: MSG_UPDATE_DATA18:44:54.817 25521-25521/*:aidl D/:MyAIDLService:: handleMessage: MSG_UPDATE_DATA, Callback Done!// 客户端响应回调18:44:54.818 25369-25389/* D/:ShowIPCActivity:: updateData: myDataParcelable = name: cgi, arrays: 1 2 3 , book.name: gdhhb, book.price: 16// 客户端回调执行完毕18:44:57.818 25369-25389/* D/:ShowIPCActivity:: updateData: done!18:45:00.052 25369-25369/* D/:ShowIPCActivity:: onClick: button.onClick = UnBind AIDL// 解除服务绑定18:45:00.052 25369-25369/* D/:ShowIPCActivity:: unBindAIDLService: mAIDLIsBound = true18:45:00.057 25521-25541/*:aidl D/:MyAIDLService:: unregisterCallback: 18:45:00.069 25521-25521/*:aidl D/:MyAIDLService:: onDestroy: 结论 如果是在相同进程中，只需要使用本地扩展 Binder 如果跨进程通信并不考虑并发，可以使用 Messenger 实现通信，但是该方式只支持异步通信 如果跨进程通信需要并发以及同步调用，则必须使用 AIDL 来通信 传输大小限制默认跨进程通信，传输大小为 1M：The Binder transaction buffer has a limited fixed size, currently 1Mb, which is shared by all transactions in progress for the process.链接：https://developer.android.com/reference/android/os/TransactionTooLargeException.html 参考文档 https://developer.android.com/guide/components/aidl.html http://blog.csdn.net/luoyanglizi/article/details/51980630 http://blog.csdn.net/jiwangkailai02/article/details/48098087 http://blog.csdn.net/scnuxisan225/article/details/49970217 https://my.oschina.net/zhoulc/blog/199199 http://blog.csdn.net/luoyanglizi/article/details/51958091 https://stackoverflow.com/questions/5507990/how-to-return-hashmap-in-an-aidl-file http://www.dre.vanderbilt.edu/~schmidt/cs282/PDFs/8-Services-and-IPC-parts-14-15-and-16.pdf]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Messenger 详解]]></title>
    <url>%2F2017%2F11%2F29%2F0034-messenger%2F</url>
    <content type="text"><![CDATA[概念让服务与远程进程通信，可使用 Messenger 为服务提供接口。通过 Messenger 发送消息（Message）来实现进程间的通信 (IPC)。 Messenger 实现双向通信及示例通信流程 双方实例化 MessengerActivity 和 Service 两边各自都要实例化 Messenger ，分别为：AMessenger 和 SMessenger。 Activity 到 Service 的通信Service 在 onBind 时，返回SMessenger 的 IBinder 。Activity 在 bindService 连接后，通过该 IBinder 得到 SMessenger 实例，并通过它来向 Service 发送消息。 Service 到 Activity 的通信（回调）Activity 组建消息 Message 并将 AMessenger 存放消息中，再通过 SMessenger 实例发送消息时传递给 Service，Service 通过拿到的 AMessenger 实例发送消息，形成对 Activity 的回调。 服务端 定义各种 Message 的 ID 1234567// 从客户端来的消息public static final int MSG_FROM_CLIENT_REGISTER = 20001;public static final int MSG_FROM_CLIENT_UNREGISTER = 20002;public static final int MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK = 20003;// 服务端反馈给客户端的消息 public static final int MSG_FROM_SERVICE_RESULT = 30001; 自定义 Handler 并实例化 SMessenger接受来自客户端的消息，后台处理： 123456789101112131415161718192021222324252627/** Keeps track of all current registered clients. */private ArrayList&lt;Messenger&gt; mClients = new ArrayList&lt;Messenger&gt;();private class IncomingFromClientsHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; Log.d(TAG, "IncomingFromClientsHandler:handleMessage: "); switch (msg.what) &#123; case MSG_FROM_CLIENT_REGISTER: Log.d(TAG, "handleMessage: MSG_FROM_CLIENT_REGISTER"); mClients.add(msg.replyTo); break; case MSG_FROM_CLIENT_UNREGISTER: Log.d(TAG, "handleMessage: MSG_FROM_CLIENT_UNREGISTER"); mClients.remove(msg.replyTo); break; case MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK: Log.d(TAG, "handleMessage: MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK"); doLongRunningWork(msg); break; default: super.handleMessage(msg); &#125; &#125;&#125;final Messenger mSMessenger = new Messenger(new IncomingFromClientsHandler()); onBind 返回 Messenger 12345@Overridepublic IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind: "); return mSMessenger.getBinder();&#125; 服务端向客户端发送消息（回调） 12345678910111213private void feedbackToClient(Messenger replyTo)&#123; Log.d(TAG, "feedbackToClient: "); Message msg = Message.obtain(null, MSG_FROM_SERVICE_RESULT); MyDataParcelable data = RandomData.genMyDataParcelable(); Bundle bundle = new Bundle(MyDataParcelable.class.getClassLoader()); bundle.putParcelable(IPC_PARCELABLE_DATA_KEY ,data); msg.setData(bundle); try &#123; replyTo.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125;&#125; 客户端 自定义 Handler 并实例化 AMessenger接受来自服务端的消息，响应回调： 12345678910111213141516171819private class IncomingFromServiceHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; Log.d(TAG, "IncomingFromServiceHandler:handleMessage: "); switch (msg.what) &#123; case MessengerService.MSG_FROM_SERVICE_RESULT: Log.d(TAG, "handleMessage: MSG_FROM_SERVICE_RESULT"); showMsgFromServiceResult(msg); break; default: super.handleMessage(msg); &#125; &#125;&#125;/** * Target we publish for clients to send messages to IncomingHandler. */final Messenger mAMessenger = new Messenger(new IncomingFromServiceHandler()); 绑定服务后获取 SMessenger其中 mService 即从服务器端获取到的 SMessenger： 1234567891011121314/** Flag indicating whether we have called bind on the service. */private boolean mBound = false;/** Messenger for communicating with service. */private Messenger mService;private ServiceConnection mMessengerServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, "onServiceConnected: Bound!"); mBound = true; // 拿到服务器端的 SMessenger mService = new Messenger(service); &#125; ...&#125;; 客户端向服务端发送消息也就是客户端有两个 Messenger 的实例，一个用于响应回调的 AMessenger，一个用于发送消息的 SMessenger： 12345678910111213141516171819private void doLongRunningWork()&#123; Log.d(TAG, "doLongRunningWork: "); Message msg = Message.obtain(null, MessengerService.MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK); Bundle bundle = new Bundle(MyDataParcelable.class.getClassLoader()); MyDataParcelable data = RandomData.genMyDataParcelable(); bundle.putParcelable(MessengerService.IPC_PARCELABLE_DATA_KEY, data); msg.setData(bundle); // 客户端的 AMessenger，传递给服务端后用于回调 msg.replyTo = mAMessenger; if(mService != null)&#123; try &#123; // SMessenger 发送消息给服务端 mService.send(msg); &#125; catch (RemoteException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 示例及 Log 分析客户端向服务端下发耗时任务，并响应服务端的回调1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 启动客户端 Activity17:24:16.964 30355-30355/D:ShowIPCActivity:: onCreate: // 绑定服务17:24:18.228 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = Bind Service17:24:18.228 30355-30355/D:ShowIPCActivity:: bindMessengerService: 17:24:18.229 30355-30355/D:ShowIPCActivity:: bindMessengerService: Binding...// 服务端启动17:24:18.246 30355-30355/D:MessengerService:: onCreate: 17:24:18.246 30355-30355/D:MessengerService:: onBind: // 连接服务端17:24:18.252 30355-30355/D:ShowIPCActivity:: onServiceConnected: Bound!17:24:18.253 30355-30355/D:ShowIPCActivity:: registerClient: 17:24:18.253 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 17:24:18.253 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_REGISTER// 下发耗时任务17:24:20.886 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = LongRunningWork17:24:20.886 30355-30355/D:ShowIPCActivity:: doLongRunningWork: 17:24:20.892 30355-30355/D:ShowIPCActivity:: doLongRunningWork: data = name: bic, arrays: 1 2 3 , book.name: icfhd, book.price: 49// 服务端接受到耗时任务消息17:24:20.899 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 17:24:20.899 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK17:24:20.899 30355-30355/D:MessengerService:: doLongRunningWork: 17:24:20.899 30355-30355/D:MessengerService:: doLongRunningWork: msg.data = name: bic, arrays: 1 2 3 , book.name: icfhd, book.price: 49// 服务端新建线程 30467 执行耗时任务17:24:20.905 30355-30476/D:MessengerService:: MyDataRunnable:run... 17:24:23.908 30355-30476/D:MessengerService:: MyDataRunnable:run: done!// 服务端执行完任务后，发送消息给客户端（回调）17:24:23.908 30355-30476/D:MessengerService:: feedbackToClient: 17:24:23.909 30355-30476/D:MessengerService:: feedbackToClient: data = name: ahf, arrays: 1 2 3 , book.name: ifebd, book.price: 40// 客户端收到服务端的回调消息并处理17:24:23.909 30355-30355/D:ShowIPCActivity:: IncomingFromServiceHandler:handleMessage: 17:24:23.909 30355-30355/D:ShowIPCActivity:: handleMessage: MSG_FROM_SERVICE_RESULT17:24:23.909 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: 17:24:23.909 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: msg.data = name: ahf, arrays: 1 2 3 , book.name: ifebd, book.price: 40// 解除服务绑定17:24:31.812 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = Unbind Service17:24:31.812 30355-30355/D:ShowIPCActivity:: unBindMessengerService: 17:24:31.812 30355-30355/D:ShowIPCActivity:: unBindMessengerService: unBind!17:24:31.812 30355-30355/D:ShowIPCActivity:: unregisterClient: 17:24:31.816 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 17:24:31.816 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_UNREGISTER// 服务销毁17:24:31.817 30355-30355/D:MessengerService:: onDestroy: 客户端同时下发三条耗时任务下发了三条耗时任务，服务端串行接收这些消息并处理。耗时任务是新建线程执行的，可以等待该线程执行完了再接受消息（即串行执行耗时任务），也可以接受消息时再开启新开线程执行（即并行执行耗时任务），示例是并行执行耗时任务： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 绑定服务18:45:32.446 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = Bind Service18:45:32.446 30355-30355/D:ShowIPCActivity:: bindMessengerService: 18:45:32.446 30355-30355/D:ShowIPCActivity:: bindMessengerService: Binding...18:45:32.455 30355-30355/D:MessengerService:: onCreate: 18:45:32.455 30355-30355/D:MessengerService:: onBind: 18:45:32.457 30355-30355/D:ShowIPCActivity:: onServiceConnected: Bound!18:45:32.457 30355-30355/D:ShowIPCActivity:: registerClient: 18:45:32.457 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 18:45:32.457 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_REGISTER// 下发耗时任务 118:45:35.196 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = LongRunningWork18:45:35.196 30355-30355/D:ShowIPCActivity:: doLongRunningWork: 18:45:35.196 30355-30355/D:ShowIPCActivity:: doLongRunningWork: data = name: eha, arrays: 1 2 3 , book.name: ddaca, book.price: 99// 服务端接受到耗时任务消息 118:45:35.197 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 18:45:35.197 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK18:45:35.197 30355-30355/D:MessengerService:: doLongRunningWork: 18:45:35.198 30355-30355/D:MessengerService:: doLongRunningWork: msg.data = name: eha, arrays: 1 2 3 , book.name: ddaca, book.price: 99// 新建线程 8198 执行耗时任务118:45:35.203 30355-8198/D:MessengerService:: MyDataRunnable:run... // 下发耗时任务218:45:35.418 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = LongRunningWork18:45:35.418 30355-30355/D:ShowIPCActivity:: doLongRunningWork: 18:45:35.418 30355-30355/D:ShowIPCActivity:: doLongRunningWork: data = name: hhg, arrays: 1 2 3 , book.name: haace, book.price: 13// 服务端接受到耗时任务消息218:45:35.418 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 18:45:35.418 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK18:45:35.418 30355-30355/D:MessengerService:: doLongRunningWork: 18:45:35.418 30355-30355/D:MessengerService:: doLongRunningWork: msg.data = name: hhg, arrays: 1 2 3 , book.name: haace, book.price: 13// 新建线程 8199 执行耗时任务218:45:35.423 30355-8199/D:MessengerService:: MyDataRunnable:run... // 下发耗时任务318:45:35.648 30355-30355/D:ShowIPCActivity:: onClick: button.onClick = LongRunningWork18:45:35.648 30355-30355/D:ShowIPCActivity:: doLongRunningWork: 18:45:35.648 30355-30355/D:ShowIPCActivity:: doLongRunningWork: data = name: gid, arrays: 1 2 3 , book.name: hfbie, book.price: 40// 服务端接受到耗时任务消息318:45:35.648 30355-30355/D:MessengerService:: IncomingFromClientsHandler:handleMessage: 18:45:35.649 30355-30355/D:MessengerService:: handleMessage: MSG_FROM_CLIENT_DO_LONG_RUNNING_WORK18:45:35.649 30355-30355/D:MessengerService:: doLongRunningWork: 18:45:35.649 30355-30355/D:MessengerService:: doLongRunningWork: msg.data = name: gid, arrays: 1 2 3 , book.name: hfbie, book.price: 40// 新建线程 8209 执行耗时任务318:45:35.650 30355-8209/D:MessengerService:: MyDataRunnable:run... // 耗时任务1 线程 8198 执行完毕，并发送回调消息18:45:38.203 30355-8198/D:MessengerService:: MyDataRunnable:run: done!18:45:38.203 30355-8198/D:MessengerService:: feedbackToClient: 18:45:38.203 30355-8198/D:MessengerService:: feedbackToClient: data = name: afi, arrays: 1 2 3 , book.name: ibabe, book.price: 9318:45:38.204 30355-30355/D:ShowIPCActivity:: IncomingFromServiceHandler:handleMessage: 18:45:38.204 30355-30355/D:ShowIPCActivity:: handleMessage: MSG_FROM_SERVICE_RESULT18:45:38.204 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: 18:45:38.204 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: msg.data = name: afi, arrays: 1 2 3 , book.name: ibabe, book.price: 93// 耗时任务2 线程 8199 执行完毕，并发送回调消息18:45:38.423 30355-8199/D:MessengerService:: MyDataRunnable:run: done!18:45:38.423 30355-8199/D:MessengerService:: feedbackToClient: 18:45:38.423 30355-8199/D:MessengerService:: feedbackToClient: data = name: ffc, arrays: 1 2 3 , book.name: dcdfd, book.price: 6518:45:38.424 30355-30355/D:ShowIPCActivity:: IncomingFromServiceHandler:handleMessage: 18:45:38.424 30355-30355/D:ShowIPCActivity:: handleMessage: MSG_FROM_SERVICE_RESULT18:45:38.424 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: 18:45:38.424 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: msg.data = name: ffc, arrays: 1 2 3 , book.name: dcdfd, book.price: 65// 耗时任务3 线程 8209 执行完毕，并发送回调消息18:45:38.650 30355-8209/D:MessengerService:: MyDataRunnable:run: done!18:45:38.650 30355-8209/D:MessengerService:: feedbackToClient: 18:45:38.650 30355-8209/D:MessengerService:: feedbackToClient: data = name: icc, arrays: 1 2 3 , book.name: ibicd, book.price: 5318:45:38.651 30355-30355/D:ShowIPCActivity:: IncomingFromServiceHandler:handleMessage: 18:45:38.651 30355-30355/D:ShowIPCActivity:: handleMessage: MSG_FROM_SERVICE_RESULT18:45:38.651 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: 18:45:38.651 30355-30355/D:ShowIPCActivity:: showMsgFromServiceResult: msg.data = name: icc, arrays: 1 2 3 , book.name: ibicd, book.price: 53 自定义 Parcelable 数据传输进程间通信时，Messenger 在传递数据时，需要通过 Bundle 将自定义的数据打包传输。但是另一个进程在取出 Bundle 时的 ClassLoader 为 null，会使用系统默认值 BootClassLoader 来加载自定义的 Parcelable 数据，所以会出现异常找不到该数据类。如果是在相同进程中使用 Messenger 则不会出现这个问题，不过如果是相同进程也不需要使用 Messenger 来通信了。 解决方案在取出 Parcelable 数据前，设置该应用为 ClassLoader 的值： 123456789if(msg != null &amp;&amp; msg.getData() != null)&#123; Bundle bundle = msg.getData(); if(bundle != null) &#123; // must set class loader before getParcelable, ClassNotFoundException // 必须设置 ClassLoader，才能获取 Bundle 中的数据 bundle.setClassLoader(getClassLoader()); MyDataParcelable data = bundle.getParcelable(IPC_PARCELABLE_DATA_KEY); &#125;&#125; 异常ClassNotFoundException 异常 Log ： 123456789101112131415161718192014:50:33.803 14568-14568/:messenger D/AndroidRuntime: Shutting down VM14:50:33.804 14568-14568/:messenger E/AndroidRuntime: FATAL EXCEPTION: main Process: :messenger, PID: 14568 android.os.BadParcelableException: ClassNotFoundException when unmarshalling: .ipc.MyDataParcelable at android.os.Parcel.readParcelableCreator(Parcel.java:2295) at android.os.Parcel.readParcelable(Parcel.java:2245) at android.os.Parcel.readValue(Parcel.java:2152) at android.os.Parcel.readArrayMapInternal(Parcel.java:2485) at android.os.BaseBundle.unparcel(BaseBundle.java:221) at android.os.Bundle.getParcelable(Bundle.java:755) at .ipc.MessengerService.doLongRunningWork(MessengerService.java:129) at .ipc.MessengerService.access$100(MessengerService.java:18) at .ipc.MessengerService$IncomingFromClientsHandler.handleMessage(MessengerService.java:71) at android.os.Handler.dispatchMessage(Handler.java:102) at android.os.Looper.loop(Looper.java:135) at android.app.ActivityThread.main(ActivityThread.java:5344) at java.lang.reflect.Method.invoke(Native Method) at java.lang.reflect.Method.invoke(Method.java:372) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:908) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:703) 源码分析从源码可以看出：Messenger 的本质还是使用的 AIDL，只是封装后更方便使用。 123456789101112131415161718192021222324252627282930313233343536// Messenger.javapublic final class Messenger implements Parcelable &#123; // IMessenger.aidl 实例 private final IMessenger mTarget; /* Create a new Messenger pointing to the given Handler. */ public Messenger(Handler target) &#123; mTarget = target.getIMessenger(); &#125; /* Create a Messenger from a raw IBinder */ public Messenger(IBinder target) &#123; mTarget = IMessenger.Stub.asInterface(target); &#125; ...&#125;// IMessenger.aidl的具体实现是在 Handler.java 中final IMessenger getIMessenger() &#123; synchronized (mQueue) &#123; if (mMessenger != null) &#123; return mMessenger; &#125; mMessenger = new MessengerImpl(); return mMessenger; &#125;&#125;// 具体实现，消息的发送是通过 Handler 实现的private final class MessengerImpl extends IMessenger.Stub &#123; public void send(Message msg) &#123; msg.sendingUid = Binder.getCallingUid(); Handler.this.sendMessage(msg); &#125;&#125; Messenger 和 Message 的区别和联系从源码中可以看出，Message 是一个包含各种数据的容器，Messenger 可以作为 Parcelable 数据，通过 Message 装载后传递出去。而从 Messenger 的 AIDL 来看，它唯一的方法就是发送 Message，是一名信差。 Messenger 总结 本质还是 AIDL 只能异步通信，同步的话必须使用 AIDL 因为使用的是 Handler 和 Message，所以所有的消息都是串行接受和处理的，处理的过程可以是多线程或单线程来处理 参考文档 https://developer.android.com/guide/components/bound-services.html#Binding http://blog.csdn.net/lmj623565791/article/details/47017485 http://blog.csdn.net/jiwangkailai02/article/details/48098087 http://blog.csdn.net/hyhdcl/article/details/52680301]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Serializable 和 Parcelable]]></title>
    <url>%2F2017%2F11%2F28%2F0033-serializable-parcelable%2F</url>
    <content type="text"><![CDATA[基本概念序列化和反序列化序列化和反序列化是指：将一个实例对象编码成字节流，并从字节流编码中重新构建对象实例的能力。 序列化将一个对象编码成字节流。 反序列化从一个字节流中读出一个对象实例。 反序列化是按照序列化写入的顺序读取的。 对象变量类型 序列化对象的时候只是针对变量进行序列化，不针对方法进行序列化 静态成员 static 变量属于类不属于对象，所以不参与序列化过程 用 transient 关键字标记的成员变量不参与序列化过程 两种方法 Java 提供的 Serializable Android 提供的 Parcelable Serializable 接口Serializable 接口是 Java 提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。使用 Serializable 来实现的对象的序列化相当简单，只需要在类中指定 serialVersionUID 标识即可自动实现默认的序列化过程。 serialVersionUID 概念Java 的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 serialVersionUID 与本地相应实体（类）的 serialVersionUID 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。 值根据类名、接口名、成员方法及属性等来生成一个 64 位的哈希字段。默认值是 1L ，但是 Android 强烈建议显示指定一个值。 生成方法Android Studio 自动生成 serialVersionUID 的方法：打开 Settings，切换到 Editor-&gt;Inspections-&gt;Java-&gt;Serialization issues，找到 Serializationzable class without ‘serialVersionUID’，将其勾选即可。或者直接搜索 serialVersionUID。鼠标放在 Serializable 接口的类名上， Android Studio 的智能提示(智能检查)，就会多出了 Add ‘serialVersionUID’ field，完毕！ 示例类MyDataSerializable 自定义可以序列化的类，内部支持集合，但是静态变量和 tansient 申明的变量是无法序列化的。 123456789101112131415161718192021222324252627282930313233343536public class MyDataSerializable implements Serializable &#123; private static final long serialVersionUID = -6385208676051817341L; public String name; public int age; // 支持集合 public List&lt;Book&gt; bookList; // 静态变量 public static int static_field; // transien 申明的变量 public transient int transient_filed; public static class Book implements Serializable&#123; private static final long serialVersionUID = -4088466130897610219L; public String name; public long price; public Book(String name, long price)&#123; ... &#125; public String toString()&#123; ... &#125; &#125; public MyDataSerializable(String name, int age)&#123; ... &#125; public String toString()&#123; ... &#125;&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void testSerializable()&#123; MyDataSerializable myDataSerializable = initDataSerializable(); Log.d(TAG, "testSerializable: myDataSerializable = " + myDataSerializable); byte[] bytes = serializeData(myDataSerializable); // 改变类中的静态变量的值 myDataSerializable.static_field = 10002; MyDataSerializable deSerialData = deserializeBytes(bytes); Log.d(TAG, "testSerializable: deSerialData = " + deSerialData);&#125;private MyDataSerializable initDataSerializable()&#123; MyDataSerializable myDataSerializable = new MyDataSerializable("kobe", 36); MyDataSerializable.Book book1 = new MyDataSerializable.Book("abc", 13); MyDataSerializable.Book book2 = new MyDataSerializable.Book("xyz", 56); myDataSerializable.bookList.add(book1); myDataSerializable.bookList.add(book2); return myDataSerializable;&#125;private byte[] serializeData(MyDataSerializable myDataSerializable)&#123; byte[] bytes = null; try &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(myDataSerializable); objectOutputStream.flush(); objectOutputStream.close(); bytes = byteArrayOutputStream.toByteArray(); &#125;catch (IOException e)&#123; Log.e(TAG, "serializeData: e = ", e); &#125; return bytes;&#125;private MyDataSerializable deserializeBytes(byte[] bytes)&#123; MyDataSerializable data = null; try &#123; ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); data = (MyDataSerializable) objectInputStream.readObject(); &#125;catch (Exception e)&#123; Log.e(TAG, "deserializeBytes: e = ", e); &#125; return data;&#125; 结果分析12345611:32: 6536/com.yD/:ShowIPCActivity:: testSerializable: myDataSerializable = name: kobe, age: 36, book.name: abc, book.price: 13, book.name: xyz, book.price: 56, static_field: 10001, transient_filed: 2000111:32: 6536/com.yD/:ShowIPCActivity:: testSerializable: deSerialData = name: kobe, age: 36, book.name: abc, book.price: 13, book.name: xyz, book.price: 56, static_field: 10002, transient_filed: 0 从 Log 中可以看出： transient 关键字申明的变量不能序列化，反序列化的结果为 0。 static 变量定义为 static 的变量，是属于类的，全局的，实际上并不参与序列化。所以读取到的 static 变量值是全局数据区中的值，并不是反序列化产生的值，本例中表示改变后的值。 Parcelable 接口Parcelable 接口是 Android SDK 提供的一种专门用于 Android 应用中对象的序列化和反序列化的方式，相比于 Seriablizable 具有更好的性能。实现 Parcelable 接口的对象就可以实现序列化并可以通过Intent 和 Binder 传递。序列化的对象可以包含：基本数据类型，Bitmap，List，Map，IBinder等，以及所有已经实现 Parcelable 的类。 实现及重写实现 Parcelable 的类， Android Studio 会给出需要实现和重写的方法模板： 123456789101112131415161718192021222324252627282930313233343536public static class Test implements Parcelable&#123; // 空构造方法 public Test()&#123; &#125; public Test(Parcel in) &#123; readFromParcel(in); &#125; // 序列化 @Override public void writeToParcel(Parcel dest, int flags) &#123; &#125; // 反序列化 public void readFromParcel(Parcel in)&#123; &#125; @Override public int describeContents() &#123; return 0; &#125; public static final Creator&lt;Test&gt; CREATOR = new Creator&lt;Test&gt;() &#123; // 反序列化 @Override public Test createFromParcel(Parcel in) &#123; return new Test(in); &#125; @Override public Test[] newArray(int size) &#123; return new Test[size]; &#125; &#125;;&#125; 序列化writeToParcel 表示序列化的过程，将变量都写入 Parcel。 反序列化readFromParcel 表示反序列化的过程，从 Parcel 中读取并生成类对象。 describeContents该方法通常直接返回 0 。Parcelable 对象在扁平化中，如果包含文件描述符，则该值必须返回 CONTENTS_FILE_DESCRIPTOR 。 参考 Parcelable API 这里“空构造方法”和 readFromParcel 两个都不是必须的。反序列化也可以在 createFromParcel 中直接反序列化；但是 AIDL 中反序列化时，必须定义“空构造方法”和 readFromParcel 才能成功反序列化。所以我们最好在自定义 Parcelable 中默认实现这两个方法养成好习惯。 反序列化是按照序列化的顺序读取的，所以 readFromParcel 反序列化读取变量的值时，一定要按照 writeToParcel 写入的顺序读取。 示例类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class MyDataParcelable implements Parcelable &#123; public static final int ARRAY_SIZE = 3; private String name; // 可以是数组，注意写入和读取数组初始化的大小必须一致 private int[] arrays = new int[ARRAY_SIZE]; // 可以包含 List 以及已经实现了 Parcelable 的类 private List&lt;Book&gt; bookList; public static class Book implements Parcelable&#123; ... &#125; public MyDataParcelable(String name, int[] arrays) &#123; this.name = name; this.arrays = arrays; bookList = new ArrayList&lt;Book&gt;(); &#125; // 空构造方法 public MyDataParcelable()&#123; &#125; public MyDataParcelable(Parcel in)&#123; readFromParcel(in); &#125; ... // 序列化 @Override public void writeToParcel(Parcel dest, int flags) &#123; // 注意写入顺序 dest.writeString(name); dest.writeIntArray(arrays); dest.writeList(bookList); &#125; // 反序列化 public void readFromParcel(Parcel in)&#123; // 注意读取顺序，严格按照写入顺序读取 this.name = in.readString(); // 读取数组的大小也必须和写入的一致 this.arrays = new int[ARRAY_SIZE]; in.readIntArray(arrays); this.bookList = new ArrayList&lt;Book&gt;(); in.readList(bookList, Book.class.getClassLoader()); &#125; @Override public int describeContents() &#123; return 0; &#125; public static final Creator&lt;MyDataParcelable&gt; CREATOR = new Creator&lt;MyDataParcelable&gt;() &#123; @Override public MyDataParcelable createFromParcel(Parcel in) &#123; return new MyDataParcelable(in); &#125; @Override public MyDataParcelable[] newArray(int size) &#123; return new MyDataParcelable[size]; &#125; &#125;; public String toString()&#123; ... &#125;&#125; 测试代码123456789101112131415161718192021222324252627282930// Activity1 中初始化 MyDataParcelable， 启动 Activity2// 并将 MyDataParcelable 的对象传递过去 private void testParcelable()&#123; int[] arrays = new int[]&#123;1, 2, 3&#125;; MyDataParcelable myDataParcelable = new MyDataParcelable("parcelable", arrays); MyDataParcelable.Book book1 = new MyDataParcelable.Book("xiyouji", 20); MyDataParcelable.Book book2 = new MyDataParcelable.Book("sanguo", 30); myDataParcelable.addBook(book1); myDataParcelable.addBook(book2); Log.d(TAG, "testParcelable: myDataParcelable = " + myDataParcelable); Intent intent = new Intent(ShowIPCActivity.this, Main2Activity.class); intent.putExtra("PARCELABLE_DATA", myDataParcelable); startActivity(intent);&#125;// Activity2 中收到 Intent 后，获取 MyDataParcelable 数据protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Intent intent = getIntent(); if(intent != null)&#123; MyDataParcelable myDataParcelable = intent.getParcelableExtra("PARCELABLE_DATA"); Log.d(TAG, "onCreate: intent, myDataParcelable = " + myDataParcelable); &#125;&#125; 结果分析从结果上看，复杂数据对象 MyDataParcelable 成功的被序列化后传递出去，接收后能正常的反序列化解析出来。 12345616:02: 11509/com.yD/:ShowIPCActivity:: testParcelable: myDataParcelable = name: parcelable, arrays: 1 2 3 , book.name: xiyouji, book.price: 20, book.name: sanguo, book.price: 3016:02: 11509/com.yD/:Main2Activity:: onCreate: intent, myDataParcelable = name: parcelable, arrays: 1 2 3 , book.name: xiyouji, book.price: 20, book.name: sanguo, book.price: 30 对比 Serializable是 Java 中的序列化接口，使用起来简单但是开销大，序列化和反序列化需要大量的 I/O 操作。主要用于序列化到存储设备或者序列化后通过网络传输。 Parcelable是 Android 提供的标准序列化接口，因此更适合 Android 平台，缺点是使用稍微麻烦，但是效率高；主要用于内存序列化。 参考文档 http://www.cnblogs.com/yezhennan/p/5527506.html http://www.developerphil.com/parcelable-vs-serializable/ http://www.jianshu.com/p/fcc59fb523b6 http://www.cnblogs.com/xyczero/p/4021245.html http://www.linuxidc.com/Linux/2015-03/115270.htm]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
        <tag>Serializable</tag>
        <tag>Parcelable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和线程]]></title>
    <url>%2F2017%2F11%2F28%2F0032-process-thread%2F</url>
    <content type="text"><![CDATA[Android 应用启动时，系统会为应用新建一个 Linux 的进程，默认情况下同一应用程序下的所有组件运行在相同的进程和线程（主线程，也是 UI 线程）中。一个Android 应用就是一个 Linux 进程，每个应用在各自的进程中运行，互不干扰比较安全。一个应用对应一个主线程，就是通常所说的 UI 线程，Android 遵守的就是单线程模型，所以说 UI 操作不是线程安全的。 进程概念虽然默认整个应用在同一进程中，但是可以在清单文件 AndroidManifest.xml 中定义组件是否以新建进程的方式运行。元素：&lt;application&gt;, &lt;activity&gt;, &lt;service&gt;, &lt;receiver&gt;, &lt;provider&gt;，均支持 android:process 属性，默认进程名为包名，如果设置了 android:process=&quot;:remote&quot; 属性，则进程名为：包名:remote。可以通过设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外还可以设置此属性，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。 注意：android:process=&quot;:remote&quot;，是否带分号是有区别的： 有分号创建一个专属于当前进程的进程，他们的 PID 不同，但是父进程 PPID 是一样的。 没有分号创建全局进程，不同的应用程序共享该进程。如果不带冒号，需要使用标准的命名规范命名进程名，例如 com.xxx.xxx.xxx，而且该进程是全局共享的进程，即不同应用的组件都可以运行于该进程，会创建两个完全独立的进程。这可以突破应用程序的 24M（或 16M ）内存限制。 如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。当这些组件需要再次运行时，系统将为它们重启进程。 低内存进程管理Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要移除旧进程来回收内存。为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。 进程优先级顺序为： Foreground process：前台进程用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程： 托管用户正在交互的 Activity （已调用 Activity 的 onResume() 方法） 托管某个 Service ，后者绑定到用户正在交互的 Activity 托管正在“前台”运行的 Service （服务已调用 startForeground() ） 托管正执行一个生命周期回调的 Service（onCreate() 、onStart()、onDestroy()） 托管正执行其 onReceive() 方法的 BroadcastReceiver 通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应. Visible prcess：可见进程没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。如果一个进程满足以下任一条件，即视为可见进程： 托管不在前台、但仍对用户可见的 Activity （已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况 托管绑定到可见（或前台）Activity 的 Service 可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。 Service process：服务进程正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。 Background process：后台进程包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。通常会有很多后台进程在运行，因此它们会保存在LRU（最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 Empty process：空进程不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。 一个进程的优先级是可以变化的。 此外一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。 线程主线程（ UI 线程）应用启动时，系统会为应用创建一个名为“主线程”的执行线程。此线程非常重要，因为它负责将事件分派给相应的用户界面小部件，其中包括绘图事件。此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为UI 线程。响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。此外 Android UI 工具包并非线程安全工具包，因此只能通过 UI 线程操纵用户界面。 因此 Android 的单线程模式必须遵守两条规则： 不要阻塞 UI 线程 不要在 UI 线程之外访问 Android UI 工具包 工作线程根据单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。 如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。Android 提供了几种途径来从其他线程访问 UI 线程： Activity.runOnUiThread(Runnable) View.post(Runnable) View.postDelayed(Runnable,long) 为了避免代码变得复杂且难以维护，可以在工作线程中使用 Handler 处理来自 UI 线程的消息。 示例分析 PID 进程 ID TID 线程 ID 可以通过 adb shell top 或者 adb shell ps 来查看应用的进程及线程 ID。 以下两个例子分别是： Activity 和 Service 属于同一进程或不同进程： 12345678910111213141516171819202122// Service 设置新建进程// Activity 进程和 UI 主线程都是 1858507-31 09:51:28.002 18585-18585/? D/:XMT:ShowService:: onClick: button.onClick = Start Service// 启动 Service ，新进程和线程都是 1868807-31 09:51:28.015 18688-18688/? D/:XMT:StartService:: onCreate: 07-31 09:51:28.016 18688-18688/? D/:XMT:StartService:: onStartCommand: flags = 0, startId = 1// Service 中新建线程 31645 执行耗时操作07-31 09:51:28.020 18688-31645/? D/:XMT:StartService:: run: 07-31 09:51:31.020 18688-31645/? D/:XMT:StartService:: run: stopSelfResult.mStartId = 1// Service 完成生命周期销毁（实际通过 top 命令查看并未销毁，下次启动 Service 还是 18688）07-31 09:51:31.026 18688-18688/? D/:XMT:StartService:: onDestroy: // 回到 Activity 07-31 09:51:32.854 18585-18585/? D/:XMT:ShowService:: onClick: button.onClick = Stop Service// 默认 Service 和 Activity 等属于同一个进程和主线程 31813 07-31 09:52:29.439 31813-31813/? D/:XMT:ShowService:: onClick: button.onClick = Start Service07-31 09:52:29.463 31813-31813/? D/:XMT:StartService:: onCreate: 07-31 09:52:29.464 31813-31813/? D/:XMT:StartService:: onStartCommand: flags = 0, startId = 1// Service 中新建线程 31868 执行耗时操作07-31 09:52:29.467 31813-31868/? D/:XMT:StartService:: run: 07-31 09:52:32.468 31813-31868/? D/:XMT:StartService:: run: stopSelfResult.mStartId = 107-31 09:52:32.471 31813-31813/? D/:XMT:StartService:: onDestroy: 区别和联系 单位 线程是进程的一个组成部分，一个进程可以包含一个或多个线程。 占用资源计算机内部的软硬件资源的分配与线程无关，进程是系统所有资源分配时候的一个基本单位，拥有一个完整的虚拟空间地址，线程是不会分配资源的。系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享进程的资源。 CPU 调度 线程是进程的一个实体，是 CPU 调度和分配的基本单位，即执行运算的最小单位。其本身不拥有系统资源，只含有程序计数器、寄存器和栈等一些运行时必不可少的基本资源。所以在多核系统中开多线程才能最大化利用 CPU。 新开进程还是线程，如何选择？考虑的因素是什么？根据上面的分析可以得出，如果是仅仅考虑后台处理，并发执行等可以只需要开线程就能满足；如果是需要考虑低内存管理进程优先级，应用能分配更多的源等可以新建进程。 参考文档 https://developer.android.com/guide/components/processes-and-threads.html#Threads http://www.cnblogs.com/yw123/p/3614734.html http://blog.csdn.net/u011895534/article/details/46873479 http://www.cnblogs.com/android-blogs/p/5632549.html http://blog.csdn.net/u014297278/article/details/46762407]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Progress</tag>
        <tag>Thread</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View 事件分发机制]]></title>
    <url>%2F2017%2F11%2F28%2F0031-view-dispatch-event%2F</url>
    <content type="text"><![CDATA[基本概念事件类型主要有如下三种： 123- MotionEvent.ACTION_DOWN - MotionEvent.ACTION_MOVE - MotionEvent.ACTION_UP 事件处理 API123456- Activity.dispatchTouchEvent() - Activity.onTouchEvent() - ViewGroup.dispatchTouchEvent() - ViewGroup.onInterceptTouchEvent() - View.dispatchTouchEvent() - View.onTouchEvent() 主要是描述 Touch 事件的分发，拦载，响应三者的关系。 Touch 事件发生时，会由根元素逐级分发直到最内层 View，然后反过来逐级响应该事件。 名词解释 dispatchTouchEvent() 分发：该方法封装了事件分发的整个过程，是事件分发的调度者和指挥官。 onInterceptTouchEvent() 拦载：该方法表示是否拦截事件，只有 ViewGroup 有该回调。返回 true 表示拦截，返回 false 或者 super.onInterceptTouchEvent 表示不拦截 onTouchEvent() 响应：该方法表示响应并处理事件 消费：表示事件不再继续逐级向下传递分发，或者不再继续逐级向上响应。也就是事件在某个方法中被消费后，该方法就是整个分发、拦载、响应流程的终点。 处理顺序分发顺序为逐级向下：dispatchTouchEvent: Activity(Window) -&gt; ViewGroup -&gt; View响应顺序为逐级向上：onTouchEvent: View -&gt; ViewGroup --&gt; Activity 事件分发流程DOWN 事件 U 型流程图流程图是针对 ACTION_DOWN 事件的分析，而 ACTION_MOVE/ACTION_UP 和事件的消费有关，放到后面分析。事件的正常流程是：由上向下分发，并由下向上响应的一个 U 型图。箭头上的值表示返回值，其中 super 表示返回父类实现。 流程图总结 所有 API 返回值都为 super ，表示事件能走完整个 U 型流程。 分发和响应只要返回值为 true 都表示消费该事件，流程不再继续流转。 Activity 中的分发和响应 分发：只有返回 super 才能逐级向下分发，true/false 都表示事件最终被消费。响应：不管返回什么值，都表示事件被最终消费。 ViewGroup 和 View 的分发和响应返回 false ，都表示流转到上一级执行 onTouchEvent (响应)。 拦载返回 true 表示拦载，事件不会继续分发， 当前 ViewGroup 直接响应事件， U 型流程继续向前走。返回 false 或者 super 表示不拦载，事件继续向下分发。 MOVE 和 UP 事件流程ACTION_MOVE/ACTION_UP 和 ACTION_DOWN 事件的消费有关。在 U 型图中，ACTION_DOWN 事件在哪一层被消费，ACTION_MOVE/ACTION_UP 就只能到达这一层。 分发如果 DOWN 事件被分发消费，UP 事件只能逐级向下分发到这一层。 响应如果 DOWN 事件被响应后消费，UP 事件逐级向下分发到这一层，并在这一层响应后直接被消费。 示例 1View 分发时消费 DOWN 事件。View 在 dispatchTouchEvent 中消费 DOWN 事件， MVOE/UP 也只能分发到 CustomView 这一层。 示例 2ViewGroup 响应时消费 DOWN 事件。ViewGroup 在 onTouchEvent 中消费 DOWN 事件， MOVE/UP 只能分发到这一层，并在这一层响应后直接消费。 示例 Log 分析示例结构图CustomView ：为自定义 ViewCustomLayout ：为自定义 ViewGroupCustomLayout2 ：继承 LinearLayout 示例完整布局文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context="com.***.view.ViewEvent"&gt; &lt;com.***.view.CustomLayout android:id="@+id/view_event_custom_layout" android:layout_width="300dp" android:layout_height="300dp" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" app:layout_constraintTop_toTopOf="parent" android:layout_marginTop="8dp" app:custom_orientation="vertical"&gt; &lt;com.***.view.CustomLayout2 android:id="@+id/view_event_custom_layout_2" android:layout_width="wrap_content" android:layout_height="wrap_content" app:custom_orientation="horizontal"&gt; &lt;com.***.view.CustomView android:id="@+id/view_event_custom_view_button" android:layout_width="wrap_content" android:layout_height="wrap_content" app:custom_text="@string/view_event_custom_view_button" app:custom_color="@color/colorAccent" app:custom_size="@dimen/smallTextSize" android:layout_marginLeft="@dimen/custom_margin_view"/&gt; &lt;TextView android:id="@+id/view_event_textview" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/view_event_textview" android:layout_marginLeft="@dimen/custom_margin_text"/&gt; &lt;/com.***.view.CustomLayout2&gt; &lt;TextView android:id="@+id/view_event_textview_2" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/view_event_textview" app:custom_margin="@dimen/custom_margin_text"/&gt; &lt;/com.***.view.CustomLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 正常流程，不做任何处理所有 API 都返回的是 super.***，走完整个 U 型图的流程。如下示例为点击 CustomView 后，触发了事件逐级向下分发、拦载、逐级向上响应的完整流程，包含 ACTION_DOWN 和 ACTION_UP 事件。 123456789101112131415161718192021222324// 处理 ACTION_DOWN 事件，Activity 开始分发事件19:26: 26395/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;// 第一层 ViewGroup 接收事件并向下分发 19:26: 26395/com.yD/:CustomLayout:: dispatchTouchEvent: // 第一层 ViewGroup 判断是否拦载19:26: 26395/com.yD/:CustomLayout:: onInterceptTouchEvent: // 第二层 ViewGroup 接收事件并向下分发 19:26: 26395/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: // 第二层 ViewGroup 判断是否拦载19:26: 26395/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: // 第三层 View 接收事件并分发19:26: 26395/com.yD/:CustomView:: dispatchTouchEvent: // 第三层 View 响应事件19:26: 26395/com.yD/:CustomView:: onTouchEvent: // 第二层 ViewGroup 向上响应事件19:26: 26395/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: // 第一层 ViewGroup 向上响应事件19:26: 26395/com.yD/:CustomLayout:: onTouchEvent: // Activity 开始响应事件并消费19:26: 26395/com.yD/:ViewEventActivity:: onTouchEvent: // 点击结束抬手，ACTION_UP，Activity 开始分发事件19:26: 26395/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;// 因为是 Activity 消费了 DOWN 事件，所以 UP 事件只到这一层响应并消费19:26: 26395/com.yD/:ViewEventActivity:: onTouchEvent: dispatchTouchEvent 的返回值 当层返回 super.dispatchTouchEvent不影响事件分发和响应，和正常流程完全一样 当层返回 false 分发：表示事件不再逐级向下传递分发。响应：同时该层也不会响应事件，该层（不含）逐级向上所有层都响应事件。如下示例为在 CustomLayout2 层直接返回 false： 123456789101112// 处理 ACTION_DOWN 事件19:40: 6728/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;19:40: 6728/com.yD/:CustomLayout:: dispatchTouchEvent: 19:40: 6728/com.yD/:CustomLayout:: onInterceptTouchEvent: // CustomLayout2 层直接返回 false ，事件不再向下分发传递，同时本层也不响应事件19:40: 6728/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: // 该层（不含）逐级向上所有层都响应事件19:40: 6728/com.yD/:CustomLayout:: onTouchEvent: 19:40: 6728/com.yD/:ViewEventActivity:: onTouchEvent: // 处理 ACTION_UP 事件，Activity 消费了 DOWN 事件，所以 UP 事件只到这一层响应并消费19:40: 6728/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;19:40: 6728/com.yD/:ViewEventActivity:: onTouchEvent: 当层返回 true表示该层消费了这次事件。 分发：事件不会继续在整个流程中传递分发响应：所有层都不响应该事件（因为分发流程未走完，所以响应流程无法开始）如下示例为在最底层的 CustomView 中直接返回 true 12345678910111213141516// 处理 ACTION_DOWN 事件19:46: 11801/com.yD/:XMT:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;19:46: 11801/com.yD/:XMT:CustomLayout:: dispatchTouchEvent: 19:46: 11801/com.yD/:XMT:CustomLayout:: onInterceptTouchEvent: 19:46: 11801/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 19:46: 11801/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: // CustomView 层直接返回 true，事件不再继续分发，同时所有层都不会响应事件19:46: 11801/com.yD/:XMT:CustomView:: dispatchTouchEvent: // 处理 ACTION_UP 事件，CustomView 的dispatchTouchEvent 消费了 DOWN 事件19:46: 11801/com.yD/:XMT:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;19:46: 11801/com.yD/:XMT:CustomLayout:: dispatchTouchEvent: 19:46: 11801/com.yD/:XMT:CustomLayout:: onInterceptTouchEvent: 19:46: 11801/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 19:46: 11801/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: // ACTION_UP 传递分发到这一层的 dispatchTouchEvent 并消费19:46: 11801/com.yD/:XMT:CustomView:: dispatchTouchEvent: onInterceptTouchEvent 的返回值无法消费事件。 当层返回 false 或者 super.onInterceptTouchEvent表示该层不做拦载，不影响事件分发和响应，和正常流程完全一样。 当层返回 true表示该层拦载了事件。 分发：事件不再逐级向下传递。响应：该层（含）逐级向上所有层都响应事件。如下示例为在 CustomLayout2 中直接返回 true 1234567891011121314// 处理 ACTION_DOWN 事件19:57: 22163/com.yD/:XMT:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;19:57: 22163/com.yD/:XMT:CustomLayout:: dispatchTouchEvent: 19:57: 22163/com.yD/:XMT:CustomLayout:: onInterceptTouchEvent: 19:57: 22163/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: // CustomLayout2 层直接返回true，拦载该事件，事件不再继续向下分发19:57: 22163/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: // 从 CustomLayout2 层（含）开始逐级向上响应事件 19:57: 22163/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: 19:57: 22163/com.yD/:XMT:CustomLayout:: onTouchEvent: 19:57: 22163/com.yD/:XMT:ViewEventActivity:: onTouchEvent: // 处理 ACTION_UP 事件，Activity 消费了 DOWN 事件，所以 UP 事件只到这一层响应并消费19:57: 22163/com.yD/:XMT:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;19:57: 22163/com.yD/:XMT:ViewEventActivity:: onTouchEvent: onTouchEvent 返回值分发：返回值不影响事件传递分发。响应：决定该层（不含）逐级向上所有层是否响应事件。 当层返回 false 或者 super.onTouchEvent表示不影响事件分发和响应，和正常流程完全一样。如果直接返回 false 仅仅是比 super.onTouchEvent 少调用一次父类的 onTouchEvent。 当层返回 true表示该层消费了事件，即该层（不含）逐级向上所有层都不响应事件了。该层（含）及之下层已经响应了事件。如下示例为 CustomLayout2 中返回 true： 123456789101112131415161718// 处理 ACTION_DOWN 事件20:01: 25724/com.yD/:XMT:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;20:01: 25724/com.yD/:XMT:CustomLayout:: dispatchTouchEvent: 20:01: 25724/com.yD/:XMT:CustomLayout:: onInterceptTouchEvent: 20:01: 25724/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 20:01: 25724/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 20:01: 25724/com.yD/:XMT:CustomView:: dispatchTouchEvent: // 并不影响事件的分发，也不影响下层级的响应20:01: 25724/com.yD/:XMT:CustomView:: onTouchEvent: // CustomLayout2 中返回 true，该层（不含）逐级向上将不再响应事件20:01: 25724/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: // 处理 ACTION_UP 事件，CustomLayout2 的 onTouchEvent 响应并消费了事件20:01: 25724/com.yD/:XMT:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;20:01: 25724/com.yD/:XMT:CustomLayout:: dispatchTouchEvent: 20:01: 25724/com.yD/:XMT:CustomLayout:: onInterceptTouchEvent: 20:01: 25724/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: // ACTION_UP 传递分发到这一层，onTouchEvent 响应并消费20:01: 25724/com.yD/:XMT:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: CustomLayout2 继承 CustomLayout如果 CustomLayout2 继承 CustomLayout ，则在调用 supder.*** 会多执行一次 CustomLayout 相关方法。 正常流程 Log 分析 12345678910111213141516171819// 事件正常下发10:01: 12487/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;10:01: 12487/com.yD/:CustomLayout:: dispatchTouchEvent: 10:01: 12487/com.yD/:CustomLayout:: onInterceptTouchEvent: 10:01: 12487/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: // 调用 super.***10:01: 12487/com.yD/:CustomLayout:: dispatchTouchEvent: 10:01: 12487/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: // 调用 super.***10:01: 12487/com.yD/:CustomLayout:: onInterceptTouchEvent: 10:01: 12487/com.yD/:CustomView:: dispatchTouchEvent: 10:01: 12487/com.yD/:CustomView:: onTouchEvent: 10:01: 12487/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: // 调用 super.***10:01: 12487/com.yD/:CustomLayout:: onTouchEvent: 10:01: 12487/com.yD/:CustomLayout:: onTouchEvent: 10:01: 12487/com.yD/:ViewEventActivity:: onTouchEvent: 10:01: 12487/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;10:01: 12487/com.yD/:ViewEventActivity:: onTouchEvent: CustomLayout 的 onTouchEvent 返回 true 时 12345678910111213141516171819202122232425// 事件正常下发10:10: 19035/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;10:10: 19035/com.yD/:CustomLayout:: dispatchTouchEvent: 10:10: 19035/com.yD/:CustomLayout:: onInterceptTouchEvent: 10:10: 19035/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: // 调用 super.***10:10: 19035/com.yD/:CustomLayout:: dispatchTouchEvent: 10:10: 19035/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: // 调用 super.***10:10: 19035/com.yD/:CustomLayout:: onInterceptTouchEvent: 10:10: 19035/com.yD/:CustomView:: dispatchTouchEvent: 10:10: 19035/com.yD/:CustomView:: onTouchEvent: 10:10: 19035/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: // 调用 super.***，但是 CustomLayout 在 onTouchEvent 响应完后消费了该事件10:10: 19035/com.yD/:CustomLayout:: onTouchEvent: // 所以不再再次调用 CustomLayout:: onTouchEvent: // UP 事件正常下发10:10: 19035/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;10:10: 19035/com.yD/:CustomLayout:: dispatchTouchEvent: 10:10: 19035/com.yD/:CustomLayout:: onInterceptTouchEvent: 10:10: 19035/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 10:10: 19035/com.yD/:CustomLayout:: dispatchTouchEvent: 10:10: 19035/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: // 同理调用 super.*** 时 CustomLayout 在 onTouchEvent 响应完后消费了该事件10:10: 19035/com.yD/:CustomLayout:: onTouchEvent: 事件分发及响应的部分源码分析 Activity 事件分发源码 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev);&#125; 大体的分发过程为：首先传递到 Activity，然后传给了 Activity 依附的 Window，接着由 Window 传给视图的顶层 View 也就是 DecorView，最后由 DecorView 向整个 ViewTree 分发。在 getWindow().superDispathTouchEvent 就是用来分发事件到 DecorView 中。如果整个 ViewTree 分发没有消费事件，会调用 Activity 的 onTouchEvent。 ViewGroup 和 View 事件分发伪代码 1234567891011121314151617181920212223242526// 点击事件产生后，会直接调用 dispatchTouchEvent() 方法public boolean dispatchTouchEvent(MotionEvent e) &#123; // 代表是否消费事件 boolean consumed = false; if (onInterceptTouchEvent(e)) &#123; // 只有 ViewGroup 才有该方法 // 如果返回 true 则代表当前 ViewGroup 拦截了点击事件 // 则该事件由当前 ViewGroup 的 onTouchEvent (）方法逐级向上响应事件 consumed = onTouchEvent(e); &#125; else &#123; // 如果返回 false 则代表当前 ViewGroup 不拦截点击事件 // 则该点击事件则会继续传递给它的子元素 // 子元素的 dispatchTouchEvent（）重复上述过程 for (View view: children) &#123; consumed = view.dispatchTouchEvent(e); if (consumed) &#123; break; &#125; &#125; // 如果分发没有消费该事件，则逐级向上响应 if (!consumed) &#123; consumed = onTouchEvent(e); &#125; &#125; return consumed;&#125; 常见监听事件的消费onTouch 监听 事件监听 123456view.setOnTouchListener(new View.OnTouchListener()&#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; ... &#125;&#125; onTouch 返回值返回 false 表示不影响整个事件分发响应流程。返回 true 表示 dispatchTouchEvent 分发消费这次事件。对应的 Log 打印： 1234567891011121314151617181920212223242526272829303132333435// CustomView 监听 onTouch 事件后的分发流程// onTouch 返回 false 走完整个 U 型流程17:07: 29706/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;17:07: 29706/com.yD/:CustomLayout:: dispatchTouchEvent: 17:07: 29706/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:07: 29706/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:07: 29706/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:07: 29706/com.yD/:CustomView:: dispatchTouchEvent: 17:07: 29706/com.yD/:ViewEventActivity:: customView, onTouch: 17:07: 29706/com.yD/:CustomView:: onTouchEvent: 17:07: 29706/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onTouchEvent: 17:07: 29706/com.yD/:CustomLayout:: onTouchEvent: 17:07: 29706/com.yD/:ViewEventActivity:: onTouchEvent: 17:07: 29706/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;17:07: 29706/com.yD/:ViewEventActivity:: onTouchEvent: // CustomView 监听 onTouch 事件后的分发流程// onTouch 返回 true// 查看源码 onTouch 是在 View 的 dispatchTouchEvent 中调用的// 返回 true 表示 消费了该事件17:09: 31152/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;17:09: 31152/com.yD/:CustomLayout:: dispatchTouchEvent: 17:09: 31152/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:09: 31152/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:09: 31152/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:09: 31152/com.yD/:CustomView:: dispatchTouchEvent: 17:09: 31152/com.yD/:ViewEventActivity:: customView, onTouch: 17:09: 31152/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;17:09: 31152/com.yD/:CustomLayout:: dispatchTouchEvent: 17:09: 31152/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:09: 31152/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:09: 31152/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:09: 31152/com.yD/:CustomView:: dispatchTouchEvent: 17:09: 31152/com.yD/:ViewEventActivity:: customView, onTouch: 源码分析源码可以看出，onTouch 回调是在 dispatchTouchEvent 中调用的，所以返回 true 时，表示分发消费了事件。 12345678910111213141516public boolean dispatchTouchEvent(MotionEvent event) &#123; ... ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED // 回调 onTouch 事件监听 &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; // 执行 onTouchEvent 事件分发响应流程 if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; ...&#125; onLongClick 监听 事件监听 123456view.setOnLongClickListener(new View.OnLongClickListener()&#123; @Override public boolean onLongClick(View v) &#123; ... &#125;&#125; onLongClick 返回值不管返回 true 还是 false，都表示在 onTouchEvent 响应中消费该事件，并且是在 ACTION_DOWN 中执行 onLongClick 回调。分析见下面 onTouchEvent 部分源码。对应的 Log 打印： 1234567891011121314151617:14: 3237/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;17:14: 3237/com.yD/:CustomLayout:: dispatchTouchEvent: 17:14: 3237/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:14: 3237/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:14: 3237/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:14: 3237/com.yD/:CustomView:: dispatchTouchEvent: 17:14: 3237/com.yD/:CustomView:: onTouchEvent: // ACTION_DOWN 中响应 onLongClick 事件17:14: 3237/com.yD/:ViewEventActivity:: customView, onLongClick: 17:14: 3237/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;17:14: 3237/com.yD/:CustomLayout:: dispatchTouchEvent: 17:14: 3237/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:14: 3237/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:14: 3237/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:14: 3237/com.yD/:CustomView:: dispatchTouchEvent: 17:14: 3237/com.yD/:CustomView:: onTouchEvent: onClick 监听 事件监听 123456view.setOnClickListener(new View.OnClickListener()&#123; @Override public void onClick(View v) &#123; ... &#125;&#125; 事件消费在 onTouchEvent 响应中消费该事件，并且是在 ACTION_UP 中执行 onClick 回调。对应的 Log 打印： 123456789101112131415161718// CustomView 监听 onClick 事件后的分发流程// 相当于在 onTouchEvent 中消费了该事件17:03: 26616/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_DOWN...&#125;17:03: 26616/com.yD/:CustomLayout:: dispatchTouchEvent: 17:03: 26616/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:03: 26616/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:03: 26616/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:03: 26616/com.yD/:CustomView:: dispatchTouchEvent: 17:03: 26616/com.yD/:CustomView:: onTouchEvent: 17:03: 26616/com.yD/:ViewEventActivity:: dispatchTouchEvent: ev MotionEvent &#123; action=ACTION_UP...&#125;17:03: 26616/com.yD/:CustomLayout:: dispatchTouchEvent: 17:03: 26616/com.yD/:CustomLayout:: onInterceptTouchEvent: 17:03: 26616/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, dispatchTouchEvent: 17:03: 26616/com.yD/:CustomLayout2:: :XMT:CustomLayout2:, onInterceptTouchEvent: 17:03: 26616/com.yD/:CustomView:: dispatchTouchEvent: 17:03: 26616/com.yD/:CustomView:: onTouchEvent: // ACTION_UP 中响应 onClick 事件17:03: 26616/com.yD/:ViewEventActivity:: customView, onClick: 源码分析参考如下源码，onLongClick 和 onClick 事件都是在 onTouchEvent 响应中回调了监听，其中：onLongClick 是在 ACTION_DOWN 中处理监听回调onClick 是在 ACTION_UP 中处理监听回调 1234567891011121314151617181920212223242526272829public boolean onTouchEvent(MotionEvent event) &#123; ... final int action = event.getAction(); ... if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: ... if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; // 事件点击事件监听 performClick(); &#125; ... case MotionEvent.ACTION_DOWN: ... setPressed(true, x, y); // 处理长按事件监听 checkForLongClick(0, x, y); ... &#125; return true; &#125; ...&#125; ViewGroup 中拒绝拦载事件可以通过设置 FLAG_DISALLOW_INTERCEPT 来要求 ViewGroup 拒绝拦载事件，源码如下： 12345678910111213141516171819202122// ViewGroup.java@Overridepublic void requestDisallowInterceptTouchEvent( boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We're already in this state, assume our ancestors are too return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 通过 requestDisallowInterceptTouchEvent 设置好 FLAG 后，在 ViewGroup 的事件分发机制中可以看到： 1234567891011121314151617181920212223242526// ViewGroup.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; ... boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; ... // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; // 获取 FLAG 判断是否允许拦载 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); &#125; else &#123; intercepted = false; &#125; &#125; else &#123; intercepted = true; &#125; ... ...&#125; 参考链接 http://www.jianshu.com/p/e99b5e8bd67b http://www.jianshu.com/p/7daf0feb6c2d http://blog.csdn.net/guolin_blog/article/details/9097463/ http://blog.csdn.net/guolin_blog/article/details/9153747/ http://www.cnblogs.com/duoduohuakai/p/3996385.html http://www.cnblogs.com/sunzn/archive/2013/05/10/3064129.html http://blog.csdn.net/carson_ho/article/details/54136311]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 ViewGroup]]></title>
    <url>%2F2017%2F11%2F28%2F0030-custom-viewgroup%2F</url>
    <content type="text"><![CDATA[基本概念ViewGroup 继承 View ，但是用来作为一个容器，装载各种 View 以及对它们做 UI 布局，比如高、宽、对齐方式等等，布局文件中凡是以 layout_ 开头的属性，都是传递给 ViewGroup 来解析和使用的。ViewGroup 主要是计算子 View 的测量高宽并决定他们的位置。 重写 LayoutParams 可以自定义子 View 的特定参数，比如 weight 等。 框架和层级结构View 和 ViewGroup 的绘制流程框架： 层级结构如下： 重要 API onMeasure测量自己的高宽；测量所有子 View 的高宽 onLayout抽象函数，必须重写。自定义子 View 的排列规则 自定义 ViewGroup 步骤自定义布局属性及 LayoutParams同样在 res/values/attr.xml 文件中定义 ViewGroup 的属性及样式。 123456789&lt;attr name="custom_orientation"&gt; &lt;enum name="horizontal" value="0" /&gt; &lt;enum name="vertical" value="1" /&gt;&lt;/attr&gt;&lt;declare-styleable name="CustomLayout"&gt; &lt;attr name="custom_orientation"/&gt; &lt;attr name="custom_margin" format="integer"/&gt;&lt;/declare-styleable&gt; 在布局文件使用时，示例如下： 123456789101112131415&lt;com.***.view.CustomLayout android:id="@+id/view_event_custom_layout" android:layout_width="300dp" android:layout_height="300dp" // 自定义Layout的属性1 app:custom_orientation="vertical" &gt; &lt;TextView android:id="@+id/view_event_textview" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@string/view_event_textview" // 自定义Layout的属性2 app:custom_margin="@dimen/custom_margin_text"/&gt;&lt;/com.***.view.CustomLayout&gt; 获取自定义布局属性在 ViewGroup 或者自定义 LayoutParams 的构造方法中获取自定义属性值。 123456789public CustomLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.CustomLayout); // 注意这里的 styleable 的字符串拼接 // 获取layout自定义属性orientation mOrientation = a.getInt(R.styleable.CustomLayout_custom_orientation, HORIZONTAL);&#125; 重写 LayoutParams 相关方法自定义类 LayoutParams 继承 ViewGroup.LayoutParams，并定义布局所需的几个变量。 123456789101112131415161718192021public static class LayoutParams extends ViewGroup.LayoutParams&#123; // layout 时需要使用的几个变量 public int left = 0; public int top = 0; public int right = 0; public int bottom = 0; // custom layout property public int custom_margin = 0; // 构造方法 public LayoutParams(Context c, AttributeSet attrs)&#123; super(c, attrs); // 获取layout自定义属性margin final TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.CustomLayout); custom_margin = a.getDimensionPixelSize( R.styleable.CustomLayout_custom_margin, 0); &#125; ...&#125; 如果自定义了 LayoutParams ，必须重写下面四个方法，确保能做类型转换。 1234567891011121314151617181920@Overridepublic LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new CustomLayout.LayoutParams(getContext(), attrs);&#125;@Overrideprotected ViewGroup.LayoutParams generateDefaultLayoutParams() &#123; return new CustomLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);&#125;@Overrideprotected boolean checkLayoutParams(ViewGroup.LayoutParams p) &#123; return p instanceof CustomLayout.LayoutParams;&#125;@Overrideprotected ViewGroup.LayoutParams generateLayoutParams(ViewGroup.LayoutParams p) &#123; return new CustomLayout.LayoutParams(p);&#125; 注意：如果没有重写这四个方法，会导致子 View 获取的 LayoutParams 转换为自定义时抛出异常：CustomLayout.LayoutParams lp = (CustomLayout.LayoutParams) childView.getLayoutParams();转换失败异常 Log 打印如下：java.lang.ClassCastException: android.view.ViewGroup$LayoutParams cannot be cast to com.***.view.CustomLayout$LayoutParams 重写 onMeasure实现两个功能： 计算子 View 的测量高宽 计算自身测量高宽 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); //measureChildren(widthMeasureSpec, heightMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int measureWidth = 0, measureHeight = 0; if(widthMode != MeasureSpec.AT_MOST)&#123; measureWidth = widthSize; &#125; if(heightMode != MeasureSpec.AT_MOST)&#123; measureHeight = heightSize; &#125; int totalLeft = 0, totalTop = 0; int count = getChildCount(); for(int i = 0; i &lt; count; i++)&#123; View childView = getChildAt(i); // 1. 计算子 View 的测量高宽 measureChild(childView, widthMeasureSpec, heightMeasureSpec); int measureChildWidth = childView.getMeasuredWidth(); int measureChildHeight = childView.getMeasuredHeight(); LayoutParams lp = (LayoutParams) childView.getLayoutParams(); // 方向为垂直是的计算方式 if(mOrientation == VERTICAL) &#123; lp.left = 0; lp.top = totalTop + lp.custom_margin; lp.right = measureChildWidth; lp.bottom = lp.top + measureChildHeight; totalTop = lp.bottom; // 如果 ViewGroup 高宽设置的是 wrap_content ，需要计算实际大小 if(widthMode == MeasureSpec.AT_MOST)&#123; measureWidth = Math.max(measureWidth, measureChildWidth); &#125; if(heightMode == MeasureSpec.AT_MOST)&#123; measureHeight = lp.bottom; &#125; &#125; ... &#125; // 2. 设置 ViewGroup 自身的测量高宽 setMeasuredDimension(measureWidth, measureHeight);&#125; 重写 onLayout计算子 View 的具体布局位置 1234567891011@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int count = getChildCount(); for(int i = 0; i &lt; count; i++)&#123; View childView = getChildAt(i); CustomLayout.LayoutParams lp = (CustomLayout.LayoutParams) childView.getLayoutParams(); // 指定子 View 具体的布局位置，这些位置是在 onMeasure 中计算的 childView.layout(lp.left, lp.top, lp.right, lp.bottom); &#125;&#125; 自定义 ViewGroup 中，至少需要重写 onMeasure 和 onLayout 总结 onMeasure 主要计算 wrap_content 模式下的测量高宽，包含自己和所有的子 View onLayout 主要计算子 View 布局的具体位置 onDraw 绘制自己，展现需要显示的内容 自定义 ViewGroup 主要计算自身和子 View 的测量高宽，以及子 View 布局的具体位置。自定义 View 主要计算自身的测量高宽，以及绘制自己。 问题在 Log 跟踪中发现 onLayout 和 onMeasure 会被调用执行两次 目标 自定义 ViewGroup 常见流程 必须重写 onLayout 及需要实现那些功能 是否处理事件分发流程 参考文档 http://www.jianshu.com/p/3d2c49315d68 http://blog.csdn.net/lmj623565791/article/details/38339817/ http://www.jianshu.com/p/138b98095778]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义 View]]></title>
    <url>%2F2017%2F11%2F28%2F0029-custom-view%2F</url>
    <content type="text"><![CDATA[基本概念测量模式 MeasureSpecMeasureSpec 由两部分组成： mode ： 测量模式 size ： 测量的尺寸大小 其中模式有三种： UNSPECIFIEDViewGroup 没有做约束，想要多大就多大，一般用于系统内部，如 ListView 等。 EXACTLY默认模式，按照给定的值精确计算，具体高宽值和 match_parent 都是这种模式。 AT_MOST相当于 wrap_content ，根据自身的内容的高宽来计算。 View 根据 ViewGroup 传入的测量值和模式，对自己宽高进行确定，并完成绘制。 onMeasure 实现测量，然后在 onDraw 中完成对自己的绘制。 重要 API onMeasure测量，决定高宽等，不是必须但大部分都会重写，重写主要需要针对 wrap_content 模式计算自身实际的高宽，通过调用 setMeasuredDimension 来设置。如果指定具体的高宽或者 match_parent 可以不用重写，父类默认是以这种方式来测量的。 onDraw绘制，即如何展现，必须重写 自定义 View 步骤自定义属性和样式在 res/values/ 下建立一个 attrs.xml ， 在里面定义 View 的属性和声明整个样式。 12345&lt;declare-styleable name="CustomView"&gt; &lt;attr name="custom_text" format="string" /&gt; &lt;attr name="custom_color" format="color" /&gt; &lt;attr name="custom_size" format="integer" /&gt;&lt;/declare-styleable&gt; 其中，format 一共有如下几种类型：string, boolean, color, dimension, enum, flag, float, fraction, integer, reference。在布局文件中需要引入这个自定义的属性，先加上这一句（老版本需要手动导入自定义 View 的包名）：xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;。后续就可以通过 app:custom*** 来设置自定义的属性了，如下所示： 12345678&lt;com.***.view.CustomView android:id="@+id/view_event_custom_view_button" android:layout_width="wrap_content" android:layout_height="wrap_content" // 自定义属性 app:custom_text="@string/view_event_custom_view_button" app:custom_color="@color/colorYellow" app:custom_size="@dimen/smallTextSize" /&gt; 在构造方法中获得自定义属性的值解析自定义属性时，注意 styleable 是通过 declare-styleable 中名称拼接来的。 12345678910111213141516171819202122final Resources.Theme theme = context.getTheme();TypedArray a = theme.obtainStyledAttributes(attrs, R.styleable.CustomView, defStyleAttr, 0);int n = a.getIndexCount();for (int i = 0; i &lt; n; i++) &#123; int attr = a.getIndex(i); switch (attr) &#123; // CustomView 和 custom_text 拼接 case R.styleable.CustomView_custom_text: mText = a.getText(attr).toString(); break; case R.styleable.CustomView_custom_color: mColor = a.getColor(attr, Color.BLACK); break; case R.styleable.CustomView_custom_size: int defaultSize = (int) TypedValue.applyDimension( TypedValue.COMPLEX_UNIT_SP, 24, getResources().getDisplayMetrics()); mSize = a.getDimensionPixelSize(attr, defaultSize); break; &#125;&#125; 重写 onMesure不是必须的，但是大部分都会重写。如果没有重写，当我们设置明确的宽度和高度时，系统帮我们测量的结果就是我们设置的结果；当我们设置为 WRAP_CONTENT 或者 MATCH_PARENT 系统帮我们测量的结果就是 MATCH_PARENT 的长度。所以当设置了 WRAP_CONTENT 时，需要代码中进行测量，即重写 onMesure 方法。 123456789101112131415161718192021222324252627282930313233343536@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 1. 获取模式 int widthMode = MeasureSpec.getMode(widthMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); Log.d(TAG, "onMeasure: widthMeasureSpec = " + MeasureSpec.toString(widthMeasureSpec) + ", heightMeasureSpec = " + MeasureSpec.toString(heightMeasureSpec)); // 2. 获取文本实际大小 Rect mBound mPaint.setTextSize(mSize); mPaint.getTextBounds(mText, 0, mText.length(), mBound); // 3. 初始化测量高宽 int measureWidth, measureHeight; // 如果是精确模式，测量高宽就是xml中设置的高宽 if(widthMode == MeasureSpec.EXACTLY)&#123; measureWidth = widthSize; &#125;else&#123; // 否则其他模式，设置为文本实际大小的高宽 float textWidth = mBound.width(); measureWidth = (int) (getPaddingLeft() + textWidth + getPaddingRight()); &#125; if(heightMode == MeasureSpec.EXACTLY)&#123; measureHeight = heightSize; &#125;else&#123; float textHeight = mBound.height(); measureHeight = (int) (getPaddingTop() + textHeight + getPaddingBottom()); &#125; // 4. 设置最终的高宽 setMeasuredDimension(measureWidth, measureHeight);&#125; 重写 onDraw主要是通过 Paint 和 Canvas 将需要表达的内容画出来。本例只是仿照 TextView 显示一段文本比较简单，所以只需要画出文本就行。 123456789101112@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 将整个 View 的框画出来，一目了然 mPaint.setColor(Color.BLUE); canvas.drawRect(0, 0, getMeasuredWidth(), getMeasuredHeight(), mPaint); // 需要显示的文本画出来 mPaint.setColor(mColor); canvas.drawText(mText, getWidth()/2 - mBound.width()/2, getHeight()/2 + mBound.height()/2, mPaint);&#125; View.draw() 的流程12345678910111213141516171819202122232425262728public void draw(Canvas canvas) &#123;/* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */// Step 1, draw the background, if neededdrawBackground(canvas);// skip step 2 &amp; 5 if possible (common case)// Step 3, draw the contentonDraw(canvas);// Step 4, draw the childrendispatchDraw(canvas);// Step 6, draw decorations (foreground, scrollbars)onDrawForeground(canvas);...&#125; 重新布局和绘制API requestLayout会调用 onMeasure 和 onLayout 进行重新测量及布局，但不会调用 draw 的过程，不会重新绘制任何 View 包括该调用者本身 invalidate只能在 UI 线程中执行。请求重绘 View （也就是 draw方法），哪个 View 请求 invalidate 系列方法，就重绘该 View。即 View 只绘制该 View，ViewGroup 绘制整个 ViewGroup postInvalidate非 UI 线程中请求重绘 View 示例CustomView 设置文本时请求重新布局和绘制 12345public void setText(String text)&#123; mText = text; requestLayout(); invalidate();&#125; 目标 自定义 View 常见流程 View 的绘制 处理事件分发流程 参考文档 http://blog.csdn.net/lmj623565791/article/details/24252901/ http://blog.csdn.net/congqingbin/article/details/7869730 http://blog.csdn.net/yanbober/article/details/46128379/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CheckedTextView 详解]]></title>
    <url>%2F2017%2F11%2F28%2F0028-checked-textview%2F</url>
    <content type="text"><![CDATA[介绍查看源码，CheckedTextView 实际上就是一个可以接受选中的 TextView ，并且能自定义更换选中的图标. 123456789public class CheckedTextView extends TextView implements Checkable &#123; // 标记选中状态 private boolean mChecked; ... // 可以更换选中显示的图标 private Drawable mCheckMarkDrawable; public void setCheckMarkDrawable(@Nullable Drawable d)&#123;...&#125; ...&#125; 多种样式系统自带三种样式： 多选模式 单选模式 选中模式 12345678// 多选模式android:checkMark="?android:attr/listChoiceIndicatorMultiple"// 单选模式android:checkMark="?android:attr/listChoiceIndicatorSingle"// 复选标记，图标是一个对勾android:checkMark="?android:attr/textCheckMark"// 垂直居中android:gravity="center_vertical" 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;CheckedTextView android:id="@+id/ctv_single_choice" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" android:layout_marginTop="16dp" android:checkMark="?android:attr/listChoiceIndicatorSingle" android:checked="false" android:gravity="center_vertical" android:text="@string/checked_text_single_choice" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt;&lt;CheckedTextView android:id="@+id/ctv_multiple_choice" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" android:layout_marginTop="16dp" android:checkMark="?android:attr/listChoiceIndicatorMultiple" android:gravity="center_vertical" android:text="@string/checked_text_multiple_choice" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toBottomOf="@+id/ctv_single_choice" /&gt;&lt;CheckedTextView android:id="@+id/ctv_check_mark" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" android:layout_marginTop="16dp" android:checkMark="?android:attr/textCheckMark" android:gravity="center_vertical" android:text="@string/checked_text_check_mark" app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" app:layout_constraintTop_toBottomOf="@+id/ctv_multiple_choice" /&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout 详解]]></title>
    <url>%2F2017%2F11%2F28%2F0027-constraint-layout%2F</url>
    <content type="text"><![CDATA[概述ConstraintLayout 是一种构建于弹性 Constraints（约束）系统的新型 Android Layout，使用方法和 RelativeLayout 类似，但是比它更灵活和更容易使用。 依赖包12345678910111213To use ConstraintLayout in your project, proceed as follows: Ensure you have the latest Constraint Layout library: 1. Click Tools &gt; Android &gt; SDK Manager. 2. Click the SDK Tools tab. 3. Expand Support Repository and then check ConstraintLayout for Android and Solver for ConstraintLayout. Check Show Package Details and take note of the version you&apos;re downloading (you&apos;ll need this below).4. Click OK. 5. Add the library as a dependency in your module-level build.gradle file: dependencies &#123; compile &apos;com.android.support.constraint:constraint-layout:1.0.1&apos;&#125;The library version you download may be higher, so be sure the value you specify here matches the version from step 3.6. In the toolbar or sync notification, click Sync Project with Gradle Files.Now you&apos;re ready to build your layout with ConstraintLayout 现在 Android Studio 2.3 工具默认新建的 layout 就是 ConstraintLayout，作为官方标配。而且支持将其他官方 layout 一键直接转换为 ConstraintLayout。 View 的尺寸三种值与其他 Layout 不同之处在于，它的 layout_width 和 layout_height 不支持设置 match_parent，其属性取值只有以下三种情况： wrap_content 指定具体dp值 0dp（match_constraint，any size） 0dp 的用途代表填充约束之意（any size），注意不要以为和 match_parent 是一样的；match_parent 是用于填充满当前控件的父布局，而 any size 是用于填充满当前控件的约束规则。 填充屏幕宽度 1234567&lt;Spinner android:id="@+id/spinner_show_checkedtextview" android:layout_width="0dp" android:layout_height="wrap_content" // 左右两边拉伸到和屏幕宽度保持一致 app:layout_constraintLeft_toLeftOf="parent" app:layout_constraintRight_toRightOf="parent" /&gt; 设置特定的宽高比 123456789&lt;ImageView android:id="@+id/imageView" android:layout_width="0dp" android:layout_height="126dp" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintRight_toRightOf="parent" app:srcCompat="@mipmap/ic_launcher" // 设置宽和高的比例为2:1 app:layout_constraintDimensionRatio="w,2:1" /&gt; 链（chain）Chain 链是一种特殊的约束，让多个 chain 链连接的 Views 能够平分剩余空间位置。和 LinearLayout 中的权重比 weight 很相似 ，但 Chains 链能做到的远远不止权重比 weight 的功能。 创建链选择多个想要链接到一起的 Views ，然后再右键选择 Center Horizontally 或者 Center Vertically 来创建水平链或者垂直链。如下，创建一个水平链： 链的模式 spread chainChain 链的默认模式就是 spread 模式，它将平分间隙让多个 Views 布局到剩余空间 spread inside chainspread inside 模式，它将会把两边最边缘的两个 View 到外向父组件边缘的距离去除，然后让剩余的 Views 在剩余的空间内平分间隙布局 packed chainspacked 模式将所有 Views 打包到一起不分配多余的间隙（当然不包括通过 margin 设置多个 Views 之间的间隙），然后将整个组件组在可用的剩余位置居中。在 packed chain 链模式，打包在一起的 Views 组可以进一步通过控制修改 bias 值来控制打包组的位置，如 bias 模式是 0.5 将 Views 组居中。 链的权重spread 和 spread inside 链可以设置每个组件的 weight 权重，类似于 LinearLayout 的 weight 权重。当前 AS 版本不能直接在视图编辑器设置这个权重，需要在 XML 文件中手动设置。假设该 View 是在一个水平的 Chain 链中，在 XML 中设置 12android:layout_width="0dp"app:layout_constraintHorizontal_weight="1" 注意：在 packed 链模式下设置权重 weight 并没有作用。 就是说并不像 spread 和 spread inside 模式中表现的占据尽可能的剩余空间，在 packed 模式下该组件就会被收缩成 0 大小。 示例三个 ListView 水平并列排列，使用默认的链模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;ListView // 最左边的ListView android:id="@+id/lv_array_adapter_left" // 宽度设置为0dp，同时水平权重设置为1 android:layout_width="0dp" android:layout_height="160dp" android:layout_marginTop="16dp" app:layout_constraintHorizontal_weight="1" // 最左边 app:layout_constraintLeft_toLeftOf="parent" // 链组合 app:layout_constraintRight_toLeftOf="@+id/lv_array_adapter_center" app:layout_constraintTop_toTopOf="parent" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" // 链模式 app:layout_constraintHorizontal_chainStyle="spread" /&gt; &lt;ListView // 中间的ListView android:id="@+id/lv_array_adapter_center" // 宽度设置为0dp，同时水平权重设置为2 android:layout_width="0dp" android:layout_height="160dp" android:layout_marginTop="16dp" app:layout_constraintHorizontal_weight="2" app:layout_constraintTop_toTopOf="parent" // 链组合 app:layout_constraintRight_toLeftOf="@+id/lv_array_adapter_right" app:layout_constraintLeft_toRightOf="@+id/lv_array_adapter_left" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" /&gt;&lt;ListView // 最右边的ListView android:id="@+id/lv_array_adapter_right" // 宽度设置为0dp，同时水平权重设置为1.5 android:layout_width="0dp" android:layout_height="160dp" android:layout_marginTop="16dp" app:layout_constraintHorizontal_weight="1.5" app:layout_constraintTop_toTopOf="parent" // 最右边 app:layout_constraintRight_toRightOf="parent" // 链组合 app:layout_constraintLeft_toRightOf="@+id/lv_array_adapter_center" android:layout_marginLeft="8dp" android:layout_marginRight="8dp" /&gt; 对应生成的效果图： 参考文档 http://www.jianshu.com/p/a8b49ff64cd3 https://developer.android.com/training/constraint-layout/index.html https://codelabs.developers.google.com/codelabs/constraint-layout/#0 http://www.tuicool.com/articles/QJBbUfv 了解使用-constraintlayout-的性能优势]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adapter 详解]]></title>
    <url>%2F2017%2F11%2F28%2F0026-adapter%2F</url>
    <content type="text"><![CDATA[基础适配器模式将一个类的接口转换成客户希望的另外一个接口， Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 Android 中适配器模式的运用Android 中的 ListView 、 GridView 、 Spinner 、 AutoCompleted 等 AdapterView 在做视图展示时需要填充数据，但是每个视图的显示效果，需要的数据等等都不一样，所以增加了一个 Adapter 层来应对变化。 常用的 Adapter BaseAdapter抽象类，自定义 Adapter 实现该类，拥有较高的灵活性 ArrayAdapter支持泛型操作，最为简单，常用来展示一行文本 SimpleCursorAdapter绑定查询到的 Cursor 游标到视图上，字段和 View 的 id 对应起来 SimpleAdapter有最好的扩充性，可以自定义出各种效果，需要实现数据填充 Adapter 对应的常用系统自带布局文件1234567891011121314151617181920212223242526// 单行文本TextView android.R.layout.simple_list_item_1.xml // 两行文本TextView，如名字-电话号码 android.R.layout.simple_list_item_2.xml // 单行文本CheckedTextView，具有RadioButton样式 android.R.layout.simple_list_item_single_choice.xml // 单行文本CheckedTextView，具有CheckBox样式 android.R.layout.simple_list_item_multiple_choice.xml // 单行文本CheckedTextView，也是多选但是是&quot;对勾&quot;样式 android.R.layout.simple_list_item_checked.xml // 两行文本TextView，加上一个RadioButton android.R.layout.simple_list_item_2_single_choice.xml // 单行文本TextView，选中整行高亮 android.R.layout.simple_list_item_activated_1.xml // 两行文本TextView，选中整行高亮 android.R.layout.simple_list_item_activated_2.xml // 单行文本TextView，spinner android.R.layout.simple_spinner_item.xml // 单行文本CheckedTextView，下拉样式，和simple_spinner_item区别不大android.R.layout.simple_spinner_dropdown_item.xml // 单行文本TextView，下拉样式，常用于自动填充，AutoCompleted android.R.layout.simple_dropdown_item_1line.xml// 单行文本TextView，expandalble样式（有左边距，左边空出一部分）android.R.layout.simple_expandable_list_item_1.xml// 两行文本TextView，expandalble样式android.R.layout.simple_expandable_list_item_2.xml ArrayAdapter 介绍源码分析用来显示至少包含一行 TextView 的字符串列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 定义，泛型操作，T 可以是简单数据类型，也可以是自定义的类（需要实现 toString ）public class ArrayAdapter&lt;T&gt; extends BaseAdapter implements Filterable, ThemedSpinnerAdapter &#123;...&#125;// 构造函数必须要指定布局// 不指定 TextView id，表示布局就是一个 TextView，初始化空 ArrayListpublic ArrayAdapter(Context, int) &#123;...&#125;// 组合布局，指定具体的 TextView idpublic ArrayAdapter(Context, int, int) &#123;...&#125;// 不指定 TextView id，布局就是一个 TextView，指定数据数组public ArrayAdapter(Context, int, T[]) &#123;...&#125;// 组合布局，指定具体的 TextView id，并指定数据数组public ArrayAdapter(Context, int, int, T[]) &#123;...&#125;// 不指定 TextView id，布局就是一个 TextView，指定数据 Listpublic ArrayAdapter(Context, int, List&lt;T&gt;) &#123;...&#125;// 以上构造函数都会调用这个最详细的构造public ArrayAdapter(@NonNull Context context, @LayoutRes int resource, @IdRes int textViewResourceId, @NonNull List&lt;T&gt; objects) &#123;...&#125;...// getView 的具体实现@Overridepublic @NonNull View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; return createViewFromResource(mInflater, position, convertView, parent, mResource);&#125;private @NonNull View createViewFromResource(@NonNull LayoutInflater inflater, int position, @Nullable View convertView, @NonNull ViewGroup parent, int resource) &#123; final View view; final TextView text; if (convertView == null) &#123; view = inflater.inflate(resource, parent, false); &#125; else &#123; view = convertView; &#125; try &#123; if (mFieldId == 0) &#123; // If no custom field is assigned, assume the whole resource is a TextView // 不指定 TextView id，则默认整个布局文件就是 TextView text = (TextView) view; &#125; else &#123; // Otherwise, find the TextView field within the layout // 至少包含一个 TextView text = (TextView) view.findViewById(mFieldId); if (text == null) &#123; throw new RuntimeException("Failed to find view with ID " + mContext.getResources().getResourceName(mFieldId) + " in item layout"); &#125; &#125; &#125; catch (ClassCastException e) &#123; Log.e("ArrayAdapter", "You must supply a resource ID for a TextView"); throw new IllegalStateException( "ArrayAdapter requires the resource ID to be a TextView", e); &#125; // getItem 的实现是从 objects 中获取数据 final T item = getItem(position); if (item instanceof CharSequence) &#123; text.setText((CharSequence) item); &#125; else &#123; // 数据转换为字符串。T 可以是简单数据类型，也可以是自定义的类 text.setText(item.toString()); &#125; return view;&#125; 示例根据源码构造函数的分析，我们常用的有如下三种： 简单字符串显示 自定义布局 自定义数据集合 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 展示三种 ArrayAdapter 的用法private void initArrayAdapter()&#123; // 简单字符串显示，使用系统自带的布局 simple_list_item_1 ListView arrayListLeft = (ListView) findViewById(R.id.lv_array_adapter_left); String[] arrayData1 = new String[]&#123;"Left1", "Left2", "Left3", "Left4"&#125;; ArrayAdapter stringAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, arrayData1); arrayListLeft.setAdapter(stringAdapter); // 自定义布局，布局 array_adapter_user_samples 文件中必须包含 TextView 和 Button // 初始化 ArrayAdapter 时，需要指定 TextView 的 ID：tv_array_adapter_sample ListView arrayListCenter = (ListView) findViewById(R.id.lv_array_adapter_center); String[] arrayData2 = new String[]&#123;"Center1", "Center2", "Center3", "Center4"&#125;; ArrayAdapter userLayoutAdapter = new ArrayAdapter&lt;String&gt;(this, R.layout.array_adapter_user_samples, R.id.tv_array_adapter_sample, arrayData2); arrayListCenter.setAdapter(userLayoutAdapter); // 自定义数据集合，使用系统自带布局 simple_list_item_checked ListView arrayListRight = (ListView) findViewById(R.id.lv_array_adapter_right); List&lt;UserData&gt; dataList = initUserDataList(); ArrayAdapter userDataAdapter = new ArrayAdapter&lt;UserData&gt;(this, android.R.layout.simple_list_item_checked, dataList); arrayListRight.setAdapter(userDataAdapter);&#125;// 自定义数据类，必须重写 toString，根据 ArrayAdapter 源码分析// 数据填充时，必须使用 toString 来赋值private class UserData&#123; private String mStr; private int mNum; public UserData(String str, int num)&#123; mStr = str; mNum = num; &#125; public String toString()&#123; return mStr + String.valueOf(mNum); &#125;&#125;// 初始化数据集合private List&lt;UserData&gt; initUserDataList()&#123; List&lt;UserData&gt; dataList = new ArrayList&lt;UserData&gt;(); String pre = "Right"; for(int i = 1; i &lt;= 4; i++) &#123; UserData data = new UserData(pre, i); dataList.add(data); &#125; return dataList;&#125; 如上代码对应的效果图： SimpleCursorAdapter 介绍类定义123456789101112131415161718// 类定义public class SimpleCursorAdapter extends ResourceCursorAdapter &#123;...&#125;public abstract class ResourceCursorAdapter extends CursorAdapter &#123;...&#125;/** * Adapter that exposes data from a &#123;@link android.database.Cursor Cursor&#125; to a * &#123;@link android.widget.ListView ListView&#125; widget. * &lt;p&gt; * The Cursor must include a column named "_id" or this class will not work. * Additionally, using &#123;@link android.database.MergeCursor&#125; with this class will * not work if the merged Cursors have overlapping values in their "_id" * columns. */public abstract class CursorAdapter extends BaseAdapter implements Filterable, CursorFilter.CursorFilterClient, ThemedSpinnerAdapter &#123;...&#125;// 构造函数public SimpleCursorAdapter(Context context, int layout, Cursor c, String[] from, int[] to, int flags) &#123;...&#125; 注意： CursorAdapter 中的 Cursor 必须包含一列 “_id”，也就是查询时 projection 中要包含 _id，但 UI 中并不需要显示这列 具体示例及错误分析12345678910111213141516171819202122232425262728// 例子使用 CursorLoader 异步加载// 构造函数初始化时传递的是一个 null 的 cursor，只需要显示姓名和号码String[] from = new String[]&#123; ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME, ContactsContract.CommonDataKinds.Phone.NUMBER&#125;;int[] to = new int[]&#123;android.R.id.text1, android.R.id.text2&#125;;mSimpleCursorAdapter = new SimpleCursorAdapter(this, android.R.layout.simple_list_item_2, null, from, to, 0);// 定义 projections，必须包含一列 _idString[] projections = new String[]&#123; ContactsContract.CommonDataKinds.Phone._ID, ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME, ContactsContract.CommonDataKinds.Phone.NUMBER&#125;;// 返回具体的实例，包含 Cursorreturn new CursorLoader(getApplicationContext(), ContactsContract.CommonDataKinds.Phone.CONTENT_URI, projections, null, null, null);// 如果 projections 中不包含 id， 在使用 swapCursor 时会抛出如下异常06-30 11:15:26.679 11899-11899/com.***.*** E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.***.***, PID: 11899java.lang.IllegalArgumentException: column '_id' does not exist at android.database.AbstractCursor.getColumnIndexOrThrow(AbstractCursor.java:303) at android.database.CursorWrapper.getColumnIndexOrThrow(CursorWrapper.java:78) at android.widget.CursorAdapter.swapCursor(CursorAdapter.java:342) at android.widget.SimpleCursorAdapter.swapCursor(SimpleCursorAdapter.java:346) swapCursor 的源码分析CursorAdapter.java 文件中： SimpleAdapter 介绍SimpleAdapter 的扩展性最好，可以定义各种各样的布局出来，可以显示比较复杂的列表，包括每行显示图片、文字等，只是简单的负责显示。使用 SimpleAdapter 的数据用一般都是 HashMap 构成的 List。HashMap 的每个键值数据映射到布局文件中对应 id 的组件上。因为系统没有对应的布局文件可用，我们可以自己定义一个布局。 构造函数12public SimpleAdapter(Context context, List&lt;? extends Map&lt;String, ?&gt;&gt; data, @LayoutRes int resource, String[] from, @IdRes int[] to) &#123; 参数说明： context data由 Map(String ,Object) 列表填充的数据集合 resource界面布局文件 from数据 Map 集合中的 key to布局文件中各组件 id，和 Map 集合中的 key 需要一一对应，资源数据按照这个对应关系来填充值 系统默认支持的布局默认布局中支持如下控件： Checkable TextView ImageView 参考 bindview 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// SimpleAdapter.java:: bindview，代码部分有删减private void bindView(int position, View view) &#123; ... final ViewBinder binder = mViewBinder; final String[] from = mFrom; final int[] to = mTo; ... boolean bound = false; // 使用了系统默认不支持的控件，需要实现 ViewBinder // 重写 setViewValue if (binder != null) &#123; bound = binder.setViewValue(v, data, text); &#125; // 系统默认支持的控件：Checkable，TextView，ImageView // 如果 binder 不存在或者绑定不成功，使用系统默认方式绑定 if (!bound) &#123; if (v instanceof Checkable) &#123; if (data instanceof Boolean) &#123; ((Checkable) v).setChecked((Boolean) data); &#125; else if (v instanceof TextView) &#123; // Note: keep the instanceof TextView check at the bottom of these // ifs since a lot of views are TextViews (e.g. CheckBoxes). setViewText((TextView) v, text); &#125; else &#123; throw new IllegalStateException(v.getClass().getName() + " should be bound to a Boolean, not a " + (data == null ? "&lt;unknown type&gt;" : data.getClass())); &#125; &#125; else if (v instanceof TextView) &#123; // Note: keep the instanceof TextView check at the bottom of these // ifs since a lot of views are TextViews (e.g. CheckBoxes). setViewText((TextView) v, text); &#125; else if (v instanceof ImageView) &#123; if (data instanceof Integer) &#123; setViewImage((ImageView) v, (Integer) data); &#125; else &#123; setViewImage((ImageView) v, text); &#125; &#125; else &#123; throw new IllegalStateException(v.getClass().getName() + " is not a " + " view that can be bounds by this SimpleAdapter"); &#125; &#125; ...&#125; 参考源码，按以下顺序绑定数据： Checkable如果 View 实现了 Checkable（例如 CheckBox），期望绑定值是一个布尔类型 TextView期望绑定值是一个字符串类型，通过调用 setViewText(TextView, String) 绑定数据 ImageView期望绑定值是一个资源 id 或者一个字符串，通过调用 setViewImage(ImageView, int) 或 setViewImage(ImageView, String) 绑定数据 如果没有一个合适的绑定发生将会抛出 IllegalStateException 自定义布局自定义布局中如果包含了不是系统默认支持控件，需要实现 ViewBinder 接口 123456789101112131415161718public static interface ViewBinder &#123; /** * Binds the specified data to the specified view. * * When binding is handled by this ViewBinder, this method must return true. * If this method returns false, SimpleAdapter will attempts to handle * the binding on its own. * * @param view the view to bind the data to * @param data the data to bind to the view * @param textRepresentation a safe String representation of the supplied data: * it is either the result of data.toString() or an empty String but it * is never null * * @return true if the data was bound to the view, false otherwise */ boolean setViewValue(View view, Object data, String textRepresentation);&#125; BaseAdapter 介绍类定义及重写类定义：public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter {...} 重写四个方法： 1234public int getCount() &#123;...&#125;public Object getItem(int position)&#123;...&#125;public long getItemId(int position)&#123;...&#125;public View getView(int position, View convertView, ViewGroup parent) &#123;...&#125; 其中 getView 最关键，特别是数据很多时如果全部加载会非常消耗资源，导致 ListView 滑动慢，常用的解决方案是：convertView + ViewHolder 方案 ViewHolder 的意义ViewHolder 是一个静态类， 用来缓存了显示数据的视图，加快 UI 的响应速度。 To work efficiently the adapter implemented here uses two techniques:（译：提升 Adapter 性能的两种方法：）-It reuses the convertView passed to getView() to avoid inflating View when it is not necessary（译：重用缓存 convertView 传递给 getView() 方法来避免填充不必要的视图）-It uses the ViewHolder pattern to avoid calling findViewById() when it is not necessary（译：使用 ViewHolder 模式来避免没有必要的调用 findViewById()：因为太多的 findViewById 也会影响性能）ViewHolder类的作用-The ViewHolder pattern consists in storing a data structure in the tag of the viewreturned by getView().This data structures contains references to the views we want to bind data to, thus avoiding calling to findViewById() every time getView() is invoked（译：ViewHolder 模式通过 getView() 方法返回的视图的标签 Tag 中存储一个数据结构，这个数据结构包含了指向我们要绑定数据的视图的引用，从而避免每次调用 getView() 的时候调用 findViewById()） 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 静态类ViewHolderprivate static class ViewHolder&#123; ImageView img; TextView tvName; TextView tvDesc;&#125;private class CustomAdapter extends BaseAdapter&#123; private LayoutInflater mLayoutInflater; public CustomAdapter(Context context)&#123; mLayoutInflater = LayoutInflater.from(context); &#125; // 重写四个方法 @Override public int getCount() &#123; return mAdapterData.size(); &#125; @Override public Object getItem(int position) &#123; return mAdapterData.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; // 使用Holder ViewHolder holder = null; if(convertView == null)&#123; convertView = mLayoutInflater.inflate(R.layout.simple_adapter_user_samples, null); holder = new ViewHolder(); holder.img = (ImageView) convertView.findViewById(R.id.iv_simple_adapter); holder.tvName = (TextView) convertView.findViewById(R.id.tv_simple_adapter_name); holder.tvDesc = (TextView) convertView.findViewById(R.id.tv_simple_adapter_desc); // Holder保存到converView中 convertView.setTag(holder); &#125;else &#123; holder = (ViewHolder) convertView.getTag(); &#125; Map&lt;String, Object&gt; map = mAdapterData.get(position); holder.img.setImageResource((int)map.get(ADAPTER_KEY_IMG)); holder.tvName.setText((String)map.get(ADAPTER_KEY_NAME)); holder.tvDesc.setText((String)map.get(ADAPTER_KEY_DESC)); return convertView; &#125;&#125; Spinner 介绍标准用法定义布局文件和下拉布局，并填充数据 1234567Spinner spinner = (Spinner)findViewById(R.id.spinner_show_checkedtextview);// Spinner 显示的样式为 simple_spinner_item，自定义的布局修改了系统的背景色ArrayAdapter&lt;CharSequence&gt; adapter = ArrayAdapter.createFromResource( this, R.array.screen_orientations, R.layout.simple_spinner_item);// Spinner 下拉菜单显示的样式为 simple_spinner_dropdown_itemadapter.setDropDownViewResource(R.layout.simple_spinner_dropdown_item);spinner.setAdapter(adapter); Spinner 显示样式和下拉菜单样式的区别： 如果 Adapter 不设置 setDropDownViewResource ，默认下拉菜单和显示使用同一个布局。 两种模式默认模式为 dropdown 12android:spinnerMode="dialog"android:spinnerMode="dropdown"]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loader 机制]]></title>
    <url>%2F2017%2F11%2F27%2F0025-loader%2F</url>
    <content type="text"><![CDATA[概述加载器 Loader 支持在 Activity 或 Fragment 中异步加载数据，具有如下几个特点： 可用于每个 Activity 和 Fragment 支持异步加载数据 监控其数据源并在内容变化时传递新结果 在某一配置更改后重建 Loader 时，会自动重新连接上一个 Loader 的 Cursor，因此它们无需重新查询其数据 API 简介 LoaderManager与 Activity 或 Fragment 相关联的的抽象类，用于管理一个或多个 Loader 实例。这有助于应用管理与 Activity 或 Fragment 生命周期相关联的、运行时间较长的操作。用来管理实例初始化，获取，重启一个 Loader。 LoaderManager.LoaderCallbacks回调接口，用于 UI 与 LoaderManager 进行交互。执行 Loader 回调，绑定分发 Loader，完成加载，重置数据等。 Loader执行异步数据加载的抽象类，基类。运行异步操作，有开始，完成，后台加载等接口实现。常用 CursorLoader 或自己定义的子类。 AsyncTaskLoader提供 AsyncTask 来执行工作的抽象加载器。 CursorLoaderAsyncTaskLoader 的子类，它将查询 ContentResolver 并返回一个 Cursor。此类采用标准方式为查询游标实现 Loader 协议。它是以 AsyncTaskLoader 为基础而构建，在后台线程中执行 Cursor 查询，以免阻塞应用的 UI 。使用此加载器是从 ContentProvider 异步加载数据的最佳方式，而不用通过 Fragement 或 Activity 的 API 来执行托管查询。 使用加载器LoaderManager 可在 Activity 或 Fragment 内管理一个或多个 Loader 实例；但是每个 Activity 或 Fragment 中只有一个 LoaderManager 。常用接口： 123456public abstract &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback);public abstract &lt;D&gt; Loader&lt;D&gt; restartLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback);public abstract void destroyLoader(int id);public abstract &lt;D&gt; Loader&lt;D&gt; getLoader(int id); 启动加载器通常在 Activity 的 onCreate() 方法或 Fragment 的 onActivityCreated() 方法内初始化 Loader ，如： 1234567// Prepare the loader. Either re-connect with an existing one,// or start a new one.getLoaderManager().initLoader(0, null, this);// initLoader的详细定义public abstract &lt;D&gt; Loader&lt;D&gt; initLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback); initLoader() 方法参数解析： id用于标识加载器的唯一 ID，此示例中为 0 args在构建时提供给加载器的可选参数，可以保存任何数据，示例中为 null callbackLoaderManager.LoaderCallbacks 的实现，LoaderManager 将调用此实现来报告加载器事件 注意： initLoader() 方法将返回已创建的 Loader，但不必使用该引用， LoaderManager 将自动管理加载器的生命周期，根据需要启动和停止加载，并维护加载器的状态及其相关内容。 重启加载器使用 initLoader() 时，将使用含有指定 ID 的现有加载器。如果没有则它会创建一个。但是如果需要舍弃这些旧数据并重新开始，可以重启加载器： 123456// 重启加载器，ID必须和初始化时相同getLoaderManager().restartLoader(0, null, this);// restartLoader的详细定义public abstract &lt;D&gt; Loader&lt;D&gt; restartLoader(int id, Bundle args, LoaderManager.LoaderCallbacks&lt;D&gt; callback); 使用加载器回调LoaderManager.LoaderCallbacks 是交互的回调接口，都是在主线程中执行，包括以下方法： 12345public interface LoaderCallbacks&lt;D&gt; &#123; public Loader&lt;D&gt; onCreateLoader(int id, Bundle args); public void onLoadFinished(Loader&lt;D&gt; loader, D data); public void onLoaderReset(Loader&lt;D&gt; loader);&#125; onCreateLoader()针对指定的 ID 进行实例化并返回新的 Loader onLoadFinished()在先前创建的加载器完成加载时调用 onLoaderReset()在先前创建的加载器重置且其数据因此不可用时调用 onCreateLoader 详解initLoader() 方法检查是否已存在由该 ID 指定的加载器。如果没有它将触发LoaderManager.LoaderCallbacks 方法 onCreateLoader() 。在此方法中，返回新建的加载器。比如：返回 CursorLoader 对 ContentProvider 执行查询时所需的一系列完整信息，查询是异步执行的。 onLoadFinished 详解当先前创建的加载器完成加载时调用此方法。一般情况下会使用 CursorLoader 和 CursorAdapter 组合的方式异步更新数据源。其中 CursorLoader 异步加载 Cursor 后，通过 CursorAdapter 的 swapCursor() 方法来更新数据，该方法会返回之前旧的 Cursor ，但是我们不需要手动去关闭这个旧游标，CursorLoader 会在 onLoadFinished 执行完后自动关闭这个旧游标。示例及源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940// 1. 示例// This is the Adapter being used to display the list's data.SimpleCursorAdapter mAdapter;...// 每次数据源都有更新的时候，就会回调这个方法，然后update 我们的 UI 了public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor data) &#123; // Swap the new cursor in. (The framework will take care of closing the // old cursor once we return.) mAdapter.swapCursor(data);&#125;// 2. 游标管理源码分析// CursorLoader.java/* Runs on the UI thread */@Overridepublic void deliverResult(Cursor cursor) &#123; if (isReset()) &#123; // An async query came in while the loader is stopped if (cursor != null) &#123; cursor.close(); &#125; return; &#125; Cursor oldCursor = mCursor; mCursor = cursor; if (isStarted()) &#123; // 这里会执行回调函数 onLoadFinished // 回调中一般都是数据交换：mAdapter.swapCursor(data); // 返回的旧游标如果需要做数据处理，需要在回调函数中执行 super.deliverResult(cursor); &#125; // 执行完 onLoadFinished 后，关闭旧游标 // 如果UI线程中后续再操作该旧游标会抛出异常 android.database.StaleDataException // : Attempted to access a cursor after it has been closed. if (oldCursor != null &amp;&amp; oldCursor != cursor &amp;&amp; !oldCursor.isClosed()) &#123; oldCursor.close(); &#125;&#125; onLoaderReset 详解此方法将在先前创建的加载器重置且其数据因此不可用时调用。通过此回调可以了解何时将释放数据，因而能够及时移除其引用。使用 null 来实现：mAdapter.swapCursor(null); 常用 Loader类定义：public class Loader&lt;D&gt; {...} CursorLoader类定义及构造函数 123456// 类定义public class CursorLoader extends AsyncTaskLoader&lt;Cursor&gt; &#123;...&#125;// 除了 context 之外，其他参数都是 ContentProvider 用来查询数据的条件public CursorLoader(Context context, Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123;...&#125; AsyncTaskLoaderpublic abstract class AsyncTaskLoader&lt;D&gt; extends Loader&lt;D&gt; {...} 自定义 Loader 问题： ????数据是需要两次 cursor 拼接才能完成，该如何实现？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Asynchronous</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步 -- AsyncTask]]></title>
    <url>%2F2017%2F11%2F27%2F0024-async-task%2F</url>
    <content type="text"><![CDATA[查看源码 AsyncTask 只是对 Thread 和 Handler 的一个封装，其中线程是使用线程池技术。 基本概念1234567891011public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; public AsyncTask() &#123;...&#125; protected void onPreExecute() &#123;...&#125; protected abstract Result doInBackground(Params... params); protected void onProgressUpdate(Progress... values) &#123;...&#125; protected void onPostExecute(Result result) &#123;...&#125; public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123;...&#125; public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123;...&#125; public static void execute(Runnable runnable) &#123;...&#125; ...&#125; 3 个泛型参数AsyncTask &lt;Params, Progress, Result&gt; Params指定的是我们传递给异步任务执行时的参数的类型。注意：这里是可变长参数，如果只传递了一个参数，使用时为 params[0]。 Progress指定的是我们的异步任务在执行的时候将执行的进度返回给 UI 线程的参数的类型。注意：这里也是可变长参数，如果只传递了一个参数，使用时为 progress[0]。 Result指定的是异步任务执行完后返回给 UI 线程的结果的类型。 我们在定义一个类继承 AsyncTask 类的时候，必须指定好这三个泛型的类型，如果都不指定的，则将其写成 Void。 4 个执行步骤 onPreExecute()UI Thread 当中执行，这个方法是在执行异步任务之前的时候执行，我们可以在异步任务执行前做 UI 提示。 doInBackground(Params... params)这个方法就是来处理异步任务的方法，执行耗时操作。这个方法也是必须要实现的抽象方法。 onProgressUpdate(Progess... values)UI Thread 当中执行，用来更新进度条等。 onPostExecute(Result... result)UI Thread 当中执行，当异步任务执行完之后，将 doInBackground 结果返回给这个方法来更新 UI。 2 种执行方式“执行”必须在主线程中调用，而后台线程的执行方式可以为串行或者并行执行。 串行：execute(Params... params)/execute(Runnable runnable) 并行：executeOnExecutor(Executor exec, Params... params) 注意：各 SDK 版本 execute 默认执行方式不统一，1.5 中顺序执行，1.6 到 2.3 中并行执行，3.0 以后又改回串行执行，并添加并行执行接口 executeOnExecutor。 注意事项 必须在 UI 线程中加载和创建，以及调用 execute 不能做特别耗时的操作，建议只几秒内的异步任务 一个 AsyncTask 对象只能被执行一次，即只能调用一次 execute，否则会抛出异常报错:Caused by: java.lang.IllegalStateException: Cannot execute task: the task has already been executed (a task can be executed only once) 不能在程序中主动调用 4 个步骤 代码示例123456789101112131415161718192021222324252627282930313233// 初始化AsyncTask及执行protected void function() &#123; ... // 串行执行，识别一张 bitmap，每次执行前都需要重新 new 一个对象 mClassifierAsyncTask = new ClassifierAsyncTask(); mClassifierAsyncTask.execute(bitmap);&#125;// 自定义 AsyncTask 任务类，实现 doInBackgroundprivate ClassifierAsyncTask mClassifierAsyncTask;private class ClassifierAsyncTask extends AsyncTask&lt;Bitmap , Void, String &gt;&#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); mTvResult.setText(getString(R.string.classifying)); &#125; @Override protected String doInBackground(Bitmap... bitmaps) &#123; if(mMyTfClassifier == null) &#123; mMyTfClassifier = new MyTfClassifier(MainActivity.this); &#125; String result = mMyTfClassifier.recognizeImage(bitmaps[0]); return result; &#125; @Override protected void onPostExecute(String result) &#123; super.onPostExecute(result); mTvResult.setText(result); &#125;&#125; 源码解析线程池12345678910111213141516171819202122232425262728293031private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();// We want at least 2 threads and at most 4 threads in the core pool,// preferring to have 1 less than the CPU count to avoid saturating// the CPU with background workprivate static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR;static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); threadPoolExecutor.allowCoreThreadTimeOut(true); THREAD_POOL_EXECUTOR = threadPoolExecutor;&#125; 参数及返回结果封装123456789101112131415161718192021222324252627282930313233343536private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; &#123; Params[] mParams;&#125;private final WorkerRunnable&lt;Params, Result&gt; mWorker;private final FutureTask&lt;Result&gt; mFuture;public AsyncTask() &#123; mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Result result = null; try &#123; Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked result = doInBackground(mParams); Binder.flushPendingCommands(); &#125; catch (Throwable tr) &#123; mCancelled.set(true); throw tr; &#125; finally &#123; postResult(result); &#125; return result; &#125; &#125;; mFuture = new FutureTask&lt;Result&gt;(mWorker) &#123; @Override protected void done() &#123; ... postResultIfNotInvoked(get()); ... &#125; &#125;;&#125; 在构造方法中，传进来的参数 Params 被包装成到 mWorker 中，它是一个 Callable。同时在 mWorker 中定义了返回结果类型 Result，并在 call 中调用了回调方法 doInBackground，执行具体的后台任务。最后 mWorker 包装到 FutureTask 中，当执行完毕后，通过 get() 获取执行的结果，并通知 UI 去更新。 任务执行12345678910111213141516@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; ... onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this;&#125; 不管是串行还是并行，最终都调用了 executeOnExecutor，这里才真正的把参数传递进来，参数赋值给 mWorker，根据构造方法中参数封装的分析，mFuture 携带了参数和返回值类型，此时只需要调用执行器执行即可 exec.execute(mFuture);。 串行执行示例：mClassifierAsyncTask.execute(bitmap);，串行执行源码分析： 123456789101112131415161718192021222324252627282930313233343536373839404142// 1. 串行执行，使用的都是 sDefaultExecutor@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;@MainThreadpublic static void execute(Runnable runnable) &#123; sDefaultExecutor.execute(runnable);&#125;// 2. sDefaultExecutor 的定义public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;// 3. SerialExecutor 的实现方式// 使用双端队列存储，每来一个任务后先入队，确保每次只执行一个任务// 任务也是交给 THREAD_POOL_EXECUTOR 来执行的private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 并行执行示例：mClassifierAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, bitmaps);，并行执行源码见任务执行。 1234/** * An &#123;@link Executor&#125; that can be used to execute tasks in parallel. */public static final Executor THREAD_POOL_EXECUTOR; 查看默认线程池定义，THREAD_POOL_EXECUTOR 是 static final 类型的，可以作为并行 Executor 来使用，或者用户也可以自定义。 存在的问题Activity 屏幕旋转或销毁时，如果 AsyncTask 没有执行完毕就会存在内存泄露。特别是屏幕旋转时 AsyncTask 没有执行完毕，会导致屏幕异常。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Asynchronous</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handler 机制]]></title>
    <url>%2F2017%2F11%2F27%2F0023-handler%2F</url>
    <content type="text"><![CDATA[Handler 机制是 Android 系统处理同一进程不同线程间通信的机制，基于 Linux 系统的 epoll 机制实现。 Android 两大机制：Binder 机制用于处理进程间通信；Handler 机制用于处理进程内的线程间通信，线程间交互。 概念 Message意为消息，发送到 Handler 进行处理的对象，携带描述信息和任意数据。 MessageQueue意为消息队列，Message 的集合。 Looper消息泵，用来从 MessageQueue 中抽取 Message，发送给 Handler 进行处理。 Handler处理 Looper 抽取出来的 Message。 也就是说所有的消息处理都是串行执行的。 他们之间的关系： 每个 Thread 只对应一个 Looper 每个 Looper 只对应一个 MessageQueue 每个 MessageQueue 中有 N 个 Message 每个 Message 最多指定一个 Handler 来处理事件 每个 Thread 可以对应多个 Handler 在如下操作中都是基于 UI 主线程，在异步任务中使用 Handler 机制更新 UI 必须用 new Handler(); 来初始化。 123// 默认使用 UI 主线程的 LooperHandler mHandler = new Handler();mHandler.post(new Runnable()&#123;&#125;); 源码目录及类对应文件源码目录结构123456789101112131415// Framework Javaframeworks/base/core/java/android/os/ Message.java MessageQueue.java Looper.java Handler.java// Framework JNIframeworks/base/core/jni/ android_os_MessageQueue.h android_os_MessageQueue.cpp// System Nativesystem/core/libutils/include/utils/Looper.hsystem/core/libutils/Looper.cpp 类或接口对应文件12345678Message.java: MessageMessageQueue.java: MessageQueueLooper.java: LooperHandler.java: HandlerLooper.h: Message, MessageHandler, WeakMessageHandler, LooperCallback, SimpleLooperCallback, Looperandroid_os_MessageQueue.h: MessageQueueandroid_os_MessageQueue.cpp: NativeMessageQueue Message 详解Message 是 Handler 机制中的数据容器，和 Binder 机制中的 Parcel 功能一样。Message 数据结构特点： 链表Message 是单链表数据结构，成员变量 next 保存下一条消息，而当前消息是链表的头结点。Message 中的消息池 Message sPool 利用链表头结点特性实现栈，快速存取消息；MessageQueue 中的成员变量 Message mMessages 利用链表结构实现先进先出队列，确保先进入的消息先被处理。 存储简单数据成员变量 arg1, arg2 用来存储简单整型数据。 存储复杂数据成员变量 Object obj, Bundle data 用来存储复杂数据，其中 Bundle 能够存放键值对。 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public final class Message implements Parcelable &#123; // 消息唯一标记 public int what; // 存储简单数据 public int arg1; public int arg2; public Object obj; // Messenger 用于跨进程通信 public Messenger replyTo; public int sendingUid = -1; // 存储复杂数据，可以通过 get/set Data 来设置 /*package*/ Bundle data; public Bundle getData() &#123; if (data == null) &#123; data = new Bundle(); &#125; return data; &#125; public Bundle peekData() &#123; return data; &#125; public void setData(Bundle data) &#123; this.data = data; &#125; // 消息池是单向链表，最大长度为 50 /*package*/ Message next; private static Message sPool; private static final int MAX_POOL_SIZE = 50; // 构造方法，但是强烈推荐使用 Obtain 来获取 // Obtain 会通过消息池来重复使用 Message public Message() &#123;&#125; public static Message obtain(Handler h)&#123;...&#125; public static Message obtain(Handler h, int what)&#123;...&#125; public static Message obtain(Handler h, Runnable callback)&#123;...&#125; public static Message obtain(Message orig)&#123;...&#125; public static Message obtain(Handler h, int what, int arg1, int arg2, Object obj)&#123;...&#125; public static Message obtain(Handler h, int what, int arg1, int arg2)&#123;...&#125; public static Message obtain(Handler h, int what, Object obj)&#123;...&#125; public static Message obtain() &#123; synchronized (sPoolSync) &#123; if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; &#125; &#125; return new Message(); &#125; // 消息回收，重置当前消息，并进入消息池 public void recycle() &#123; if (isInUse()) &#123; if (gCheckRecycle) &#123; throw ... &#125; return; &#125; recycleUnchecked(); &#125; void recycleUnchecked() &#123; flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++; &#125; &#125; &#125; // 消息投递的绝对时间 /*package*/ long when; public long getWhen() &#123;return when;&#125; // target 通常保存处理该消息的 Handler /*package*/ Handler target; public void setTarget(Handler target) &#123; this.target = target; &#125; public Handler getTarget() &#123; return target; &#125; // 如果消息中定义了 callback // Handler 在处理消息时，直接回调该 callback，不会再执行 handleMessage /*package*/ Runnable callback; public Runnable getCallback() &#123; return callback; &#125; // 消息标识 /*package*/ static final int FLAG_IN_USE = 1 &lt;&lt; 0; /*package*/ static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1; /*package*/ static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE; /*package*/ int flags; // 是否正在使用 /*package*/ boolean isInUse() &#123; return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE); &#125; /*package*/ void markInUse() &#123; flags |= FLAG_IN_USE; &#125; // 是否为异步消息 public boolean isAsynchronous () &#123;...&#125; public void setAsynchronous (boolean async) &#123;...&#125; // 消息对象浅拷贝 public void copyFrom (Message o) &#123;...&#125; // Parcelable 相关 public static final Parcelable.Creator&lt;Message&gt; CREATOR = new Parcelable.Creator&lt;Message&gt;() &#123;...&#125; public int describeContents() &#123;...&#125; public void writeToParcel(Parcel dest, int flags) &#123;...&#125; private void readFromParcel(Parcel source) &#123;...&#125; ...&#125; 快速查看 Message API 。 消息池 sPoolMessage 中使用了单向链表结构的消息池，sPool 总是指向链表顶部，所以这个链表模拟的是栈结构，即消息池的数据结构为链表实现的栈。 消息池的创建源码中可以看出，消息在被回收后 recycleUnchecked()，将当前消息加入到消息池链表中，即消息池才开始有可以重复利用的 Message ；创建消息池使用了 synchronized 关键字，确保线程池的操作是同步的。如果系统中，同时有很多消息在被传递，当一部分消息使用结束后都会被回收，此时消息池会积蓄的越来越多。 消息的重复利用创建消息时推荐使用 Message.obtain() 方式，因为每次 obtain 时，都会判断消息池中是否有可以循环利用的消息，如果存在则取出并清空消息标记，否则才新建一个消息。 实例化一个消息，请使用 Message.obtain() ，充分利用消息池循环利用的特点。 重要成员变量 long when消息投递的绝对时间（投递时当前时间+设置的延迟时间），在 Handler 发送消息或发布任务时，指定具体的值。MessageQueue 在消息加入队列时，会根据 when 值决定消息在队列中的顺序。 Handler target保存处理该消息的 Handler ，在 Handler.enqueueMessage() 中将 Message 和对应处理该消息的 Handler 关联起来。 Runnable callback在 Handler.java 的分析中得出结论：消息的处理有三个优先级，可以直接使用 Message.callback 来进行消息处理。 消息标识 flags成员变量 flags 有如下四个值： 0消息标识清除。表示该消息被创建 new Message()、或者是从消息池中新取出的 Message.obtain()。可以理解是一个新消息，能修改当前消息内容。 FLAG_IN_USE消息正在被使用。表示消息进入了消息池栈 sPool中、或者进入了消息队列 MessageQueue 中。在消息池中，表示被回收了的消息正在被消息池管理，可以被取出循环利用；在消息队列中，表示消息被投递，正等待被取出处理。 FLAG_ASYNCHRONOUS表示异步消息；消息默认都是同步的，只能在 Message 和 Handler 构造方法中，特别指定为异步消息。如果设置了同步屏障，异步消息优先级将高于同步消息；消息队列 MessageQueue.next() 在取出消息时，遇到同步屏障会暂停所有的同步消息，将异步消息取出并处理，直到移除同步屏障。所以异步消息通常和同步屏障配合使用，同步屏障详细分析见 MessageQueue 中的分析。 FLAGS_TO_CLEAR_ON_COPY_FROM它的值和 FLAG_IN_USE 一样，只有在 copyFrom() 方法中会用到。 Messenger 相关Message 包含具体的数据信息，Messenger 是一名信差，用于进程间发送指定的 Message 。实质上 Messenger 使用 AIDL 和 Handler 机制来实现进程间的异步通信。详细参考Messenger 详解 。 Messenger replyTo回复此消息的回调信差，跨进程时通信时，可以利用 Message 中携带的信差，完成消息回复。 sendingUid跨进程发送异步消息的进程 ID 。 Looper 详解Looper 类设计原则：此类包含基于 MessageQueue 设置和管理事件循环所需的代码。影响队列状态的 API 应该在 MessageQueue, Handler 上定义，而不是在 Looper 本身上定义。例如在队列上定义 idle handlers 和 sync barriers，而在 Looper 上定义准备线程，循环和退出。Looper 类的主要功能： 提供线程上下文环境，创建与线程绑定的 Looper 创建 MessageQueue loop 循环从 MessageQueue 中获取下一条消息（若无消息线程阻塞等待），指派 Handler 处理消息并回收消息 提供 loop 循环退出方法 源码分析Looper 类中大部分都是 static 的变量和方法，不能直接实例化，通常都是固定格式来初始化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public final class Looper &#123; private static final String TAG = "Looper"; // sThreadLocal.get() will return null unless you've called prepare(). static final ThreadLocal&lt;Looper&gt; sThreadLocal=new ThreadLocal&lt;Looper&gt;(); private static Looper sMainLooper; // guarded by Looper.class final MessageQueue mQueue; final Thread mThread; ... public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException( "Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; /** * Initialize the current thread as a looper, marking it as an * application's main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself. See also: &#123;@link #prepare()&#125; */ public static void prepareMainLooper() &#123; prepare(false); synchronized (Looper.class) &#123; if (sMainLooper != null) &#123; throw new IllegalStateException( "The main Looper has already been prepared."); &#125; sMainLooper = myLooper(); &#125; &#125; // Returns the application's main looper, // which lives in the main thread of the application. public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; return sMainLooper; &#125; &#125; public static @Nullable Looper myLooper() &#123; return sThreadLocal.get(); &#125; public static @NonNull MessageQueue myQueue() &#123; return myLooper().mQueue; &#125; private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); &#125; public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123;throw new RuntimeException("...");&#125; final MessageQueue queue = me.mQueue; ... for (;;) &#123; // 线程会阻塞 Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; ... msg.target.dispatchMessage(msg); ... msg.recycleUnchecked(); &#125; &#125; public void quit() &#123; mQueue.quit(false); &#125; public void quitSafely() &#123; mQueue.quit(true); &#125; ...&#125; 快速查看 Looper API 。 重要成员变量 sThreadLocal结论：一个线程只能对应一个 Looper 。从源码中可以看到，静态变量 sThreadLocal 存储了所有线程对应的 Looper ，而 ThreadLocal 中数据存储的数据结构是一个定制的哈希表，其 key 值是当前线程。 sMainLooper当前应用主线程对应的 Looper ，在应用对应的主线程 ActivityThread.main() 中初始化。通常我们在 Activity 中获取到的主线程 Looper 对应的就是 sMainLooper 。 Looper 的初始化代码中可以看到，Looper 的构造方法是私有的，客户端通常使用 Looper.prepare(...) 来实例化，并初始化应用场景。而 Looper.prepareMainLooper() 是用来初始化主线程环境的，整个 Android Framework 中只有 ActivityThread, SystemServer 这两个带有 main() 方法的类调用过，而这两个类分别用来开启应用主线程和系统主线程。Looper 的构造方法中，初始化了 mQueue 和 mThread ： mQueueHandler 机制的消息队列 MessageQueue 就是在 Looper 的构造方法中实例化的。 mThread赋值的是当前线程：可以是主线程或者工作线程。 Looper.loop()流程非常简单，进入无限循环并不停的从消息队列中获取消息，而获取消息的过程可能会阻塞。 Looper 线程拿到消息后，执行消息处理 Handler.dispatchMessage() 并回收已经处理过的消息 Message.recycleUnchecked() 。 Looper 退出Looper 通常是通过 Looper.loop() 进入无线循环，从消息队列中取出消息并处理。Handler 机制为工作线程提供了退出方法 quit/quitSafely ，调用 MessageQueue.quit() 来结束并退出。只要调用了 quit/quitSafely，不管是正在退出还是已经退出，Looper 就不再接收新的消息。Handler 发送的消息，在 MessageQueue.enqueueMessage 中直接返回 false，不做任何处理。 主线程的 Looper 是不允许退出的，在 MessageQueue 的构造方法中设定。prepareMainLooper 调用的是 prepare(false)，即不能退出。 典型工作线程流程Looper 线程典型的实现示例如下，将 prepare() 和 loop() 的分离，来创建一个与 Looper 通信的 Handler。 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; // process incoming messages here &#125; &#125;; Looper.loop(); &#125;&#125; Handler 详解Handler 子类必须是 static 的，避免潜在的内存泄露，在构造方法中可以打开开关做检测。Handler 类将 Message, Looper, MessageQueue 串起来，给外部提供完整的接口，发送并处理消息。它管理的消息队列 MessageQueue 是 Looper 的成员变量；而 Looper 可以是主线程，也可以是工作线程，在 Handler 初始化时指定。主要功能包含： 初始化一个消息 发布任务或者发送消息 回到 Looper 所在线程处理消息 移除消息或其回调 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277public class Handler &#123; ... final Looper mLooper; final MessageQueue mQueue; final Callback mCallback; final boolean mAsynchronous; public interface Callback &#123; public boolean handleMessage(Message msg); &#125; private static void handleCallback(Message message) &#123; message.callback.run(); &#125; // Subclasses must implement this to receive messages. public void handleMessage(Message msg) &#123; &#125; // 消息处理入口，三个优先级： // 1. 如果 Message 中定义了 Callback，直接处理 // 2. 否则如果 Handler 中定义了 Callback，调用处理 // 3. 最后才是子类重写的 handleMessage public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125; &#125; // 构造方法，最终都是初始化 4 个成员变量 public Handler() &#123;this(null, false);&#125; public Handler(Callback callback) &#123;this(callback, false);&#125; public Handler(Looper looper) &#123;this(looper, null, false);&#125; public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false); &#125; public Handler(boolean async) &#123;this(null, async);&#125; public Handler(Callback callback, boolean async) &#123; // 检查子类实例化时，是否存在内存泄露 if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, "The following Handler class should be static " + "or leaks might occur: " + klass.getCanonicalName()); &#125; &#125; mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException("Can't create handler inside " + " thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; &#125; public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; &#125; // 生成对应的消息 Message，但都是对 Message.obtain 的封装 public final Message obtainMessage()&#123;return Message.obtain(this);&#125; public final Message obtainMessage(int what)&#123; return Message.obtain(this, what); &#125; public final Message obtainMessage(int what, Object obj)&#123; return Message.obtain(this, what, obj); &#125; public final Message obtainMessage(int what, int arg1, int arg2)&#123; return Message.obtain(this, what, arg1, arg2); &#125; public final Message obtainMessage(int what, int arg1, int arg2, Object obj)&#123; return Message.obtain(this, what, arg1, arg2, obj); &#125; private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; private static Message getPostMessage(Runnable r, Object token) &#123; Message m = Message.obtain(); m.obj = token; m.callback = r; return m; &#125; // 发布任务，最终都是调用的 enqueueMessage public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125; public final boolean postAtTime(Runnable r, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis); &#125; public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)&#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis); &#125; public final boolean postDelayed(Runnable r, long delayMillis) &#123; return sendMessageDelayed(getPostMessage(r), delayMillis); &#125; public final boolean postAtFrontOfQueue(Runnable r) &#123; return sendMessageAtFrontOfQueue(getPostMessage(r)); &#125; public final boolean sendMessage(Message msg)&#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what,long delayMillis)&#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what,long uptimeMillis)&#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis()+delayMillis); &#125; public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis); &#125; public final boolean sendMessageAtFrontOfQueue(Message msg) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, 0); &#125; private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; // Message 和 Handler 关联 msg.target = this; if (mAsynchronous) &#123; // 设置异步消息 msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis); &#125; // 移除 Message 和 Messa.callback，最终都是在 MessageQueue 中移除 public final void removeCallbacks(Runnable r)&#123; mQueue.removeMessages(this, r, null); &#125; public final void removeCallbacks(Runnable r, Object token)&#123; mQueue.removeMessages(this, r, token); &#125; public final void removeMessages(int what) &#123; mQueue.removeMessages(this, what, null); &#125; public final void removeMessages(int what, Object object) &#123; mQueue.removeMessages(this, what, object); &#125; public final void removeCallbacksAndMessages(Object token) &#123; mQueue.removeCallbacksAndMessages(this, token); &#125; // Messenger 相关 IMessenger mMessenger; final IMessenger getIMessenger() &#123; synchronized (mQueue) &#123; if (mMessenger != null) &#123; return mMessenger; &#125; mMessenger = new MessengerImpl(); return mMessenger; &#125; &#125; private final class MessengerImpl extends IMessenger.Stub &#123; public void send(Message msg) &#123; msg.sendingUid = Binder.getCallingUid(); Handler.this.sendMessage(msg); &#125; &#125; // 阻塞，同步执行任务 public final boolean runWithScissors(final Runnable r, long timeout) &#123; if (r == null) &#123; throw new IllegalArgumentException("runnable must not be null"); &#125; if (timeout &lt; 0) &#123; throw new IllegalArgumentException( "timeout must be non-negative"); &#125; if (Looper.myLooper() == mLooper) &#123; r.run(); return true; &#125; BlockingRunnable br = new BlockingRunnable(r); return br.postAndWait(this, timeout); &#125; private static final class BlockingRunnable implements Runnable &#123; private final Runnable mTask; private boolean mDone; public BlockingRunnable(Runnable task) &#123; mTask = task; &#125; @Override public void run() &#123; try &#123; mTask.run(); &#125; finally &#123; synchronized (this) &#123; mDone = true; notifyAll(); &#125; &#125; &#125; public boolean postAndWait(Handler handler, long timeout) &#123; if (!handler.post(this)) &#123; return false; &#125; synchronized (this) &#123; if (timeout &gt; 0) &#123; final long expirationTime = SystemClock.uptimeMillis() + timeout; while (!mDone) &#123; long delay = expirationTime - SystemClock.uptimeMillis(); if (delay &lt;= 0) &#123; return false; // timeout &#125; try &#123; wait(delay); &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; else &#123; while (!mDone) &#123; try &#123; wait(); &#125; catch (InterruptedException ex) &#123; &#125; &#125; &#125; &#125; return true; &#125; &#125; ...&#125; 快速查看 Handler API 。 构造方法及成员变量从 Handler 的构造方法可以看出来，实例化时主要对 Looper, MessageQueue, Callback, mAsynchronous 四个成员变量的赋值。 LooperLooper 如果来自于主线程，则不需要通过构造方法赋值；如果来自于工作线程，需要先执行 Looper.prepare 初始化 Looper 使用环境，并作为参数传递到构造方法中。 MessageQueueLooper 值确定后，消息队列即为其成员变量 mQueue 。 Callback可以直接通过 Callback 处理消息事件；特别是不需要自定义 Handler 子类来重写 handleMessage 时，默认为 null。 mAsynchronous是否允许异步执行，默认值为 false 即是同步执行的。它最终会被设置到对应的 Message.flags = FLAG_ASYNCHRONOUS，在 Handler 中被没有其他作用。 自定义 Handler 的子类在实例化时，为了避免内存泄露，通常将子类设置为 static 类型，也就是避免内部类引用当前 Activity 对象。 生成消息Handler 提供了生成消息的方法，但都是对 Message.obtain 的封装，所以在使用消息前，推荐直接使用 Message 类来生成。 任务发布不管是通过 post***() 还是 send***() 方法来发布任务或者消息，最终都是调用的 enqueueMessage()，即将 Message 加入到消息队列中 MessageQueue 。enqueueMessage() 的两个重要动作： Handler 和 Message 的关联Message 的成员变量 target 存储了处理该消息的 Handler ，在消息入队时，将两者关联起来。 设置异步消息Handler.mAsynchronous 成员变量，在入队时将对应的 Message 设置为异步。 消息处理dispatchMessage 是 Handler 消息处理的入口方法，有三个优先级来处理消息： 优先：如果 Message 中定义了 Callback 其次：如果 Handler 中定义了 Callback 最后：才是调用子类重写的 handleMessage 如果是自定义 Handler 子类，必须重写 handleMessage 来实现消息处理。而消息处理是在 Looper 所在线程来处理的，Looper 如果来自于主线程则在主线程中处理消息；如果来自于工作线程则在工作线程中处理消息。 移除消息remove***() 系列的方法，是指移除 Message 或者 Message.callback；最终调用的是从 MessageQueue 中移除对应消息。 Messenger 相关Handler 中实现了 Messenger 用于进程间异步通信的代码。源码中可以看出 Messenger 通过 AIDL 来实现的进程间通信的；而通过 Handler.sendMessage 来实现异步通信。详细参考Messenger 详解 。 BlockingRunnable 阻塞并同步执行任务BlockingRunnable 同步等待指定任务执行完成才会返回，通过 Object.wait/notify 实现同步阻塞功能。Handler.runWithScissors 方法是具体的实现，它是一个 @hide 方法，客户端 App 并不能直接调用若。该方法是如果调用线程与 Looper 所在线程如果在同一个线程，直接执行完后退出；如果不是同一线程，可以简单的实现 timeout，方法调用以后会阻塞，直到传入的 runnable 结束或者是 timeout 。 MessageQueue 详解MessageQueue 的内部存储了一组消息，以队列的形式对外提供插入和删除的工作。采用单链表的数据结构来存储消息列表，按照消息发生的绝对时间 Message.when 排序。所以消息队列并不是绝对的先进先出队列，是按照消息发生时间先进先出。Looper.loop 会进入无限循环，而它会调用 MessageQueue.next 方法取出下一条消息；当有消息时，取出交给 Handler 处理；当没有消息时，当前线程便会阻塞在 next() 方法的 nativePollOnce() 中，当线程便会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生时，唤醒当前线程；这里的线程休眠唤醒，涉及到 Linux epoll 机制，后面会详细介绍。MessageQueue 是在多线程环境下操作，所以绝大部分的方法都使用了 synchronized(this) 关键字；是 Handler 机制的核心类，native 代码在 android_os_MessageQueue.cpp 中实现；MessageQueue 还能监听文件描述符，当发生变化时做出相应事件处理，但是 Handler 机制中并没有使用该功能，本文不做介绍。MessageQueue 主要功能： 初始化 native 环境 将 Message 加入队列 调用 native 方法，当前线程阻塞等待，直到从队列中取出 Message 多线程环境中维护消息队列入队、出队、销毁 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438public final class MessageQueue &#123; ... // True if the message queue can be quit. private final boolean mQuitAllowed; private boolean mQuitting; private long mPtr; // used by native code Message mMessages; private final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;(); private SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords; private IdleHandler[] mPendingIdleHandlers; // Indicates whether next() is blocked waiting // in pollOnce() with a non-zero timeout. private boolean mBlocked; // 构造方法 MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit(); &#125; // Must only be called on the looper thread or the finalizer. // 释放资源 private void dispose() &#123; if (mPtr != 0) &#123; nativeDestroy(mPtr); mPtr = 0; &#125; &#125; // 当前线程 Idle 状态时，相关方法和接口 public boolean isIdle() &#123; synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); return mMessages == null || now &lt; mMessages.when; &#125; &#125; public void addIdleHandler(@NonNull IdleHandler handler) &#123; if (handler == null) &#123; throw new NullPointerException("Can't add a null IdleHandler"); &#125; synchronized (this) &#123; mIdleHandlers.add(handler); &#125; &#125; public void removeIdleHandler(@NonNull IdleHandler handler) &#123; synchronized (this) &#123; mIdleHandlers.remove(handler); &#125; &#125; public static interface IdleHandler &#123; boolean queueIdle(); &#125; // 当前线程是否在轮询获取下条消息 public boolean isPolling() &#123; synchronized (this) &#123; return isPollingLocked(); &#125; &#125; private boolean isPollingLocked() &#123; // If the loop is quitting then it must not be idling. // We can assume mPtr != 0 when mQuitting is false. return !mQuitting &amp;&amp; nativeIsPolling(mPtr); &#125; // 判断是否存在指定条件的消息 boolean hasMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return false; &#125; synchronized (this) &#123; Message p = mMessages; while (p != null) &#123; if (p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; return true; &#125; p = p.next; &#125; return false; &#125; &#125; boolean hasMessages(Handler h, Runnable r, Object object) &#123;...&#125; // 移除指定消息或整个消息队列 void removeMessages(Handler h, int what, Object object) &#123; if (h == null) &#123; return; &#125; synchronized (this) &#123; Message p = mMessages; // Remove all messages at front. // 如果消息队列头结点或者头部几个节点，就是目标消息 while (p != null &amp;&amp; p.target == h &amp;&amp; p.what == what &amp;&amp; (object == null || p.obj == object)) &#123; Message n = p.next; mMessages = n; p.recycleUnchecked(); p = n; &#125; // Remove all messages after front. // 遍历整个队列，找到目标消息移出队列并回收 while (p != null) &#123; Message n = p.next; if (n != null) &#123; if (n.target == h &amp;&amp; n.what == what &amp;&amp; (object == null || n.obj == object)) &#123; Message nn = n.next; n.recycleUnchecked(); p.next = nn; continue; &#125; &#125; p = n; &#125; &#125; &#125; void removeMessages(Handler h, Runnable r, Object object) &#123;...&#125; void removeCallbacksAndMessages(Handler h, Object object) &#123;...&#125; private void removeAllMessagesLocked() &#123;...&#125; private void removeAllFutureMessagesLocked() &#123;...&#125; // 消息队列退出循环 void quit(boolean safe) &#123; // 是否允许退出？主线程 Looper 是不允许退出的，工作线程可以 if (!mQuitAllowed) &#123; throw new IllegalStateException( "Main thread not allowed to quit."); &#125; synchronized (this) &#123; // 如果已经正在退出了返回 if (mQuitting) &#123; return; &#125; mQuitting = true; // 如果是安全退出，只移除没有投递和处理的消息 // 已经投递的等待处理完毕 // 非安全退出，移除所有消息 if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123; removeAllMessagesLocked(); &#125; //We can assume mPtr!=0 because mQuitting was previously false. nativeWake(mPtr); &#125; &#125; // 设置和移除同步屏障 // The next barrier token. // Barriers are indicated by messages with a null target // whose arg1 field carries the token. private int mNextBarrierToken; public int postSyncBarrier() &#123; return postSyncBarrier(SystemClock.uptimeMillis()); &#125; private int postSyncBarrier(long when) &#123; // Enqueue a new sync barrier token. // We don't need to wake the queue // because the purpose of a barrier is to stall it. synchronized (this) &#123; final int token = mNextBarrierToken++; // 同步屏障消息 target 为空，arg1 保存令牌 final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; // 同步屏障消息是插入到队列头部的，优先级高 if (when != 0) &#123; while (p != null &amp;&amp; p.when &lt;= when) &#123; prev = p; p = p.next; &#125; &#125; if (prev != null) &#123; // invariant: p == prev.next msg.next = p; prev.next = msg; &#125; else &#123; msg.next = p; mMessages = msg; &#125; return token; &#125; &#125; public void removeSyncBarrier(int token) &#123; // Remove a sync barrier token from the queue. // If the queue is no longer stalled by a barrier then wake it. synchronized (this) &#123; Message prev = null; Message p = mMessages; while (p != null &amp;&amp; (p.target != null || p.arg1 != token)) &#123; prev = p; p = p.next; &#125; if (p == null) &#123; throw new IllegalStateException( "The specified message queue synchronization barrier token" + " has not been posted or has already been removed."); &#125; final boolean needWake; // 移除同步屏障 if (prev != null) &#123; prev.next = p.next; needWake = false; &#125; else &#123; mMessages = p.next; needWake = mMessages == null || mMessages.target != null; &#125; // 回收同步屏障 p.recycleUnchecked(); // If the loop is quitting then it is already awake. // We can assume mPtr != 0 when mQuitting is false. if (needWake &amp;&amp; !mQuitting) &#123; nativeWake(mPtr); &#125; &#125; &#125; // 消息入队 boolean enqueueMessage(Message msg, long when) &#123; // 为空，表示是同步屏障；不能直接入队，需要通过 postSyncBarrie 插入队列头部 if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; // FLAG_IN_USE，表示消息已经在消息池或者消息队列中 if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; // 如果消息队列正在退出，直接回收当前消息并返回 if (mQuitting) &#123; IllegalStateException e = new IllegalStateException(msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // 消息队列为空，或者没有设置消息绝对时间 // 或者新消息绝对时间最小：将当前消息插入到队首 // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // 消息队列阻塞情况下，并且队首为同步屏障 // 并且当前消息为异步消息，则唤醒队列 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; // 消息队列中还存在其他异步消息，不唤醒 if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; // 按照消息绝对时间排序，插入到指定位置 msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. // 唤醒消息队列 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; // 取出消息 Message next() &#123; // native 变量地址为空，直接返回 final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; // 无限循环等待 for (;;) &#123; // 线程阻塞前写入所有命令 if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; // 阻塞等待 nextPollTimeoutMillis 时间 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // 消息队列队首为同步屏障，挂起所有同步消息 // 循环取出所有异步消息 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // 下一条消息时间还没到 // 设置 nextPollTimeoutMillis 为消息延迟时间 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. 获取一条消息并返回 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. 消息队列为空 nextPollTimeoutMillis = -1; &#125; // 消息队列正在退出，释放资源并返回空 if (mQuitting) &#123; dispose(); return null; &#125; // 没有空闲处理器 IdleHandler，初始化计数 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; // 还是没有空闲处理器 IdleHandler， // 标记消息队列阻塞，进入下一次循环 if (pendingIdleHandlerCount &lt;= 0) &#123; mBlocked = true; continue; &#125; // 初始化并设置 IdleHandler if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers=mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // 利用这段空闲时间，线程处理 IdleHandler 任务 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // 重置空闲任务计数和阻塞超时时间 pendingIdleHandlerCount = 0; nextPollTimeoutMillis = 0; &#125; &#125; // public boolean isPolling() &#123; synchronized (this) &#123; return isPollingLocked(); &#125; &#125; private boolean isPollingLocked() &#123; return !mQuitting &amp;&amp; nativeIsPolling(mPtr); &#125; // 监听文件描述符相关，本文不做介绍 public void addOnFileDescriptorEventListener(@NonNull FileDescriptor fd, @OnFileDescriptorEventListener.Events int events, @NonNull OnFileDescriptorEventListener listener) &#123;...&#125; public void removeOnFileDescriptorEventListener( @NonNull FileDescriptor fd) &#123;...&#125; private void updateOnFileDescriptorEventListenerLocked(FileDescriptor fd, int events, OnFileDescriptorEventListener listener) &#123;...&#125; // Called from native code.处理文件描述事件回调 private int dispatchEvents(int fd, int events) &#123;...&#125; public interface OnFileDescriptorEventListener &#123; ... @Events int onFileDescriptorEvents(@NonNull FileDescriptor fd, @Events int events); &#125; private static final class FileDescriptorRecord &#123;...&#125; // native 方法 private native static long nativeInit(); private native static void nativeDestroy(long ptr); /*non-static for callbacks*/ private native void nativePollOnce(long ptr, int timeoutMillis); private native static void nativeWake(long ptr); private native static boolean nativeIsPolling(long ptr); private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events);&#125; 快速查看 MessageQueue API 重要成员变量 mMessages用于存储消息，利用 Message 链表结构实现先进先出队列，确保先进入或者时间最近的消息先被处理。 ArrayList mIdleHandlers记录消息队列中有多少个 IdleHandler 。 IdleHandler[] mPendingIdleHandlers由 mIdleHandlers 转换为对应的数组。 mBlocked当 next 方法在等待 pollOnce ，mBlocked 记录 next 是否处于阻塞状态。 mQuitting记录当前消息队列是否正在退出。 mNextBarrierToken同步屏障令牌，同步屏障 Barriers 表示一个没有指定 Handler 的 Message，它的 arg1 参数记录了这个令牌。 mFileDescriptorRecords存储被监听文件描述符的表，Handler 机制中消息发送并没有使用文件描述符监功能，暂时不做介绍。AOSP 系统源码中仅 frameworks/base/core/java/android/os/ParcelFileDescriptor.java 用到了。 初始化Handler 机制中，MessageQueue 的实例化是在 Looper 的构造方法中实现的，赋值两个成员变量： mQuitAllowed是否运行消息队列退出。主线程的消息队列是不允许退出的，工作线程可以。 mPtr执行 nativeInit 方法，并将 native 层的 NativeMessageQueue 类对象地址赋值给 Java 层的成员变量 mPtr 。通过这种方式将 Java 层的对象与 native 层的对象关联在了一起。这种在 Java 层保存 native 层对象引用地址来实现关联的方式，在 Android 源代码中能经常看到。 同步屏障同步屏障 SyncBarrier 是一个特殊的消息 Message ，有两个重要特点： Handler target 为空 arg1 记录同步屏障令牌同步屏障消息的 what 为空，也就是不能通过 what 来标记消息了，而通过 arg1 记录同步令牌来做为消息标记。令牌非常重要，移除同步屏障时需要指定具体的令牌。 如果设置了同步屏障，消息队列所有的同步消息都会被暂停，next() 只会取出异步消息处理，直到移除同步屏障。如果没有正确移除同步屏障，整个消息队列将会挂起，同时也不再循环取出同步消息执行。 设置同步屏障postSyncBarrier() 设置同步屏障时，将它加入到消息队列，并将同步屏障消息设为头结点。也就是同步屏障是插入到队列的头部的，优先级很高，消息通过 enqueueMessage 加入队列都是插入队尾的。设置同步屏障并不会唤醒队列。 移除同步屏障removeSyncBarrier(int token) 根据令牌移除同步屏障，遍历消息队列。如果同步屏障位于头结点，且下一条消息为同步消息，表示队列没有被被挂起，唤醒队列。移除同步屏障后，消息队列恢复正常，循环取出消息。 同步屏障相关方法都是 @hide 的，也就是说只会在 Android Framework 内部使用，客户端 App 并不能应用这些功能。并且同步屏障和异步消息在 Android Framework 中使用的也很少，比如搜索到的应用如下： 12345678910111213141516171819202122232425262728293031xmt@server005:~/android$ grep -irsn postSyncBarrier frameworks/frameworks/base/cmds/hid/src/com/android/commands/hid/Device.java:143: mBarrierToken = getLooper().myQueue().postSyncBarrie ();frameworks/base/core/java/android/view/ViewRootImpl.java:1225:public void dispatchInputEvent(InputEvent event, InputEventReceiver receiver) &#123; SomeArgs args = SomeArgs.obtain(); args.arg1 = event; args.arg2 = receiver; Message msg = mHandler.obtainMessage(MSG_DISPATCH_INPUT_EVENT, args); // 设置为异步消息 msg.setAsynchronous(true); mHandler.sendMessage(msg);&#125;void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; // 设置同步屏障 mTraversalBarrier=mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; Android 系统的屏幕点击事件，就是一个异步消息；View 请求启动绘制生命周期 ViewRootImpl.scheduleTraversals 会设置同步屏障，优先处理异步消息。 消息入队 enqueueMessage后台线程完成耗时操作后，通过对象 Handler.post***/send*** 发送消息，最终会进入到 MessageQueue.enqueueMessage ，而 enqueueMessage 仅仅是将消息按照 when 顺序插入到消息队列中。后台线程不会被阻塞，执行完毕可以退出。 入队顺序 Message.when按照消息的绝对时间 Message.when 排序，插入到队列中，如果时间相同就按照入队先后顺序。确保消息投递的绝对时间 when 越小，越早出队。 唤醒队列 needWake如果消息队列处于阻塞状态 mBlocked=true 时，插入消息时才需要唤醒队列。但是当消息队列队首为同步屏障，并且新消息本身为异步消息，同时当消息队列中还存在其他异步消息时，此时不会唤醒，具体看上面的流程图。消息插入消息队列，正常情况下不会唤醒，除了图中的几个特殊情况。 消息队列正在退出 mQuitting如果消息队列调用了 quit() 方法，表示消息队列正在退出；当消息队列正在退出时，直接回收当前准备入队的消息，并返回 false ，入队失败。 消息队列存储顺序消息队列中，首先按照 msg.when 排序，结合同步屏障，异步消息，后期补一个图。 消息出队 next主线程的 Looper.loop() 会无限循环，不停的调用 MessageQueue.next() 获取下一条消息，交给 Handler 处理。而 next 通过 nativePollOnce 方法实现线程的阻塞，阻塞时间为消息的延迟时间。当时间到了后，唤醒主线程取出这个消息；即后台线程发布的消息，回到主线程来处理。 阻塞时间 nextPollTimeoutMillis表示阻塞时间，通常为消息的延迟时间。如果为 0 ，表示不阻塞，直接返回；如果为 -1 ，表示一直阻塞。当消息队列中没有消息时，nextPollTimeoutMillis=-1 使得 next 会一直阻塞，直到有消息进来，更新这个值。 阻塞状态 mBlockednext 中的 for 循环取到消息后，next 返回这个消息并退出，消息队列阻塞状态为 false ；for 循环没有取到消息，如果存在 IdleHandler 时，利用这段时间处理空闲任务；否则设置消息队列为阻塞状态 true；重新进入循环继续阻塞等待取消息。 消息出队顺序同步消息都是按照 msg.when 即插入顺序先进先出的；当消息队列队首为同步屏障时，挂起队列中所有同步消息，循环取出队列中所有的异步消息，直到移除同步屏障。 消息队列正在退出 mQuitting如果消息队列调用了 quit() 方法，表示消息队列正在退出；当消息队列正在退出时，调用 dispose() 方法，销毁 native 环境，跳出 Looper.loop 循环，退出整个机制。 空闲线程 IdleHandler当消息队列为空，或者消息投递时间没到时；如果添加了空闲线程处理器 IdleHandler ，此时会利用线程空闲时间执行这些任务。 消息轮询状态isPolling/isPollingLocked 方法主要是否返回当前线程轮询状态，即当前线程是否处于 epoll_wait 阻塞等待中，该方法在 Android Framework 中使用的也很少： 12frameworks/base/services/core/java/com/android/server/Watchdog.java:121: if (mMonitors.size() == 0 &amp;&amp; mHandler.getLooper().getQueue().isPolling()) &#123;...&#125; MessageQueue.mBlocked 也是记录的阻塞状态，和 isPolling/isPollingLocked 功能差不多，只是没有 isPolling/isPollingLocked 方法返回的状态更精细、更准确。 删除消息 删除指定消息符合指定消息的可能并不止一个，所以需要遍历整个队列，找到这些符合条件的消息。删除时分两种情况：如果指定消息是头结点，或者头部几个节点都是指定消息，删除指定消息后，重新指定头结点；如果头结点或者新的头结点不是指定消息，依次遍历整个队列，找到目标消息移出队列并回收。 删除所有消息从头结点开始遍历队列，移出队列中所有消息并删除。 删除延迟消息从头结点开始遍历队列，对比当前时间和 Message.when ，找出延迟消息，删除掉这些还没来得及投递处理的消息。 消息队列退出MessageQueue.quit() 方法中有如下几个判断： 是否运行退出 mQuitAllowed主线程的 Looper 循环是不允许退出的，这在主线程初始化时，构造 MessageQueue 决定的；工作线程可以退出。 是否正在退出 mQuitting因为是多线程环境，所以使用了 synchronized 关键字来确保并发正确。 是否安全移除 safe是否安全移除，主要区别在于移除哪些消息。如果不安全退出，直接移除队列中所有消息；如果安全退出，对比当前时间和 Message.when ，只移除延迟消息。 MessageQueue.quit() 方法主要是移除消息队列中对应的消息，并设置了 mQuitting=true ；调用 nativeWake() 方法唤醒 next() 方法，如果是安全退出，则取出剩余的消息并返回给 Handler 处理；next 方法中如果取不到消息，当 mQuitting=true 时，释放资源并退出整个 Looper.loop() 循环机制。 IdleHandler 接口一个回调接口，在消息队列阻塞等待前，当前线程可以利用这段时间做别的事情。 MessageQueue.addIdleHandler()添加回调接口。 MessageQueue.removeIdleHandler()移除回调接口。 示例比如 ActivityThread 中，利用这个空闲时间，添加了 GcIdle 回收内存和 Idler 释放 AMS 相关资源。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1.内存回收Looper.myQueue().addIdleHandler(mGcIdler);final class GcIdler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; doGcIfNeeded(); return false; &#125;&#125;void doGcIfNeeded() &#123; mGcIdlerScheduled = false; final long now = SystemClock.uptimeMillis(); //Slog.i(TAG, "**** WE MIGHT WANT TO GC: then=" + // Binder.getLastGcTime() + "m now=" + now); if ((BinderInternal.getLastGcTime()+MIN_TIME_BETWEEN_GCS) &lt; now) &#123; //Slog.i(TAG, "**** WE DO, WE DO WANT TO GC!"); BinderInternal.forceGc("bg"); &#125;&#125;// 2. AMS 释放相关资源，调用 activityIdleLooper.myQueue().addIdleHandler(new Idler());private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; ... if (a != null) &#123; mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do &#123; ... if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; ... &#125;&#125; native 方法简要描述几个 native 方法的作用： private native static long nativeInit(); ：初始化 native 对象，绑定 Looper 和线程等 private native static void nativeDestroy(long ptr); 销毁 native 对象 private native void nativePollOnce(long ptr, int timeoutMillis);唯一的非静态方法，也就是说这个方法是属于对象的；当前线程阻塞最多等待 timeoutMillis 时间（类似 Object.wait(timeout)），这段时间内可能会被 nativeWake 唤醒。 private native static void nativeWake(long ptr); 唤醒 nativePollOnce 函数 private native static boolean nativeIsPolling(long ptr); 查询 nativePollOnce 是否正处于阻塞状态 private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events); 添加文件描述符监听事件 Native JNI 层Native JNI 层起到一个连接的作用，Handler 机制中使用的 epoll 等功能都是在系统层实现的，JNI 对这些功能调用做一个封装，相当于外观模式中的外观类。注意：Android Framework 中还有一个 ALooper 类，也是实现的消息机制，它主要是用于多媒体相关，代码路径 frameworks/av/media/ ，和本文介绍的消息机制没有任何关系。如下根据 MessageQueue 中的 6 个 native 方法逐一展开分析，具体对应的 JNI 类为 Android_os_MessageQueue.cpp ： 环境初始化 nativeInitnativeInit 函数主要是初始化所有 native 需要使用的类对象，变量等，主要就是 Looper.cpp 相关资源的初始化；函数的返回值是一个 nativeMessageQueue 对象，它是对 Looper.cpp 相关功能的一个封装。 123456789101112131415161718192021222324252627282930313233343536373839404142static jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; // NativeMessageQueue 对象实例化 NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, "Unable to allocate native queue"); return 0; &#125; // 增加引用计数 nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125;NativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; // Looper 对象初始化，及线程绑定和相关环境初始化 mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; mLooper = new Looper(false); // TLS 保存当前线程的 Looper 对象 Looper::setForThread(mLooper); &#125;&#125;class NativeMessageQueue : public MessageQueue, public LooperCallback &#123;public: NativeMessageQueue(); virtual ~NativeMessageQueue(); virtual void raiseException(JNIEnv* env, const char* msg, jthrowable exceptionObj); void pollOnce(JNIEnv* env, jobject obj, int timeoutMillis); void wake(); void setFileDescriptorEvents(int fd, int events); virtual int handleEvent(int fd, int events, void* data);private: JNIEnv* mPollEnv; jobject mPollObj; jthrowable mExceptionObj;&#125;; 销毁 nativeDestroynative 中的几个关键对象，都使用了智能指针管理，所以销毁时减少引用计数，如果引用不存在自动销毁。 1234567891011static void android_os_MessageQueue_nativeDestroy(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); // 减少引用计数 nativeMessageQueue-&gt;decStrong(env);&#125;// 析构函数是空的NativeMessageQueue::~NativeMessageQueue() &#123;&#125; 轮询 nativePollOnce唯一的非静态方法，也就是说这个方法是属于对象的，因为每个对象可以处理自己的回调。Handler 机制的核心，nativePollOnce 调用了 epoll 中的 epoll_wait 方法，当前线程阻塞等待：文件描述符事件（本文主要是唤醒事件）更新或者超时。阻塞等待时当前线程会释放 CPU 资源进入休眠状态，直到被唤醒，这个功能是 Linux epoll 机制实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void android_os_MessageQueue_nativePollOnce(JNIEnv* env,jobject obj, jlong ptr, jint timeoutMillis) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125;// 方法非常简单，调用 Looper.pollOnce// pollObj 是当前对象，所以该方法不能为是静态的// Looper.pollOnce 会回调 pollObj 对象的 dispatchEvents 方法void NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125;// Looper::pollInner 中会掉用 handleEvent ，这个方法是处理// 监听的文件描述符事件更新，这里是对 java 方法的回调int NativeMessageQueue::handleEvent(int fd,int looperEvents,void* data)&#123; ... int newWatchedEvents = mPollEnv-&gt;CallIntMethod(mPollObj, gMessageQueueClassInfo.dispatchEvents, fd, events); if (!newWatchedEvents) &#123; return 0; // unregister the fd &#125; if (newWatchedEvents != oldWatchedEvents) &#123; setFileDescriptorEvents(fd, newWatchedEvents); &#125; return 1;&#125;static struct &#123; jfieldID mPtr; // native object attached to the DVM MessageQueue jmethodID dispatchEvents;&#125; gMessageQueueClassInfo;// dispatchEvents 对应的 Java 中 MessageQueue.dispatchEventsgMessageQueueClassInfo.dispatchEvents = GetMethodIDOrDie(env, clazz, "dispatchEvents", "(II)I"); pollOnce 方法非常简单，需要获取当前对象，所以该方法不能为是静态的。调用了 Looper.pollOnce 方法，它会回调 pollObj 对象的 dispatchEvents 方法。而 Handler 收发消息机制中，并不会使用到文件描述符事件的回调，只需简单了解。 唤醒 nativeWakeLooper.cpp 中，唤醒事件是单独的文件描述符在监听，具体为 eventfd ，用于线程间通信。实际上 nativeWake 函数仅仅是向 eventfd 中写入一个值，将 epoll_wait 函数唤醒。 12345678910static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125;void NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; 是否正在轮询等待 nativeIsPollingnativeIsPolling 函数返回的是 Looper.cpp 中 epoll_wait 是否处于阻塞等待状态；这个方法在 Android Framework 使用的也很少。 123456static jboolean android_os_MessageQueue_nativeIsPolling(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); return nativeMessageQueue-&gt;getLooper()-&gt;isPolling();&#125; 监听文件描述符 nativeSetFileDescriptorEventsnativeSetFileDescriptorEvents 函数通过 Looper.cpp::addFd ，向 epoll_wait 中添加文件描述符监听事件，对应的回调 dispatchEvents 在 pollOnce 中分析过。 123456789101112131415161718192021static void android_os_MessageQueue_nativeSetFileDescriptorEvents( JNIEnv* env, jclass clazz, jlong ptr, jint fd, jint events) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;setFileDescriptorEvents(fd, events);&#125;void NativeMessageQueue::setFileDescriptorEvents(int fd, int events)&#123; if (events) &#123; int looperEvents = 0; if (events &amp; CALLBACK_EVENT_INPUT) &#123; looperEvents |= Looper::EVENT_INPUT; &#125; if (events &amp; CALLBACK_EVENT_OUTPUT) &#123; looperEvents |= Looper::EVENT_OUTPUT; &#125; mLooper-&gt;addFd(fd, Looper::POLL_CALLBACK, looperEvents, this, reinterpret_cast&lt;void*&gt;(events)); &#125; else &#123; mLooper-&gt;removeFd(fd); &#125;&#125; 系统层实现系统层 Looper.cpp 都是在 Linux 中编程实现，包括下面介绍的线程相关方法、eventfd 文件描述符、epoll 机制。Looper.cpp 实现了完整的 native 消息收发机制，使用 MessageEnvelope 存储消息；Request 存储文件描述符的监听；这些都是提供给 native 层使用，不过 Android Framework 使用的并不是特别多。本文介绍的 Java 层 Handler 消息通信机制中，收发消息过程，只会有唤醒 POLL_WAKE 和超时 POLL_TIMEOUT 两种返回事件。最开始看源码时总是将 Java 消息和 native 的消息一一对应，或者相互关联；但实际上它们是两个完全不同的东西，只是共用了 eventfd, epoll 消息处理机制，本文不做 native 消息的介绍，这两个概念不要混淆了。 线程相关方法TLS: Thread Local Storage 线程本地存储，和 Java ThreadLocal 功能一样，保存线程私有数据。使用同一个变量，不同线程存储和拿到的结果能够被隔离，相当于提供了一个同名而不同值的全局变量（这个全局变量相对于拥有这个变量的线程来说）。 pthread_key_t gTLSKeygTLSKey 共享变量。 pthread_key_createpthread_key_create(&amp; gTLSKey, threadDestructor); ，绑定 gTLSKey 变量，该变量所有线程都可以访问，但各个线程可以根据自己的需要往 gTLSKey 中填入不同的值。threadDestructor 是销毁函数，线程退出时会调用该销毁函数。 pthread_setspecificpthread_setspecific(gTLSKey, looper.get()); ，当前线程向 gTLSKey 中写入数据。 pthread_getspecific(Looper*)pthread_getspecific(gTLSKey); ，从 gTLSKey 中取出当前线程存储的值。 pthread_once 仅执行一次函数声明： int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；函数功能：变量 once_control 的值设为 PTHREAD_ONCE_INIT 时，本函数保证 init_routine() 函数在进程执行序列中仅执行一次。 根据上面的简单介绍，Looper.cpp 中关于 TLS 线程本地存储的几个函数源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142// once_control 变量，即确保函数只执行一次static pthread_once_t gTLSOnce = PTHREAD_ONCE_INIT;static pthread_key_t gTLSKey = 0;sp&lt;Looper&gt; Looper::getForThread() &#123; // 确保多线程中 initTLSKey 方法只执行一次 int result = pthread_once(&amp; gTLSOnce, initTLSKey); LOG_ALWAYS_FATAL_IF(result != 0, "pthread_once failed"); // 从 gTLSKey 取出当前线程存储的数据 return (Looper*)pthread_getspecific(gTLSKey);&#125;void Looper::initTLSKey() &#123; // 创建并绑定 gTLSKey int result = pthread_key_create(&amp; gTLSKey, threadDestructor); LOG_ALWAYS_FATAL_IF(result != 0, "Could not allocate TLS key.");&#125;// 销毁函数void Looper::threadDestructor(void *st) &#123; Looper* const self = static_cast&lt;Looper*&gt;(st); if (self != NULL) &#123; self-&gt;decStrong((void*)threadDestructor); &#125;&#125;void Looper::setForThread(const sp&lt;Looper&gt;&amp; looper) &#123; // also has side-effect of initializing TLS sp&lt;Looper&gt; old = getForThread(); if (looper != NULL) &#123; looper-&gt;incStrong((void*)threadDestructor); &#125; // 当前线程向 gTLSKey 写入数据 pthread_setspecific(gTLSKey, looper.get()); if (old != NULL) &#123; old-&gt;decStrong((void*)threadDestructor); &#125;&#125; eventfd 文件描述符eventfd 是一个用来通知事件的文件描述符，用来实现进程/线程间的等待/通知 wait/notify 机制以及数据交互，通过内核取唤醒用户态的事件。只有一个系统调用接口：int eventfd(unsigned int initval, int flags);，返回一个新建的 eventfd 对象，该对象是一个内核维护的无符号的 64 位整型计数器，初始化值为 initval ；flags 有几个可选项： EFD_NONBLOCK ：设置对象为非阻塞状态，read 读取 eventfd 时不会阻塞 EFD_CLOEXEC ：表示执行时关闭；设置此标志后，在执行 exec 时才关闭 eventfd 描述符，否则该描述符一直打开 eventfd 是一个文件描述符，所以直接通过 read/write/close 来读写关闭。常见示例为进程/线程 A 向 eventfd 中写入数据，进程/线程 B 从 eventfd 中读取数据。Looper.cpp 中源码分析： 1234567891011121314151617181920212223242526272829303132333435363738394041Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX)&#123; // 构造方法中创建 mWakeEventFd 对象 mWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); LOG_ALWAYS_FATAL_IF(mWakeEventFd &lt; 0,"Could not make wake event fd: %s", strerror(errno)); AutoMutex _l(mLock); rebuildEpollLocked();&#125;Looper::~Looper() &#123; // 析构方法中，关闭 mWakeEventFd 句柄 close(mWakeEventFd); // 析构方法中，关闭 epoll 句柄 if (mEpollFd &gt;= 0) &#123; close(mEpollFd); &#125;&#125;void Looper::wake() &#123; ... uint64_t inc = 1; // 唤醒函数中，实际是向 mWakeEventFd 中写数据 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; ALOGW("Could not write wake signal: %s", strerror(errno)); &#125; &#125;&#125;void Looper::awoken() &#123; ... uint64_t counter; // 将 mWakeEventFd 中的数据都读出来 TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, sizeof(uint64_t)));&#125; epoll 机制I/O 多路复用就通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（通常是读或者写就绪），能够通知程序进行相应的读写操作。select, poll, epoll 都是 IO 多路复用的机制，本质上它们都是同步 I/O，都需要在读写事件就绪后自己负责进行读写。epoll 是 select 和 poll 的增强版本；相对于 select, poll 来说，epoll 更加灵活，没有描述符限制。epoll 使用一个文件描述符可以监听多个其他多个描述符，将用户关系文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 copy 只需一次。epoll 只有三个系统调用： epoll_create函数声明：int epoll_create(int size); ，创建一个 epoll 的句柄。参数 size 用来告诉内核这个监听的数目一共有多大。需要注意的是当创建好 epoll 句柄后，它就是会占用一个 fd 值，使用完后通过 close(mEpollFd); 来关闭。 epoll_ctl函数声明：int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); ，事件注册函数，告诉内核要监听什么类型的事件以及哪些文件描述符。参数 epfd 是 epoll_create 创建的句柄；fd 是被监听文件描述符；op 表示动作，用三个宏来表示：EPOLL_CTL_ADD：注册新的 fd 到 epfd 中；EPOLL_CTL_MOD：修改已经注册的 fd 的监听事件；EPOLL_CTL_DEL：从 epfd 中删除一个 fd；参数 event 告诉内核需要监听什么事，可以是以下几个宏的集合：EPOLLIN ：表示对应的文件描述符可以读；EPOLLOUT ：表示对应的文件描述符可以写；EPOLLPRI ：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；EPOLLERR ：表示对应的文件描述符发生错误；EPOLLHUP ：表示对应的文件描述符被挂断；EPOLLET ： 将 EPOLL 设为边缘触发 Edge Triggered 模式，这是相对于水平触发 Level Triggered 来说的，关于 ET/LT 主要是效率的区别，不做展开；EPOLLONESHOT ：只监听一次事件，当监听完这次事件之后，如果还需要继续监听的话，需要再次加入到队列里； epoll_wait函数声明：int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); ，阻塞等待事件的产生。参数 events 用来从内核得到事件的集合；maxevents 告诉内核这个 events 有多大，不能大于创建 epoll_create() 时的 size ；参数 timeout 是超时时间（单位为毫秒，0 会不会阻塞立即返回，-1不确定或永久阻塞）。该函数返回需要处理的事件数目，如返回 0 表示已超时。 Looper.cpp 中 epoll 除了监听唤醒文件描述符 eventfd，还可以同时监听 MessageQueue 设置的文件描述符，通过 addFd 添加。部分源码解析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132void Looper::rebuildEpollLocked() &#123; // Close old epoll instance if we have one. if (mEpollFd &gt;= 0) &#123; ... close(mEpollFd); &#125; // Allocate the new epoll instance and register the wake pipe. // 创建 epoll 句柄 mEpollFd = epoll_create(EPOLL_SIZE_HINT); LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, "Could not create epoll instance: %s" , strerror(errno)); struct epoll_event eventItem; // zero out unused members of data field union memset(&amp; eventItem, 0, sizeof(epoll_event)); // epoll 事件为 mWakeEventFd 可读事件 eventItem.events = EPOLLIN; eventItem.data.fd = mWakeEventFd; // 注册监听事件，唤醒文件描述符 mWakeEventFd int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); LOG_ALWAYS_FATAL_IF(result != 0, "Could not add wake event fd to epoll instance: %s", strerror(errno)); // 其他文件描述符 ...&#125;int Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; // 其他文件描述符 ... // mWakeEventFd 唤醒事件 if (result != 0) &#123;#if DEBUG_POLL_AND_WAKE ALOGD("%p ~ pollOnce - returning result %d", this, result);#endif if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; &#125; result = pollInner(timeoutMillis); &#125;&#125;int Looper::pollInner(int timeoutMillis) &#123; // native 消息，timeoutMillis 调整 ... // Poll. int result = POLL_WAKE; ... // We are about to idle. mPolling = true; struct epoll_event eventItems[EPOLL_MAX_EVENTS]; // epoll 阻塞等待事件的产生： mWakeEventFd 以及其他文件描述符 // 或者 timeoutMillis 超时 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); // 事件产生，唤醒继续执行 // No longer idling. mPolling = false; // Acquire lock. mLock.lock(); // 保护代码，状态检查 ... // 如果 epoll 是因为超时唤醒，更新 result // Check for poll timeout. if (eventCount == 0) &#123;#if DEBUG_POLL_AND_WAKE ALOGD("%p ~ pollOnce - timeout", this);#endif result = POLL_TIMEOUT; goto Done; &#125; ... // 不是超时，检查是哪些文件描述符唤醒的 for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; // mWakeEventFd 唤醒事件 if (epollEvents &amp; EPOLLIN) &#123; // 交给 eventfd 处理 awoken(); &#125; else &#123; ... &#125; &#125; else &#123; // 其他文件描述符的唤醒 ... &#125; &#125; Done: ; // native message 的处理 ... // Release lock. mLock.unlock(); // Invoke all response callbacks. // 处理 addFd 添加的文件描述符 ... &#123; // 回调文件描述符监听事件 handleEvent int callbackResult = response.request.callback-&gt;handleEvent (fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; &#125; return result;&#125;// 返回 epoll_wait 是否处于阻塞等待bool Looper::isPolling() const &#123; return mPolling;&#125; 从代码中可以看到，Handler 机制只监听了 mWakeEventFd 的可读事件，以及超时事件；mPolling 记录了 epoll_wait 是否处于阻塞等待，在 MessageQueue.isPolling 中查看该变量的值。 小结Looper.cpp 中通过 eventfd 实现线程间通信；通过 epoll 实现监听 eventfd 文件描述符的读写事件，以及 Message 的超时事件。 消息收发流程图Handler 机制大致流程： Looper.prepare 准备环境，初始化所有相关对象 Looper.loop 进入无限循环，阻塞等待获取下一条消息 MessageQueue.next 创建 Handler 子类，初始化 创建 Message ，存储相关信息 Handler.sendMessage 发送消息，加入到消息队列 MessageQueue.enqueueMessage Looper 从 MessageQueue 中取出 Message 后，指派给 Handler.handleMessage 处理，处理完后回收 Message.recycleUnchecked Looper.quit 退出机制 HandlerThread 创建与销毁在 Android 开发中经常会使用到线程，一想到线程，很多同学就立即使用 new Thread(){...}.start(); 这样的方式。这样如果在一个 Activity 中多次调用上面的代码，那么将创建多个匿名线程，程序运行的越久可能会越来越慢。因此，需要一个 Handler 来启动一个线程，以及删除一个线程，保证线程不会重复的创建。使用 HandlerThread 和 Handler 配合实现异步后台任务。特点： 由 2 个 Handler 和 1 个 HandlerThread 来实现 后台线程串行执行 源码分析HandlerThread 是参考 Looper 标准用法实现的工作线程， 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class HandlerThread extends Thread &#123; Looper mLooper; ... /** * Call back method that can be explicitly overridden * if needed to execute some setup before Looper loops. */ protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // If the thread has been started, // wait until the looper has been created. synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; ...&#125; HandlerThread 的创建代码示例： 123456789101112131415161718192021// UI线程的HandlerHandler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); // 处理UI更新&#125;;HandlerThread mBackThread = new HandlerThread("mybackthread");mBackThread.start();// 后台线程的HandlerHandler mBackHandler = new Handler(mBackThread.getLooper());mBackHandler.post(new Runnable() &#123; @Override public void run() &#123; // 后台线程执行耗时操作，异步 ... // mHandler发消息，回到主线程更新UI mHandler.sendMessage(msg); &#125;&#125;); 注意：mBackHandler 的初始化必须在 mBackThread.start(); 之后，否则拿不到这个线程的 looper。源码中可以看到，getLooper 会一直等待；而 Looper 是在 run 中创建的，并且通知等待线程。这种模式通过 mBackHandler.post(new Runnable() {}) 来实现后台异步任务执行，所有后台任务都是通过 HandlerThread 这个线程执行的，但是 HandlerThread 是串行执行任务的，也就是每次 post 后进入队列排队执行。 HandlerThread的退出1234567891011121314@Overrideprotected void onDestroy() &#123; super.onDestroy(); if(mBackThread != null)&#123; mBackThread.quitSafely(); try &#123; mBackThread.join(); mBackThread = null; mBackHandler = null; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在 Activity.onDestroy 退出时，等待 mBackThread 线程销毁完成再退出！ 其他线程间通信机制 LocalBroadcastManager 本质还是 Handler 机制 EventBus查看了 EventBus 源码，UI 主线程间通信还是采用了 Handler 机制：public class HandlerPoster extends Handler implements Poster {...} ；后台线程间通信，采用的是 Java 标准的 notify/wait 机制。 后续Messenger 信差Messenger 用于进程间异步通信，其中通过 AIDL 来实现的进程间通信的；通过 Handler.sendMessage 来实现异步通信。详细参考Messenger 详解 。 OnFileDescriptorEventListener 监听文件描述符MessageQueue.java 中提供了完整的文件描述符监听功能，包括 Android_os_MessageQueue.cpp, Looper.cpp 中也实现了对应的功能，本文暂不做描述。 Native Loop 机制Java 层的 Handler 机制，在系统层的 Looper.cpp 文件中重新全部实现了一遍，供 Native 代码使用。本文仅仅介绍了其中的唤醒和轮询两个功能。而 Looper.cpp 中还包含添加文件描述符监听，收发 native 的消息。可以参考：Android Native层Looper详解 ，Android Native Looper机制 - 监听文件描述符 。 总结 Handler 通过 Linux 系统调用的意义本文介绍的 Handler 消息收发机制，完全可以使用 Object.wait/notify 来简单实现；但是源码为什么还使用了 Linux epoll 来实现呢？这是因为 Framework 除了提供等待和唤醒方法，还提供了其他文件描述符监听机制等，epoll 机制更强大更高效。 应用程序的主线程处于无限循环状态应用主线程 ActivityThread 进入 Looper.loop() 后不允许退出，直到应用退出；也就是说主线程是无限循环的，通过 epoll 机制阻塞等待时释放 CPU 资源，直到超时或事件触发才唤醒主线程。而我们经常遇到的 Activity 的 ANR 限制是针对 Activity 等组件的，实际上并不是主线程。 Handler 机制中的线程切换Handler 机制通常有两个线程：主线程和后台工作线程。主线程 loop 无限循环阻塞等待；后台工作线程完成耗时任务，发送完消息后就可以退出了；此时阻塞等待的主线程收到 epoll 机制的唤醒，拿到这个消息直接处理。因为消息 Message 是共享变量，所以整个 Handler 机制使用了很多同步锁 synchronized ，所以两个线程之间仅仅只是等待/通知交互。Looper.cpp 底层 epoll 机制并没有涉及数据交互，仅仅是线程间的通知什么时候能够取出消息，相当于 Java notify/wait 机制。而 epoll 还支持监听文件描述符涉及到数据交互，但是不属于本文介绍范围。 Handler 机制的退出主线程是无法退出的，会一直循环等待，除非退出应用程序；其他线程的退出通过调用 Looper.quit 来退出，退出时会移除消息队列的所有消息，并设置 mQuitting 使得 MessageQueue.next 返回 null ，Looper.loop 退出循环。 消息队列的唤醒消息队列 MessageQueue 有三个地方会唤醒：退出 quit 必须唤醒；移除同步屏障 removeSyncBarrier 和消息入队 enqueueMessage 满足条件时才唤醒。通过 nativeWake 触发唤醒。 参考文档 gityuan:Android消息机制-Handler 隔壁老李头：Android Handler 机制系列 Android Handler.java API Android Looper.java API Android MessageQueue.java API Android Message.java API Android Handler Looper机制 Looper 探底 Android消息机制 空闲消息处理器 AMS 释放内存详解 Android中Looper的quit方法和quitSafely方法 Handler之同步屏障机制sync barrier Linux 本地线程存储栈-TLS Linux多线程学习 pthread_once Linux eventfd Linux IO多路复用之epoll总结 Android源码解析之Handler机制详解-Java简化版本的实现 Handler BlockingRunnable 介绍 MessageQueue的队列管理 深入理解MessageQueue]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Asynchronous</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件 -- ContentProvider]]></title>
    <url>%2F2017%2F11%2F27%2F0022-content-provider%2F</url>
    <content type="text"><![CDATA[基础概念ContentProvider 一般为存储和获取数据提供统一的接口，可以在不同的应用程序之间共享数据。 参考文档1.ContentProvider从入门到精通]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FourComponents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件 -- LocalBroadcastManager]]></title>
    <url>%2F2017%2F11%2F27%2F0021-local-broadcast%2F</url>
    <content type="text"><![CDATA[LocalBroadcastManager 本地广播，用于应用内部通信，可以实现线程间交互。 标准的广播 BroadcastReceiver 用于跨进程通信，不同应用之间的通信，实现原理基于 Binder 机制。而同一个应用相同进程内，通过观察者模式来实现消息传递，并不需要全局广播，在 support.v4 包中提供的 LocalBroadcastManager 就是用来实现本地广播的，它是基于 Handler 机制，实现线程间通信，Handler.mLooper 为应用的主线程 Looper 。LocalBroadcastManager 本地广播通过 Handler 逐条处理广播的（串行处理方式），它支持异步和同步处理方式。 内部类ReceiverRecord 广播接收器记录ReceiverRecord 类存储了一个广播接收器，及其对应的过滤器。 BroadcastReceiver receiver ：注册的广播接收器 IntentFilter filter ：注册广播接收器时对应过滤器 broadcasting ：表示是否正在处理对应的广播，避免重复处理 12345678910111213private static class ReceiverRecord &#123; final IntentFilter filter; final BroadcastReceiver receiver; boolean broadcasting; ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver)&#123; filter = _filter; receiver = _receiver; &#125; @Override public String toString() &#123;...&#125;&#125; BroadcastRecord 广播发送记录ReceiverRecord 类存储了一个广播 Intent ，及其匹配的所有广播接收器记录列表。 Intent intent ：记录发送的广播 ArrayList&lt;ReceiverRecord&gt; receivers ：匹配该广播的所有接收器列表 123456789private static class BroadcastRecord &#123; final Intent intent; final ArrayList&lt;ReceiverRecord&gt; receivers; BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers)&#123; intent = _intent; receivers = _receivers; &#125;&#125; 成员变量和构造方法源码列表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Application Contextprivate final Context mAppContext;// 存储应用所有的广播接收器，及对应的广播过滤器列表private final HashMap&lt;BroadcastReceiver,ArrayList&lt;IntentFilter&gt;&gt; mReceivers = new HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt;();// 存储应用所有的广播，及对应的广播接收器列表private final HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions = new HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt;();// 存储所有需要处理的广播private final ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts = new ArrayList&lt;BroadcastRecord&gt;();static final int MSG_EXEC_PENDING_BROADCASTS = 1;// 使用 Handler 通信机制来处理应用内部的所有本地广播private final Handler mHandler;// 单例模式 private static final Object mLock = new Object();private static LocalBroadcastManager mInstance;public static LocalBroadcastManager getInstance(Context context) &#123; synchronized (mLock) &#123; if (mInstance == null) &#123; 整个应用的 Context mInstance = new LocalBroadcastManager( context.getApplicationContext()); &#125; return mInstance; &#125;&#125;private LocalBroadcastManager(Context context) &#123; mAppContext = context; // 应用主线程 Looper mHandler = new Handler(context.getMainLooper()) &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_EXEC_PENDING_BROADCASTS: executePendingBroadcasts(); break; default: super.handleMessage(msg); &#125; &#125; &#125;;&#125; 重要成员变量 mAppContext ：整个应用的 Context ，避免组件退出引起内存泄露 mReceivers ：哈希表，存储应用所有的广播接收器，及每个广播接收器对应的广播过滤器列表（一个广播接收器可以监听多个广播） mActions ：哈希表，存储应用所有的广播，及每条广播对应的广播接收器列表（一个广播可以有多个广播接收器响应） mPendingBroadcasts ：数组列表，记录需要处理广播 mHandler ：使用 Handler 通信机制来处理应用内部的所有本地广播，Looper 对应的是应用主线程 Looper 单例模式LocalBroadcastManager 的构造方法是私有的，使用单例模式来获取实例。构造方法中，实例化 Handler 并实现消息处理方法。（这里单例模式更推荐双检锁实现方式） 注册/取消注册广播注册广播注册广播的过程，就是一个数据存储过程。 根据注册的广播接收器和过滤器，新建 ReceiverRecord 对象 将广播接收器和过滤器，存储到 mReceivers 中 将广播过滤器的 Action 存储到 mActions 中，方便后续根据 Action 查找对应的广播接收器 123456789101112131415161718192021public void registerReceiver(BroadcastReceiver receiver, IntentFilter filter) &#123; synchronized (mReceivers) &#123; ReceiverRecord entry = new ReceiverRecord(filter, receiver); ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver); if (filters == null) &#123; filters = new ArrayList&lt;IntentFilter&gt;(1); mReceivers.put(receiver, filters); &#125; filters.add(filter); for (int i=0; i&lt;filter.countActions(); i++) &#123; String action = filter.getAction(i); ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action); if (entries == null) &#123; entries = new ArrayList&lt;ReceiverRecord&gt;(1); mActions.put(action, entries); &#125; entries.add(entry); &#125; &#125;&#125; 取消广播注册取消广播注册，就是一个移除数据的过程。 从 mReceivers 中移除该广播接收器 从 mActions 中移除该广播接收器监听的广播过滤器列表中每个 Action 1234567891011121314151617181920212223242526public void unregisterReceiver(BroadcastReceiver receiver) &#123; synchronized (mReceivers) &#123; ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver); if (filters == null) &#123; return; &#125; for (int i=0; i&lt;filters.size(); i++) &#123; IntentFilter filter = filters.get(i); for (int j=0; j&lt;filter.countActions(); j++) &#123; String action = filter.getAction(j); ArrayList&lt;ReceiverRecord&gt; receivers=mActions.get(action); if (receivers != null) &#123; for (int k=0; k&lt;receivers.size(); k++) &#123; if (receivers.get(k).receiver == receiver) &#123; receivers.remove(k); k--; &#125; &#125; if (receivers.size() &lt;= 0) &#123; mActions.remove(action); &#125; &#125; &#125; &#125; &#125;&#125; 发送广播发送广播广播的发送有两种：同步和异步发送；异步发送是通过 Handler.sendEmptyMessage 实现，而同步则是在异步的基础上，马上执行广播接收器响应（主要是在异步出现阻塞或者之前有过多任务时，才能体现出明显的效率）。 从 mActions 中查找广播对应的广播接收记录列表 每个广播接收记录中，如果不是正在被广播，则添加到 mPendingBroadcasts 中 Handler 发送消息，异步执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public boolean sendBroadcast(Intent intent) &#123; synchronized (mReceivers) &#123; final String action = intent.getAction(); final String type = intent.resolveTypeIfNeeded( mAppContext.getContentResolver()); final Uri data = intent.getData(); final String scheme = intent.getScheme(); final Set&lt;String&gt; categories = intent.getCategories(); ... ArrayList&lt;ReceiverRecord&gt; entries=mActions.get(intent.getAction()); if (entries != null) &#123; ... ArrayList&lt;ReceiverRecord&gt; receivers = null; for (int i=0; i&lt;entries.size(); i++) &#123; ReceiverRecord receiver = entries.get(i); ... if (receiver.broadcasting) &#123; ... continue; &#125; int match = receiver.filter.match(action, type, scheme, data, categories, "LocalBroadcastManager"); if (match &gt;= 0) &#123; ... if (receivers == null) &#123; receivers = new ArrayList&lt;ReceiverRecord&gt;(); &#125; receivers.add(receiver); receiver.broadcasting = true; &#125; else &#123; ... &#125; &#125; if (receivers != null) &#123; for (int i=0; i&lt;receivers.size(); i++) &#123; receivers.get(i).broadcasting = false; &#125; mPendingBroadcasts.add(new BroadcastRecord(intent,receivers)); if (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123; mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS); &#125; return true; &#125; &#125; &#125; return false;&#125;public void sendBroadcastSync(Intent intent) &#123; if (sendBroadcast(intent)) &#123; executePendingBroadcasts(); &#125;&#125; sendBroadcastSync 同步广播，如果有广播在排队处理，直接调用广播执行方法 executePendingBroadcasts ；如果广播队列并没有等待，效率区别不大。 响应广播不管是同步广播还是异步广播，最终响应执行都是调用 executePendingBroadcasts 方法。主要功能是：从 mPendingBroadcasts 中逐个取出广播接收器，响应 BroadcastReceiver.onReceive 回调方法。 123456789101112131415161718192021private void executePendingBroadcasts() &#123; while (true) &#123; BroadcastRecord[] brs = null; synchronized (mReceivers) &#123; final int N = mPendingBroadcasts.size(); if (N &lt;= 0) &#123; return; &#125; brs = new BroadcastRecord[N]; mPendingBroadcasts.toArray(brs); mPendingBroadcasts.clear(); &#125; for (int i=0; i&lt;brs.length; i++) &#123; BroadcastRecord br = brs[i]; for (int j=0; j&lt;br.receivers.size(); j++) &#123; br.receivers.get(j).receiver. onReceive(mAppContext, br.intent); &#125; &#125; &#125;&#125; 示例在 Activity 中注册一个广播接收器，在 Services 后台线程中发送本地广播，形成线程间本地广播通信。 广播注册/取消注册123456789101112131415161718192021222324252627282930313233343536373839// LocalBroadcastActivity.javaprivate LocalBroadcastManager mLocalBroadcastManager = null;private boolean mRegistered;private BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent != null)&#123; String response = intent.getStringExtra("key"); Log.d(TAG, "onReceive: response: " + response); &#125; &#125;&#125;;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_local_broadcast); mLocalBroadcastManager = LocalBroadcastManager.getInstance(this);&#125;@Overrideprotected void onStart() &#123; super.onStart(); IntentFilter intentFilter = new IntentFilter(ACTION_RESPONSE); mLocalBroadcastManager.registerReceiver(mReceiver, intentFilter); mRegistered = true;&#125;@Overrideprotected void onStop() &#123; super.onStop(); if (mRegistered)&#123; mRegistered = false; mLocalBroadcastManager.unregisterReceiver(mReceiver); Log.d(TAG, "onStop: mLocalBroadcastManager.unregisterReceiver"); &#125;&#125; 广播发送1234567891011121314151617// LocalBroadcastService.javaprivate void doLongWork(final String value)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, "run: sleep..."); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Intent intent = new Intent(ACTION_RESPONSE); intent.putExtra("key", "response"); LocalBroadcastManager.getInstance(this).sendBroadcast(intent); &#125; &#125;).start();&#125; 小结本地广播的三个特点： 数据只会在当前应用中广播，不会传递到其他应用（甚至当前应用的其他进程），确保数据安全 其他应用的广播不会发送到当前应用中，不用担心安全漏洞 不用通过系统 AMS 全局管理广播，而是本地保存数据，广播更高效 另外：本地广播只支持动态注册的方式。 参考文档 Android reference: LocalBroadcastManager]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FourComponents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件 -- Broadcast]]></title>
    <url>%2F2017%2F11%2F27%2F0021-broadcast%2F</url>
    <content type="text"><![CDATA[广播 Broadcast 属于 Android 四大组件之一，通过观察者模式，用于实现进程间的异步通信。 广播的实现机制是观察者模式；消息发布/订阅模式的事件驱动模型，消息的生产者发布事件，而使用者订阅感兴趣的事件。Broadcast 机制和 Binder 机制不一样的地方在于：广播的发送者和接收者事先是不需要知道对方的存在的，这也是观察者模式的特点，显而易见的优点是系统的各个组件可以松耦合地组织在一起，所有的广播发送和接收都是通过系统 AMS 来调度的，它充当了广播总线的功能。 基础广播实现进程间异步交互：进程间通信时通过 Binder 来实现的，异步通信是通过 Handler 实现。 广播接收器的分类 静态注册广播接收器：Manifest-declared receivers在 AndroidManifest.xml 文件中通过 &lt;receiver&gt; 声明的广播接收器。 动态注册广播接收器：Context-registered receivers通过 registerReceiver 注册的广播接收器。 广播的分类 普通广播通过 sendBroadcast 发出的广播。 有序广播通过 sendOrderedBroadcast 发出的广播；有序广播对应的广播接收器存在优先级关系，优先级越高越先收到广播。有序广播还可以有回调广播接收器，即广播匹配的所有广播接收器处理完毕后，系统会再向广播发送者，发回这个回调。 粘性广播通过 sendStickyBroadcast 发出的广播。粘性广播发送后，系统会把代表这个广播的 Intent 保存下来，如果后面在动态注册相同 Action 的广播接收器时，系统就将最后发出的粘性广播重新发送给这个广播接收器。也就是说，尽管广播早就发送处理完毕了，但是后续如果有新注册的广播接收器能匹配这个广播，还是会响应广播事件的。但是粘性广播从 Android 5.0 开始就将相关系统接口全部标注为 @Deprecated。它们不提供安全性（任何人都可以访问它们），没有保护（任何人都可以修改它们）以及许多其他问题。所以 Android 平台已经弃用，本文也不做介绍。 广播的标记根据发送广播 Intent 设置的标记来区分： FLAG_RECEIVER_FOREGROUND表示广播为前台广播，允许接收者以前台的优先级运行，有更短的时间间隔。默认情况下广播都是后台广播 FLAG_RECEIVER_REPLACE_PENDING表示新的广播会替换掉那些已存在的相同广播。相同的定义是通过 Intent.filterEquals 方法对两个广播的 Intent 比较，当匹配到相同的，新的广播和对应的接收器会将待发送的广播列表中已存在的替换掉，在列表中保留同样的位置。这个标志通常被粘性广播使用，只保证将最新的广播的值传递给接收器。 广播的 ANR前台广播的 ANR 时间是 10 秒，后台广播是 60 秒。因为默认为后台广播，所以通常情况下，需要在 60 秒内处理完所有的广播事件。广播的 ANR 只会出现在有序处理的广播队列中（包含有序广播和静态注册的广播接收器匹配的普通广播）中。 1234// ActivityManagerService.java// How long we allow a receiver to run before giving up on it.static final int BROADCAST_FG_TIMEOUT = 10*1000;static final int BROADCAST_BG_TIMEOUT = 60*1000; 相关类文件速查表1234567891011121314framework/base ./core/java/android/app/ContextImpl.java ./core/java/android/app/ActivityThread.java ./core/java/android/app/LoadedApk.java ./core/java/android/app/BroadcastOptions.java ./core/java/android/content/IIntentReceiver.aidl ./core/java/android/content/pm/PackageParser.java ./core/java/android/content/BroadcastReceiver.java ./services/core/java/com/android/server/am/BroadcastRecord.java ./services/core/java/com/android/server/am/ReceiverList.java ./services/core/java/com/android/server/am/BroadcastFilter.java ./services/core/java/com/android/server/am/BroadcastQueue.java ./services/core/java/com/android/server/am/ActivityManagerService.java ./services/core/java/com/android/server/pm/PackageManagerService.java 类简介 BroadCastReceiver广播接收器，用于处理接收的每个广播事件。 IIntentReceiver是 AIDL 文件，每个 BroadCastReceiver 都会转换为一个 IIntentReceiver，用来跨进程传递数据。 LoadedApk.ReceiverDispatcher广播接收发布器，BroadCastReceiver 都是在这转换为 IIntentReceiver 的。每个动态注册的广播接收器 BroadcastReceiver 都对应一个 LoadedApk.ReceiverDispatcher ，最终都是在这进行响应调用 onReceive 的。 BroadcastFilter是 IntentFilter 的子类，广播过滤器，用于匹配广播 Intent；包含广播接收者相关信息，权限等。只有动态注册广播广播接收器会用到。 ReceiverList是 ArrayList 的子类，是一个集合用来存储 BroadcastFilter 。记录广播接收器相关信息等，只有动态注册的广播接收器会用到，每个 BroadCastReceiver 对应一个 ReceiverList ，而每个 ReceiverList 可以包含多个 BroadcastFilter ，表示能够监听多个广播。 BroadcastRecord继承了 Binder，用来跨进程传递数据。发送的每个广播 Intent ，最后都会对应一个 BroadcastRecord ；它记录了广播的发送时间，发送者，接受者，广播携带的数据，回调，所在 BroadcastQueue 等等。 BroadcastQueue广播队列，有两个 ArrayList&lt;BroadcastRecord&gt; 用于存储 BroadcastRecord 分别是：mParallelBroadcasts 存储并行处理的广播；mOrderedBroadcasts 存储有序处理的广播。 ContextImpl广播发送，广播接收器动态注册的入口。 ActivityThread应用主线程，广播发送过程都是由它进入系统进程 AMS，广播接收器响应事件是有系统 AMS 进入它。 ActivityManagerServiceAMS 系统四大组件大管家，类似广播总线：管理广播接收器的注册，管理广播的发送到匹配的广播接收器中处理。 PackageParser包解析类，会从 AndroidManifest.xml 中解析出静态注册的广播接收器。 PackageManagerServicePMS 系统包管家，负责静态注册广播接收器的存储，查询。 BroadcastFilter 类详解BroadcastFilter 继承了 IntentFilter 类，广播信息过滤器，即动态注册广播接收器时，注册的是哪个广播过滤器。 源码分析12345678910111213141516171819202122232425final class BroadcastFilter extends IntentFilter &#123; // Back-pointer to the list this filter is in. final ReceiverList receiverList; final String packageName; final String requiredPermission; final int owningUid; final int owningUserId; BroadcastFilter(IntentFilter _filter, ReceiverList _receiverList, String _packageName, String _requiredPermission, int _owningUid, int _userId) &#123; super(_filter); receiverList = _receiverList; packageName = _packageName; requiredPermission = _requiredPermission; owningUid = _owningUid; owningUserId = _userId; &#125; public void dump(PrintWriter pw, String prefix) &#123;...&#125; public void dumpBrief(PrintWriter pw, String prefix) &#123;...&#125; public void dumpInReceiverList(PrintWriter pw, Printer pr, String prefix) &#123;...&#125; void dumpBroadcastFilterState(PrintWriter pw, String prefix) &#123;...&#125; public String toString() &#123;...&#125; 成员变量 receiverList ：当前对象属于哪个接收列表 packageName ：动态注册广播发起者的包名 requiredPermission ：设置发送广播时需要的权限 owningUid ：动态注册广播发起者 Uid owningUserId ：动态注册广播发起者 UserId 这里简单介绍下 uid, userId 的区别： uid是 Linux 下的概念，表示 Linux 系统下的用户 ID 。 userId是 Android 的多用户概念，从 4.2 开始系统支持多用户登录，记录登录用户的 ID ；不支持多用户登录的系统上，这个值是唯一的。多用户支持是在 frameworks/base/core/res/res/values/config.xml 文件中，config_multiuserMaximumUsers 值来决定的。 ReceiverList 类详解ReceiverList 继承了 ArrayList ，本质上是一个数据集合，数据类型为 BroadcastFilter。动态注册广播接收器时，每个广播接收器 BroadCastReceiver 对应一个 ReceiverList ，记录了一系列 BroadcastFilter 的列表，表示这个广播接收器注册了一个或多个广播过滤器。 源码分析1234567891011121314151617181920212223242526272829303132333435final class ReceiverList extends ArrayList&lt;BroadcastFilter&gt; implements IBinder.DeathRecipient &#123; final ActivityManagerService owner; public final IIntentReceiver receiver; public final ProcessRecord app; public final int pid; public final int uid; public final int userId; BroadcastRecord curBroadcast = null; boolean linkedToDeath = false; String stringName; ReceiverList(ActivityManagerService _owner, ProcessRecord _app, int _pid, int _uid, int _userId, IIntentReceiver _receiver) &#123; owner = _owner; receiver = _receiver; app = _app; pid = _pid; uid = _uid; userId = _userId; &#125; // Want object identity, not the array identity we are inheriting. public boolean equals(Object o) &#123;return this == o;&#125; public int hashCode() &#123;return System.identityHashCode(this);&#125; public void binderDied() &#123; linkedToDeath = false; owner.unregisterReceiver(receiver); &#125; void dumpLocal(PrintWriter pw, String prefix) &#123;...&#125; void dump(PrintWriter pw, String prefix) &#123;...&#125; public String toString() &#123;...&#125; 成员变量 ActivityManagerService owner ： AMS 对象 IIntentReceiver receiver ：当前 ReceiverList 对应的 IIntentReceiver ProcessRecord app ：动态注册广播发起者进程相关信息 pid ：动态注册广播发起者进程 Id uid ：动态注册广播发起者 uid userId ：动态注册广播发起者 userId BroadcastRecord curBroadcast ：动态注册的广播，其详细信息 linkedToDeath ：Binder 通信机制是否断开 stringName ：ReceiverList 转换成的字符串 BroadCastReceiver 类详解BroadCastReceiver 广播接收器，用来处理监听的广播事件。BroadcastReceiver 是抽象类，抽象方法为 onReceive ，注册广播接收器前，需要在其子类中实现。 PendingResult 类PendingResult 是广播接收器待处理的结果类，是异步结果类；简要介绍下这个类存在的意义：通常情况下，UI 主线程阻塞超过 5 秒就会产生 ANR，更不用说卡顿现象 UI Jank；所以广播接收器中如果有耗时工作（比如磁盘读写，网络下载等），需要及时切换到后台工作线程中执行；而 PendingResult 就存储了广播处理器接收到广播所有相关信息，将 PendingResult 对象传递到后台工作线程完成广播处理，处理完后需要调用 PendingResult.finish() 通过系统该广播接收器已经处理完毕。 PendingResult 类有两个注意事项： PendingResult 类中的状态不是线程安全的，使用时将整个对象交给后台工作线程，避免并发竞争，该线程将负责设置结果并最终调用 finish() 系统中关于广播接收器的 ANR ：前台广播接收器允许运行时间大概是 10 秒，后台广播是 60 秒，如果广播处理器没有处理完毕就会产生 ANR 。注意这个过程的计算时间是：从广播分发到广播处理器，直到广播处理器通知系统处理完毕的总时间。即使通过 PendingResult 切换到后台工作线程，直到调用 PendingResult.finish() ，这整个过程都受到了这个 ANR 时间的限制。所以长时间的工作是不能放到 BroadCastReceiver 中来实现的，PendingResult 仅仅是多争取到了几秒钟 PendingResult 类的两个子类PendingResult 类的构造方法是 @hide 隐藏的，通常在 BroadcastReceiver.onReceive() 中调用 goAsync() 返回得到；而实际构造是在其子类中，静态注册广播和动态注册广播对应不同的子类： ActivityThread.ReceiverData 对应静态注册广播 123456789101112131415static final class ReceiverData extends BroadcastReceiver.PendingResult &#123; public ReceiverData(Intent intent,int resultCode,String resultData, Bundle resultExtras, boolean ordered, boolean sticky, IBinder token, int sendingUser) &#123; super(resultCode, resultData, resultExtras, TYPE_COMPONENT, ordered, sticky,token, sendingUser, intent.getFlags()); this.intent = intent; &#125; Intent intent; ActivityInfo info; CompatibilityInfo compatInfo; public String toString() &#123;...&#125;&#125; LoadedApk.ReceiverDispatcher.Args 对应动态注册广播 12345678910111213141516171819final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; private Intent mCurIntent; private final boolean mOrdered; private boolean mDispatched; public Args(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, int sendingUser) &#123; super(resultCode, resultData, resultExtras, mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered, sticky, mIIntentReceiver.asBinder(), sendingUser, intent.getFlags()); mCurIntent = intent; mOrdered = ordered; &#125; public void run() &#123;...&#125;&#125; PendingResult 类源码分析PendingResult 对应的广播类型有三种： TYPE_COMPONENT ：静态注册广播 TYPE_REGISTERED ：动态注册广播 TYPE_UNREGISTERED ：取消广播注册 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public static class PendingResult &#123; // 广播类型：静态注册，动态注册，解除注册 public static final int TYPE_COMPONENT = 0; public static final int TYPE_REGISTERED = 1; public static final int TYPE_UNREGISTERED = 2; final int mType; final boolean mOrderedHint; final boolean mInitialStickyHint; final IBinder mToken; final int mSendingUser; final int mFlags; int mResultCode; String mResultData; Bundle mResultExtras; boolean mAbortBroadcast; boolean mFinished; /** @hide */ public PendingResult(int resultCode, String resultData, Bundle resultExtras, int type, boolean ordered, boolean sticky, IBinder token, int userId, int flags) &#123; mResultCode = resultCode; mResultData = resultData; mResultExtras = resultExtras; mType = type; mOrderedHint = ordered; mInitialStickyHint = sticky; mToken = token; mSendingUser = userId; mFlags = flags; &#125; // 获取和保存广播相关信息 public final void setResultCode(int code) &#123;...&#125; public final int getResultCode() &#123;...&#125; public final void setResultData(String data) &#123;...&#125; public final String getResultData() &#123;...&#125; public final void setResultExtras(Bundle extras) &#123;...&#125; public final Bundle getResultExtras(boolean makeMap) &#123;...&#125; public final void setResult(int code, String data, Bundle extras) &#123;...&#125; public int getSendingUserId() &#123;...&#125; // 终止有序广播 public final boolean getAbortBroadcast() &#123;return mAbortBroadcast;&#125; public final void abortBroadcast() &#123; checkSynchronousHint(); mAbortBroadcast = true; &#125; public final void clearAbortBroadcast() &#123; mAbortBroadcast = false; &#125; public final void finish() &#123; if (mType == TYPE_COMPONENT) &#123; // 如果是静态注册广播 final IActivityManager mgr = ActivityManager.getService(); if (QueuedWork.hasPendingWork()) &#123; // 如果还有任务没有执行完，将任务加入队列排队执行 QueuedWork.queue(new Runnable() &#123; @Override public void run() &#123; ... sendFinished(mgr); &#125; &#125;, false); &#125; else &#123; ... sendFinished(mgr); &#125; &#125; else if (mOrderedHint &amp;&amp; mType != TYPE_UNREGISTERED) &#123; // 如果是有序广播 ... final IActivityManager mgr = ActivityManager.getService(); sendFinished(mgr); &#125; &#125; // 设置类加载器 public void setExtrasClassLoader(ClassLoader cl) &#123; if (mResultExtras != null) &#123; mResultExtras.setClassLoader(cl); &#125; &#125; /** @hide */ public void sendFinished(IActivityManager am) &#123; synchronized (this) &#123; if (mFinished) &#123; throw new IllegalStateException("..."); &#125; mFinished = true; try &#123; if (mResultExtras != null) &#123; mResultExtras.setAllowFds(false); &#125; if (mOrderedHint) &#123; am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras, mAbortBroadcast, mFlags); &#125; else &#123; am.finishReceiver(mToken, 0, null, null, false, mFlags); &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125; &#125; ...&#125; BroadcastReceiver 源码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class BroadcastReceiver &#123; private PendingResult mPendingResult; ... public static class PendingResult &#123;...&#125; public BroadcastReceiver() &#123;&#125; public abstract void onReceive(Context context, Intent intent); public final PendingResult goAsync() &#123; PendingResult res = mPendingResult; mPendingResult = null; return res; &#125; public IBinder peekService(Context myContext, Intent service) &#123;...&#125; // 设置 PendingResult 实例，存储获取相关结果 public final void setPendingResult(PendingResult result) &#123; mPendingResult = result; &#125; public final PendingResult getPendingResult() &#123; return mPendingResult; &#125; public final String getResultData() &#123; return mPendingResult != null ? mPendingResult.mResultData : null; &#125; public final void setResultExtras(Bundle extras) &#123; checkSynchronousHint(); mPendingResult.mResultExtras = extras; &#125; public final void setResultCode(int code) &#123;...&#125; public final int getResultCode() &#123;...&#125; public final Bundle getResultExtras(boolean makeMap) &#123;...&#125; public final void setResult(int code, String data, Bundle extras) &#123;...&#125; public int getSendingUserId() &#123;...&#125; // 终止有序广播 public final boolean getAbortBroadcast() &#123; return mPendingResult != null ? mPendingResult.mAbortBroadcast : false; &#125; public final void abortBroadcast() &#123; checkSynchronousHint(); mPendingResult.mAbortBroadcast = true; &#125; public final void clearAbortBroadcast() &#123; if (mPendingResult != null) &#123; mPendingResult.mAbortBroadcast = false; &#125; &#125; public final boolean isOrderedBroadcast() &#123;...&#125; public final boolean isInitialStickyBroadcast() &#123;...&#125; ...&#125; BroadcastReceiver 重要方法BroadcastReceiver 大部分数据存储都是通过 PendingResult 实例来保存的。 onReceive抽象方法，子类必须实现；广播接收器处理的入口。 goAsync异步广播，返回 PendingResult 实例，进入后台线程处理；处理完毕后必须调用 PendingResult.finish() 结束。 abortBroadcast如果广播接收器收到的是有序广播，则终止有序广播继续向下传递。 IIntentReceiver 详解IIntentReceiver 是一个 AIDL 文件，所以 IIntentReceiver 接口继承了 Binder 机制中的 IInterface ，表示服务端拥有的能力或者说能提供的功能。 IIntentReceiver 声明的方法，是在 LoadedApk.ReceiverDispatcher.InnerReceiver 中实现的。IIntentReceiver.aidl 源码如下： 12345678910111213// frameworks/base/core/java/android/content/IIntentReceiver.aidl/** * System private API for dispatching intent broadcasts. * This is given to the activity manager as part of registering for * an intent broadcasts, and is called when it receives intents. * * &#123;@hide&#125; */oneway interface IIntentReceiver &#123; void performReceive(in Intent intent, int resultCode, String data, in Bundle extras, boolean ordered, boolean sticky, int sendingUser);&#125; BroadCastReceiver 是系统组件，并不支持跨进程传输，Android Broadcast 机制使用 IIntentReceiver 来进行代替 BroadCastReceiver 来进行跨进程传输。可以看出 IIntentReceiver 只提供了一个方法 performReceive ，该方法仅仅在动态注册的广播接收器中会触发调用（静态注册广播接收器在 ActivityThread 中通过反射直接调用 onReceive 回调）；系统进程 AMS 在分发广播处理事件时，会向注册了广播接收的应用进程调用该方法，最终调用 BroadcastReceiver.onReceive 触发回调。注意：方法使用了 oneway 关键字，表示非阻塞调用；即 AMS 进程分发广播事件时，不需要等待每个应用接收者执行完 onReceive 。 LoadedApk 类LoadedApk 类存储了当前加载的 Apk 相关信息，包括主线程，文件所在路径，类加载器，注册的广播列表，启动的服务列表等等；LoadedApk 类是在每个应用加载初始化进程、主线程时实例化的，每个应用对应一个 LoadedApk 实例。本文只分析和广播 Broadcast 相关内容，LoadedApk 中存储了当前 Apk 中所有的普通广播接收器 BroadCastReceiver ，即通过 registerReceiver 注册到系统中的广播接收器。而有序广播中的回调广播接收器，即广播发送出去后，等待所有广播接收器处理完毕，最后产生一个回调给广播发送者，作用类似 startActivityForResult 。回调 BroadCastReceiver 不需要通过 registerReceiver 注册到系统中，是以参数的形式在 sendOrderedBroadcast() 发送广播时传递出去，这类广播不会存储到 LoadedApk 中。 在 ContextImpl 代码中可以看到：LoadedApk 对这两类广播接收器的处理过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// ContextImpl.java // 1. 普通广播接收器：注册广播接收器时，在 LoadedApk 中保存下来private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; // 获取广播接收器对应的 IIntentReceiver // register 变量值为 true, LoadedApk 保存该广播接收器 rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; // 如果 LoadedApk 没有加载，则新建一个 IIntentReceiver 对象 rd = new LoadedApk.ReceiverDispatcher(receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; ...&#125;// 2. 有序广播接收器：不注册广播，所以也不会保存@Overridepublic void sendOrderedBroadcastAsUser(Intent intent, UserHandle user, String receiverPermission, int appOp, Bundle options, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras) &#123; IIntentReceiver rd = null; if (resultReceiver != null) &#123; if (mPackageInfo != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; // 获取广播接收器对应的 IIntentReceiver // register 变量值为 false，不做保存 rd = mPackageInfo.getReceiverDispatcher( resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher(resultReceiver, getOuterContext(), scheduler, null, false) .getIIntentReceiver(); &#125; &#125;&#125; 部分源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219public final class LoadedApk &#123; // 保存所有通过 registerReceiver 注册的广播接收器 private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt;&gt; mReceivers = new ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt;(); private final ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt; mUnregisteredReceivers = new ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt;(); public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map=null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); // 如果是通过 registerReceiver 注册的，保存到 mReceivers 中 if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125; &#125; public IIntentReceiver forgetReceiverDispatcher(Context context, BroadcastReceiver r) &#123; synchronized (mReceivers) &#123; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = mReceivers.get(context); LoadedApk.ReceiverDispatcher rd = null; if (map != null) &#123; rd = map.get(r); if (rd != null) &#123; map.remove(r); if (map.size() == 0) &#123; mReceivers.remove(context); &#125; if (r.getDebugUnregister()) &#123; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder = mUnregisteredReceivers.get(context); if (holder == null) &#123; holder = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mUnregisteredReceivers.put(context, holder); &#125; ... holder.put(r, rd); &#125; rd.mForgotten = true; return rd.getIIntentReceiver(); &#125; &#125; ... throw ... &#125; &#125; static final class ReceiverDispatcher &#123; // 静态内部类 InnerReceiver final static class InnerReceiver extends IIntentReceiver.Stub &#123; ... InnerReceiver(LoadedApk.ReceiverDispatcher rd, boolean strong) &#123; mDispatcher=new WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd); mStrongRef = strong ? rd : null; &#125; // 最终调用的是外部类的 performReceive @Override public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final LoadedApk.ReceiverDispatcher rd; if (intent == null) &#123; Log.wtf(TAG, "Null intent received"); rd = null; &#125; else &#123; rd = mDispatcher.get(); &#125; ... if (rd != null) &#123; // 调用外部类的 performReceive rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; ... IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; // 广播接收器已经处理完这条广播 mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; &#125; &#125; final IIntentReceiver.Stub mIIntentReceiver; final BroadcastReceiver mReceiver; final Context mContext; final Handler mActivityThread; final Instrumentation mInstrumentation; final boolean mRegistered; final IntentReceiverLeaked mLocation; RuntimeException mUnregisterLocation; boolean mForgotten; // 成员内部类 Args final class Args extends BroadcastReceiver.PendingResult implements Runnable &#123; private Intent mCurIntent; private final boolean mOrdered; private boolean mDispatched; public Args(Intent intent, int resultCode, String resultData, Bundle resultExtras, boolean ordered, boolean sticky, int sendingUser) &#123; super(resultCode, resultData, resultExtras, mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered, sticky, mIIntentReceiver.asBinder(), sendingUser, intent.getFlags()); mCurIntent = intent; mOrdered = ordered; &#125; // 执行当前广播接收器 BroadCastReceiver.onReceive // 并告诉系统广播接收器处理完毕 public void run() &#123; final BroadcastReceiver receiver = mReceiver; final boolean ordered = mOrdered; ... final IActivityManager mgr=ActivityManagerNative.getDefault(); ... try &#123; ClassLoader cl = mReceiver.getClass().getClassLoader(); intent.setExtrasClassLoader(cl); intent.prepareToEnterProcess(); setExtrasClassLoader(cl); receiver.setPendingResult(this); receiver.onReceive(mContext, intent); &#125; catch (Exception e) &#123; if (mRegistered &amp;&amp; ordered) &#123; ... sendFinished(mgr); &#125; ... &#125; // 如果没有 PendingResult，调用 finish 开始处理下一个广播接收器 if (receiver.getPendingResult() != null) &#123; finish(); &#125; ... &#125; &#125; ReceiverDispatcher(BroadcastReceiver receiver, Context context, Handler activityThread, Instrumentation instrumentation, boolean registered) &#123; if (activityThread == null) &#123; throw new NullPointerException("Handler must not be null"); &#125; mIIntentReceiver = new InnerReceiver(this, !registered); mReceiver = receiver; mContext = context; mActivityThread = activityThread; mInstrumentation = instrumentation; mRegistered = registered; mLocation = new IntentReceiverLeaked(null); mLocation.fillInStackTrace(); &#125; ... BroadcastReceiver getIntentReceiver() &#123;return mReceiver;&#125; IIntentReceiver getIIntentReceiver() &#123;return mIIntentReceiver;&#125; public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; final Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); ... // 当前线程发布任务 Args if (intent == null || !mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr=ActivityManagerNative.getDefault(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(...); args.sendFinished(mgr); &#125; &#125; &#125; &#125; ...&#125; 成员变量 mReceivers ：当前 Apk 注册的广播列表 mUnregisteredReceivers ：当前 Apk 取消广播注册的列表 这两个成员变量都是 Map 结构，Key 值都是 Context，Value 仍然是一个 Map 结构： Key: Context每个 Activity 或者每个 Service 注册的广播分开记录，方便快速查找某个 Context 实例注册的所有广播。 Value: ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt; BroadcastReceiver 和 ReceiverDispatcher 是一一对应的，每个广播接收器都会对应一个广播接收分发器。ContextImpl.sendOrderedBroadcast, ContextImpl.registerReceiver 会对每个广播接收器 BroadCastReceiver ，通过 LoadedApk 找到或者生成对应的 ReceiverDispatcher ；在发送有序广播或者注册广播接收器，等到广播接收者开始执行时，AMS 通过 ReceiverDispatcher.InnerReceiver 来触发回调，即调用 BroadCastReceiver.onReceive 。 ReceiverDispatcher 静态内部类ReceiverDispatcher 是 LoadedApk 的静态内部类，同时它自己还包含两个内部类： 静态内部类 InnerReceiver实现了 IIntentReceiver.performReceive 方法，实际最终调用的是外部类 ReceiverDispatcher.performReceive 方法。 成员内部类 Args继承了 BroadCastReceiver.PendingResult 类，可以执行部分异步操作；同时实现了 Runnable ，通过传入的 Handler 发布这个任务，并调用 BroadCastReceiver.onReceive ，处理广播接收器回调事件。处理完后，通知系统该广播接收器处理完毕。 成员变量mRegistered ：记录该广播接收器是否通过 registerReceiver 注册的，即是否为动态注册的广播接收器。 ReceiverDispatcher 的几个重要方法： getIIntentReceiver ：返回广播接收器 BroadCastReceiver 对应的 IIntentReceiver 对象 performReceive ：使用当前线程 Handler 发送 Args 对象并执行；所有动态注册的广播接收器，都是在这里回调 onReceive 方法 广播相关方法 getReceiverDispatcher根据广播接收器获取广播接收分发器的 IIntentReceiver ，用于跨进程传递。主要是从 mReceivers 中获取；如果不存在则新建。 forgetReceiverDispatcher从 mReceivers 中移除指定回调广播接收器，并放入 mUnregisteredReceivers 中，返回值也是该广播接收器对应的 IIntentReceiver 。 BroadcastRecord 类详解BroadcastRecord 继承了 Binder ，表明该对象作为数据容器，能被跨进程通信。BroadcastRecord 保存了广播发送者相关信息，包含发送者的：包名，进程信息，广播是否有序，请求的权限等等。 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/** * An active intent broadcast. */final class BroadcastRecord extends Binder &#123; final Intent intent; // the original intent that generated us // original component name set on the intent final ComponentName targetComp; final ProcessRecord callerApp; // process that sent this final String callerPackage; // who sent this final int callingPid; // the pid of who sent this final int callingUid; // the uid of who sent this final boolean ordered; // serialize the send to receivers? final boolean sticky; // originated from existing sticky data? // initial broadcast from register to sticky? final boolean initialSticky; final int userId; // user id this broadcast was for final String resolvedType; // the resolved data type // permissions the caller has required final String[] requiredPermissions; final int appOp; // an app op that is associated with this broadcast final BroadcastOptions options; // BroadcastOptions supplied by caller final List receivers; // contains BroadcastFilter and ResolveInfo final int[] delivery; // delivery state of each receiver IIntentReceiver resultTo; // who receives final result if non-null long enqueueClockTime; // the clock time the broadcast was enqueued long dispatchTime; // when dispatch started on this set of receivers long dispatchClockTime; // the clock time the dispatch started long receiverTime; // when current receiver started for timeouts. long finishTime; // when we finished the broadcast. int resultCode; // current result code value. String resultData; // current result data value. Bundle resultExtras; // current result extra data values. boolean resultAbort; // current result abortBroadcast value. int nextReceiver; // next receiver to be executed. IBinder receiver; // who is currently running, null if none. int state; int anrCount; // has this broadcast record hit any ANRs? int manifestCount; // number of manifest receivers dispatched. int manifestSkipCount; // number of manifest receivers skipped. BroadcastQueue queue; // the outbound queue handling this broadcast // 广播的五种状态 static final int IDLE = 0; static final int APP_RECEIVE = 1; static final int CALL_IN_RECEIVE = 2; static final int CALL_DONE_RECEIVE = 3; static final int WAITING_SERVICES = 4; // 四种投递状态 static final int DELIVERY_PENDING = 0; static final int DELIVERY_DELIVERED = 1; static final int DELIVERY_SKIPPED = 2; static final int DELIVERY_TIMEOUT = 3; // The following are set when we are calling a receiver (one that // was found in our list of registered receivers). BroadcastFilter curFilter; // The following are set only when we are launching a receiver (one // that was found by querying the package manager). ProcessRecord curApp; // hosting application of current receiver. // the receiver class that is currently running. ComponentName curComponent; // info about the receiver that is currently running. ActivityInfo curReceiver; BroadcastRecord(BroadcastQueue _queue, Intent _intent, ProcessRecord _callerApp, String _callerPackage, int _callingPid, int _callingUid, String _resolvedType, String[] _requiredPermissions, int _appOp, BroadcastOptions _options, List _receivers, IIntentReceiver _resultTo, int _resultCode, String _resultData, Bundle _resultExtras, boolean _serialized, boolean _sticky, boolean _initialSticky, int _userId) &#123; if (_intent == null) &#123; throw new NullPointerException(" Can't construct with a null intent"); &#125; queue = _queue; intent = _intent; targetComp = _intent.getComponent(); callerApp = _callerApp; callerPackage = _callerPackage; callingPid = _callingPid; callingUid = _callingUid; resolvedType = _resolvedType; requiredPermissions = _requiredPermissions; appOp = _appOp; options = _options; receivers = _receivers; delivery = new int[_receivers != null ? _receivers.size() : 0]; resultTo = _resultTo; resultCode = _resultCode; resultData = _resultData; resultExtras = _resultExtras; ordered = _serialized; sticky = _sticky; initialSticky = _initialSticky; userId = _userId; nextReceiver = 0; state = IDLE; &#125; boolean cleanupDisabledPackageReceiversLocked(String packageName, Set&lt;String&gt; filterByClasses, int userId, boolean doit) &#123; if ((userId != UserHandle.USER_ALL &amp;&amp; this.userId != userId) || receivers == null) &#123; return false; &#125; boolean didSomething = false; Object o; for (int i = receivers.size() - 1; i &gt;= 0; i--) &#123; o = receivers.get(i); if (!(o instanceof ResolveInfo)) &#123; continue; &#125; ActivityInfo info = ((ResolveInfo)o).activityInfo; final boolean sameComponent = packageName == null || (info.applicationInfo.packageName.equals(packageName) &amp;&amp; (filterByClasses == null || filterByClasses.contains(info.name))); if (sameComponent) &#123; if (!doit) &#123; return true; &#125; didSomething = true; receivers.remove(i); if (i &lt; nextReceiver) &#123; nextReceiver--; &#125; &#125; &#125; nextReceiver = Math.min(nextReceiver, receivers.size()); return didSomething; &#125; void dump(PrintWriter pw, String prefix, SimpleDateFormat sdf) &#123;...&#125; public String toString() &#123;...&#125;&#125; 重要成员变量 Intent intent ：广播发送时的 Intent ComponentName targetComp ：广播发送者组件名称 ProcessRecord callerApp ：广播发送者进程记录 String callerPackage ：广播发送者包名 callingPid ：广播发送者 Pid callingUid ：广播发送者 Uid userId ：广播发送者 userId ordered ：广播是否有序发送 sticky ：广播是否为粘性广播 initialSticky ：广播是否一开始就设置为粘性广播 resolvedType ：Intent 的类型 String[] requiredPermissions ：广播发送者拥有的广播权限 appOp ：广播对应的应用管理权限 BroadcastOptions options ：广播发送者设定的选项 List receivers ：广播接收者列表，特别需要注意的是：它包含了两种类型数据 ResolveInfo, BroadcastFilter，分别对应静态注册广播接收器和动态注册广播接收器，取出时需要做类型判断 int[] delivery ：每个广播接收者的投递状态，状态分为四种 IIntentReceiver resultTo ：有序广播中回调的广播接收器，它也是有序广播的最后一个接收者 enqueueClockTime ：广播进入队列的时间 dispatchTime ：开始分派广播的开机时间 dispatchClockTime ：开始分派广播的系统绝对时间 receiverTime ：广播接收者接收到的时间 finishTime ：广播接收者处理完广播的完成时间 resultCode ：广播处理完毕的结果码 resultData ：广播处理完毕的简单数据 resultExtras ：广播处理完毕的复杂数据 resultAbort ：广播是否被终止 int nextReceiver ：下一个广播接收者索引 IBinder receiver ：广播当前接收者 int state ：广播的当前状态，状态分为五种 anrCount ：当前广播出现的 ANR 次数 manifestCount ：分发给静态注册广播接收者的次数 manifestSkipCount ：分发给静态注册广播接收者跳过的次数 BroadcastQueue queue ：处理当前广播所在队列 BroadcastFilter curFilter ：处理广播时当前广播过滤器 ProcessRecord curApp ：广播当前接收者的进程信息 ComponentName curComponent ：广播当前接收者的组件信息 ActivityInfo curReceiver ：广播当前接收者的信息 cleanupDisabledPackageReceiversLocked 方法BroadcastRecord 中只有一个包内可见的方法 cleanupDisabledPackageReceiversLocked ，该方法功能是从 List receivers 清理掉已经取消注册的广播注册接收者。 BroadcastQueue 类详解BroadcastQueue 用来保存系统和应用发出的广播信息；通常使用两个广播队列 BroadcastQueue ：一个用来保存前台广播，一个用来保存后台广播；而每个广播队列 BroadcastQueue 包含两个列表：一个用来并行处理；一个用来有序处理。 重要成员变量 ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts存储并行处理的广播：首先它是普通广播，其次这些广播匹配的广播接收器必须是动态注册的。 ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts存储有序处理的广播：包含有序广播和普通广播（匹配的广播接收器时静态注册的）。 mTimeoutPeriod广播接收器 ANR 超时时间阀值。前台广播是 10 秒，后台广播是 60 秒。 BroadcastHandler 类BroadcastHandler 是成员内部类，用来处理下一条广播，或者处理广播超时 ANR 。 123456789101112131415161718192021222324252627static final int BROADCAST_INTENT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG;static final int BROADCAST_TIMEOUT_MSG = ActivityManagerService.FIRST_BROADCAST_QUEUE_MSG + 1;final BroadcastHandler mHandler;private final class BroadcastHandler extends Handler &#123; public BroadcastHandler(Looper looper) &#123; super(looper, null, true); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BROADCAST_INTENT_MSG: &#123; if (DEBUG_BROADCAST) Slog.v( TAG_BROADCAST, "Received BROADCAST_INTENT_MSG"); processNextBroadcast(true); &#125; break; case BROADCAST_TIMEOUT_MSG: &#123; synchronized (mService) &#123; broadcastTimeoutLocked(true); &#125; &#125; break; &#125; &#125;&#125; AppNotResponding 类AppNotResponding 成员内部类，广播接收器处理广播事件时发生 ANR 。 123456789101112131415private final class AppNotResponding implements Runnable &#123; private final ProcessRecord mApp; private final String mAnnotation; public AppNotResponding(ProcessRecord app, String annotation) &#123; mApp = app; mAnnotation = annotation; &#125; @Override public void run() &#123; mService.mAppErrors.appNotResponding(mApp, null, null, false, mAnnotation); &#125;&#125; 静态注册广播接收器流程分析静态注册的广播接收器，又称为 Manifest 文件声明广播接收器，是在 PMS 扫描 AndroidManifest.xml 信息时解析的；所有静态注册的广播接收器，统一由 PMS 保存，广播在发送过程中，查找匹配的静态注册广播接收器也是在 PMS 中查询。 流程图 PackageParser.parseBaseApplication 详解PackageParser 主要用于详细解析包内相关信息，而 parseBaseApplication 主要解析 AndroidManifest.xml ，将每个 TAG 都解析并保存，其中静态注册的广播接收器存储到 receivers 中，而 PMS 会根据每个包解析的数据，保存整个系统全部的静态注册广播接收器（当然也保存其他 Activity, Services, ContentProvider 等信息）。 123456789101112131415161718192021222324252627282930313233// PackageParser.java// 保存当前 Package 中所有的 BroadCastReceiverpublic final ArrayList&lt;Activity&gt; receivers = new ArrayList&lt;Activity&gt;(0);private boolean parseBaseApplication(Package owner, Resources res, XmlResourceParser parser, int flags, String[] outError) ... while ((type = parser.next()) != XmlPullParser.END_DOCUMENT &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123; if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123; continue; &#125; String tagName = parser.getName(); if (tagName.equals("activity")) &#123; ... &#125; else if (tagName.equals("receiver")) &#123; // 解析到是静态注册的广播接收器，添加到 receivers 中 Activity a = parseActivity(owner, res, parser, flags, outError, cachedArgs, true, false); if (a == null) &#123; mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED; return false; &#125; owner.receivers.add(a); &#125; ... &#125; ...&#125; PMS 静态注册广播接收器PMS 在调用完 PackageParser.parsePackage 解析完指定包名信息后，将存储在 PackageParser.Package.receivers 的静态广播接收器信息，再保存到 PMS.mReceivers 中，方便后续全局查询。 1234567891011121314151617181920212223242526272829303132333435363738// PackageManageServices.java// All available receivers, for your resolving pleasure.// 存储整个系统所有的静态注册广播接收器final ActivityIntentResolver mReceivers = new ActivityIntentResolver();/** * Adds a scanned package to the system. When this method is finished, * the package will be available for query, resolution, etc... */private void commitPackageSettings(PackageParser.Package pkg, PackageSetting pkgSetting, UserHandle user, int scanFlags, boolean chatty) throws PackageManagerException &#123; final String pkgName = pkg.packageName; ... // PackageParser 解析到静态注册广播接收器 N = pkg.receivers.size(); r = null; for (i=0; i&lt;N; i++) &#123; PackageParser.Activity a = pkg.receivers.get(i); a.info.processName=fixProcessName(pkg.applicationInfo.processName, a.info.processName); // 将广播接收器存储到 PMS 的 mReceivers 中 mReceivers.addActivity(a, "receiver"); if (chatty) &#123; if (r == null) &#123; r = new StringBuilder(256); &#125; else &#123; r.append(' '); &#125; r.append(a.info.name); &#125; &#125; if (r != null) &#123; if (DEBUG_PACKAGE_SCANNING) Log.d(TAG, " Receivers: " + r); &#125; ...&#125; PMS 查询静态注册广播接收器AMS 在发送广播时，会从 PMS 中查询匹配的静态广播接收器；PMS.queryIntentReceiversInternal 根据广播 Intent ，从 mReceivers 中查询匹配的 ResolveInfo，而 ResolveInfo.activityInfo 存储了对应的广播接收器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// PackageManageServices.java// PMS.queryIntentReceivers --&gt; queryIntentReceiversInternalprivate @NonNull List&lt;ResolveInfo&gt; queryIntentReceiversInternal( Intent intent, String resolvedType, int flags, int userId, boolean allowDynamicSplits) &#123; ... synchronized (mPackages) &#123; String pkgName = intent.getPackage(); if (pkgName == null) &#123; // 从 mReceivers 中查询匹配的静态注册广播接收器 final List&lt;ResolveInfo&gt; result = mReceivers.queryIntent( intent, resolvedType, flags, userId); return applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, callingUid, userId); &#125; final PackageParser.Package pkg = mPackages.get(pkgName); if (pkg != null) &#123; // 从 mReceivers 中查询匹配的静态注册广播接收器 final List&lt;ResolveInfo&gt; result=mReceivers.queryIntentForPackage( intent, resolvedType, flags, pkg.receivers, userId); return applyPostResolutionFilter(result, instantAppPkgName, allowDynamicSplits, callingUid, userId); &#125; return Collections.emptyList(); &#125;&#125;// 自定义类，根据广播 Intent ，查询匹配的 ResolveInfofinal class ActivityIntentResolver extends IntentResolver&lt; PackageParser.ActivityIntentInfo, ResolveInfo&gt; &#123; public List&lt;ResolveInfo&gt; queryIntent(Intent intent, String resolvedType, boolean defaultOnly, int userId) &#123; if (!sUserManager.exists(userId)) return null; mFlags = (defaultOnly ? PackageManager.MATCH_DEFAULT_ONLY : 0); return super.queryIntent(intent, resolvedType, defaultOnly, userId); &#125; public List&lt;ResolveInfo&gt; queryIntent(Intent intent, String resolvedType, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; mFlags = flags; return super.queryIntent(intent, resolvedType, (flags &amp; PackageManager.MATCH_DEFAULT_ONLY) != 0, userId); &#125; public List&lt;ResolveInfo&gt; queryIntentForPackage(Intent intent, String resolvedType, int flags, ArrayList&lt;PackageParser.Activity&gt; packageActivities, int userId) &#123;...&#125; ...&#125; protected-broadcast 受保护的广播在 AndroidManifest.xml 中声明的 protected-broadcast 受保护广播 ACTION ，表示它们只能被有系统权限的广播接收器接收。在 PackageParser.Package.protectedBroadcasts 中保存，同时 PMS.mProtectedBroadcasts 会做系统全局保存， AMS 发送广播时会查询 PMS 做权限检查，如果没有权限则不会分发给该广播接收器。 动态注册/取消广播接收器流程分析流程图 动态注册 ContextImpl/LoadedApk动态注册时统一由 ContextImpl.registerReceiverInternal 向系统注册广播接收器。这个过程主要功能： 将 BroadCastReceiver 转换为对应的 IIntentReceiver ，用于跨进程通信 LoadedApk.getReceiverDispatcher 会将当前 Apk 注册的每个广播接收器保存到 mReceivers 中；如果是有序广播的回调广播接收器则不保存 向 AMS 中注册 IIntentReceiver 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// LoadedApk.java private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context, int flags) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; // BroadCastReceiver 转换为 IIntentReceiver rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher(receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; // 向 AMS 中注册 IIntentReceiver final Intent intent = ActivityManager.getService() .registerReceiver(mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId, flags); if (intent != null) &#123; intent.setExtrasClassLoader(getClassLoader()); intent.prepareToEnterProcess(); &#125; return intent; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;// LoadedApk.javapublic IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; if (rd == null) &#123; // 新建 ReceiverDispatcher 对象 rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; // 注册的广播接收器都保存到 mReceivers 中 // 如果是有序广播的回调广播接收器则不保存 if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125;&#125; 动态注册 AMS广播接收器动态注册时，广播接收器的相关信息保存在 AMS 中： mRegisteredReceivers保存所有动态注册的广播接收器对应的 ReceiverList 。mRegisteredReceivers 并没有太多作用，注册保存信息，取消注册时从这里删除。 mReceiverResolver保存所有所有动态注册广播接收器时对应的广播过滤器 BroadcastFilter 。广播发送过程中，会根据 Intent 从 mReceiverResolver 中查找 BroadcastFilter ；每个 BroadcastFilter 都保存了它所属的 ReceiverList ；而 ReceiverList 保存了 BroadCastReceiver 对应的 IIntentReceiver ；动态注册广播接收器事件处理时，使用 IIntentReceiver 处理 onReceive 回调。 主要功能： 获取动态注册广播接收器，应用进程相关信息 处理粘性广播事件 BroadCastReceiver 生成对应的 ReceiverList 和 BroadcastFilter 将 ReceiverList 添加到 mRegisteredReceivers 中 将 BroadcastFilter 添加到 mReceiverResolver 中 1234567891011121314151617181920212223242526272829303132333435363738394041// ActivityManagerService.javapublic Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId, int flags) &#123; enforceNotIsolatedCaller("registerReceiver"); ArrayList&lt;Intent&gt; stickyIntents = null; ProcessRecord callerApp = null; ... int callingUid; int callingPid; ... Intent sticky = allSticky != null ? allSticky.get(0) : null; ... synchronized (this) &#123; if (callerApp != null &amp;&amp; (callerApp.thread == null || callerApp.thread.asBinder() != caller.asBinder())) &#123; // Original caller already died return null; &#125; ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); if (rl == null) &#123; rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver); if (rl.app != null) &#123; rl.app.receivers.add(rl); &#125; else &#123; ... &#125; mRegisteredReceivers.put(receiver.asBinder(), rl); &#125; else ... BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId, instantApp, visibleToInstantApps); rl.add(bf); ... mReceiverResolver.addFilter(bf); ... return sticky; &#125;&#125; 取消注册 ContextImpl/LoadedApk取消注册时统一由 ContextImpl.unregisterReceiver 向系统取消注册广播接收器。这个过程主要功能： 将 BroadCastReceiver 转换为对应的 IIntentReceiver ，用于跨进程通信 LoadedApk.forgetReceiverDispatcher 会将当前需要取消注册的广播接收器，从 mReceivers 中移除；如果需要调试，会同时将它加入 mUnregisteredReceivers 中 向 AMS 中取消注册 IIntentReceiver 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Overridepublic void unregisterReceiver(BroadcastReceiver receiver) &#123; if (mPackageInfo != null) &#123; // BroadCastReceiver 转换为 IIntentReceiver // 在 LoadedApk 中从 mReceivers 中移除 IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher( getOuterContext(), receiver); try &#123; // 向 AMS 中取消广播接收器的注册 ActivityManager.getService().unregisterReceiver(rd); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; else &#123; throw new RuntimeException("Not supported in system context"); &#125;&#125;public IIntentReceiver forgetReceiverDispatcher(Context context, BroadcastReceiver r) &#123; synchronized (mReceivers) &#123; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = mReceivers.get(context); LoadedApk.ReceiverDispatcher rd = null; if (map != null) &#123; rd = map.get(r); if (rd != null) &#123; map.remove(r); // 从 mReceivers 中移除 if (map.size() == 0) &#123; mReceivers.remove(context); &#125; if (r.getDebugUnregister()) &#123; ... // 如果需要调试，存入 mUnregisteredReceivers 中 mUnregisteredReceivers.put(context, holder); ... &#125; rd.mForgotten = true; return rd.getIIntentReceiver(); &#125; &#125; ... &#125;&#125; 取消注册 AMS广播接收器取消注册时，从 AMS 中移除对应的数据，主要功能为： 从 mRegisteredReceivers 中移除 ReceiverList 从 mReceiverResolver 中移除 ReceiverList 中所有的 BroadcastFilter 如果还存在没有处理完的广播接收器，触发 BroadcastQueue.processNextBroadcast 继续处理 1234567891011121314151617181920212223242526272829303132333435363738394041// ActivityManagerService.javapublic void unregisterReceiver(IIntentReceiver receiver) &#123; ... final long origId = Binder.clearCallingIdentity(); try &#123; boolean doTrim = false; synchronized(this) &#123; ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder()); if (rl != null) &#123; final BroadcastRecord r = rl.curBroadcast; // 还存在没有处理完的广播接收器 if (r != null &amp;&amp; r == r.queue.getMatchingOrderedReceiver(r)) &#123; final boolean doNext = r.queue.finishReceiverLocked( r, r.resultCode, r.resultData, r.resultExtras, r.resultAbort, false); if (doNext) &#123; doTrim = true; r.queue.processNextBroadcast(false); &#125; &#125; if (rl.app != null) &#123; rl.app.receivers.remove(rl); &#125; // 移除当前广播接收器对应的所有信息 removeReceiverLocked(rl); ... &#125; &#125; ... &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125;// 移除当前广播接收器对应的所有信息void removeReceiverLocked(ReceiverList rl) &#123; mRegisteredReceivers.remove(rl.receiver.asBinder()); for (int i = rl.size() - 1; i &gt;= 0; i--) &#123; mReceiverResolver.removeFilter(rl.get(i)); &#125;&#125; 广播发送流程分析先回顾下基础概念，广播的类型： 普通广播：通过 sendBroadcast 发送的广播 有序广播：通过 sendOrderedBroadcast 发送的广播 系统对广播响应并处理的方式分为： 并行处理广播存储位置：BroadcastQueue.mParallelBroadcasts ；并行处理的广播为：普通广播，且它对应的广播接收器一定是动态注册的。 有序处理广播存储位置：BroadcastQueue.mOrderedBroadcasts ；有序处理的广播为：有序广播和普通广播（对应的广播接收器是静态注册的）。mOrderedBroadcasts 中处理普通广播（对应的广播接收器时静态注册的）非常费解，初看代码时很容易搞错，存储逻辑是在 AMS 调度时决定的。 流程图 广播发送过程，从广播发送所在应用进程进入系统进程 Context -&gt; AMS -&gt; BroadcastQueue 广播发送过程，从系统进程进入广播接收器应用所在进程 BroadcastQueue -&gt; ActivityThread -&gt; BroadCastReceiver.onReceive ContextImpl.sendBroadcast 发送普通广播ContextImpl 对于普通广播并不做特别处理，比较简单，直接将 Intent 和广播发送应用相关信息传递给 AMS ，进入系统来处理分发流程。 123456789101112131415@Overridepublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType=intent.resolveTypeIfNeeded(getContentResolver()); try &#123; intent.prepareToLeaveProcess(this); // 进入 AMS 处理具体的广播发送流程 ActivityManager.getService().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; ContextImpl.sendOrderedBroadcast 发送有序广播有序广播支持广播接收器回调，所以进入系统 AMS 处理前，会先将 BroadCastReceiver 转换为 IIntentReceiver ，回调广播接收器在 LoadedApk 中不做保存。 123456789101112131415161718192021222324252627282930313233343536373839void sendOrderedBroadcast(Intent intent, String receiverPermission, int appOp, BroadcastReceiver resultReceiver, Handler scheduler, int initialCode, String initialData, Bundle initialExtras, Bundle options) &#123; warnIfCallingFromSystemProcess(); IIntentReceiver rd = null; if (resultReceiver != null) &#123; if (mPackageInfo != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; // 将 BroadCastReceiver 转换为 IIntentReceiver // 回调广播接收器在 LoadedApk 中不做保存 rd = mPackageInfo.getReceiverDispatcher( resultReceiver, getOuterContext(), scheduler, mMainThread.getInstrumentation(), false); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( resultReceiver, getOuterContext(), scheduler, null, false).getIIntentReceiver(); &#125; &#125; String resolvedType=intent.resolveTypeIfNeeded(getContentResolver()); String[] receiverPermissions = receiverPermission == null ? null : new String[] &#123;receiverPermission&#125;; try &#123; intent.prepareToLeaveProcess(this); // 进入 AMS 处理具体的有序广播发送流程 ActivityManager.getService().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, rd, initialCode, initialData, initialExtras, receiverPermissions, appOp, options, true, false, getUserId()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125; AMS.broadcastIntentLocked 广播发送解析不管是普通广播还是有序广播，在 AMS 中都是进入了 broadcastIntentLocked(Intent, ...) 方法来调度处理的。这个方法中会处理很多系统级广播，比如 Intent.ACTION_PACKAGE_ADDED, Intent.ACTION_PACKAGE_REMOVED, Intent.ACTION_TIME_CHANGED 等等，在 AMS 做预处理或者直接处理完毕。该方法主要功能： 各种权限检查 系统广播处理 收集该广播匹配的所有动态注册广播接收器 收集该广播匹配的所有静态注册广播接收器 将广播对应的广播记录存入广播队列（如果是有序广播，会按照优先级先排序再存入） 代码分析（代码有简化和调整位置）如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// ActivityManagerService.javafinal int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) &#123; intent = new Intent(intent); // 各种权限检查，系统广播处理 ... List receivers = null; List&lt;BroadcastFilter&gt; registeredReceivers = null; // 1. 查询广播对应的所有静态注册的广播接收器 receivers = collectReceiverComponents(intent, resolvedType, callingUid, users); ... // 2. 查询广播对应的所有动态注册的广播接收器 registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false /*defaultOnly*/, users[i]); int NR = registeredReceivers != null ? registeredReceivers.size() : 0; // 3. 普通广播对应的动态注册广播接收器列表，新建广播记录对象 // 加入到 mParallelBroadcasts 广播队列 if (!ordered &amp;&amp; NR &gt; 0) &#123; ... final BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, callerInstantApp, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r); final boolean replaced = replacePending &amp;&amp; (queue.replaceParallelBroadcastLocked(r) != null); // Note: We assume resultTo is null for non-ordered broadcasts. if (!replaced) &#123; // 加入到 mParallelBroadcasts 广播队列 queue.enqueueParallelBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; registeredReceivers = null; NR = 0; &#125; // 其他情况时，合并两个广播接收器列表： // 即有序广播对应的动态注册广播接收器， // 和普通广播对应的静态注册广播接收器。 // Merge into one list. int ir = 0; // 有序广播对应的广播接收器排序 ... while (ir &lt; NR) &#123; if (receivers == null) &#123; receivers = new ArrayList(); &#125; receivers.add(registeredReceivers.get(ir)); ir++; &#125; // resultTo 是有序广播的回调广播接收器 // 4. 将合并的广播接收器列表，新建广播记录对象， // 加入到 mOrderedBroadcasts 广播队列 if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, callerInstantApp, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); ... // 加入到 mOrderedBroadcasts 广播队列 queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125; ... return ActivityManager.BROADCAST_SUCCESS;&#125; BroadcastQueue.processNextBroadcast 广播发送解析不管是并行处理还是有序处理，在 BroadcastQueue 中都是进入 processNextBroadcast(boolean fromMsg) 方法处理的。该方法主要功能： 并行处理的广播接收器，一次全部处理完 有序广播处理完毕后，处理回调广播接收器 各种权限检查 调用 deliverToRegisteredReceiverLocked 处理所有动态注册的广播接收器 如果是静态广播接收器，开启对应的应用进程 调用 processCurBroadcastLocked 处理所有静态注册的广播接收器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// BroadcastQueue.javafinal void processNextBroadcast(boolean fromMsg) &#123; BroadcastRecord r = null; ... // 1. mParallelBroadcasts 广播队列中，处理普通广播对应的动态注册的广播接收器 // 特点是：一次调用整个队列全部处理完 while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0); ... final int N = r.receivers.size(); for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i); ... // 动态注册的广播接收器： target 可以直接强制转换为 BroadcastFilter deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false, i); &#125; ... &#125; // mOrderedBroadcasts 队列中，找到下一个需要处理的广播接收器 boolean looped = false; do &#123; // mOrderedBroadcasts 广播队列处理完毕退出 if (mOrderedBroadcasts.size() == 0) &#123; ... return; &#125; r = mOrderedBroadcasts.get(0); boolean forceReceive = false; int numReceivers = (r.receivers != null) ? r.receivers.size() : 0; ... if (r.receivers == null || r.nextReceiver &gt;= numReceivers || r.resultAbort || forceReceive) &#123; // No more receivers for this broadcast! Send the final // result if requested... // 有序广播全部处理完毕，执行回调 BroadCastReceiver if (r.resultTo != null) &#123; try &#123; if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, "Finishing broadcast [" + mQueueName + "] " + r.intent.getAction() + " app=" + r.callerApp); performReceiveLocked(r.callerApp, r.resultTo, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, false, false, r.userId); r.resultTo = null; &#125; catch (RemoteException e) &#123; ... &#125; &#125; ... if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Finished with ordered broadcast " + r); ... mOrderedBroadcasts.remove(0); r = null; looped = true; continue; &#125; &#125; while (r == null); // Get the next receiver... int recIdx = r.nextReceiver++; ... final Object nextReceiver = r.receivers.get(recIdx); // 2. mOrderedBroadcasts 队列中，下一个广播接收器是动态注册的 // 类型检查，它对应的一定是有序广播，处理完后返回 if (nextReceiver instanceof BroadcastFilter) &#123; // Simple case: this is a registered receiver who gets // a direct call. BroadcastFilter filter = (BroadcastFilter)nextReceiver; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Delivering ordered [" + mQueueName + "] to registered " + filter + ": " + r); deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx); ... return; &#125; // 3. mOrderedBroadcasts 队列中，下一个广播接收器是静态注册的 // Hard case: need to instantiate the receiver, possibly // starting its application process to host it. ResolveInfo info = (ResolveInfo)nextReceiver; ComponentName component = new ComponentName( info.activityInfo.applicationInfo.packageName, info.activityInfo.name); ... String targetProcess = info.activityInfo.processName; ProcessRecord app = mService.getProcessRecordLocked(targetProcess, info.activityInfo.applicationInfo.uid, false); ... // Is this receiver's application already running? // 3.1 如果对应 app 已经在运行，处理广播接收器事件 if (app != null &amp;&amp; app.thread != null &amp;&amp; !app.killed) &#123; try &#123; app.addPackage(info.activityInfo.packageName, info.activityInfo.applicationInfo.versionCode, mService.mProcessStats); processCurBroadcastLocked(r, app); return; &#125; catch (RuntimeException e) &#123; ... return; &#125; &#125; // Not running--get it started, to be executed when the app comes up. // 3.2 如果 app 没有运行，启动该应用进程 if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Need to start app [" + mQueueName + "] " + targetProcess + " for broadcast " + r); if ((r.curApp=mService.startProcessLocked(targetProcess, info.activityInfo.applicationInfo, true, r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND, "broadcast", r.curComponent, (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0, false, false)) == null) &#123; // 启动失败 ... return; &#125; // 3.2 将广播设置为 pending 状态，等到应用启动后 // AMS 会调用 sendPendingBroadcastsLocked 执行该广播接收器事件 mPendingBroadcast = r; mPendingBroadcastRecvIndex = recIdx; ...&#125; deliverToRegisteredReceiverLocked 方法解析BroadcastQueue.deliverToRegisteredReceiverLocked 专门用来处理动态注册的广播接收器，最终是在 performReceiveLocked 方法中调用了 ActivityThread.scheduleRegisteredReceiver ，进入广播接收器所在进程处理具体的回调 onReceive。这个阶段主要功能： 各种权限检查 添加完善广播记录 跨进程进入广播接收器所在应用进程，调用 onReceive 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void deliverToRegisteredReceiverLocked(BroadcastRecord r, BroadcastFilter filter, boolean ordered, int index) &#123; boolean skip = false; // 各种权限检查等等 ... // 如果忽略该广播直接返回 if (skip) &#123; r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED; return; &#125; // If this is not being sent as an ordered broadcast, then we // don't want to touch the fields that keep track of the current // state of ordered broadcasts. // 有序广播相关处理 if (ordered) &#123; r.receiver = filter.receiverList.receiver.asBinder(); r.curFilter = filter; filter.receiverList.curBroadcast = r; r.state = BroadcastRecord.CALL_IN_RECEIVE; if (filter.receiverList.app != null) &#123; // Bump hosting application to no longer be in background // scheduling class. Note that we can't do that if there // isn't an app... but we can only be in that case for // things that directly call the IActivityManager API, which // are already core system stuff so don't matter for this. r.curApp = filter.receiverList.app; filter.receiverList.app.curReceivers.add(r); mService.updateOomAdjLocked(r.curApp, true); &#125; &#125; try &#123; if (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST, "Delivering to " + filter + " : " + r); if (filter.receiverList.app != null &amp;&amp; filter.receiverList.app.inFullBackup) &#123; ... &#125; else &#123; // 处理动态注册的广播接收器 performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver, new Intent(r.intent), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.initialSticky, r.userId); &#125; if (ordered) &#123; r.state = BroadcastRecord.CALL_DONE_RECEIVE; &#125; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Failure sending broadcast " + r.intent, e); ... &#125;&#125;void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously // using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. try &#123; // 跨进程通信，进入应用所在进程处理动态注册的广播接收器 app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; catch (RemoteException ex) &#123; ... &#125; &#125; else &#123; // Application has died. Receiver doesn't exist. throw new RemoteException("app.thread must not be null"); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125;&#125; ActivityThread.scheduleRegisteredReceiver 方法解析每个应用的主线程中 ActivityThread.scheduleRegisteredReceiver 来执行广播处理事件，performReceive 对应的是 LoadedApk.ReceiverDispatcher.InnerReceiver.performReceive 方法。 12345678public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125; processCurBroadcastLocked 方法解析BroadcastQueue.processCurBroadcastLocked 专门处理静态注册的广播接收器。该方法主要功能： 将 BroadCastReceiver 子类存储到 intent 中 跨进程进入静态广播接收器所在进程，通过反射调用 onReceive 123456789101112131415161718192021222324252627282930313233343536private final void processCurBroadcastLocked(BroadcastRecord r, ProcessRecord app) throws RemoteException &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Process cur broadcast " + r + " for app " + app); ... r.receiver = app.thread.asBinder(); r.curApp = app; app.curReceivers.add(r); app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER); mService.updateLruProcessLocked(app, false, null); mService.updateOomAdjLocked(); // Tell the application to launch this receiver. // 将 BroadCastReceiver 子类存储到 intent 中 r.intent.setComponent(r.curComponent); boolean started = false; try &#123; ... // 跨进程通信，进入应用所在进程处理静态注册的广播接收器 app.thread.scheduleReceiver(new Intent(r.intent), r.curReceiver, mService.compatibilityInfoForPackageLocked( r.curReceiver.applicationInfo), r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId, app.repProcState); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Process cur broadcast " + r + " DELIVERED for app " + app); started = true; &#125; finally &#123; if (!started) &#123; ... &#125; &#125;&#125; ActivityThread.scheduleReceiver 方法解析ActivityThread.scheduleReceiver 处理静态注册的广播接收器，从 intent 中获取具体的广播接收器子类组件名，在 handleReceiver 中使用反射技术生成对应的实例对象，并调用其 onReceive 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final void scheduleReceiver(Intent intent, ActivityInfo info, CompatibilityInfo compatInfo, int resultCode, String data, Bundle extras, boolean sync, int sendingUser, int processState)&#123; updateProcessState(processState, false); // 新建 ReceiverData 对象 ReceiverData r = new ReceiverData(intent, resultCode, data, extras, sync, false, mAppThread.asBinder(), sendingUser); r.info = info; r.compatInfo = compatInfo; sendMessage(H.RECEIVER, r);&#125;private void handleReceiver(ReceiverData data) &#123; ... // 从 intent 中取出 BroadCastReceiver 子类的组件名 String component = data.intent.getComponent().getClassName(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); IActivityManager mgr = ActivityManager.getService(); Application app; BroadcastReceiver receiver; ContextImpl context; try &#123; app = packageInfo.makeApplication(false, mInstrumentation); context = (ContextImpl) app.getBaseContext(); if (data.info.splitName != null) &#123; context = (ContextImpl) context. createContextForSplit(data.info.splitName); &#125; // 反射，生成对应的 BroadCastReceiver 子类实例对象 java.lang.ClassLoader cl = context.getClassLoader(); data.intent.setExtrasClassLoader(cl); data.intent.prepareToEnterProcess(); data.setExtrasClassLoader(cl); receiver = (BroadcastReceiver)cl.loadClass(component) .newInstance(); &#125; catch (Exception e) &#123; if (DEBUG_BROADCAST) Slog.i(...); data.sendFinished(mgr); throw new RuntimeException(...); &#125; try &#123; ... // 调用 onReceive 方法 sCurrentBroadcastIntent.set(data.intent); receiver.setPendingResult(data); receiver.onReceive(context.getReceiverRestrictedContext(), data.intent); &#125; catch (Exception e) &#123; if (DEBUG_BROADCAST) Slog.i(...); data.sendFinished(mgr); if (!mInstrumentation.onException(receiver, e)) &#123; throw new RuntimeException(...); &#125; &#125; finally &#123; sCurrentBroadcastIntent.set(null); &#125; if (receiver.getPendingResult() != null) &#123; data.finish(); &#125;&#125; AMS.finishReceiver 结束广播所有的广播接收器处理完毕后，最终会调用系统 ActivityManagerService.finishReceiver 结束整个流程。结束流程前会再次检查确认，是否还有广播接收器没有处理完（静态注册的广播接收器，如果应用没有启动，会先启动应用进程），存在的话就触发 BroadcastQueue.processNextBroadcast 继续分发。 12345678910111213141516171819202122232425262728293031// ActivityManagerService.javapublic void finishReceiver(IBinder who, int resultCode, String resultData, Bundle resultExtras, boolean resultAbort, int flags) &#123; ... final long origId = Binder.clearCallingIdentity(); try &#123; boolean doNext = false; BroadcastRecord r; // 再次检查，如果还存在没有处理完的广播接收器 // 触发 processNextBroadcast 继续分发广播 synchronized(this) &#123; BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != 0 ? mFgBroadcastQueue : mBgBroadcastQueue; r = queue.getMatchingOrderedReceiver(who); if (r != null) &#123; doNext = r.queue.finishReceiverLocked(r, resultCode, resultData, resultExtras, resultAbort, true); &#125; &#125; if (doNext) &#123; r.queue.processNextBroadcast(false); &#125; trimApplications(); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; 广播 ANRprocessNextBroadcast 中可以看到，广播的 ANR 只会出现在有序处理的广播队列 mOrderedBroadcasts 中，也就是普通广播匹配的动态注册的广播接收器不会出现 ANR 。 setBroadcastTimeoutLocked ：设置广播超时延时消息 broadcastTimeoutLocked ：当广播接收者等待时间过长，触发 ANR 机制 cancelBroadcastTimeoutLocked ：当广播正常执行完毕清除 超时时间计算方式：从队列中取出有效广播开始计时，直到所有的广播接收器处理完毕，才取消计时。示例：发送一个有序广播，AndroidManifest.xml 中静态注册的广播接收器和一个动态注册的广播接收器都能匹配到，同时有序广播带有回调广播接收器，也就是说该广播一共会有三个 BroadCastReceiver.onReceive 响应处理。看对应的 Log 文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1. AMS.broadcastIntent 发送广播06-17*.163: D/XMT(1485): ***********AMS: broadcastIntent##########06-17*.163: V/ActivityManager(1485): Broadcast: Intent &#123; act=broadcast.service.order flg=0x10 (has extras) &#125; ordered=true userid=006-17*.163: V/ActivityManager(1485): Enqueueing broadcast: broadcast.service.order replacePending=false// 2. 广播是后台广播06-17*.163: I/ActivityManager(1485): Broadcast intent Intent &#123; act=broadcast.service.order flg=0x10 (has extras) &#125; on background queue// 3. 存入 BroadcastQueue.mOrderedBroadcasts 中06-17*.163: V/ActivityManager(1485): Enqueueing ordered broadcast BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125;: prev had 006-17*.163: I/ActivityManager(1485): Enqueueing broadcast broadcast.service.order06-17*.164: V/BroadcastQueue(1485): Schedule broadcasts [background]: current=false06-17*.164: V/BroadcastQueue(1485): Received BROADCAST_INTENT_MSG// 4. 进入 BroadcastQueue.processNextBroadcast 处理具体的广播， mOrderedBroadcasts 中只有一个广播06-17*.164: V/BroadcastQueue(1485): processNextBroadcast [background]: 0 parallel broadcasts, 1 ordered broadcasts// 5. 从 mOrderedBroadcasts 中取出有效广播 06-17*.164: V/BroadcastQueue(1485): Processing ordered broadcast [background] BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125;// 6. 有序处理广播 ANR 开始计时06-17*.164: V/BroadcastQueue(1485): Submitting BROADCAST_TIMEOUT_MSG [background] for BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125; at 40095097// 7. deliverToRegisteredReceiverLocked 开始处理动态注册的广播接收器06-17*.164: V/BroadcastQueue(1485): Delivering ordered [background] to registered BroadcastFilter&#123;d73ca43 u0 ReceiverList&#123;a3cf3f2 9397 com.ymzs.androidbasicknowledge:broadcast/10076/u0 remote:550afd&#125;&#125;: BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125;06-17*.165: I/BroadcastQueue(1485): Delivering to BroadcastFilter&#123;d73ca43 u0 ReceiverList&#123;a3cf3f2 9397 com.ymzs.androidbasicknowledge:broadcast/10076/u0 remote:550afd&#125;&#125; : BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125;// 8. 动态注册的广播接收器响应 onReceive06-17*.168: D/XMT:BroadcastService(9397): mActionOrderBroadcastReceiver: onReceive = order// 9. 动态注册广播接收器响应完毕后，调用 finishReceiver 结束广播流程06-17*.169: V/ActivityManager(1485): Finish receiver: android.os.BinderProxy@550afd// 10. 结束广播流程时，发现 mOrderedBroadcasts 中还有广播没有处理完毕// 触发 processNextBroadcast 继续分发广播06-17*.169: V/BroadcastQueue(1485): processNextBroadcast [background]: 0 parallel broadcasts, 1 ordered broadcasts// 11. processCurBroadcastLocked 开始处理静态注册的广播接收器06-17*.169: V/BroadcastQueue(1485): Process cur broadcast BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125; for app ProcessRecord&#123;64ad616 9368:com.ymzs.androidbasicknowledge/u0a76&#125;06-17*.170: V/BroadcastQueue(1485): Delivering to component ComponentInfo&#123;com.ymzs.androidbasicknowledge/com.ymzs.androidbasicknowledge.ipc.BroadcastReceiverMy&#125;: BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125;06-17*.171: V/BroadcastQueue(1485): Process cur broadcast BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125; DELIVERED for app ProcessRecord&#123;64ad616 9368:com.ymzs.androidbasicknowledge/u0a76&#125;// 12. 静态注册的广播接收器响应 onReceive06-17*.175: D/XMT:BroadcastReceiverMy(9368): BroadcastReceiverMy: onReceive = order// 13. 静态注册广播接收器响应完毕后，调用 finishReceiver 结束广播流程06-17*.176: V/ActivityManager(1485): Finish receiver: android.os.BinderProxy@61c0b97// 14. 结束广播流程时，发现 mOrderedBroadcasts 中还有广播没有处理完毕// 触发 processNextBroadcast 继续分发广播，处理有序广播的回调06-17*.176: V/BroadcastQueue(1485): processNextBroadcast [background]: 0 parallel broadcasts, 1 ordered broadcasts// 15. 有序广播的回调广播接收器响应 onReceive06-17*.176: D/XMT:BroadcastActivity(9397): mResultBroadcastReceiver: onReceive = order06-17*.176: I/BroadcastQueue(1485): Finishing broadcast [background] broadcast.service.order app=ProcessRecord&#123;64ad616 9368:com.ymzs.androidbasicknowledge/u0a76&#125;// 17. 有序处理广播 ANR 计时取消06-17*.177: V/BroadcastQueue(1485): Cancelling BROADCAST_TIMEOUT_MSG06-17*.177: V/BroadcastQueue(1485): Finished with ordered broadcast BroadcastRecord&#123;46a4f31 u0 broadcast.service.order&#125; 示例静态注册广播接收器 BroadCastReceiver 子类文件 123456789101112131415161718public class BroadcastReceiverMy extends BroadcastReceiver &#123; private static final String TAG = "XMT:BroadcastReceiverMy"; @Override public void onReceive(Context context, Intent intent) &#123; if (intent != null)&#123; // broadcast ANR 60s //Log.d(TAG, "BroadcastReceiverMy: sleep..."); //try&#123; // Thread.sleep(65*1000); //&#125; catch(Exception e)&#123;&#125; String value = intent.getStringExtra("key"); Log.d(TAG, "BroadcastReceiverMy: onReceive = " + value); &#125; &#125;&#125; 在 AndroidManifest.xml 中声明 1234567891011&lt;receiver android:name=".ipc.BroadcastReceiverMy" android:enabled="true" android:exported="true"&gt; &lt;intent-filter&gt; &lt;action android:name="broadcast.service.normal"&gt;&lt;/action&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="broadcast.service.order"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册广播接收器动态注册和取消注册广播必须在生命周期中成对出现，比如在 onCreate/onDestroy, onResume/onPause, onStart/onStop 对应出现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private boolean registeredOrder;private boolean registeredNormal;private BroadcastReceiver mActionOrderBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent != null) &#123; String value = intent.getStringExtra("key"); Log.d(TAG, "mActionOrderBroadcastReceiver: onReceive = " + value); setResultData("mActionOrderBroadcastReceiver:From Service"); &#125; &#125;&#125;;private BroadcastReceiver mActionNormalBroadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent != null)&#123; String value = intent.getStringExtra("key"); Log.d(TAG, "mActionNormalBroadcastReceiver: onReceive = " + value); &#125; &#125;&#125;;@Overridepublic void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: "); IntentFilter intentFilter = new IntentFilter(BroadcastActivity.BROADCAST_ACTION_ORDER); registerReceiver(mActionOrderBroadcastReceiver, intentFilter); registeredOrder = true; intentFilter = new IntentFilter(BroadcastActivity.BROADCAST_ACTION_NORMAL); registerReceiver(mActionNormalBroadcastReceiver, intentFilter); registeredNormal = true;&#125;@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; doLongWork(); return super.onStartCommand(intent, flags, startId);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy: "); if (registeredOrder)&#123; unregisterReceiver(mActionOrderBroadcastReceiver); mActionOrderBroadcastReceiver = null; registeredOrder = false; &#125; if (registeredNormal)&#123; unregisterReceiver(mActionNormalBroadcastReceiver); mActionNormalBroadcastReceiver = null; registeredNormal = false; &#125;&#125; 广播发送12345678910111213141516171819202122232425// 发送有序广播，并包含回调广播接收器private void sendOrderBroadcast()&#123; Log.d(TAG, "sendOrderBroadcast: "); Intent intent = new Intent(BROADCAST_ACTION_ORDER); intent.putExtra("key", "order"); sendOrderedBroadcast(intent, null, mResultBroadcastReceiver, null, 0, null, null);&#125;private BroadcastReceiver mResultBroadcastReceiver = new BroadcastReceiver()&#123; @Override public void onReceive(Context context, Intent intent) &#123; String result = getResultData(); mTvResultReceiver.setText(result); &#125;&#125;;// 发送普通广播private void sendNormalBroadcast()&#123; Log.d(TAG, "sendNormalBroadcast: sendNormalBroadcast"); Intent intent = new Intent(BROADCAST_ACTION_NORMAL); intent.putExtra("key", "normal"); sendBroadcast(intent);&#125; 小结广播接收器静态注册过程静态注册的广播接收器，是开机时 PMS 启动后解析扫描所有包时注册的，保存在每个包的 PackageParser.Package.receivers 中，系统 PMS.mReceivers 会全局保存所有静态注册的广播接收器。 AMS 中并不会保存静态注册的广播接收器信息，而是直接向 PMS 中查询。 AMS 中存储的广播相关信息 广播队列：前台广播队列 mFgBroadcastQueue 和后台广播队列 mBgBroadcastQueue 广播接收器哈希表 mRegisteredReceivers：所有动态注册的广播接收器 广播过滤器符号表 mReceiverResolver：所有动态注册的广播过滤器 123456BroadcastQueue mFgBroadcastQueue;BroadcastQueue mBgBroadcastQueue;final HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = new HashMap&lt;&gt;();final IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver = new IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt;() &#123;...&#125; 权限检查广播在发送的过程中，会有大量的权限检查，比如 AMS.broadcastIntentLocked, BroadcastQueue.processNextBroadcast, BroadcastQueue.deliverToRegisteredReceiverLocked 都会反复做权限检查。 广播接收器优先级数字越大表示优先级越高，接收有序广播时优先级高的先接收到。 静态注册广播接收器 12345&lt;receiver android:name=".smsReceiver"&gt; &lt;intent-filter android:priority="1000"&gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 动态注册广播接收器 1234IntentFilter intentFilter = new IntentFilter( "android.provider.Telephony.SMS_RECEIVED");intentFilter.setPriority(1000);registerReceiver(broadcastReceiver, intentFilter); 广播接收器响应广播接收器回调 onReceive 触发响应的位置 静态注册的广播接收器ActivityThread.handleReceiver 中使用反射，触发 onReceive 方法。静态注册的广播接收器并不会对应 ReceiverDispatcher 。 动态注册的广播接收器动态注册的广播接收器对应一个 ReceiverDispatcher ，通过它找到 LoadedApk.Args ，在 Runnable.run 中触发 onReceive 方法。 前后台广播及 ANR广播发送时，通过 Intent 是否设置 FLAG_RECEIVER_FOREGROUND 来区分，如果设置了表示前台广播，对应 ANR 超时为 10 秒；默认为后台广播，对应超时为 60 秒。广播的 ANR 是会出现在有序处理广播队列中，在 BroadcastQueue.processNextBroadcast 中计算的，从有序队列 mOrderedBroadcasts 取出有效广播后开始计时，直到有序广播匹配的所有广播接收器包括有序广播的回调广播接收器，全部处理完毕才会取消计时。具体可以看“广播 ANR” 这一节的 Log 分析。注意：如果广播接收器的 onReceive 是在主线程中处理，同时还会受到 Activity 超时 5 秒产生 ANR 的限制！也就是说等不到 60 秒，可能 Activity 就出现 ANR 了。如果 onReceive 有耗时任务，请新开线程处理。 有序广播 可以被终止优先级高的广播接收者接收到后，可以通过 abortBroadcast 来终止继续向下传递广播。 可以有回调 BroadCastReceiver广播接收器回调，发送有序广播时，可以同时指定一个 BroadCastReceiver 回调；当有序广播全部被执行完后，会触发这个回调。也就是说有序广播，在顺序接收过程中，每个广播接收者都可以在回调 BroadCastReceiver 中向发送者写回数据。 广播发送过程 整个广播发送及响应过程都是异步的，大量使用 Handler 异步处理 源码中可以看到大量 synchronized 关键字，而且大多使用 AMS 作为对象锁，所以系统处理广播的过程有大量同步过程 并行处理和有序处理 mParallelBroadcasts 广播队列存储的广播为普通广播（对应的广播接收器是动态注册的），该队列的所有广播都是并行处理的，在 processNextBroadcast 中一次全部处理完。 mOrderedBroadcasts 广播队列存储的广播为有序广播和普通广播（对应的广播接收器时静态注册的）该队列的所有广播都是有序处理的，在 processNextBroadcast 中从队列中取出一个有效广播，处理完一个广播接收器后，会触发 AMS.finishReceiver 结束整个广播过程。但是 finishReceiver 方法每次都会调用 BroadcastQueue.finishReceiverLocked 检查 mOrderedBroadcasts 是否全部处理完毕。如果没有，调用 processNextBroadcast 继续从有序队列中取出广播处理。具体可以参考“广播 ANR” 中的 Log 分析。 进程和线程间交互 Handler 线程间异步通信 LocalBroadcastManager 同一个应用相同进程内异步通信，本质上仍然是通过 Handler 实现的 BroadCastReceiver 进程间异步通信，不同应用不同进程间的通信，通过系统广播总线统一管理广播，用户使用很简单方便 Messenger 进程间异步通信，相同应用不同进程间的通信，常用于 Activity, Service 不在同一进程时使用 AIDL 进程间同步通信 参考文档 Android developer: Broadcast BroadcastReceiver API 老罗：广播机制 Broadcast Android广播之发送广播的源码分析 Android广播之注册广播源码分析 gityuan: Android Broadcast广播机制分析 gityuan: BroadcastRecord Android中的广播Broadcast详解 品茗论道说广播-上 品茗论道说广播-下 Android四大组件：BroadcastReceiver protected-broadcast 的一些细节]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FourComponents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件 -- Service]]></title>
    <url>%2F2017%2F11%2F27%2F0020-service%2F</url>
    <content type="text"><![CDATA[基础概念Service 是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务可由其他应用组件启动，而且即使用户切换到其他应用，服务仍将在后台继续运行。此外组件可以绑定到服务，以与之进行交互，甚至是执行进程间通信 (IPC)。例如，服务可以处理网络事务、播放音乐，执行文件 I/O 或与内容提供程序交互，而所有这一切均可在后台进行。 选择使用服务还是线程简单地说，服务是一种即使用户未与应用交互也可在后台运行的组件，但是它仍会在应用的主线程中运行。如需在主线程外部执行工作，不过只是在用户正在与应用交互时才有此需要，则应创建新线程而非服务。 注意：Service 和 Activity 都属于 UI 主线程，所以在 Service 中同样需要开新线程来执行耗时操作 两种启动方式 启动服务 startService 组件间无交互：启动服务时，服务即可在后台无限期运行，即使启动服务的组件已被销毁也不受影响。已启动的服务通常是执行单一操作，而且不会将结果返回给调用方。例如它可能通过网络下载或上传文件，操作完成后服务会自行停止运行。 绑定服务 bindService 组件间有交互：绑定到服务时，服务提供了一个客户端-服务器接口，允许组件与服务进行交互、发送请求、获取结果，甚至是利用进程间通信 ( IPC )跨进程执行这些操作。仅当与另一个应用组件绑定时，绑定服务才会运行。多个组件可以同时绑定到该服务，但全部取消绑定后，该服务即会被销毁。 实际使用中，大量会出现两种启动方式同时使用，既希望服务不受影响的在后台运行，又需要达到组件交互的目的。 清单属性 android:exported这个属性用于指示该服务是否能够被其他应用程序组件调用或跟它交互。如果设置为true，则能够被调用或交互。设置为 false，只有同一个应用程序的组件或带有相同用户 ID 的应用程序才能启动或绑定该服务 android:enabled是否可以被系统实例化，默认为 true，表示服务能被激活，否则不会激活 android:process是否需要在单独的进程中运行，格式： android:process=”:remote”： 后面表示新的进程名，为包名加上冒号后值，如：AppPackageName:remote android:name服务的名称 示例： 123&lt;service android:name=".MyIntentService" android:exported="false"&gt;&lt;/service&gt; 启动服务 startService重写回调 onStartCommand通过调用 startService() 启动服务时，系统将调用此方法。源码：public int onStartCommand(Intent intent, int flags, int startId) {...}其中 startId 为该服务的唯一标记符 返回值在 Service 被意外 Kill 掉后是否重启，代表的含义分别为： START_NOT_STICKY则除非有挂起 Intent 要传递，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务 START_STICKY会重建服务，并调用 onStartCommand()，传递一个空 Intent。如果有挂起 Intent 要启动服务，才会传递这些 Intent，否则为空。适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务） START_REDELIVER_INTENT会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。任何挂起 Intent 均依次传递。这适用于主动执行应该立即恢复的作业（例如下载文件）的服务等 START_STICKY_COMPATIBILITYSTART_STICKY 的兼容版本，但不保证服务一定能重启 显示启动和停止服务显示启动和停止服务都是通过 Intent 来实现，指定具体的服务类名 1234567// 启动服务Intent intent = new Intent(ShowServiceActivity.this, StartService.class);startService(intent);// 停止服务Intent intent = new Intent(ShowServiceActivity.this, StartService.class);stopService(intent); 启动服务，一般是在服务中新建工作线程做耗时操作，操作完成后结束服务。因为组件间生命周期相互不影响，为了避免浪费系统资源和消耗电池电量，应用必须在耗时工作完成之后停止其服务，所以在服务中直接结束会更合适。源码： 123public void stopSelf();// startId 为 onStartCommnd 中指定的服务 Idpublic final boolean stopSelfResult(int startId) &#123;...&#125; 示例分析启动服务后，在服务中新建线程执行耗时操作，耗时执行完后关闭服务 123456789101112131415161718192021222324252627282930private class MyRunnable implements Runnable &#123; // 服务的 Id private int mStartId; public MyRunnable(int startId)&#123; mStartId = startId; &#125; @Override public void run() &#123; try &#123; Log.d(TAG, "run: "); Thread.sleep(3000); Log.d(TAG, "run: stopSelfResult.mStartId = " + mStartId); // 耗时操作之后，结束服务 stopSelfResult(mStartId); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: flags = " + flags + ", startId = " + startId); // 新建线程执行耗时操作，并传递该服务的 Id Thread thread = new Thread(new MyRunnable(startId)); thread.start(); return super.onStartCommand(intent, flags, startId);&#125; 对应的 Log 分析： 正常流程，服务自我关闭 12345678910// 点击启动服务，服务新建线程，执行完耗时操作后主动关闭服务11:15:14.046 17723-17723/ ShowService:: onClick: button.onClick = Start Service// Activity 和 Service 都属于主线程，线程 id 相同11:15:14.063 17723-17723/ StartService:: onCreate: 11:15:14.064 17723-17723/ StartService:: onStartCommand: flags = 0, startId = 1// 线程 id 可以看出，进入后台线程运行11:15:14.066 17723-17917/ StartService:: run: 11:15:17.066 17723-17917/ StartService:: run: stopSelfResult.mStartId = 111:15:17.068 17723-17723/ StartService:: onDestroy: 11:15:20.358 17723-17723/ ShowService:: onClick: button.onClick = Stop Service 主动点击停止服务 123456789// 点击启动服务，服务新建线程，执行完耗时，点击停止服务，并没有影响后台线程继续执行11:15:34.975 17723-17723/ ShowService:: onClick: button.onClick = Start Service11:15:34.998 17723-17723/ StartService:: onCreate: 11:15:34.999 17723-17723/ StartService:: onStartCommand: flags = 0, startId = 111:15:35.003 17723-18238/ StartService:: run: 11:15:36.455 17723-17723/ ShowService:: onClick: button.onClick = Stop Service// 点击停止服务，服务销毁后 ，后台线程继续执行11:15:36.457 17723-17723/ StartService:: onDestroy: 11:15:38.004 17723-18238/ StartService:: run: stopSelfResult.mStartId = 1 连续启动服务 123456789101112131415161718192021// 连续点击三次启动服务，服务会逐个开启线程并放到后台执行，直到所有线程执行完才会停止服务// 只要服务没有停止，Id 会逐渐增加，一旦停止服务，Id 重新由 1 开始计数11:18:09.999 17723-17723/ ShowService:: onClick: button.onClick = Start Service11:18:10.011 17723-17723/ StartService:: onCreate: 11:18:10.013 17723-17723/ StartService:: onStartCommand: flags = 0, startId = 1// 后台线程 111:18:10.025 17723-20539/ StartService:: run: 11:18:10.702 17723-17723/ ShowService:: onClick: button.onClick = Start Service11:18:10.711 17723-17723/ StartService:: onStartCommand: flags = 0, startId = 2// 后台线程 2 11:18:10.713 17723-20555/ StartService:: run: 11:18:11.404 17723-17723/ ShowService:: onClick: button.onClick = Start Service11:18:11.409 17723-17723/ StartService:: onStartCommand: flags = 0, startId = 3// 后台线程 3 11:18:11.413 17723-20567/ StartService:: run: // 后台耗时逐个执行完毕11:18:13.026 17723-20539/ StartService:: run: stopSelfResult.mStartId = 111:18:13.713 17723-20555/ StartService:: run: stopSelfResult.mStartId = 211:18:14.413 17723-20567/ StartService:: run: stopSelfResult.mStartId = 3// 所有后台线程执行完后，服务才销毁11:18:14.415 17723-17723/ StartService:: onDestroy: 生命周期启动服务的生命周期：onCreate() --&gt; onStartCommand() --&gt; onDestroy() 绑定服务 bindService本地服务，扩展 Binder 类如果服务仅供本地应用使用，不需要跨进程工作，则可以实现自有 Binder 类，让客户端通过该类直接访问服务中的公共方法。只有在客户端和服务位于同一应用和进程内这一最常见的情况下方才有效。 例如，对于需要将 Activity 绑定到在后台播放音乐的自有服务的音乐应用，此方法非常有效 12345public class LocalBinder extends Binder&#123; public BindService getService()&#123; return BindService.this; &#125;&#125; 重写回调 onBind当另一个组件想通过调用 bindService() 与服务绑定（例如执行 RPC）时，系统将调用此方法。在此方法的实现中，必须通过返回 IBinder 提供一个接口，供客户端用来与服务进行通信。如果不允许绑定服务，则应返回 null。源码：public IBinder onBind(Intent intent) {...} 多个客户端可同时连接到一个服务，或者一个客户端多次连接同一个服务。不过只有在第一次绑定时，系统才会调用服务的 onBind() 方法来检索 IBinder。系统随后无需再次调用 onBind()，便可将同一 IBinder 传递至任何其他绑定的客户端，也就是onBind 只会执行一次 如本地服务中： 1234private final IBinder mBinder = new LocalBinder();public IBinder onBind(Intent intent) &#123; return mBinder;&#125; 建立连接 ServiceConnection绑定是异步的，bindService() 会立即返回，不会使 IBinder 返回客户端。要接收 IBinder 客户端必须创建一个 ServiceConnection 实例来接收。重写两个回调方法： onServiceConnected()系统会调用该方法接收服务的 onBind() 方法返回的 IBinder onServiceDisconnected()系统会在与服务的连接意外中断时（例如当服务崩溃或被终止时）调用该方法。当客户端取消绑定时，系统不会调用该方法 1234567891011121314151617private boolean mBound = false;private ServiceConnection mBindServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; // IBinder 是 Service 中 onBind 的返回值，根据这个得到 Service mBindService = ((BindService.LocalBinder)service).getService(); // 拿到 Service 后，可以调用公共方法 int randomNumber = mBindService.genRandomNumber()); mBound = true; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mBindService = null; mBound = false; &#125;&#125;; 显示绑定和解绑服务显示启动和停止服务也是通过 Intent 来实现，指定具体的服务类名 123456789// 显示绑定服务Intent intent = new Intent(ShowServiceActivity.this, StartService.class);bindService(intent, mBindServiceConnection, Context.BIND_AUTO_CREATE);// 解绑服务if(mBound) &#123; unbindService(mBindServiceConnection); mBound = false;&#125; 注意：解绑前必须要判断该服务是否已经绑定，如果服务并没有绑定就直接解绑，会抛出异常 1234510:30: 9105/com.y E/AndroidRuntime: FATAL EXCEPTION: mainProcess: com.y, PID: 9105Caused by: java.lang.IllegalArgumentException: Service not registered: com.y.ShowService$1@11bddcab` 常见 flags 的含义： BIND_AUTO_CREATE创建尚未激活的服务 BIND_NOT_FOREGROUND系统将阻止驻留该服务的进程具有前台优先级，仅在后台运行 生命周期onCreate() --&gt; onBind() --&gt; onUnBind() --&gt; onDestroy() 联合使用 start and bind service既可以后台保留服务，又可以通过 IBinder 和服务做交互 客户端12345intent.setClass(ShowService.this, StartAndBindService.class);// 显示启动服务startService(intent);// 显示绑定服务bindService(intent, mStartAndBindServiceConnection, Context.BIND_AUTO_CREATE); 服务端同时实现 onStartCommand 和 onBind 123456789101112131415161718192021// 扩展本地 Binderpublic class LocalStartAndBinder extends Binder&#123; public StartAndBindService getService()&#123; return StartAndBindService.this; &#125;&#125;// 实例化本地 Binderprivate final IBinder mBinder = new LocalStartAndBinder();// 启动服务回调@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; return super.onStartCommand(intent, flags, startId);&#125;// 绑定服务回调，并返回本地 Binder@Overridepublic IBinder onBind(Intent intent) &#123; return mBinder;&#125; Log 显示123456719:05: 8807/com.yD/StartAndBindService: onCreate: 19:05: 8807/com.yD/StartAndBindService: onStartCommand: flags = 0, startId = 119:05: 8807/com.yD/StartAndBindService: onBind: 19:05: 8807/com.yD/:ShowService:: onServiceConnected: mStartAndBindService.genRandomString = hechiffecd19:05: 8807/com.yD/StartAndBindService: onUnbind: 19:05: 8807/com.yD/StartAndBindService: onDestroy: 生命周期对比图 onUnbind 返回值对生命周期的影响如果服务没有停止，onUnbind 返回 true 时，下次再次绑定会执行 onRebind，源码：public void onRebind(Intent intent) {...} 生命周期流程对比图： 对应 Log 分析： 12345678910111213141516171819202122232425// 点击按钮启动服务16:39:14.923 20504-20504/ D/:ShowService:: onClick: button.onClick = Start Service// 创建服务16:39:14.932 20504-20504/ D/:StartAndBindService: onCreate: 16:39:14.935 20504-20504/ D/:StartAndBindService: onStartCommand: flags = 0, startId = 1// 点击按钮绑定服务16:39:15.730 20504-20504/ D/:ShowService:: onClick: button.onClick = Bind Service// 第一次绑定 onBind16:39:15.732 20504-20504/ D/:StartAndBindService: onBind: // 服务连接16:39:15.734 20504-20504/ D/:ShowService:: onServiceConnected: mStartAndBindService.genRandomString = bhahahafeh// 点击按钮解绑服务16:39:16.715 20504-20504/ D/:ShowService:: onClick: button.onClick = Unbind Service// onUnbind 返回 true16:39:16.721 20504-20504/ D/:StartAndBindService: onUnbind: // 再次点击按钮绑定服务16:39:17.846 20504-20504/ D/:ShowService:: onClick: button.onClick = Bind Service// 服务连接16:39:17.848 20504-20504/ D/:ShowService:: onServiceConnected: mStartAndBindService.genRandomString = bdghebhdde// 重新绑定 onRebind16:39:17.848 20504-20504/ D/:StartAndBindService: onRebind: // 解绑服务16:39:19.288 20504-20504/ D/:ShowService:: onClick: button.onClick = Unbind Service IntentServiceService 因为属于主线程，开启后需要新建线程来执行耗时操作，我们需要去管理 Service 的生命周期以及子线程，所以 Android 提供了 IntentService 来处理这些问题。IntentService 继承了 Service，并实现了 ServiceHandler 和 HandlerThread，极大的方便了后台线程操作，并且执行完耗时操作后自动关闭本服务。 特点 串行执行因为使用的是Handler 和 Message 的机制，所以所有任务都是串行执行，逐一执行收到的 Intent 启动方式 startService默认属于启动服务，无法组件间交互 带参数通过 Intent 传递参数到服务中 重写回调 构造函数必须调用 super 并传递类名 onHandleIntent在这里执行所有的耗时工作 示例： 123456789101112131415161718192021222324252627public class MyIntentService extends IntentService &#123; /** * A constructor is required, and must call the super IntentService(String) * constructor with a name for the worker thread. */ public MyIntentService() &#123; super("MyIntentService"); &#125; /** * The IntentService calls this method from the default worker thread with * the intent that started the service. When this method returns, IntentService * stops the service, as appropriate. */ @Override protected void onHandleIntent(Intent intent) &#123; // Normally we would do some work here, like download a file. // For our sample, we just sleep for 5 seconds. try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; // Restore interrupt status. Thread.currentThread().interrupt(); &#125; &#125;&#125; 其他生命周期函数如果要重写，必须调用 super.*** 否则影响 IntentService 的功能 示例及 Log 分析同时开启两次服务，分别处理 ActionBaz 和 ActionFoo 123456789101112131415161718192021222324// 同时发送 ActionBaz 和 ActionFoo 两个 Intent，串行处理14:00:49.965 7776-7776/:ShowService:: onCreate: // 点击 Button ，启动两次服务14:00:51.332 7776-7776/:ShowService:: onClick: button.onClick = Start Intent Service14:00:51.333 7776-7776/:MyIntentService:: startActionBaz: 14:00:51.337 7776-7776/:MyIntentService:: startActionFoo: // 启动服务14:00:51.343 7776-7776/:MyIntentService:: onCreate: // 开启服务 1 14:00:51.344 7776-7776/:MyIntentService:: onStartCommand: startId = 114:00:51.347 7776-7866/:MyIntentService:: onHandleIntent: action = com...action.BAZ// 开启服务 2 14:00:51.348 7776-7776/:MyIntentService:: onStartCommand: startId = 2// 处理 ActionBaz，工作线程处理耗时工作14:00:51.348 7776-7866/:MyIntentService:: handleActionBaz: param1 = Action, param2 = Baz14:00:51.348 7776-7866/:MyIntentService:: doLongRunningWork Start...14:00:54.349 7776-7866/:MyIntentService:: doLongRunningWork Done!// 处理 ActionFoo，工作线程处理耗时工作14:00:54.349 7776-7866/:MyIntentService:: onHandleIntent: action = com...action.FOO14:00:54.350 7776-7866/:MyIntentService:: handleActionFoo: param1 = Action, param2 = Foo14:00:54.350 7776-7866/:MyIntentService:: doLongRunningWork Start...14:00:57.350 7776-7866/:MyIntentService:: doLongRunningWork Done!// 关闭服务14:00:57.351 7776-7776/:MyIntentService:: onDestroy: 前台服务前台服务被认为是用户主动意识到的一种服务，因此在内存不足时，系统也不会考虑将其终止。 前台服务必须为状态栏提供通知，放在“正在进行”标题下方，这意味着除非服务停止或从前台移除，否则不能清除通知 开启前台服务 startForeground()通过 startForeground 来标记服务为前台服务，源码：public final void startForeground(int id, Notification notification) {...}参数 id 是唯一标识通知的整型数但不能为 0和状态栏的通知 Notification 移除前台服务 stopForeground移除不是停止服务，所以移除后，服务还是在运行，源码：public final void stopForeground(boolean removeNotification) {...} 示例代码： 12345678910111213141516171819202122232425private void startForegroundService()&#123; Log.d(TAG, "startForegroundService: "); CharSequence text = getText(R.string.foreground_service_started); PendingIntent contentIntent = PendingIntent.getActivity(this, 0, new Intent(this, ShowService.class), 0); // Set the info for the views that show in the notification panel. // 设置通知 Notification notification = new Notification.Builder(this) .setSmallIcon(R.drawable.stat_sample) // the status icon .setTicker(text) // the status text .setWhen(System.currentTimeMillis()) // the time stamp .setContentTitle(getText(R.string.alarm_service_label)) // the label .setContentText(text) // the contents of the entry .setContentIntent(contentIntent) // The intent to send when clicked .build(); // 设置前台服务 startForeground(R.string.foreground_service_started, notification);&#125;private void stopForegroundService()&#123; // 移除前台服务 stopForeground(true);&#125; 小结 启动服务建议使用 IntentService，不用关心生命周期及线程的管理，它的任务是串行执行的，不支持并发。并发还是需要继承 Service 来实现。 绑定服务继承 Service，大部分情况绑定服务一般会和启动服务联合使用。 参考文档 https://developer.android.com/guide/components/services.html https://developer.android.com/guide/components/bound-services.html http://blog.csdn.net/u013553529/article/details/54754491 http://blog.csdn.net/huutu/article/details/40357481 http://blog.csdn.net/javazejian/article/details/52709857 http://blog.csdn.net/lmj623565791/article/details/47143563]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FourComponents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment]]></title>
    <url>%2F2017%2F11%2F27%2F0019-fragment%2F</url>
    <content type="text"><![CDATA[基本概念Fragment 是 Activity 的模块化组成部分，它具有自己的生命周期，能接收自己的输入事件，可以在 Activity 运行时添加或移除。 它存在于 Activity 视图层次结构的某个 ViewGroup 内部，并且会定义其自己的视图布局。一个 Fragment 可以被加入多个 Activity ；一个 Activity 可以加入多个 Fragment。 生命周期Fragment 生命周期，如下图所示： 每个 Fragment 至少需要实现这三个生命周期回调：onCreate() --&gt; onCreateView() --&gt; onPause() Fragment 和 Activity 的生命周期对比： 生命周期函数中，只有 onCreate 和 onResume 是 Activity比 Fragment 先执行，其他都是后执行，示例如下： 123456789101112131415161718192021// Activity启动Activity:: onCreate// Fragment初始化Fragment:: onAttachFragment:: onCreateFragment:: onCreateViewFragment:: onActivityCreatedFragment:: onStartActivity:: onStart// Activity先执行resumeActivity:: onResumeFragment:: onResume...Fragment:: onPauseActivity:: onPauseFragment:: onStopActivity:: onStopFragment:: onDestroyViewFragment:: onDestroyFragment:: onDetachActivity:: onDestroy 向Activity添加Fragment静态添加在 Activity 的布局文件内定义 Fragment，至少需要指定如下属性： android:name android:id tools:layout 示例如下： 123456789&lt;fragment // 指定一个id android:id="@+id/frag_activity_lifecycle_c" android:layout_width="368dp" android:layout_height="495dp" // fragment对应的类名 android:name="com.***.fourcomponents.FragmentLifeCycleC" // fragment对应的layout tools:layout="@layout/fragment_life_cycle_c" /&gt; 动态添加代码中将 Fragment 添加到某个现有 ViewGroup，都是事务性操作，必须 commit 后才能生效。 123456FragmentManager fragmentManager = getSupportFragmentManager();FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();FragmentLifeCycleC fragmentLifeCycleC = FragmentLifeCycleC.newInstance("ActivityLifeCycleC", "code");//fragmentTransaction.add(R.id.frag_activity_lifecycle_c_content, fragmentLifeCycleC);fragmentTransaction.replace(R.id.frag_activity_lifecycle_c_content, fragmentLifeCycleC);fragmentTransaction.commit(); Activity 和 Fragment 之间的通信 Activity 调用 Fragment 中的方法通过拿到 FragmentManager 来查找对应的 Fragment, 如下： 12ExampleFragment fragment = (ExampleFragment) getFragmentManager() .findFragmentById(R.id.example_fragment); Fragment 调用 Activity 中的方法Fragment 定义一个接口，在 Activity 中实现这个回调。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FourComponents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件 -- Activity]]></title>
    <url>%2F2017%2F11%2F24%2F0018-activity%2F</url>
    <content type="text"><![CDATA[基本概念Activity 用来做界面显示，交互，也是程序的入口。 生命周期生命周期流转图 注意: 在实现生命周期方法时必须始终先调用超类实现，然后再执行其他操作。 123456@Overrideprotected void onResume() &#123; super.onResume(); ... // my code.&#125; 生命周期回调方法汇总表 生命周期回调方法汇总表 onPause 和 onStop 的区别onPause：失去焦点，不可交互onStop：完全被遮挡，Activity 不可见 示例：Activity 在弹出 Dialog 时，只是失去焦点，并没有完全不可见，所以只会执行 onPause ；而 Activity 在启动另一个 Activity 时被完全遮挡，就会执行到 onStop A 启动 B 生命周期的执行顺序12345678// 启动AA:: onCreate -&gt; A:: onStart -&gt; A:: onResume// 点击A中的button启动BA:: onPause -&gt; B:: onCreate -&gt; B:: onStart -&gt; B:: onResume -&gt; A:: onStop// 在B中点击Back退出B:: onPause -&gt; A:: onRestart -&gt; A:: onStart -&gt; A:: onResume -&gt; B:: onStop -&gt; B:: onDestroy// 在A中点击Back退出A:: onPause -&gt; A:: onStop -&gt; A:: onDestroy 可以清楚的看到在 A 启动 B 的流程中，onPause 在失去焦点后就立即执行，当 B 完全启动后并遮挡了 A，onStop 才开始执行。同理，B 在退出过程中，等 A 完全恢复并遮挡 B 后，B 才开始执行 onStop -&gt; onDestroy。onStop -&gt; onRestart 这个流程出现在：Activity 被遮挡但没有销毁，下次恢复时就会执行 onRestart -&gt; onStart。 finish() 对生命周期的影响 在 onCreate 中调用，执行顺序 onCreate -&gt; onDestroy 在 onStart 中调用，执行顺序 onCreate -&gt; onStart -&gt; onStop -&gt; onDestroy Activity 重建的影响因素如下因素的变化，都会导致 Activity 重建，也就是会走 onDestroy -&gt; onCreate： mcc国际移动用户识别码所属国家代号是改变了，sim 被侦测到了，去更新 mcc。 mcc 是移动用户所属国家代号 mncMNC 是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网 locale地址改变了，用户选择了一个新的语言会显示出来 touchscreen触摸屏是改变了，通常是不会发生的 keyboard键盘发生了改变，例如用户用了外部的键盘 keyboardHidden键盘的可用性发生了改变 navigation导航发生了变化，通常也不会发生 screenLayout屏幕的显示发生了变化，不同的显示被激活 fontScale字体比例发生了变化，选择了不同的全局字体 uiMode用户的模式发生了变化 orientation屏幕方向改变了 screenSize屏幕大小改变了 smallestScreenSize屏幕的物理大小改变了，如：连接到一个外部的屏幕上 这些影响因素可以在 AndroidManifest.xml 中设置来屏蔽掉，凡是在这申明后，将不会影响生命周期。 12&lt;activity android:name=".fourcomponents.ActivityLifeCycleA" android:configChanges="***"&gt; 屏幕旋转对生命周期的影响 常规流程 Activity 销毁重建屏幕旋转会完整的触发这两个生命周期，其中状态恢复在 onCreate 和 onRestoreInstanceState 中都可以实现 12345678910111213141516171819TAG:: onCreateTAG:: onStartTAG:: onResume// 开始旋转屏幕，Activity被销毁TAG:: onPause// 触发状态保存TAG:: onSaveInstanceState, outState.value = hello InstanceStateTAG:: onStopTAG:: onDestroy// Activity重建TAG:: onCreate// 状态恢复，可以在onCreate中恢复TAG:: onCreate, savedInstanceState.value = hello InstanceStateTAG:: onStart// 触发状态回复，也可以在这里恢复TAG:: onRestoreInstanceStateTAG:: onRestoreInstanceState, savedInstanceState.value = hello InstanceStateTAG:: onResume// 界面显示 避免 Activity 销毁重建在屏幕旋转时，避免 Activity 销毁重建，可以在 AndroidManifest.xml 中设置对应属性（Android 3.2 及以上需要设置 screenSize）： 12&lt;activity android:name=".fourcomponents.ActivityLifeCycleA" android:configChanges="orientation|screenSize"&gt; 设置后屏幕旋转将完全不影响 Activity 的生命周期，如果想监听屏幕旋转，可以重写如下方法： 12345@Overridepublic void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.d(TAG, "onConfigurationChanged: newConfig = " + newConfig);&#125; “锁屏/解锁”对生命周期的影响“锁屏/解锁” 整个流程包含：锁屏，亮屏，解锁三个步骤： 不涉及横竖屏切换如：当前 Activity 为竖屏，在竖屏状态下，锁屏并解锁，不做方向切换，即正常流程：锁屏：onPause -&gt; onStop解锁：onRestart -&gt; onStart -&gt; onResume 涉及横竖屏切换如：当前 Activity 为横屏，在横屏状态下锁屏会显示锁屏界面，涉及方向切换，当前 Activity 会被销毁重建。锁屏：onPause -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onResume -&gt; onPause 解锁后当前 Activity 变为竖屏解锁：onResume 解锁后当前 Activity 仍然转换为横屏即会出现当前 Activity 销毁重建过程解锁：onResume -&gt; onPause -&gt; onStop -&gt; onDestroy -&gt; onCreate -&gt; onStart -&gt; onResume 横竖屏切换监听屏幕旋转如：当前 Activity 为横屏，并且设置了属性 android:configChanges=&quot;orientation|screenSize&quot; 。即当前 Activity 不会销毁重建，方向切换时会被监听。锁屏：onPause -&gt; onStop -&gt; onConfigurationChanged，此时当前 Activity 已经被切换到竖屏。解锁：onRestart -&gt; onStart -&gt; onResume -&gt; onConfigurationChanged 小结 屏幕旋转如果涉及屏幕旋转，当前 Activity 在“锁屏/解锁”两个阶段都会出现销毁重建（onDestroy -&gt; onCreate），如果此时监听了屏幕旋转，则在方向切换时仅执行 onConfigurationChanged。 锁屏总体来说会先执行 onPause -&gt; onStop，即不可见流程。如果屏幕旋转当前 Activity 重建，会执行到 onPause，同时解锁会直接从 onResume 开始；如果监听了旋转，则屏幕切换时仅会执行 onConfigurationChanged。 亮屏不影响生命周期 解锁总体来说会先执行 onRestart --&gt; onResume，即恢复可见流程。如果当前 Activity 重建过，则直接从 onResume 恢复；如果监听了旋转，则屏幕切换时仅会执行 onConfigurationChanged。 ?为什么锁屏时，如果出现 Activity 销毁重建时，只执行到 onPause，而不执行 onStop ? Home 键对生命周期的影响按下 Home 键不影响生命周期，正常的不可见和恢复可见流程：不可见流程：onPause -&gt; onStop恢复可见流程：onRestart -&gt; onStart -&gt; onResume 状态栏下拉对生命周期的影响下拉状态栏不影响生命周期，但是如果需要监听状态栏下拉，可以重写如下方法： 123456@Overridepublic void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); // 状态栏弹出和收回，都会触发这次事件 Log.d(TAG, "onWindowFocusChanged: ");&#125; 保存 Activity 的状态状态保存和恢复 涉及到两个函数：onSaveInstanceState() 和 onRestoreInstanceState() ，这两个函数大部分情况下并不会成对出现。如果没有重写这两个函数，系统 Activity 类的 onSaveInstanceState() 默认实现也会恢复部分 Activity 状态。具体地讲，默认实现会为布局中的每个 View 调用相应的 onSaveInstanceState() 方法，让每个视图都能提供有关自身的应保存信息。Android框架中几乎每个小部件都会根据需要实现此方法，以便在重建 Activity 时自动保存和恢复对 UI 所做的任何可见更改。例如 EditText 小部件保存用户输入的任何文本，CheckBox 小部件保存复选框的选中或未选中状态。 注意：想要保存其状态的每个小部件，必须提供一个唯一的 ID（通过 android:id 属性）。如果小部件没有 ID，则系统无法保存其状态；如果是相同的 ID，数据会被覆盖，在恢复时数据显示出错。 保存的数据数据通过 Bundle 保存起来，使用 putString() 和 putInt() 等方法以[名称-值]对形式保存有关 Activity 状态的瞬时数据，如成员变量，UI 状态等。如果需要保存持久数据，需要在 onPause 中保存。 onSaveInstanceState()触发时机在 Activity 不可见时触发，也就是 onPause --&gt; onSaveInstanceState --&gt; onStop，但是系统并不是每次都会调用。 调用遵循一个重要原则，即当系统存在“未经你许可”销毁 Activity 的可能时，onSaveInstanceState 会被系统调用，这是系统的责任：必须要提供一个机会让你保存你的数据。 启动另外一个 Activity 并被遮挡 屏幕旋转时当前 Activity 销毁并被重新创建 Home 键相关操作 按下电源键灭屏 不调用 直接退出当前 Activity 被 kill 命令杀掉 onRestoreInstanceState()触发时机在 Activity 恢复可见时触发，也就是 onStart --&gt; onRestoreInstanceState --&gt; onResume，同样系统也不是每次都会调用。 调用重要原则，即当 Activity 确实已经被销毁。 屏幕旋转时当前 Activity 销毁并被重新创建 不调用 当 Activity 并没有销毁而只是进入生命周期恢复过程中，并不会被调用，直接走流程 onRestart --&gt; onStart --&gt; onResume 被 kill 命令杀掉 示例可以参考：“屏幕旋转对生命周期的影响”中“常规流程 Activity 销毁重建”的 log 打印。 Activity存储方式：栈基本概念 返回栈(Back Stack)返回栈： 这些 Activity 按照各自的打开顺序排列在栈中，表示 Activity 的存储方式。返回栈以“后进先出”对象结构运行，并且栈中的 Activity 永远不会重新排列，仅推入和弹出栈。由当前 Activity 启动时推入堆栈；用户使用“返回”按钮退出时弹出堆栈。 源码中查看推测是如下结构来存储返回栈的，但是似乎不像是栈的操作？ 123// TaskRecord.java中定义，暂时没有看出来是栈存储结构？/** List of all activities in the task arranged in history order */final ArrayList&lt;ActivityRecord&gt; mActivities; 任务(Task)任务：在执行特定作业时与用户交互的一系列 Activity，使用返回栈记录这些 Activity 的执行顺序。任务分为前台任务和后台任务，前台任务接受用户交互；任务被移动到后台时，整个返回栈顺序不变。任务可以是同一个应用程序中的 Activity，也可以是跨应用的 Activity，放到同一个任务中，以维护这种无缝的用户体验。 源码中通过如下方式来记录前后台任务列表，每个任务对应一个 TaskRecord： 123456// ActivityStatck.java/** * The back history of all previous (and possibly still * running) activities. It contains #TaskRecord objects. */private final ArrayList&lt;TaskRecord&gt; mTaskHistory = new ArrayList&lt;&gt;(); 前后台任务切换时，仅仅把需要的后台任务移动到最前面，其他任务顺序不变： 12345// ActivityStatck::moveTaskToFrontLocked方法中...// Shift all activities with this task up to the top// of the stack, keeping them in the same internal order.insertTaskAtTop(tr, null); 示例 命令adb shell dumpsys activity，通过该命令可以显示所有 Activity 的任务及存储信息，对应源码为： 12345678910// 1. ActivityManagerService.javavoid dumpActivitiesLocked(***)// 2. ActivityStackSupervisior.javaboolean dumpActivitiesLocked(***)// 3. TaskRecord.javapublic String toString() // 4. ActivityRecord.javapublic String toString()// 5. ProcessRecord.javapublic String toString() 任务只包含同一个应用的 Activity 1234567891011121314151617Display #0 (activities from top to bottom):Task id #482 TaskRecord&#123;5c00e23 #482 A=com.ymzs.androidbasicknowledge U=0 sz=5&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.androidbasicknowledge/.MainActivity &#125; Hist #4: ActivityRecord&#123;18068e4d u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA t482&#125; Hist #3: ActivityRecord&#123;3048f0d9 u0 // 在ActivityLifeCycleB中再次启动ActivityLifeCycleAcom.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleB t482&#125; Hist #2: ActivityRecord&#123;214418e1 u0 // 在ActivityLifeCycleA中启动ActivityLifeCycleB com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleB t482&#125; Hist #1: ActivityRecord&#123;1e375a73 u0 // 启动ActivityLifeCycleA com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA t482&#125; Hist #0: ActivityRecord&#123;19cecd32 u0 // 启动MainActivity com.ymzs.androidbasicknowledge/.MainActivity t482&#125; 由于返回栈中的 Activity 永远不会重新排列，因此如果应用启动特定 Activity，则会创建该 Activity 的新实例并推入堆栈中（而不是将 Activity 的任一先前实例置于顶部），因此应用中的一个 Activity 可能会多次实例化。如上面 Log 显示，A 和 B 有多次实例化。 任务包含不同应用的 Activity 12345678910111213141516171819// 1. ActivityManagerService::dumpActivitiesLocked打印ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)// 2. ActivityStackSupervisior::dumpActivitiesLocked打印Display #0 (activities from top to bottom): Stack #1: Task id #478 // 3. TaskRecord::toString打印，其中A表示affinity的值，sz表示size TaskRecord&#123;f8000a3 #478 A=com.ymzs.mytensorflowandroid U=0 sz=2&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.mytensorflowandroid/.MainActivity &#125; // MainActivity中启动图库应用com.android.gallery3d/.app.Gallery // 4. ActivityRecord::toString打印，t表示task_id Hist #1: ActivityRecord&#123;1ce46759 u0 com.android.gallery3d/.app.Gallery t478&#125; Intent &#123; act=android.intent.action.PICK dat=content://media/external/images/media cmp=com.android.gallery3d/.app.Gallery &#125; // 5. ProcessRecord::toString打印，13594表示进程id，u0a10表示userid ProcessRecord&#123;24a57d18 13594:com.android.gallery3d/u0a10&#125; // 程序入口，启动MainActivity Hist #0: ActivityRecord&#123;1a87e335 u0 com.ymzs.mytensorflowandroid/.MainActivity t478&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.mytensorflowandroid/.MainActivity bnds=[276,999][540,1292] &#125; ProcessRecord&#123;3ac41fa0 13096:com.ymzs.mytensorflowandroid/u0a155&#125; 使用清单文件定义启动模式在清单文件中声明 Activity 时，可以使用 android:launchMode 属性指定 Activity 应该如何与任务关联，默认为 android:launchMode=&quot;standard&quot;，launchMode 属性的启动模式共有四种： standard系统默认，Activity 会被多次实例化。 singleTop如果当前任务的顶部已存在该 Activity 的一个实例，则系统不会创建 Activity 的新实例；如果不在顶部，则和 standard 一样，创建多个实例。假设任务的返回栈顺序是 A-B-C-D，并且 D 位于顶部，再启动 D 时，示例对比： 如果 D 为 standard 模式，将会新建D的实例，返回栈为 A-B-C-D-D 如果 D 为 singleTop 模式，不会创建D的实例，返回栈还是 A-B-C-D singleTask系统根据 taskAffinity 来决定是否开启新任务，taskAffinity 如果不设置，默认值为包名。已有的任务中如果已经存在该 Activity 实例，下次调用时会把该任务的返回栈中位于这个实例上面所有的 Activity 全部结束掉，即最终这个 Activity 实例会位于该任务的堆栈顶端中。 taskAffinity 为默认值或包名，在原任务中装载该 Activity。如下示例： 12345678910111213141516// 任务及返回栈信息// MainActivity --&gt; A --&gt; BTask id #507 TaskRecord&#123;24103cd5 #507 A=com.ymzs.androidbasicknowledge U=0 sz=3&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.androidbasicknowledge/.MainActivity &#125; Hist #2: ActivityRecord&#123;3cae8310 u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleB t507&#125; Hist #1: ActivityRecord&#123;227bef6a u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA t507&#125; Hist #0: ActivityRecord&#123;db2c04f u0 com.ymzs.androidbasicknowledge/.MainActivity t507&#125;// MainActivity --&gt; A --&gt; B --&gt; A，即B中重新启动A// B被结束掉，并执行onDestroy销毁，A重新回到返回栈栈顶Task id #507 TaskRecord&#123;24103cd5 #507 A=com.ymzs.androidbasicknowledge U=0 sz=2&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.androidbasicknowledge/.MainActivity &#125; Hist #1: ActivityRecord&#123;227bef6a u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA t507&#125; Hist #0: ActivityRecord&#123;db2c04f u0 com.ymzs.androidbasicknowledge/.MainActivity t507&#125; 对应的生命周期流程：B:: onPause -&gt; A:: onNewIntent -&gt; A:: onRestart -&gt; A:: onStart -&gt; A:: onResume -&gt; B:: onStop -&gt; B:: onDestroy taskAffinity 不是包名，开启新的任务并加载该 Activity 到底部，后续新开启的 Activity 也会在这个新任务中。 123456789101112131415// 启动流程仍然是MainActivity --&gt; A --&gt; BStack #1: // 开启A，A的affinity名称为com.ymzs.androidbasicknowledge.singleTask，后续开启的B也在这个任务中 // 如果B再调用A，则B被返回栈弹出销毁，使A到栈顶显示 Task id #509 TaskRecord&#123;1fb922e2 #509 A=com.ymzs.androidbasicknowledge.singleTask U=0 sz=2&#125; Intent &#123; flg=0x10000000 cmp=com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA &#125; Hist #1: ActivityRecord&#123;3b4246dc u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleB t509&#125; Hist #0: ActivityRecord&#123;3cd3c703 u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA t509&#125; // 程序入口进入MainActivity， affinity名称为包名com.ymzs.androidbasicknowledge Task id #508 TaskRecord&#123;740e673 #508 A=com.ymzs.androidbasicknowledge U=0 sz=1&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.androidbasicknowledge/.MainActivity &#125; Hist #0: ActivityRecord&#123;98712e4 u0 com.ymzs.androidbasicknowledge/.MainActivity t508&#125; singleInstance系统会启动一个新的任务来装载该 Activity，并且该 Activity 始终是其任务唯一仅有的成员，也就是 Activity 和任务是一一对应的。 12345678910111213141516171819202122// 启动顺序 MainActivity --&gt; ActivityLifeCycleA --&gt; ActivityLifeCycleBACTIVITY MANAGER ACTIVITIES (dumpsys activity activities)Display #0 (activities from top to bottom): Stack #1: // MainActivity和ActivityLifeCycleB属于同一应用程序，默认放到同一个任务中 Task id #489 TaskRecord&#123;8812eba #489 A=com.ymzs.androidbasicknowledge U=0 sz=2&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.androidbasicknowledge/.MainActivity &#125; Hist #1: ActivityRecord&#123;2408fb5a u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleB t489&#125; Intent &#123; flg=0x10400000 cmp=com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleB &#125; ProcessRecord&#123;37f1bd8e 13928:com.ymzs.androidbasicknowledge/u0a156&#125; Hist #0: ActivityRecord&#123;214f1aee u0 com.ymzs.androidbasicknowledge/.MainActivity t489&#125; Intent &#123; act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.ymzs.androidbasicknowledge/.MainActivity bnds=[804,999][1068,1292] &#125; ProcessRecord&#123;37f1bd8e 13928:com.ymzs.androidbasicknowledge/u0a156&#125; // ActivityLifeCycleA设置为&quot;singleInstance&quot;模式，因此该Activity单独且唯一的存在于一个任务中 Task id #490 TaskRecord&#123;1dbdd3e5 #490 A=com.ymzs.androidbasicknowledge U=0 sz=1&#125; Intent &#123; flg=0x10000000 cmp=com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA &#125; Hist #0: ActivityRecord&#123;4b095d9 u0 com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA t490&#125; Intent &#123; flg=0x10000000 cmp=com.ymzs.androidbasicknowledge/.fourcomponents.ActivityLifeCycleA &#125; ProcessRecord&#123;37f1bd8 注意:进入顺序为 MainActivity --&gt; ActivityLifeCycleA --&gt; ActivityLifeCycleB但是退出顺序为 ActivityLifeCycleB --&gt; MainActivity --&gt; ActivityLifeCycleA 从 Log 中可以看出，MainActivity 和 ActivityLifeCycleB 是在同一个任务中的返回栈中，所以按返回键会先退出 ActivityLifeCycleB，然后按照栈的顺序进入 MainActivity，再次按返回键退出 MainActivity 后，前台任务完全退出，进入 ActivityLifeCycleA 所在的任务。 总结 实例数，standard 标准模式会开启多个实例，singleTop 有条件单个实例，singleTask 和 singleInstance 都是单个实例（单例模式）。 taskAffinity 决定了 singleTask 是否开启新的任务 启动模式引入新的方法 onNewIntent定义protected void onNewIntent(Intent intent) {}如果 Activity 已经实例化但需要重新加载时，会先执行 onNewIntent，然后再执行生命周期函数。 示例 singleTop 中，如果 B 已经在栈顶，执行顺序 B:: onPause --&gt; B:: onNewIntent --&gt; B:: onResume singleTask 和 singleInstance 中，如果 A 已经存在于任务中，则再次启动 A 时，执行顺序 A:: onNewIntent --&gt; A:: onRestart --&gt; A:: onStart --&gt; A:: onResume 注意事项重写 onNewIntent，必须调用 setIntent 来更新 intent，否则默认 getIntent 还是拿到之前的 intent。参考源码注释： 12* &lt;p&gt;Note that &#123;@link #getIntent&#125; still returns the original Intent. You* can use &#123;@link #setIntent&#125; to update it to this new Intent. 使用 Intent 标志定义启动模式启动 Activity 时，可以通过在传递给 startActivity() 的 Intent 中加入相应的标志，修改 Activity 与其任务的默认关联方式。 注意：Intent 中设置的标志优先级高于 Activity 在清单文件中的定义 可用于修改默认行为的标志包括： FLAG_ACTIVITY_NEW_TASK如果 taskAffinity 的任务存在，则不用新开任务，不管该 Activity 是否存在都会创建新实例。如果不存在则新开任务，比如在 BroadcastReceiver 中开启 Activity 就需要使用该标志 FLAG_ACTIVITY_SINGLE_TOP与 singleTop 启动模式有相同的行为 FLAG_ACTIVITY_CLEAR_TOP如果 Activity 已在当前任务中运行，则会销毁当前任务返回栈中顶部的所有 Activity，直到该 Activity 位于栈顶 注意事项 屏幕旋转，需要有平滑的用户体验 用户数据在 Activity 跳转时不能丢失 特定场景下进程可能会被杀掉·]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>FourComponents</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide]]></title>
    <url>%2F2017%2F11%2F24%2F0017-glide%2F</url>
    <content type="text"><![CDATA[介绍Glide[glaɪd] 是一个快速高效的 Android 图片加载库，注重于平滑的滚动。支持拉取，解码和展示视频快照，图片，GIF 动画。默认情况下，Glide 使用的是一个定制化的基于 HttpUrlConnection 的栈，但同时也提供了与 Google Volley 和 Square OkHttp 快速集成的工具库 github官网、官方文档 特性 图片大小Glide 根据 Imageview 的宽高，下载对应大小的图片并本地保存，而不是直接下载原始大小的图片。同一张图片，当 Imageview 宽高改变时，Glide 会重新下载 存储位置下载图片存储位置： /data/data/包名/cache/image_manager_disk_cache 依赖1234dependencies &#123; compile 'com.github.bumptech.glide:glide:4.1.1' annotationProcessor 'com.github.bumptech.glide:compiler:4.1.1'&#125; 基本概念标准用法Glide 使用简明的流式语法 API，最常用的方法： 123Glide.with(fragment) // context 自动管理生命周期 .load(url) // 加载图片的 url .into(imageView); // 指定对应的 imageview with(context) 中的 context 尽量直接使用 Activity 和 Fragment ，而不是 Application 的 Context，因为 Glide 会维护生命周期，在 Acitivity/Fragment 销毁时自动取消加载并释放资源 裁剪和填充ImageView 大小和图片原始大小： centerCrop按照图片中心位置放大，填充满整个 ImageView，如果多出的部分裁剪掉 fitCenter按比例将图片完整显示，尺寸不足部分留白 和 ImageView 的 scaletype 对应关系如下，查看源码： 1234567891011121314// GenericRequestBuilder::intoswitch (view.getScaleType()) &#123; case CENTER_CROP: applyCenterCrop(); break; case FIT_CENTER: case FIT_START: case FIT_END: applyFitCenter(); break; //$CASES-OMITTED$ default: // Do nothing.&#125; 其他默认为使用 ImageView 设置的属性 ImageView 固定宽度，高度自适应图像完全显示，在 Glide 中的解决方案同时指定 adjustViewBounds 和 fitXY： 123456&lt;ImageView android:id="@+id/img" android:layout_width="match_parent" android:layout_height="wrap_content" android:adjustViewBounds="true" android:scaleType="fitXY"/&gt; 其实这就是 ImageView 标准用法，网上查看教程提到在 Glide 中不生效，实测 Glide 3.8 版本是可以生效的 占位符 placeholderplaceholder ：当图片还没有加载成功时，避免布局抖动或者为空，先显示该占位符的图片，用法： 1234Glide.with(fragment) .load(url) .placeholder(R.drawable.logo) .into(imageView); 常见使用流程 添加依赖 初始化 ImageView 并准备资源图 在 Fragment/Activity 的主线程中使用 1234Glide.with(fragment) .load(url) .placeholder(R.drawable.logo) .into(imageView); 就这么简单！其他复杂使用方法，可以参考官方教程 常见问题RecyclerView 设置宽度填充满屏幕，高度自适应，遇到的问题 问题描述 第一次加载时，Glide 加载的图片没有达到要求，图片变小了 上下滑动，RecyclerView 在复用 imageview 时，因为尺寸问题，会导致正常显示的图片，因为复用导致 imageview 大小发生变化，从而 Glide 重新下载了一张错误尺寸的图片 解决方案：ImageView 的 xml 配置文件中增加： 12android:adjustViewBounds="true"android:scaleType="fitXY" 原因：fitXY ：这种图片的显示方式的效果是：根据 ImageView 设置的大小拉伸图片以填充满空间，（单独设置此属性时）图片会变形adjustViewBounds ：是限制图片在显示时保持原图比例，和 fitXY 显示方式合用能到达自适应的效果 参考：Glide坑遇记：宽度铺满高度自适应 参考文档 github官网 官方文档 Glide 使用必须知道的基础属性 Glide: 一个图片列表的问题 Glide使用及注意的地方 Glide的一些用法 Android图片缓存之初识Glide]]></content>
      <categories>
        <category>OpenSourceLibary</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenSourceLibary</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenDao]]></title>
    <url>%2F2017%2F11%2F24%2F0016-greenDao%2F</url>
    <content type="text"><![CDATA[介绍greenDao 是一个将对象映射到 SQLite 数据库中的轻量且快速的 ORM 解决方案 greenDAO is an open source Android ORM making development for SQLite databases fun again. greenDAO frees you from these by mapping Java objects to database tables (called ORM, “object/relational mapping”).官网 , github 对象关系映射 ORMORM: Object Relational Mapping 对象关系映射，是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换，主要解决对象-关系的映射 面向对象概念 面向关系概念 类 表 对象 表的行 属性 表的列 ORM 的思想：将关系数据库中表中的记录映射成为对象，以对象的形式展现，程序员可以把对数据库的操作转化为对对象的操作 依赖需要添加三个地方，见如下注释： 12345678910111213141516171819// In your root build.gradle file:buildscript &#123; repositories &#123; jcenter() mavenCentral() // add repository &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.1&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin &#125;&#125; // In your app projects build.gradle file:apply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin dependencies &#123; compile &apos;org.greenrobot:greendao:3.2.2&apos; // add library&#125; 基本概念DaoMaster整个 greenDao 的入口，持有数据库对象（SQLiteDatabase），可以创建和删除表，它的内部类 OpenHelper 和 DevOpenHelper 是 SQLiteOpenHelper 的实现。 DaoSession管理所有的 Dao 对象，实现所有的增删改查等功能。 DaosDaos: Data access objects 数据访问对象，greenDao 为每个 Entity 都会创建一个 Dao，常见的增删改查都是在 Dao 中进行的。 Entities类似数据库的一张表。 联系图： Schema在 app/build.gradle 中添加 Schema 配置： 123greendao &#123; schemaVersion 1&#125; 支持如下参数： schemaVersion数据库 schema 版本号，如果数据库或者表相关有修改或迁移，需要增加该值 daoPackagedao 源码的包名，默认为 entity 代码所在目录 targetGenDirgreenDao 生成代码的目录地址，默认： build/generated/source/greendao generateTests自动产生带有测试目录 targetGenDirTests单元测试源码地址，默认：src/androidTest/java 常见流程创建实体类 Entity类名需要使用 @Entity 标注，主键使用 @Id 标注，必须使用 long/Long 类型。如果是 Long 类型，主键是由 greenDao 维护的，类似自增长（允许之前删掉了的 id 重复使用，所以需要注意 id 相同但实际内容已经改变），我们不需要手动修改；如果是 long 类型，需要代码中主动赋值，否则默认为 0 导致插入时抛出重复错误异常 1234567@Entitypublic class Fun &#123; @Id private Long id; private String author; ...&#125; Entity 标注的类，如果有属性字段修改，必须重新编译一次生成对应的构造函数及 setter/getter 编译工程AS 中点击编译工程，greenDao 自动生成对应文件： Entity 标注的类，自动生成构造函数，setter/getter 等 DaoMaster，DaoSession 等辅助类，方便后续编码时调用 实例化 DaoSession 创建 DbHelper，初始化数据库，处理数据库升级等等 构造函数中实例化一个 DaoSession，通过该实例来做增删改查等相关操作 12345678910111213141516171819202122public class DbHelper extends DaoMaster.OpenHelper&#123; private static final String DATABASE_NAME = &quot;FunReading.db&quot;; private static final boolean ENCRYPTED = false; private DaoSession mDaoSession; public DbHelper(Context context)&#123; super(context, DATABASE_NAME); Database db = ENCRYPTED ? getEncryptedWritableDb(&quot;super-secret&quot;) : getWritableDb(); mDaoSession = new DaoMaster(db).newSession(); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; super.onUpgrade(db, oldVersion, newVersion); &#125; public DaoSession getDaoSession()&#123; return mDaoSession; &#125;&#125; 注意：DevOpenHelper 会在数据库升级时，删除所有的表，意味着这将导致数据的丢失，只能在开发调试的时候使用 增删改查1234567891011121314151617181920212223// DaoSession 或者 通过 DaoSession 拿到 Dao 后，做增删改查FunDao funDao = mDaoSession.getFunDao();// 1. 增funDao.insert(fun); // 单条funDao.insertInTx(funList); // 批量// 2. 删 funDao.deleteByKey(fun.getId()); // 单条funDao.deleteByKeyInTx(idList); // 批量funDao.deleteAll(); // 所有// 3. 改 funDao.update(fun); // 单条funDao.updateInTx(funList); // 批量// 4. 查funDao.load(id); // 单条funDao.loadAll(); // 所有funDao.queryRaw(...); // 支持 sql 原始查看方式// 条件查询，where 条件与funDao.queryBuilder().where(where).build().list();// 条件或funDao.queryBuilder().whereOr(where).build().list(); 注解实体对应表 @Entity 定义实体 @nameInDb 在数据库中的名字，如不写则为实体中类名 @indexes 索引 @createInDb 是否创建表，默认为true,false时不创建 @schema 指定架构名称为实体 @active 无论是更新生成都刷新 @Property(nameInDb = &quot;USERNAME&quot;)标准字段对应数据库中的字段名，也就是java的字段熟悉命名可以和数据库字段命名不一致，但是要通过该注解转换 其他 @Id @NotNull 不为null @Unique 表示该字段唯一 @ToMany 一对多 @OrderBy 排序 @ToOne 一对一 @Transient 不存储在数据库中 @generated 由 greendao 产生的构造函数或方法 常见问题重复 Id 无法新增数据android.database.sqlite.SQLiteConstraintException: UNIQUE constraint failed: FUN._id (code 1555)出现这种情况可以设置主键为 Long 类型，让 greenDao 自动增长主键，避免出现字段不唯一报错 数据类型不支持12Error:Execution failed for task &apos;:app:greendao&apos;.Can&apos;t add property &apos;Variable(type=VariableType(name=com.***.funreading.model.DataType, isPrimitive=false, originalName=DataType, typeArguments=null), name=type)&apos; to entity Fun due to: Unsupported type com.***.funreading.model.DataType` 不能保存自定义数据类型 参考文档： http://blog.csdn.net/fesdgasdgasdg/article/details/51835699 http://www.open-open.com/lib/view/open1438065400878.html greenDAO3基本使用 greenDao进阶 GreenDao3.0简单使用 GreenDao 使用教程 GreenDao3 使用说明 查询进阶]]></content>
      <categories>
        <category>OpenSourceLibary</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenSourceLibary</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gson]]></title>
    <url>%2F2017%2F11%2F24%2F0015-gson%2F</url>
    <content type="text"><![CDATA[介绍JSONJSON(JavaScript Object Notation)：轻量级的数据交换格式，广泛用于服务器和客户端的交互中 GsonGoogle 公司发布的一个开放源代码的 Java 库，主要用途为序列化 Java 对象为 JSON 字符串，或反序列化 JSON 字符串成 Java 对象。官方仓库。主要优势有： 允许已经存在的无法改变的对象转换成 Json，或者 Json 转换成已存在的对象，不需要注解就可以直接转换 对泛型提供完全的支持 依赖app/build.gradle 中增加依赖： 1compile &apos;com.google.code.gson:gson:2.8.1` 基本概念Gson 源码文档写的比较好，可以直接参考 JavaDoc 来看示例 部分特点 推荐把成员变量都声明为 private Java 对象一定要有一个无参构造方法，这是 Gson 实例化对象的关键，可以没有 setter/getter 方法 默认不需要注解字段，所有包含在当前类的字段都默认会被序列化或者反序列化 JavaBean 的生成 规则尽量不使用内部类或嵌套类，如果使用需要使用 static 声明？实际使用中内部类和嵌套类都能解析！ 使用工具将 Json 生成对应的 JavaBean先将 Json 格式化，使用 bejson 生成JavaBean 序列化/反序列化 Serialization序列化，使 Java 对象到 Json 字符串的过程 Deserialization反序列化，Json 字符串转换成 Java 对象的过程 Gson 默认会序列化和反序列化所有属性字段，但是也可以自定义，不过现在推荐使用 TypeAdapter。如下为自定义的方法： 自定义序列化的一种方法 123456789101112131415161718192021public class Id&lt;T&gt; &#123; private final Class&lt;T&gt; clazz; private final long value; public Id(Class&lt;T&gt; clazz, long value) &#123; this.clazz = clazz; this.value = value; &#125; public long getValue() &#123; return value; &#125;&#125;class IdSerializer implements JsonSerializer&lt;T&gt;() &#123; public JsonElement serialize(Id id, Type typeOfId, JsonSerializationContext context) &#123; return new JsonPrimitive(id.getValue()); &#125;&#125;Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdSerializer()).create(); 自定义反序列化的一种方法 1234567891011121314151617181920public class Id&lt;T&gt; &#123; private final Class&lt;T&gt; clazz; private final long value; public Id(Class&lt;T&gt; clazz, long value) &#123; this.clazz = clazz; this.value = value; &#125; public long getValue() &#123; return value; &#125;&#125;class IdDeserializer implements JsonDeserializer&lt;Id&gt;() &#123; public Id deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException &#123; return new Id((Class)typeOfT, id.getValue()); &#125;&#125;Gson gson = new GsonBuilder().registerTypeAdapter(Id.class, new IdDeserializer()).create(); JsonReader/JsonWriterJsonReader 继承于 Reader 用来读取字符，JsonWriter 继承于 Writer用来写入字符。 JsonReader用于将 JSON 字符串转为 Java 对象 JsonWriter用于将 Java 对象写为 JSON 字符串 TypeAdapterTypeAdapter 是一个抽象类，可以用来自定义类型转换，它的流式 API 比树式 API 解析更高效 12345678910111213141516171819202122232425262728public class PointAdapter extends TypeAdapter&lt;Point&gt; &#123; public Point read(JsonReader reader) throws IOException &#123; if (reader.peek() == JsonToken.NULL) &#123; reader.nextNull(); return null; &#125; String xy = reader.nextString(); String[] parts = xy.split(","); int x = Integer.parseInt(parts[0]); int y = Integer.parseInt(parts[1]); return new Point(x, y); &#125; public void write(JsonWriter writer, Point value) throws IOException &#123; if (value == null) &#123; writer.nullValue(); return; &#125; String xy = value.getX() + "," + value.getY(); writer.value(xy); &#125;&#125;GsonBuilder builder = new GsonBuilder();builder.registerTypeAdapter(Point.class, new PointAdapter());// if PointAdapter didn't check for nulls in its read/write methods, you should instead use// builder.registerTypeAdapter(Point.class, new PointAdapter().nullSafe());...Gson gson = builder.create(); 注解关键字包含五个注解关键字，代码路径： com.google.gson.annotations @Expose @Expose 注解只有在如下构造方法初始化时才生效：Gson gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()生效时被注解的成员变量才会参与序列化/反序列化，其他不会参与。如果不是使用该构造方法，没有任何功能。 123456public class User &#123; @Expose private String firstName; @Expose(serialize = false) private String lastName; @Expose (serialize = false, deserialize = false) private String emailAddress; private String password;&#125; @SerializedName表示某个成员变量序列化/反序列化的名字。如果后台服务器使用的命名规则和 Java 规范不一致，或者返回的 Json 和 Java 类只有部分变量不一致时，通过 @SerializedName 注解转换一一对应关系 1234567public class MyClass &#123; // java 字段 a 和 json 中的 name 对应 @SerializedName("name") String a; // java 字段 b 和 json 中的 name1, name2, name3 都可以对应 @SerializedName(value="name1", alternate=&#123;"name2", "name3"&#125;) String b; String c;&#125; @Since只有在如下构造方法初始化时才生效：Gson gson = new GsonBuilder().setVersion(1.0).create()注解生效表示成员变量从哪个版本开始有效 12345678public class User &#123; private String firstName; private String lastName; @Since(1.0) private String emailAddress; @Since(1.0) private String password; // address 字段不生效，因为需要版本大于 1.1 才有效 @Since(1.1) private Address address;&#125; @Until和 since 一样，只有在如下构造方法初始化时才生效：Gson gson = new GsonBuilder().setVersion(1.2).create()注解生效时表示成员变量从哪个版本开始无效 1234567public class User &#123; private String firstName; private String lastName; // 当前版本为 1.2，而这两个字段只能支持到 1.1 @Until(1.1) private String emailAddress; @Until(1.1) private String password;&#125; @JsonAdapter表示成员变量或者类上使用指定的 TypeAdapter 来进行序列化/反序列化 1234567891011121314151617181920212223242526@JsonAdapter(UserJsonAdapter.class)public class User &#123; public final String firstName, lastName; private User(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125;public class UserJsonAdapter extends TypeAdapter&lt;User&gt; &#123; @Override public void write(JsonWriter out, User user) throws IOException &#123; // implement write: combine firstName and lastName into name out.beginObject(); out.name("name"); out.value(user.firstName + " " + user.lastName); out.endObject(); // implement the write method &#125; @Override public User read(JsonReader in) throws IOException &#123; // implement read: split name into firstName and lastName in.beginObject(); in.nextName(); String[] nameParts = in.nextString().split(" "); in.endObject(); return new User(nameParts[0], nameParts[1]); &#125;&#125; 特殊关键字 transient如果被关键字 transient 申明了的字段，不会参与 Gson 的序列化和反序列化：transient int val; 使用流程常见问题Gson 转换过程中的空字段如果元素看起来是个 list，但是实际一直为空，可以直接注释掉这个字段，也就是javabean 中不需要定义 comments 字段。否则会因空报错：com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected a string but was BEGIN_OBJECT at line 1 column 10796 path $.data.data[3].comments[0] 包含相同字段解决方案比如数据格式如下： 123456789101112131415"message": "success","data": &#123; "has_more": false, "has_new_message": false, "max_time": 1503994432, "data": [ &#123; "group": &#123; "text": "\u513f\u5b50\u521d\u4e2d\uff0c", "dislike_reason": [ &#123; "type": 1, "id": 319, "title": "\u6076\u641e" &#125;, 这里面有两个 data，json 转换为 javabean 时会出现重复字段，设计 javabean 可以通过将重复的类更换类名，但字段名不变： 1234567891011121314151617181920212223// json中的第一个 data，类名更换private DataX data;public class DataX &#123; private boolean has_more; private String tip; private boolean has_new_message; private float max_time; private float min_time; private List&lt;Data&gt; data; // json中的第二层 data public class Data &#123; private Group group; private int type; private float display_time; private float online_time; ... &#125; ...&#125; 参考文档： 官方仓库 国外经典教程 Gson源码解读 Gson全解析]]></content>
      <categories>
        <category>OpenSourceLibary</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenSourceLibary</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit]]></title>
    <url>%2F2017%2F11%2F24%2F0014-Retrofit%2F</url>
    <content type="text"><![CDATA[介绍是一个类型安全的 Http 客户端请求框架，本质是对 OkHttp 的封装 依赖app/build.gradle 中增加依赖： 1234// Retrofitcompile &quot;com.squareup.retrofit2:retrofit:2.3.0&quot;compile &quot;com.squareup.retrofit2:adapter-rxjava2:2.3.0&quot;compile &quot;com.squareup.retrofit2:converter-gson:2.3.0&quot; 基本概念Retorift负责配置请求过程中的基本参数，如：请求地址，结果转换器，自定义OKHttpClient 等，同时还会生成请求接口对象 Converter &amp; Converter.Factory分别负责网络请求结果转换以及生成Converter转换器，常见的转换器有 Gson CallAdapter &amp; CallAdapter.Factory分别负责对 Retrofit.Call 实例( OkHttpCall )进行适配及生成 CallAdapter 适配器。常见适配器有： RxJava ServiceMethod解析接口服务所有注解、生成请求对象 Request 、解析请求结果 Response 注解关键字RESTfull API 标准接口@GET、@POST、@PUT、@DELETE、@HEAD @GET：获取资源 @POST：新建资源（也可以用于更新资源） @PUT：更新资源 @DELETE：删除资源 @HEAD：获取资源的元数据 12@GET("text")Single&lt;QsbkFun&gt; getQsbkFun(@Query("page") String index); @HTTPRetrofit 提供的自定义 Http 请求，可以替代标准注解 12@HTTP(method = "GET", path = "text", hasBody = false)Single&lt;QsbkFun&gt; getQsbkFun(@Query("page") String index); 使用流程定义 entity，接收服务器返回数据常见返回数据类型为 Json，这里使用 Gson 来实现数据和对象转换，如： 123public class QsbkFun &#123; ...&#125; 定义 service 接口通过注解描述网络请求接口，返回值是 RxJava 的数据流 1234567public interface QsbkFunService &#123; /** * http://m2.qiushibaike.com/article/list/text?page=1 */ @GET("text") Single&lt;QsbkFun&gt; getQsbkFun(@Query("page") String index);&#125; 创建 Retrofit 实例创建 Retrofit 实例，指定 Url、数据解析 Json 转换器、网络请求适配器 Rxjava 等等 离线缓存，配合 okhttp实现? 12345Retrofit retrofit = new Retrofit.Builder() .baseUrl(url) .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); 创建 service 接口实例并配置网络请求参数接口，并通过该接口获取数据QsbkFunService service = retrofit.create(QsbkFunService.class); 常见错误@GET(&quot;/&quot;) 不能为空，至少包含一个斜杠java.lang.IllegalArgumentException: Missing either @GET URL or @Url parameter. 参考文档 官网文档 一份很详细的 Retrofit 2.0 使用教程 图解 Retrofit Retrofit分析-漂亮的解耦套路 透过Retrofit使用看其源码设计模式]]></content>
      <categories>
        <category>OpenSourceLibary</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenSourceLibary</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava]]></title>
    <url>%2F2017%2F11%2F24%2F0013-rxjava%2F</url>
    <content type="text"><![CDATA[介绍ReactiveX主要是响应式编程（Reactive Program），它集合了观察者模式，迭代器模式，函数式编程的优点，是一种面向集合数据流和变化传播的编程范式，是基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流ReactiveX is a combination of the best ideas from the Observer pattern, the Iterator pattern, and functional programmingIt is sometimes called “functional reactive programming” but this is a misnomer. ReactiveX may be functional, and it may be reactive, but “functional reactive programming” is a different animal. One main point of difference is that functional reactive programming operates on values that change continuously over time, while ReactiveX operates on discrete values that are emitted over time. Java 8 新特性Java 8 中引入了很多针对响应式的新特性，如 Lambda 表达式，函数式接口，MAP，Filter，Stream 流式操作等等。其中 JDK8 的 Stream 是一个受到函数式编程和多核时代影响而产生的东西。java.util.stream 包，实现了集合的流式操作，流式操作包括集合的过滤，排序，映射等功能。根据流的操作性，又可以分为串行流和并行流。根据操作返回的结果不同，流式操作又分为中间操作和最终操作。大大方便了我们对于集合的操作： 最终操作：返回一特定类型的结果 中间操作：返回流本身 流式操作最大的特点是以疏代堵，流处理方式可以处理无限的数据，只需要消耗时间。因此流式是对数据量开放的，适用于处理大数据 RxJavaRxJava 是一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库，是 JVM 的响应式扩展。最大的特点是异步，异步是通过一种扩展的观察者模式来实现的。使用了 Java 8 的新特性来实现 Reactive ExtendsionsRxJava – Reactive Extensions for the JVM – a library for composing asynchronous and event-based programs using observable sequences for the Java VM.RxJava 2.x will target Reactive Streams APIs directly for Java 8+ 仓库地址： https://github.com/ReactiveX/RxJava 依赖app/build.gradle 中增加依赖： 12compile &apos;io.reactivex.rxjava2:rxjava:2.*.*&apos; compile &apos;io.reactivex.rxjava2:rxandroid:2.*.*&apos; * 换成具体的版本号Sync Project 同步整个工程，自动下载 RxJava 相关依赖包 基本概念Observable涉及到三个概念：Observable (可观察者，即被观察者)、 Observer (观察者)、 subscribe (订阅)。Observable.subscribe(Observer) 实现订阅关系， Observable 提供数据流，Observer 响应事件并处理数据 数据流Observable 表示一个数据流集合，数据是通过 Push 的方式发出，示例图： You can think of the Observable class as a “push” equivalent to Iterable, which is a “pull.” 数据发射如果已经拿到 Observable 数据流，RxJava 会自动发射。如果新建 Observable 可以实现 ObservableOnSubscribe 通过代码控制手动发射 ObserverObserver 提供接收数据流的处理机制，包含如下几个回调： void onSubscribe(@NonNull Disposable d);表示订阅成功后，能拿到 Disposable 实例，通过它可以解除订阅关系 void onNext(@NonNull T t);表示接收数据，所有发射过来的数据都在这接收并处理 void onError(@NonNull Throwable e);表示事件队列异常，在事件处理过程中出异常时，该方法会被触发，同时队列自动终止，不允许再有事件发出 void onComplete();表示事件队列完结，RxJava 规定：当不会再有新的事件发出时，需要触发该方法作为结束标志 注意：在一个正确运行的事件序列中，onCompleted 和 onError 有且只有一个，也就是说二者必须唯一并且互斥，在响应的队列中只能调用一个 subscribe理清了上面的概念后，将 Observable 和 Observer 订阅在一起，就实现了数据流的连通 123456789101112131415161718192021222324252627282930// 第一步：新建 Observable Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(@io.reactivex.annotations.NonNull ObservableEmitter&lt;String&gt; e) throws Exception &#123; // 1. 订阅成功后，Observable 开始发射数据 e.onNext("1111"); e.onNext("2222"); e.onNext("3333"); // 发射数据结束符 e.onComplete(); &#125;// 第二步：新建 Observer// 第三步：订阅 subscrible&#125;).subscribe(new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(@io.reactivex.annotations.NonNull Disposable d) &#123;&#125; @Override public void onNext(@io.reactivex.annotations.NonNull String s) &#123; // 2. Observer 开始接收数据并处理 Log.d("XMT", "s = " + s); &#125; @Override public void onError(@io.reactivex.annotations.NonNull Throwable e) &#123;&#125; @Override public void onComplete() &#123;&#125;&#125;); Scheduler 线程调度器在 RxJava 的默认规则中，事件的发出和消费都是在同一个线程的，也就是在哪个线程调用 subscribe，就在哪个线程生产事件；在哪个线程生产事件，就在哪个线程消费事件。观察者模式本身的目的就是『后台处理，前台回调』的异步机制，因此异步对于 RxJava 是至关重要的，Scheduler 就是来完成异步的 subscribeOn指定的就是发射事件的线程，即生产事件的线程多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略 RxJava 中的所有的数据准备，发射的回调都是在这个线程中执行的 observeOn指定的就是订阅者接收事件的线程，即事件消费的线程但多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次 小结：如果不指定 subscribeOn 和 observeOn，事件就是同步执行的，也就是发射一个数据后同步消费一个数据，这样并没有体现 RxJava 的特点，所以实际中需要调用这两个接口指定具体的事件产生和消费的线程。示例 Log ： 12345678910111213141516171819202122232425262728// 数据发射和消费都在同一个线程 363314:55 3633-3633/D/: Observable, thread.name = main// 发射一个数据14:55 3633-3633/D/: Observable, emit data 111// 消费一个数据14:55 3633-3633/D/: Observer, thread.name = main, s = 11114:55 3633-3633/D/: Observable, emit data 22214:55 3633-3633/D/: Observer, thread.name = main, s = 22214:55 3633-3633/D/: Observable, emit data 33314:55 3633-3633/D/: Observer, thread.name = main, s = 333// 数据发射完毕14:55 3633-3633/D/: Observable, emit data Complete// 消费事件回调14:55 3633-3633/D/: Observer, onCompleted// 数据发射和消费在不同线程，后台处理前台回调// 后台处理线程 ID 5673，一次发射完所有数据14:57 5536-5673/D/: Observable, thread.name = RxComputationThreadPool-214:57 5536-5673/D/: Observable, emit data 11114:57 5536-5673/D/: Observable, emit data 22214:57 5536-5673/D/: Observable, emit data 33314:57 5536-5673/D/: Observable, emit data Complete// 异步处理，主线程 ID 5536 逐个逐个事件来消费14:57 5536-5536/D/: Observer, thread.name = main, s = 11114:57 5536-5536/D/: Observer, thread.name = main, s = 22214:57 5536-5536/D/: Observer, thread.name = main, s = 33314:57 5536-5536/D/: Observer, onCompleted 系统自带的几个常用线程： Schedulers.computation()专为计算所使用的线程，计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，用于计算任务，例如图形的计算，事件循环等。使用的是固定的线程池，大小为 CPU 核数，即默认线程数等于处理器的数量。不要把 I/O 操作放该线程中，否则 I/O 操作的等待时间会浪费 CPU Schedulers.newThread()总是启用新线程，并在新线程执行操作 Schedulers.io()I/O 操作：读写文件、读写数据库、网络信息交互等所使用的线程， 行为模式和 newThread 差不多，区别在于 io 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下更有效率。不要把计算工作放在 io 中，可以避免创建不必要的线程 Schedulers.single()先开线程，同时后台线程都在同一个线程中 Schedulers.from(Executor)使用指定的 Executor 作为调度器 Schedulers.trampoline()在当前线程排队执行，如果队列中已经存在其他任务 AndroidSchedulers.mainThread()RxAndroid 提供的线程， 在 Android 主线程中运行，用于事件消费时更新 UISchedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 小结：只有 trampoline() 是在当前线程中执行，其他都是新开线程，可以通过如下代码调试是在哪个线程中：Log.d(TAG, &quot;thread.name = &quot; + Thread.currentThread().getName()) 如下示例适用于多数的 『后台线程取数据，主线程显示』的程序策略： 1234567891011Observable.just(1, 2, 3, 4) // 指定 subscribe() 发生在 computation 线程 .subscribeOn(Schedulers.computation()) // 指定 Subscriber 的回调发生在 Android 主线程 .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;Integer&gt;() &#123; @Override public void call(Integer number) &#123; ... &#125; &#125;); Backpressure 背压背压是指在异步场景中，生产者发送事件速度远快于消费者的处理速度带来的问题。如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件，所以在这种情况下，根本不存在背压问题。即同步情况下，Backpressure 问题不存在。异步场景中解决背压问题就是流速控制的一种策略，要求生产者降低事件发射速度的策略 12345678910111213141516171819202122232425public enum BackpressureStrategy &#123; /** * OnNext events are written without any buffering or dropping. * Downstream has to deal with any overflow. * &lt;p&gt;Useful when one applies one of the custom-parameter onBackpressureXXX operators. */ MISSING, /** * Signals a MissingBackpressureException in case the downstream can't keep up. */ ERROR, /** * Buffers &lt;em&gt;all&lt;/em&gt; onNext values until the downstream consumes it. */ BUFFER, /** * Drops the most recent onNext value if the downstream can't keep up. */ DROP, /** * Keeps only the latest onNext value, overwriting any previous value if the * downstream can't keep up. */ LATEST&#125; BUFFER 模式默认队列大小为 128 Flowable/SubscriberRxJava 2.* 中，Observeable 用于订阅 Observer，是不支持背压的；而新引入的 Flowable 用于订阅 Subscriber，支持背压。差别图： Flowable/Subscriber 订阅示例，Flowable 需要指定背压策略： 12345678910111213141516171819202122232425262728293031323334Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(@io.reactivex.annotations.NonNull FlowableEmitter&lt;Integer&gt; e) throws Exception &#123; // 无限循环发射数据 for(int i = 0; ; i++)&#123; e.onNext(i); &#125; &#125;// 使用 BUFFER 策略 &#125;, BackpressureStrategy.BUFFER).subscribeOn(Schedulers.computation()).observeOn(AndroidSchedulers.mainThread()).subscribe(new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; // 每次只请求一部分数据处理解决背压问题 // 充分体现流式处理思想，生产端可以无限发射大数据 // 数据的消费只是时间问题，时间足够长就可以处理足够多的数据 s.request(Long.MAX_VALUE); &#125; @Override public void onNext(Integer integer) &#123; // 处理数据 Log.d("XMT", "i = " + integer); &#125; @Override public void onError(Throwable t) &#123;&#125; @Override public void onComplete() &#123;&#125;&#125;); 在选择 Observable 和 Flowable 时，官方给出了一些建议，在数据量不是很大的时候（小于 1000）选择 Observable 其他模式除了上面的 Observable/Observer 和 Flowable/Subscriber 模式外， RxJava 还提供如下几种模式： Single/SingleObserver数据流只包含一个数据，只发射一个数据 Completable/CompletableObserver不发射数据（也就没有数据消费），只会回调 onComplet Maybe/MaybeObserver上面两个的综合体，提供了以上两种功能供选择，但是只有一个功能能生效，也就是二选一。如果发射数据，发射一个数据；如果不发射数据，只能响应 onComplete 常见操作符map变换操作符，它的作用将类型装换，将上游类型转换为下游需要的类型 .map()是一对一的类型转换：输入一个事件变量 A，输出一个事件变量 B flatMap是一对多的类型转换（也就是事件拆分）：将一个发送事件的上游 Observable 变换为多个发送事件的 Observables。比如输入是一个事件 List&lt;T&gt;，转换后输出是list.count 个 T 的事件流。flatMap 并不保证事件转换后的顺序，如果需要保证顺序则需要使用 concatMap zip组合操作符，将多个 Observable 发送的事件组合到一起，然后发送这些组合事件，它按照严格的顺序应用这个函数。但只发射与发射数据项最少的那个Observable 一样多的数据，也就是事件数量和最少的那个保持一致 filter过滤操作符，把只有满足条件的事件才能发送给消费者 concat连接操作符，将多个 Observable 发送的事件连接到一起，顺序发送所有事件。即将并行数据串行发出 zip 是取最小那一组组合发送， concat 是将所有数据顺序连接发送 示例及分析总结常见操作及转换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 定义一个 T 的集合 List&lt;T&gt; list = new ArrayList&lt;T&gt;();// List&lt;T&gt; 转换为 Observable&lt;List&lt;T&gt;&gt; // 这个集合只含有一个数据 List&lt;T&gt; Observable&lt;List&lt;T&gt;&gt; listObservable = Observable.fromArray(lists);// List&lt;T&gt; 转换为 Observable&lt;T&gt; // 这个集合含有 list.count 个数据 TObservable&lt;T&gt; observable = Observable.fromIterable&lt;list&gt;// 获取指定位置的元素// 这个集合只含有一个数据 TObservable&lt;T&gt; tObservable = listObservable.flatMap(list -&gt; Observable.just(list.get(0));// blocking 同步执行并获取数据 // Observable&lt;List&lt;T&gt;&gt; (只包含一个元素的情况下) 转换为 List&lt;T&gt; List&lt;T&gt; tList = listObservable.blockingFirst();// Observable&lt;T&gt; (只包含一个元素的情况下) 转换为 TT t = observable.blockingFirst();// 获取 Observable&lt;T&gt; 的长度，即有多少个 TSingle&lt;Long&gt; count = observable.count();// Observable&lt;List&lt;T&gt;&gt; 转换为 Observable&lt;T&gt; // 通过flatmap转换Observable&lt;List&lt;T&gt;&gt; funs = null;funs.flatMap(new Function&lt;List&lt;T&gt;, ObservableSource&lt;T&gt;&gt;() &#123; @Override public ObservableSource&lt;T&gt; apply(@NonNull List&lt;T&gt; funs) throws Exception &#123; return Observable.fromIterable(funs); &#125;&#125;);// Observable&lt;T&gt; 转换为 Observable&lt;List&lt;T&gt;&gt;// 通过toList() 转换Observable&lt;T&gt;.toList();// *&lt;List&lt;T&gt;&gt; 转换为 Single&lt;List&lt;T&gt;&gt; 的方法先转换成 *&lt;T&gt; 再通过 toList() 转换为 Single&lt;List&lt;T&gt;&gt;Single.concat(remoteFuns, cachedFuns) // concat 后为 Floweable&lt;List&lt;Fun&gt;&gt; .flatMap(new Function&lt;List&lt;Fun&gt;, Publisher&lt;Fun&gt;&gt;() &#123; @Override public Publisher&lt;Fun&gt; apply(@NonNull List&lt;Fun&gt; funs) throws Exception &#123; return Flowable.fromIterable(funs); &#125; &#125;) // 转换后为 Flowable&lt;Fun&gt; .distinct() // 再转换为 Single&lt;List&lt;Fun&gt;&gt; .toList(); 问题事件分解和组合RxJava 有没有提供将一个事件分解成多个事件？有将多个事件过滤，减少，或者将多个事件组合等思路：通过 flatmap 分解成数据流，使用 filter 过滤该事件流，distinct 去重，toList 重新组合 参考文档 https://github.com/ReactiveX/RxJava/wiki http://reactivex.io http://reactivex.io/documentation/observable.html https://yq.aliyun.com/articles/63660 http://gank.io/post/560e15be2dca930e00da1083 http://www.jianshu.com/p/464fa025229e https://github.com/lzyzsd/Awesome-RxJava http://blog.csdn.net/maplejaw_/article/details/52381395 https://zhuanlan.zhihu.com/p/24482660?refer=dreawer RxJava合集]]></content>
      <categories>
        <category>OpenSourceLibary</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenSourceLibary</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2]]></title>
    <url>%2F2017%2F11%2F24%2F0012-dagger2%2F</url>
    <content type="text"><![CDATA[基本概念Dagger2 依赖注入框架，用来解耦类关系。特别是 MVP 分层结构中，方便解耦和分层测试A fast dependency injector for Android and Java.仓库地址：https://github.com/google/dagger 依赖 build.gradle 123456dependencies &#123; ... // Better IDE support for annotations (so Android Studio interacts better with Dagger) classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; ...&#125; app/build.gradle 12345678910apply plugin: &apos;com.neenbedankt.android-apt&apos;dependencies &#123; ... // Dagger dependencies apt &quot;com.google.dagger:dagger-compiler:2.11&quot; provided &apos;org.glassfish:javax.annotation:10.0-b28&apos; compile &quot;com.google.dagger:dagger:2.11&quot; ...&#125; 注解关键字Inject 标注变量要求 Dagger 为该变量提供依赖，实例化该变量。不能用 private 修饰符修饰该变量 标注构造函数@Inject 标记了的变量在需要这个类实例的时候，Dagger 会找到这个构造函数并将其实例化。也就是 @Inject 标记的构造函数为 @Inject 标记的变量提供依赖（实例化）。构造函数的参数不需要使用 NonNull 标注，Dagger 会做强制检测 标注方法标注的方法会自动在构造函数完成实例化后调用 Module格式：@Module(includes = {*module.class})@Module 注释类，用于标注提供依赖的类。和被 @Inject 标记的构造函数功能类似。但是有时候提供依赖的构造函数是第三方库，无法通过 @Inject 来标注；而且如果构造函数带参数，@Inject 也无法提供参数，所以需要 @Module 来标注。Module 类是一个简单工厂模式，通过 @Provider 提供三个重要功能： 给 @Inject 变量提供实例 给 @Inject 构造函数提供参数 给其他 @Module 中的 @Provider 方法提供参数 @Inject（构造函数）和 @Module 都可以提供依赖（实例化）， Dagger2 会如何选择呢？具体规则如下： 1234567步骤1：首先查找 @Module 标注的类中是否存在提供依赖的方法 @Provider。步骤2：若存在提供依赖的方法（实例化），查看该方法是否存在参数。 a：若存在参数，则按从步骤1开始依次初始化每个参数（开始查找参数的依赖关系，即参数的实例化是否存在依赖注入）； b：若不存在，则直接初始化该类实例，完成一次依赖注入。步骤3：若不存在提供依赖的方法，则查找 @Inject 标注的构造函数，看构造函数是否存在参数。 a：若存在参数，则从步骤1开始依次初始化每一个参数 b：若不存在，则直接初始化该类实例，完成一次依赖注入。 所以：创建类实例级别 @Module 维度要高于 @Inject 维度 Provider注释方法，以 provide 作为前缀，必须出现在有 @Module 注释的类中 它是根据返回值类型来标识和匹配的，方法名并不重要，只需要保证以 provide 开头方便阅读即可 这里细化下 @Module 通过 @Provider 提供的三个功能： 给 @Inject 变量提供实例也就是将实例化放到了 Module 中 123456789@Modulepublic class TasksRepositoryModule &#123; @Singleton @Provides public TasksDataSource provideTasksDataSource(Context context)&#123; return new TasksDataSource(context); &#125;&#125; 给 @Inject 构造函数提供参数 12345678// 构造函数及所需参数@Injectpublic TaskDetailPresenter(long taskID, TasksDataSource tasksDataSource, TaskDetailContract.View taskDetailView) &#123; mTaskID = taskID; mTasksDataSource = tasksDataSource; mTaskDetailView = taskDetailView; &#125; 对应类构造函数所需参数，可以通过 Module 的构造函数，将参数传递进来 1234567891011121314151617181920212223// 对应 module 代码 @Modulepublic class TaskDetailPresenterModule &#123; private final TaskDetailContract.View mTaskDetailView; private long mTaskID = 0; // 提供构造函数的两个参数，通过实例化 Module 的方式传递进来 public TaskDetailPresenterModule(TaskDetailContract.View view, long taskID) &#123; mTaskDetailView = view; mTaskID = taskID; &#125; @Provides public TaskDetailContract.View provideTaskDetailContractView()&#123; return mTaskDetailView; &#125; @Provides public long provideTaskID()&#123; return mTaskID; &#125;&#125; 给其他 @Module 中的 @Provider 方法提供参数该方式需要通过后面介绍的 @Component 将多个 @Module 类连接起来才能生效。给其他 @Module 中的 @Provider 方法提供参数依赖（实例化） 1234567891011121314151617181920212223@Modulepublic class TasksRepositoryModule &#123; @Singleton @Provides public TasksDataSource provideTasksDataSource(Context context)&#123; return new TasksDataSource(context); &#125;&#125;// ApplicationModule 为 TasksRepositoryModule 的 @Provider 提供参数 context // 而 ApplicationModule 的 context 来自于自身构造函数的传参 // 通过 @Component 来连接两个 @Module@Modulepublic class ApplicationModule &#123; private Context context; public ApplicationModule(Context context)&#123; context = context; &#125; @Provides Context providerContext()&#123; return context; &#125;&#125; Binds用来简化 @Provider 的注解 被注解的方法必须是抽象 必须指定返回类型，也就是类似 @Provider 的返回值 示例：将 Random 绑定到 SecureRandom 上： 12345678@Bindsabstract Random bindRandom(SecureRandom secureRandom);简化如下方案：@ProviderRandom bindRandom(SecureRandom secureRandom)&#123; return secureRandom;&#125; Component接口或抽象类，是依赖需求方 (@Inject) 和依赖提供方 (@Module) 之间的桥梁。在编译过程中 Dagger 会自动生成对应的实现类 Dagger***Component 如果 @Component 标记的类不是顶级类，生成的实现类格式为 DaggerA_B_function ，类结构之间增加下划线 注解格式格式：@Component(dependencies = {*component.class}, modules = {*modules.class})参数 dependencies ：表示 Component 和 Component 之间的依赖关系参数 module ：表示依赖提供方示例： 123456@FragmentScoped@Component (dependencies = TasksRepositoryComponent.class, modules = TaskDetailPresenterModule.class)public interface TaskDetailComponent &#123; ...&#125; @Component 注解的接口或抽象类必须包含 Provision methods 或者 Members-injection methods 其中的一种方法 123456789101112@Singleton@Component(modules = DataRepositoryModule.class)public interface AppComponent &#123; // Provision methods，使用 @Inject 注解了 DataRepository 变量 DataRepository getDataRepository(); @Component.Builder interface Builder&#123; @BindsInstance AppComponent.Builder providerContext(Context context); AppComponent build(); &#125;&#125; Provision methods：该方法没有参数，但是返回值必须为 @Inject 注解变量的类型或者注解过的构造函数的类（也就是依赖需求方），或者为 @Provider 返回值类型：DataRepository getDataRepository(); Members-injection methods：该方法满足下面条件之一： 返回值为 void 或者 传入的参数类型，此时方法必须且只能包含一个参数，该参数为 @Inject 注解所在类的类型 123// @Inject 在 TaskDetailActivity 中void inject(TaskDetailActivity activity);SomeType injectAndReturnSomeType(SomeType someType); 返回值为 MembersInjector 类型，可以没有参数MembersInjector&lt;SomeType&gt; getSomeTypeMembersInjector(); 获取 Component 实例格式：Dagger***Component.builder().***初始化参数***.build()，举例： 123mTasksRepositoryComponent = DaggerTasksRepositoryComponent.builder() .applicationModule(new ApplicationModule(getApplicationContext())) .build(); @Component 在实例化时，会将对应的所有 @Module 全都实例化，此时可以通过 @Module 构造函数传入参数 @Component.Builder默认是不需要重新定义的。如果需要通过 @Component 将参数传递给 @Module 的 @Provider 中，我们可以在这里定义 @BindsInstance 1234567@Component.Builderinterface Builder&#123; // 传递 Context @BindsInstance AppComponent.Builder providerContext(Context context); AppComponent build();&#125; 需要注意 @Component.Builder 需要满足几点条件，具体参考 Dagger 的文档。其中必须有一个 build 返回值为 @Component 类， 每次只能传递一个参数并且返回值为 Builder 类型。 Scope用于自定义的注解，限定注解作用域，实现局部的单例 Singleton注解表示为单例模式。但是 Dagger 并没有真正的创建单例，需要我们手动写代码确保只实例化一次。@Singleton 需要同时标记 Provider 和 Component，并且我们把实例化该 Component 放到 Application.onCreate 中，确保只会实例化一次，这样才能体现出单例模式的效果。作用： 更好的管理 Component 和 Module 之间的关系，保证它们是匹配的。如果两者的 Scope 是不一样的，则在编译时报错 代码可读性，更好的了解 Module 中创建的类实例是单例 Qulifier用于自定义注解，精确指定 @Module 和 Inject 的依赖对应关系。@Module 来标注提供依赖的方法时，方法名可以随便定义的，但是为了增加可读性，一般以 provide 开头。Dagger2 主要是根据返回值的类型来决定为哪个被 @Inject 标记了的变量赋值。但是如果有多个一样的返回类型，就无法区分了。因此使用 @Qulifier 来自定义一个注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方，这样就能精确匹配了。一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用@Qulifier 这个注解标示。 常规步骤引入依赖文件在 build.gradle 和 app/build.gradle 中添加依赖，并选择 Sync Project 同步并下载这些第三方包 Inject 标注标注需要依赖的变量，或者提供依赖的构造函数 实现 @Module 和 @Provider根据 Inject 来设计 Module Inject 标注了构造函数Module 可以提供构造函数所需参数 Inject 没有标注构造函数Module 直接实例化并提供返回值 实现 @Component 指定范围 Scoped 选定依赖和指定对应的 Module @Inject 标注的依赖变量，如果需要实例化，需要将变量所在类传递给 Componentvoid inject(TaskDetailActivity activity); 编译项目Dagger 自动生成 Module 和 Component 对应的文件 关联注入Dagger***Component 实现注入并实例化 @Inject 标注的变量 注意如果觉得 Dagger 生成的不对，可以 clean 整个工程，重新生成一次。有的时候只修改 @Inject 注解，并不会正确的生成对应代码，需要 clean &amp; remake 才行 常见错误没有提供依赖实例化方法@Inject 注解成员后，没有注解构造函数，导致如下错误： 12345678910C:\Users\xmt\AndroidStudioProjects\xmt\gitlab\02_myTodo\myTodo\app\src\main\java\com\ymzs\todo\mytodo\ToDoApplication.javaError:(5, 33) 错误: 找不到符号符号: 类 DaggerTaskRepositoryComponent位置: 程序包 com.***.mytodo.dataC:\Users\xmt\AndroidStudioProjects\xmt\gitlab\02_myTodo\myTodo\app\src\main\java\com\ymzs\todo\mytodo\tasks\TasksComponent.javaError:(13, 10) 错误: com.***.mytodo.tasks.TasksPresenter cannot be provided without an @Inject constructor or from an @Provides- or @Produces-annotated method.com.***.mytodo.tasks.TasksPresenter is injected atcom.***.mytodo.tasks.TasksActivity.mTasksPresentercom.***.mytodo.tasks.TasksActivity is injected atcom.***.mytodo.tasks.TasksComponent.inject(activity) @Component 没有定义范围没有定义 scoped 的 @Component 不能依赖一个定义了 scoped 的 @Component，否则导致如下报错： 12Error:(13, 1) 错误: com.***.mytodo.tasks.TasksPresenterComponent (unscoped) cannot depend on scoped components:@Singleton com.***.mytodo.data.TasksRepositoryComponent @Inject 标注私有字段@Inject 不支持注解私有字段，否则会导致如下错误： 123456Error:(5, 33) 错误: 找不到符号符号: 类 DaggerTasksRepositoryComponent位置: 程序包 com.***.mytodo.dataC:\Users\xmt\AndroidStudioProjects\xmt\gitlab\02_myTodo\myTodo\app\src\main\java\com\ymzs\todo\mytodo\tasks\TasksActivity.javaError:(27, 28) 错误: Dagger does not support injection into private fieldsC:\Users\xmt\AndroidStudioProjects\ @Binds 注解的方法，没有提供输入参数Error:(18, 20) 错误: android.app.Application cannot be provided without an @Inject constructor or from an @Provides-annotated method.被 @Binds 注解的方法，必须要提供一个 @Inject 构造函数或者一个 @Provides 注解的方法： 12@Bindsabstract Context bindContext(Application application); @Component.Builder 必须要有一个无参方法返回 @Component 类型Error:(21, 5) 错误: @Component.Builder types must have exactly one no-args method that returns the @Component type必须要有一个无参方法返回 @Component 类型，这个可以理解为 build() 提供该 Component 的实例 12345@Component.Builderinterface Builder&#123; // 必须包含一个无参方法 AppComponent build();&#125; 参考文档 官网文档 Android:dagger2基础注入框架 详解Dagger2 神兵利器Dagger2]]></content>
      <categories>
        <category>OpenSourceLibary</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OpenSourceLibary</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概览]]></title>
    <url>%2F2017%2F11%2F20%2F0011-design-patterns-summary%2F</url>
    <content type="text"><![CDATA[23 种设计模式创建型模式 Creational Patterns 工厂方法模式 Factory Method定义一个创建对象的接口，让子类决定实例化哪一个类。工厂方法将类的实例化延迟到子类 抽象工厂模式 Abstract Factory提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。主要用来创建产品集合 建造者模式 Builder将一个复杂对象的构建与它的表示分离，使得同样的构建可以创建不同的表示。隐藏了产品是如何组装的 原型模式 Prototype用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新对象 单例模式 Singleton保证一个类只产生唯一的一个实例 结构型模式 Structural Patterns 适配器模式 Adapter将类的接口转换成客户希望的接口，使得原本由于接口不兼容的类可以一起工作 桥接模式 Bridge将抽象和其实现分离，具体的子类使用不同的方式去实现，从而可以独立的改变它们。体现了组合重用原则。实现独立出来各自变化，每次变化不会影响其他实现 组合模式 Composite描述如何构造一个类层次式结构，这一结构有基元对象和组合对象，从而形成任意复杂的结构。强调“整体—部分”的层次结构 装饰模式 Decorator动态的给一个对象添加额外职责，这种模式对增加功能比生成子类更加灵活，常见于给某个对象添加功能而不是整个类 外观模式 Façade描述如何用单个对象表示整个子系统。为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口。体现了依赖倒转原则，典型场景MVC结构使用该模式；基金对股票的封装 享元模式 Flyweight运用共享技术有效的支持大量细粒度的对象 代理模式 Proxy为其他对象提供一种代理以控制这个对象的访问，使得只有确实需要这个对象时才创建和初始化 行为型模式 Behavioral Patterns 解释器模式 Interpreter定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子 模板方法模式 Template Method定义一个操作中的算法的框架，而将详细的步骤延迟到子类中。可以在不改变算法的结构下重新定义算法的步骤 责任链模式 Chain of Responsibility将多个对象的请求连成一条链，并沿着这条链传递请求，直到有一个对象处理为止，避免请求的发送者和接收者之间耦合 命令模式 Command将请求封装在对象中，可以作为参数来传递。可以对请求排队或记录日志，以及支持可撤销的操作 迭代器模式 Iterator顺序访问一个聚合对象中各个元素，而不暴露对象内部表示 中介者模式 Mediator用一个中介对象来封装一系列的对象交互。使得各对象不用显式的交互，从而使其耦合松散 备忘录模式 Memento在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。后期可以直接恢复 观察者模式 Observer定义一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。在主题对象在状态变化时会通知所有观察者对象，使它们自动更新 状态模式 State当对象的内部状态改变时允许改变其行为，该对象看起来像是改变了其类 策略模式 Strategy定义一系列的算法，单独封装并使它们可以相互替换。这一模式可以使算法独立于使用它的客户而变化 访问者模式 Visitor表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义于作用于这些元素的新操作 7 大原则具体为：单一职责原则、开闭原则、里氏代换原则、接口隔离原则、依赖倒置原则、组合重用原则、迪米特原则。前五个为面向对象设计和编程（OOD &amp; OOP）中的 S.O.L.I.D 原则。 单一职责原则 Single Responsibility (SRP)就一个类而言，应该仅有一个引起它变化的原因。也就是说一个类应该只有一个职责，如果有多个职责相当于职责耦合了，一个职责的变化就可能影响其他职责的能力，引起类的变化。所以在构造一个类时，将类的不同职责分离到多个类中，确保引起类变化的原因只有一个。 开闭原则 Open/Closed (OCP)软件组成实体（类、模块、函数等等）应该是可扩展的，但是不可修改。该原则认为应该设计永远不需要改变的模块，可以添加新代码来扩展系统的行为，不能对已有的代码进行修改。这个原则很好的实现了面向对象的封装性和可重用性。 里氏代换原则 Liskov&#39;s Substitution (LSP)子类应当可以替换父类并出现在父类能够出现的任何地方。它们之间具有 is-A 关系，但是反过来是行不通的。 接口隔离原则 Dependency Inversion (DIP)采用多个与特定客户类有关的接口比采用一个通用的涵盖多个业务方法的接口要好。这个原则本质相当简单，如果拥有一个针对多个客户的类，为每个客户都创建特定的业务接口，让客户类实现多个接口比直接加载客户所需方法有效。 依赖倒置原则 Interface Segregation (ISP)依赖关系应该尽量依赖接口和抽象类，而不是依赖具体类。高层模块不能依赖低层模块，他们都应该依赖抽象。具体类只负责业务实现，修改具体类不影响业务相关的依赖关系。 组合重用原则能用组合的地方尽量使用组合实现，而不要使用继承来扩展功能。组合能更好的实现封装，比继承具有更大的灵活性和更稳定的结构。 迪米特原则如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三者转发调用。该原则指一个对象应该对于其他对象有最少的了解，有效的降低类之间的耦合。]]></content>
      <categories>
        <category>DesignPatterns</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>DesignPatterns</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String、StringBuffer 和 StringBuilder 的区别]]></title>
    <url>%2F2017%2F11%2F20%2F0010-string-stringbuffer-stringbuild%2F</url>
    <content type="text"><![CDATA[String字符串常量，字符串内容和长度都是不可变的。定义如下： 123456789101112/** * ... * Strings are constant; their values cannot be changed after they * are created. String buffers support mutable strings. * ...*/public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; ...&#125; String 的操作都是在堆内存中重新申请一块内存区并赋值，最终返回该存储区首地址给引用变量。所以如果频繁修改 String 会产生堆内存垃圾，直到 java 触发内存管理机制才能释放。所以在形参传递时， String 类似值传递。 StringBuffer字符串变量，同时也是线程安全的（Synchronized）。 StringBuilder字符串变量，但不是线程安全的。 使用策略 String ：操作少量的数据 StringBuilder：单线程操作大量数据 StringBuffer ：多线程操作大量数据 不要使用 String 类进行频繁的字符串拼接或插入删除，因为那样的性能较差，应该使用 StringBuffer 或 StringBuilder 类，这在 Java 的优化上是一条比较重要的原则。执行速度上：String &lt; StringBuffer &lt; Stringbuilder。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java hashCode 和 eqauls]]></title>
    <url>%2F2017%2F11%2F20%2F0009-java-hashcode-equals%2F</url>
    <content type="text"><![CDATA[Object 的默认定义也就是 Java 中所有的对象都会包含这两个方法： 1234public boolean equals(Object obj) &#123; return (this == obj);&#125;public int hashCode() &#123;...&#125; HashCode哈希码是一种数据结构的算法，从对象计算出来的一个能代表该对象的整数值，这样可以根据哈希码对两个对象做快速比对。通俗来讲，一个对象的哈希码允许算法和数据结构将对象放入一个隔间，这个隔间可以关联相同的对象，也可以关联多个不同对象，相当于将一堆数据做了一个大致的分类，根据哈希码可以快速缩小范围。 需要遵循的规则： 在一个运行的进程中，相等的对象必须要有相同的哈希码 相同的哈希码，对象不一定相等 重写 equals，必须重写 hashcode 不要把哈希码误用为 Key 两个对象比较时，我们可以先比对哈希码，然后再使用 equals 来比对，提高比对效率。 hashcode() 重写，可以根据类中各个对象实例的哈希码加权： 1234@Overridepublic int hashCode() &#123; return myObject1.hashCode() + myObject2.hashCode();&#125; 在 Object 类中，hashCode 方法是通过 Object 对象的地址计算出来的，所以同一个对象的哈希码总是相同的。 equals 和 == 的区别数据类型的存储：栈和堆 基本数据类型只涉及一个存储区：是存在栈内存中的，保存的是数据值本身。 栈内存用于存放基本类型的变量和引用变量，当超过变量的作用域后，java 会自动释放掉为该变量分配的栈内存空间。 引用数据类型涉及到两块存储区：对象本身是存储在堆内存中；引用变量是存储在栈内存中，并存放指向该对象堆内存的首地址。 堆内存用于存放由 new 创建的对象和数组，堆中分配的内存由 java 虚拟机自动垃圾回收器来管理。数组和对象在没有引用变量指向它的时候才变成垃圾，不能再被使用，但是仍然占着内存。在随后的一个不确定的时间被垃圾回收器释放掉，这个也是 java 比较占内存的主要原因 如下例所示：引用变量 a 在栈中存储的是，对象 String(&quot;AA&quot;) 在堆内存中的首地址。 1234String a = new String("AA");String b = new String("AA");System.out.println(a==b);System.out.println(a.equals(b)); 操作符 ==== 操作符比较的是变量在栈内存中存储的值。比如基本数据类型变量比较的是存储的值；引用数据类型的引用变量比较的是存储的首地址。 操作符 equalsequals 操作符的作用和目标是：比较引用变量指向的对象在堆内存中的值，所有对象都需要通过该操作符来比对是否相等。 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 但是，回过头来看 Object 中默认的 eqauls 方法中直接使用了 == 操作符，即需要两个引用变量必须指向同一个对象时才认为是相等的。所以通常自定义类中 eqauls 操作符需要重写，才能确保类对象比较的是堆内存中的值。 区别综上，可以看到上例两个对象 String(&quot;AA&quot;) 和 String(&quot;AA&quot;) 申请了两块堆内存，存储的值都是 AA ；但两块存储区首地址不一样，也就是两个引用变量 a 和 b 在栈内存中存储的值不同。所以， a==b 的比对结果是 false ，但 a.equals(b) 的比对结果是 true。 String 的特殊性查看 String 源码，可以理解它为不可改变的常量，平时使用的字符串拼接或者重新赋值，内部实现其实是重新申请一块存储区存放新字符串，并将首地址返回给引用对象。如下示例： 1234String c = "StringValue";String d = "StringValue";System.out.println(c == d);System.out.println(c.equals(d); 上例中 StringValue 在编译时就分配了一个常量区存放该对象的值，引用变量 c 存放了该存储区的首地址；在下次出现相同的常量时 StringValue ，会共享同一个存储区，而不会重新申请空间，所以应用变量 d 存放了同一个首地址。即两次输出都为 true 。 参考文档 深度解读：重写equals同时必须重写hashCode]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>hashCode</tag>
        <tag>eqauls</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA 集合类概览]]></title>
    <url>%2F2017%2F11%2F20%2F0008-java-collection-basic%2F</url>
    <content type="text"><![CDATA[Java 集合（也称为容器），是将多个元素组合成一个单元的对象。分为两大类： Collection 和 Map，常用集合为 List 、Set、Map；本文源码分析基于 JDK 1.8 。 基础概念集合框架是用于表示和操作集合的统一体系结构，所有集合框架包含以下内容： 接口 Interfaces表示集合的抽象数据类型，接口允许独立于其表示的细节来操纵集合。 实现 Implementations集合接口的具体实现，本质上它们是可重用的数据结构。 算法 Algorithms这些是对实现集合接口的对象，执行有用计算（如搜索和排序）的方法，算法被认为是多态的：相同的方法可以用在集合接口的不同实现上，算法是可重用的功能。 除了 Java Collections Framework 之外，最着名的集合框架示例是 C ++ 标准模板库 STL 。 for-eachfor-each 循环是加强型 for 循环，用来循环遍历集合和数组，JDK 5.0 引入的特性。其语法如下： 123for(type element: array) &#123; System.out.println(element);&#125; Iterator即迭代器，也是一种设计模式，允许访问一个聚合对象而无需暴露内部实现。是一种”轻量级”对象，只能单向遍历。 123456789101112// java.util.Iterator.javapublic interface Iterator&lt;E&gt; &#123; // 是否结束 boolean hasNext(); // 取下一个元素 E next(); // 删除 default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;...&#125;&#125; Iterable可迭代的，实现了这个接口的类表示可迭代的，并且支持 for-each 循环遍历。 1234567// java.lang.Iterable.javapublic interface Iterable&lt;T&gt; &#123; // 包含一个迭代器 Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123;...&#125; default Spliterator&lt;T&gt; spliterator() &#123;...&#125;&#125; 接口Java 集合框架的基础是：核心集合接口，它封装了不同类型的集合，这些接口可以独立的操作集合。类图结构如下： 集合框架都是使用的是泛型，也就是说实例化时必须要指定具体类型。集合框架包含两个大的类型： Collection ：我们常说的集合 Map ：保存具有映射关系的数据，包含键和值。键不能重复，每个键只有一个对应的值 Collection 接口表示一组称为其元素的对象，Java 平台不提供此接口的任何实现，只有子接口的实现。它有四个常用的子接口： Set ：表示不能包含重复元素的集合 List ：表示元素是有序的集合，有时也称为序列 Queue ：队列，通常指先进先出 FIFO 集合，集合的操作都集中在队列某一端 Deque ：双端队列，它实际是 Queue 的子类（感觉并不能和 Queue 并列讨论），可以在队列两端操作集合；它实现了栈 LIFO 和队列 FIFO 两种数据结构 SoretedSet, SoretedMap 表示按升序排好序的集合或键值对。 Collection 接口123456789101112131415161718192021222324252627public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); default boolean removeIf(Predicate&lt;? super E&gt; filter) &#123;...&#125; boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0); &#125; default Stream&lt;E&gt; stream() &#123; return StreamSupport.stream(spliterator(), false); &#125; default Stream&lt;E&gt; parallelStream() &#123; return StreamSupport.stream(spliterator(), true); &#125;&#125; Collection 接口是可迭代的，它提供了集合的一些基本操作： 集合大小，是否为空，是否包含，增加，删除，是否相等，全部清除 迭代访问 集合转换为数组 集合间操作：集合是否包含指定集合，集合添加到目标集合，从集合中移除指定集合 集合取交集：retainAll ，如果和指定集合有交集，则当前集合只保留交集部分；否则当前集合变为空 移除符合特定条件的元素 removeIf 支持并行处理 Spliterator 支持转换为流 Stream List 接口在介绍 List 接口前，先看看 ListIterator 迭代器的定义： 1234567891011public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); boolean hasPrevious(); E previous(); int nextIndex(); int previousIndex(); void remove(); void set(E e); void add(E e);&#125; ListIterator 继承了 Iterator ，即是一个加强版的迭代器。 ListIterator 是 List 的专有接口，它在迭代时可以向前或者向后迭代，并且支持返回索引值。接下来看 List 接口定义： 1234567891011121314151617181920212223242526272829public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; ... boolean addAll(int index, Collection&lt;? extends E&gt; c); default void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); final ListIterator&lt;E&gt; li = this.listIterator(); while (li.hasNext()) &#123; li.set(operator.apply(li.next())); &#125; &#125; default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125; &#125; E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; List 接口中除了 Collection 定义的方法以及重复定义的方法外，新增了一些以索引 index 相关的操作： 集合插入操作：在指定位置插入集合 addAll(int index, Collection&lt;? extends E&gt; c) 集合替换操作：按照指定一元运算符计算并替换当前集合所有的元素 replaceAll(UnaryOperator&lt;E&gt; operator) 集合排序操作：按照指定排序方式，将当前集合内部排序 sort(Comparator&lt;? super E&gt; c) 集合截取操作：给定两个指定位置，截取这部分元素集合 List&lt;E&gt; subList(int fromIndex, int toIndex) 索引 Index 操作：获取指定位置元素、设置指定位置元素、在指定位置添加元素、移除指定位置元素、指定元素的第一个位置 indexOf 、指定元素的最后一个位置 lastIndexOf 支持 ListIterator 迭代器：既可以向前遍历，也可以向后遍历 Queue 接口12345678public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek();&#125; Queue 接口继承了 Collection ，并重新定义了如下几个方法： add/offer ：向队列中添加一个元素 remove/poll ：删除并取出队首元素 element/peek ：获取队首元素，但在队列中不删除该元素 这些功能相似，却有两个独立方法的区别是：抛出异常！ add 方法在容量有有限制的队列中，添加元素超出容量限制时会抛出异常；而 offer 只会返回 false remove 方法在队列为空时，删除会抛出异常；而 poll 只会返回 null element 方法在队列为空时，取出队首元素抛出异常；而 peek 只会返回 null 所以它们在选择并使用时，主要是考虑当前程序是否需要处理异常；当然也和集合的具体实现类有关，取决于集合实现类是否严格按照方法的定义去实现了。 Deque 接口1234567891011121314151617181920212223242526272829public interface Deque&lt;E&gt; extends Queue&lt;E&gt; &#123; void addFirst(E e); void addLast(E e); boolean offerFirst(E e); boolean offerLast(E e); E removeFirst(); E removeLast(); E pollFirst(); E pollLast(); E getFirst(); E getLast(); E peekFirst(); E peekLast(); boolean removeFirstOccurrence(Object o); boolean removeLastOccurrence(Object o); boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); void push(E e); E pop(); boolean remove(Object o); boolean contains(Object o); public int size(); Iterator&lt;E&gt; iterator(); Iterator&lt;E&gt; descendingIterator();&#125; Deque 继承了 Queue ，属于双端队列，接口中的方法明显增多，主要是多出了双端操作： 不管是增加还是删除，都提供队首或队尾操作 实现数据结构队列的操作时：从队尾插入，从队首取出，模拟 FIFO 过程 实现数据结构栈的操作时：从队首插入，从队首取出，模拟 LIFO 过程 支持指定元素操作：从队首开始删除第一个匹配的指定元素 removeFirstOccurrence/remove ，从队尾开始删除第一个匹配的指定元素 removeLastOccurrence ，判断是否包含指定元素 contains 支持双端遍历：从队首开始遍历 iterator ；从队尾开始遍历 descendingIterator Set 接口1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;...&#125; Set 继承了 Collection ，并没有增加任何新的方法，特点是集合中没有重复元素，最多只允许一个 null 元素。Set 的实现类都是基于 Map 来实现的：HashSet 是通过 HashMap 实现的；TreeSet 是通过 TreeMap 实现的。 Map 接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public interface Map&lt;K,V&gt; &#123; int size(); boolean isEmpty(); boolean containsKey(Object key); boolean containsValue(Object value); V get(Object key); V put(K key, V value); V remove(Object key); void putAll(Map&lt;? extends K, ? extends V&gt; m); void clear(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); boolean equals(Object o); int hashCode(); default V getOrDefault(Object key, V defaultValue) &#123;...&#125; // 遍历图中所有元素，每个元素按照指定方法操作 default void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123;...&#125; // 遍历图中所有元素，每个元素按照指定方法操作后的结果，替换键对应的值 default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123;...&#125; // 键对应的值为空时，存储该键值对 default V putIfAbsent(K key, V value) &#123;...&#125; // 移除指定键值对 default boolean remove(Object key, Object value) &#123;...&#125; // 使用新值替换存在的键值对 default boolean replace(K key, V oldValue, V newValue) &#123;...&#125; // 替换指定键对应的值 default V replace(K key, V value) &#123;...&#125; // 键值不存在时，使用指定方法计算后，再存储键值对 default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123;...&#125; // 键值对存在时，使用指定方法计算后，更新键值对 default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;...&#125; // 如果键值存在则移除；如果不存在，使用指定方法计算后存储键值对 default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;...&#125; // 使用给定键值对，或者指定方法，更新当前键值对 default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123;...&#125; interface Entry&lt;K,V&gt; &#123; K getKey(); V getValue(); V setValue(V value); boolean equals(Object o); int hashCode(); public static &lt;K extends Comparable&lt;? super K&gt;, V&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByKey() &#123; return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getKey().compareTo(c2.getKey()); &#125; public static &lt;K, V extends Comparable&lt;? super V&gt;&gt; Comparator&lt;Map.Entry&lt;K,V&gt;&gt; comparingByValue() &#123; return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; c1.getValue().compareTo(c2.getValue()); &#125; public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByKey(Comparator&lt;? super K&gt; cmp) &#123; Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getKey(), c2.getKey()); &#125; public static &lt;K, V&gt; Comparator&lt;Map.Entry&lt;K, V&gt;&gt; comparingByValue(Comparator&lt;? super V&gt; cmp) &#123; Objects.requireNonNull(cmp); return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (c1, c2) -&gt; cmp.compare(c1.getValue(), c2.getValue()); &#125; &#125;&#125; Map.Entry 接口表示 Map 的每个基本元素，它提供如下功能： getKey 获取当前元素的键 getValue/setValue 获取和设置当前元素的值 判断当前元素是否相等 hashCode, equals 按键比较元素 comparingByKey ，支持指定比较器 按值比较元素 comparingByValue ，支持指定比较器 Map 接口提供的功能包含： 基本操作：大小，判断是否为空，是否包含键，是否包含值，清除图中所有元素，是否相等 键值对相关操作 集合操作：获取图中所有键 keySet，获取图中所有值 values，获取图中所有元素 entrySet 整个图操作：forEach 遍历图中所有元素，每个元素按照指定方法操作；replaceAll 遍历图中所有元素，每个元素按照指定方法操作后的结果，替换键对应的值 SoretedSet 接口123456789public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123; Comparator&lt;? super E&gt; comparator(); SortedSet&lt;E&gt; subSet(E fromElement, E toElement); SortedSet&lt;E&gt; headSet(E toElement); SortedSet&lt;E&gt; tailSet(E fromElement); E first(); E last(); default Spliterator&lt;E&gt; spliterator() &#123;...&#125;&#125; SoretedSet 接口根据对象的比较顺序排序的集合。 NavigableSet 接口123456789101112131415161718public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123; E lower(E e); E floor(E e); E ceiling(E e); E higher(E e); E pollFirst(); E pollLast(); Iterator&lt;E&gt; iterator(); NavigableSet&lt;E&gt; descendingSet(); Iterator&lt;E&gt; descendingIterator(); NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive); NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive); SortedSet&lt;E&gt; subSet(E fromElement, E toElement); SortedSet&lt;E&gt; headSet(E toElement); SortedSet&lt;E&gt; tailSet(E fromElement);&#125; NavigableSet 接口继承了 SoretedSet，所以它是有序的；具有导航方法返回小于、小于等于、大于等于、大于给定元素的元素。 SoretedMap 接口1234567891011public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123; Comparator&lt;? super K&gt; comparator(); SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey); SortedMap&lt;K,V&gt; headMap(K toKey); SortedMap&lt;K,V&gt; tailMap(K fromKey); K firstKey(); K lastKey(); Set&lt;K&gt; keySet(); Collection&lt;V&gt; values(); Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();&#125; SoretedMap 接口表示按照键值升序排序的 Map，也可以按照指定比较器排序。 NavigableMap 接口123456789101112131415161718192021222324public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123; Map.Entry&lt;K,V&gt; lowerEntry(K key); K lowerKey(K key); Map.Entry&lt;K,V&gt; floorEntry(K key); K floorKey(K key); Map.Entry&lt;K,V&gt; ceilingEntry(K key); K ceilingKey(K key); Map.Entry&lt;K,V&gt; higherEntry(K key); K higherKey(K key); Map.Entry&lt;K,V&gt; firstEntry(); Map.Entry&lt;K,V&gt; lastEntry(); Map.Entry&lt;K,V&gt; pollFirstEntry(); Map.Entry&lt;K,V&gt; pollLastEntry(); NavigableMap&lt;K,V&gt; descendingMap(); NavigableSet&lt;K&gt; navigableKeySet(); NavigableSet&lt;K&gt; descendingKeySet(); NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive); NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive); SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey); SortedMap&lt;K,V&gt; headMap(K toKey); SortedMap&lt;K,V&gt; tailMap(K fromKey);&#125; NavigableMap 接口继承了 SortedMap，所以它是有序的；具有针对给定搜索目标返回最接近匹配项的导航方法，比如小于、小于等于、大于、大于等于某个键的元素等。 抽象实现类AbstractCollection 抽象类12345678910111213141516171819202122public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123; protected AbstractCollection() &#123;&#125; public abstract Iterator&lt;E&gt; iterator(); public abstract int size(); public boolean isEmpty() &#123; return size() == 0; &#125; public boolean contains(Object o) &#123;...&#125; public Object[] toArray() &#123;...&#125; public &lt;T&gt; T[] toArray(T[] a) &#123;...&#125; public boolean add(E e) &#123; throw new UnsupportedOperationException(); &#125; public boolean remove(Object o) &#123;...&#125; public boolean containsAll(Collection&lt;?&gt; c) &#123;...&#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;...&#125; public boolean removeAll(Collection&lt;?&gt; c) &#123;...&#125; public boolean retainAll(Collection&lt;?&gt; c) &#123;...&#125; public void clear() &#123;...&#125; public String toString() &#123;...&#125;&#125; 抽象集合类 AbstractCollection 中，已经实现的方法，基本都是使用最原始的迭代器 Iterator 来遍历实现的；但 iterator 方法是抽象的，也就是说迭代器由具体类来实现。 抽象类包含两个抽象方法：iterator, size add 方法必须由子类重写，否则抛出异常 AbstractList 抽象类1234567891011121314151617181920212223242526272829303132333435363738394041424344public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; protected AbstractList() &#123;&#125; public boolean add(E e) &#123; add(size(), e); return true; &#125; abstract public E get(int index); public E set(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; public int indexOf(Object o) &#123;...&#125; public int lastIndexOf(Object o) &#123;...&#125; public void clear() &#123; removeRange(0, size()); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;...&#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; public ListIterator&lt;E&gt; listIterator() &#123; return listIterator(0); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123;...&#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return (this instanceof RandomAccess ? new RandomAccessSubList&lt;&gt;(this, fromIndex, toIndex) : new SubList&lt;&gt;(this, fromIndex, toIndex)); &#125; public boolean equals(Object o) &#123;...&#125; public int hashCode() &#123;...&#125; private class Itr implements Iterator&lt;E&gt; &#123;...&#125; private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123;...&#125; class SubList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;...&#125; class RandomAccessSubList&lt;E&gt; extends SubList&lt;E&gt; implements RandomAccess &#123;...&#125;&#125; 几个内部类及对应功能： Itr ：迭代器的普通实现，顺序迭代 ListItr ：迭代器实现了 ListIterator ，即支持向前，也支持向后迭代 SubList ：AbstractList 列表的一部分，从开始到结束索引这部分的列表 RandomAccessSubList ：支持随机访问 AbstractSequentialList 抽象类123456789101112131415161718192021222324252627public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt; &#123; protected AbstractSequentialList() &#123;&#125; public E get(int index) &#123; try &#123; return listIterator(index).next(); &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException("Index: "+index); &#125; &#125; public E set(int index, E element) &#123; try &#123; ListIterator&lt;E&gt; e = listIterator(index); E oldVal = e.next(); e.set(element); return oldVal; &#125; catch (NoSuchElementException exc) &#123; throw new IndexOutOfBoundsException("Index: "+index); &#125; &#125; public void add(int index, E element) &#123;...&#125; public E remove(int index) &#123;...&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;...&#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public abstract ListIterator&lt;E&gt; listIterator(int index);&#125; AbstractSequentialList 抽象类继承了 AbstractList，重写了添加、删除、获取、设置等方法，从具体实现可以看出它只支持按次序访问；而 AbstractList 还支持随机访问的。唯一的抽象方法是 listIterator ，按照索引返回 ListIterator 迭代器。 AbstractQueue 抽象类12345678910111213141516171819202122232425262728293031public abstract class AbstractQueue&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Queue&lt;E&gt; &#123; protected AbstractQueue() &#123;&#125; public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException("Queue full"); &#125; public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException(); &#125; public E element() &#123; E x = peek(); if (x != null) return x; else throw new NoSuchElementException(); &#125; public void clear() &#123; while (poll() != null) ; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123;...&#125;&#125; AbstractQueue 抽象类实现了 Queue 接口的 add, remove, element 三个方法；Queue 接口定义的其他方法由子类去实现。 AbstractSet 抽象类12345678public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123; protected AbstractSet() &#123;&#125; public boolean equals(Object o) &#123;...&#125; public int hashCode() &#123;...&#125; public boolean removeAll(Collection&lt;?&gt; c) &#123;...&#125;&#125; AbstractSet 抽象类仅实现了 equals, hashCode, removeAll 三个方法。 AbstractMap 抽象类12345678910111213141516171819202122232425262728293031323334353637383940public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; protected AbstractMap() &#123;&#125; public int size() &#123; return entrySet().size(); &#125; public boolean isEmpty() &#123; return size() == 0; &#125; public boolean containsValue(Object value) &#123;...&#125; public boolean containsKey(Object key) &#123;...&#125; public V get(Object key) &#123;...&#125; public V put(K key, V value) &#123; throw new UnsupportedOperationException(); &#125; public V remove(Object key) &#123;...&#125; public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); &#125; public void clear() &#123; entrySet().clear(); &#125; transient volatile Set&lt;K&gt; keySet; transient volatile Collection&lt;V&gt; values; public Set&lt;K&gt; keySet() &#123;...&#125; public Collection&lt;V&gt; values() &#123;...&#125; public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet(); public boolean equals(Object o) &#123;...&#125; public int hashCode() &#123;...&#125; public String toString() &#123;...&#125; protected Object clone() throws CloneNotSupportedException &#123;...&#125; private static boolean eq(Object o1, Object o2) &#123; return o1 == null ? o2 == null : o1.equals(o2); &#125; public static class SimpleEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable &#123;...&#125; public static class SimpleImmutableEntry&lt;K,V&gt; implements Entry&lt;K,V&gt;, java.io.Serializable &#123;...&#125;&#125; 两个内部类，实现了 Entry 元素接口： SimpleEntry ：可以通过 set 修改值 SimpleImmutableEntry ：线程安全，不能通过 set 修改元素的值 AbstractMap 抽象类中，定义了数据存储方式： Set&lt;K&gt; keySet ：存储键，键是不可重复的，所以使用了 Set Collection&lt;V&gt; values ：存储值，普通集合满足 实现类分类常用集合实现类 存储方式分类任何数据结构的数据存储都只有两种：数组和链表；并基于这两种衍生出其他结构：树，hash 表，图等。本文介绍的集合，就按照其存储方式有： Hash table 哈希表实现：HashMap, HashSet Array 数组实现：ArrayList, ArrayDeque Tree 树实现：TreeMap, TreeSet Linked list 链表实现：LinkedList Hash table + Linked list 哈希表加链表混合实现：LinkedHashMap, LinkedHashSet 按照接口分类 List 接口：ArrayList, LinkedList, Vector, Stack Set 接口：HashSet, TreeSet, LinkedHashSet, EnumSet Map 接口：HashMap, TreeMap, LinkedHashMap, EnumMap Queue/Deque 接口：ArrayDeque, LinkedList ArrayList 及集合操作定义123456789public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... private static final int DEFAULT_CAPACITY = 10; transient Object[] elementData; // 动态数组的实际大小 private int size; ...&#125; ArrayList 的特点： 它是一个列表，支持随机访问，也支持顺序访问 是一个数组队列，支持容量动态扩展，每次扩展 1.5 倍 Object[] elementData 数组存储所有的元素，默认容量大小为 10 size 是动态数组的实际大小 不是线程安全的 遍历方式12345678910111213141516Iterator iterator = lists.iterator();while (iterator.hasNext()) &#123; value = (Integer) iterator.next(); System.out.print(value + " ");&#125;// Randomfor (int i = 0; i &lt; lists.size(); i++)&#123; value = lists.get(i); System.out.print(value + " ");&#125;// for-eachfor (Integer element : lists)&#123; System.out.print(element + " ");&#125; 不管是哪种遍历方式，访问顺序都是一样的，都是按照存入顺序访问的。集合中 for-each 访问效率是最高的，实际测试 ArrayList 也是如此。 数组转换12Object[] toArray();&lt;T&gt; T[] toArray(T[] contents); 其中 toArray() 可能会抛出现类型转换异常，通常使用泛型 toArray 实现： 1Integer[] values = lists.toArray(new Integer[0]); fail-fast 机制fail-fast 机制是集合 Collection 中的一种错误机制，当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件：即抛出 ConcurrentModificationException 异常。 1234567891011121314151617private void testFailFast()&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; for (Integer element : lists)&#123; System.out.print(element + " "); &#125; System.out.println(); &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; lists.remove(300); &#125; &#125;).start();&#125; 示例中，在线程遍历集合数据时，另一个线程删除了集合中的一个数据，因为 ArrayList 并不是线程安全的，所以会产生 fail-fast 事件。可以使用 concurrent 包中的 CopyOnWriterArrayList 来代替。 常用集合实现类LinkedList123456789101112131415161718192021public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; transient int size = 0; transient Node&lt;E&gt; first; transient Node&lt;E&gt; last; private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; ...&#125; LinkedList 的特点： 数据存储结构是链表实现，链表中每个元素使用 Node 表示，它记录了链表前后的元素，以及元素当前值 first 表示链表头结点；last 表示链表尾节点；size 表示链表中元素个数 链表顺序访问效率会非常高，随机访问需要遍历链表效率低 实现了 List 接口，并继承了 AbstractSequentialList，也就是可以当做列表使用；支持随机访问和顺序访问 实现了 Deque 接口，也就是可以当做双端队列使用，*实现了栈 LIFO 和队列 FIFO *两种数据结构 不是线程安全的 Vector1234567891011public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; protected Object[] elementData; protected int elementCount; ... public synchronized int size() &#123;...&#125; public synchronized boolean isEmpty() &#123;...&#125; ...&#125; Vector 的特点： 继承了 AbstractList 并实现了 List 接口，所以它是一个列表 Object[] elementData 数组存储所有的元素，该列表使用方法同 ArrayList 类似 所有的方法都是用了 synchronized 关键字，也就是说 Vector 是线程安全的 Stack123456789public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; public Stack() &#123;&#125; public E push(E item) &#123;...&#125; public synchronized E pop() &#123;...&#125; public synchronized E peek() &#123;...&#125; public boolean empty() &#123;...&#125; public synchronized int search(Object o) &#123;...&#125; ...&#125; Stack 的特点： 继承了 Vector ，也就是说实质上只是一个同步的 ArrayList 实现了 push, pop, peek 方法，即可以当做栈来使用，可以认为是一个同步栈 HashMap12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;...&#125; HashMap 核心是使用了”数组+链表”的存储方式，使用拉链法解决冲突（将冲突的 key 的对象放入链表中），Java 1.8 中链表长度大于 8 时，链表转换为红黑树结构；参考：Java HashMap 简介 。HashMap 的 key, value 都可以为 null ；但只允许出现一个为 null 的键。 LinkedHashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; transient LinkedHashMap.Entry&lt;K,V&gt; head; transient LinkedHashMap.Entry&lt;K,V&gt; tail; final boolean accessOrder; public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false; &#125; public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false; &#125; public LinkedHashMap() &#123; super(); accessOrder = false; &#125; public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false); &#125; public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; ... private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; &#125; // 新建节点，新节点会插入链表尾部 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; &#125; // 如果按照访问顺序，每次读取一个元素时都会重新排序 public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value; &#125; // 访问后将该元素移动到链表尾部 void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123;...&#125; ... &#125; abstract class LinkedHashIterator &#123; LinkedHashMap.Entry&lt;K,V&gt; next; LinkedHashMap.Entry&lt;K,V&gt; current; ... LinkedHashIterator() &#123; next = head; ... &#125; public final boolean hasNext() &#123; return next != null; &#125; // 迭代器默认使用 final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123; LinkedHashMap.Entry&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); current = e; next = e.after; return e; &#125; ... &#125; final class LinkedEntryIterator extends LinkedHashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125; &#125; final class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; ... public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new LinkedEntryIterator(); &#125; ... &#125; // 遍历时返回 LinkedEntrySet public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new LinkedEntrySet()) : es; &#125; ...&#125; LinkedHashMap 类是哈希表+链表实现的集合，有如下几个特点： 继承 HashMap ，所以数据存储和 HashMap 一致 LinkedHashMap.Entry 中增加了 after, before 来记录当前元素的前后元素，形成链表 head, tail 表示元素链表的头和尾 accessOrder 表示 LinkedHashMap 的遍历顺序：true 表示按照访问顺序输出（也就是每次访问一个元素后，这个元素都会移动到链表尾部）， false 表示按照插入顺序输出（有序性）；该变量是 final 的，只在构造方法中赋值，默认为 false newNode 新建节点时，除了存储数据，同时会将该节点插入链表尾部 LinkedEntrySet 遍历时返回的数据集，数据迭代器是按照链表顺序输出的 accessOrder 特性： 访问顺序：利用这个特性可以实现 LRU: Least Recently Used 缓存，即最近最少使用原则；链表尾总是保存最近使用的元素，当数据过多时，总是删除链表头部元素 插入顺序：解决了 HashMap 元素随机遍历的问题，可以按照插入顺序输出元素 遍历时返回的是 LinkedEntrySet，而它使用的迭代器为 LinkedEntryIterator ，迭代器中重写了访问下一个元素的方式， nexNode 会从链表头部开始逐个访问。也就是说，遍历始终是从链表头部到尾部的： 插入顺序输出：当新建节点 newNode 时，该节点同时会插入链表尾部，即链表维持了插入顺序 访问顺序输出：当访问了一个节点后 get，会同时将被访问节点移动到尾部 afterNodeAccess，即链表维护了访问顺序（没有被访问过的还是插入顺序） HashTable123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;...&#125; HashTable 是一个线程安全的散列表，所有的方法都有 synchronized 关键字，但是通常推荐使用并发包中的 ConcurrentHashMap 。 TreeMap123public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;...&#125; TreeMap 类是红黑树的 Java 实现，存储有序的键值对；参考 算法 - 红黑树 。 HashSet1234567891011121314151617181920212223242526272829303132public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... private transient HashMap&lt;E,Object&gt; map; public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c); &#125; public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor); &#125; public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor); &#125; public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125; ...&#125; HashSet 表示没有重复元素的集合，它是由 HashMap 来实现数据存储的，所以不保证元素的顺序。有如下几个特点： HashSet 公开构造方法，默认使用的是 HashMap 存储数据；数据是无序的 HashSet 还有一个包内可见的构造方法，主要是供子类 LinkedHashSet 调用的，使用的是 LinkedHashMap 来存储数据；数据是有序的 HashSet 的每个元素对应 HashMap 中一个 key ，遍历时即是遍历所有的 key LinkedHashSet12345678910111213141516171819public class LinkedHashSet&lt;E&gt; extends HashSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; ... public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true); &#125; public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true); &#125; public LinkedHashSet() &#123; super(16, .75f, true); &#125; public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c); &#125; ...&#125; LinkedHashSet 继承 HashSet，并没有提供额外的功能，仅仅是构造方法调用父类设置容量、装载因子等，而最大的特点是只调用父类包内可见构造方法，即使用 LinkedHashMap 来存储数据，所以数据是有序的。 TreeSet1234567891011121314151617181920212223public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; private transient NavigableMap&lt;E,Object&gt; m; TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator)); &#125; public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; ...&#125; TreeSet 表示有序集合，从构造方法可以看出，它是由 TreeMap 实现的有序性。 ArrayDeque12345678public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable &#123; transient Object[] elements; transient int head; transient int tail; ...&#125; ArrayDeque 类是双端队列的数组实现： Object[] elements 数组存储双端队列元素 head, tail 表示队头和队尾索引 PriorityQueue12public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123;...&#125; PriorityQueue 类是优先队列的 Java 实现，默认为小根堆；参考 算法 - 优先队列 - 二叉堆 。 工具类Arrays123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class Arrays &#123; // 普通排序 public static void sort(int[] a) &#123; DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0); &#125; public static void sort(...) &#123;...&#125; // 并行排序 public static void parallelSort(int[] a) &#123; int n = a.length, p, g; if (n &lt;= MIN_ARRAY_SORT_GRAN || (p = ForkJoinPool.getCommonPoolParallelism()) == 1) DualPivotQuicksort.sort(a, 0, n - 1, null, 0, 0); else new ArraysParallelSortHelpers.FJInt.Sorter (null, a, new int[n], 0, n, 0, ((g = n / (p &lt;&lt; 2)) &lt;= MIN_ARRAY_SORT_GRAN) ? MIN_ARRAY_SORT_GRAN : g).invoke(); &#125; public static void parallelSort(...) &#123;...&#125; // 并行计算 public static &lt;T&gt; void parallelPrefix(T[] array, BinaryOperator&lt;T&gt; op) &#123; Objects.requireNonNull(op); if (array.length &gt; 0) new ArrayPrefixHelpers.CumulateTask&lt;&gt; (null, op, array, 0, array.length).invoke(); &#125; public static &lt;T&gt; void parallelPrefix(...) &#123;...&#125; // 二分查找 public static int binarySearch(int[] a, int key) &#123; return binarySearch0(a, 0, a.length, key); &#125; public static int binarySearch(...) &#123;...&#125; // 比较数组是否相同 public static boolean equals(int[] a, int[] a2) &#123; if (a==a2) return true; if (a==null || a2==null) return false; int length = a.length; if (a2.length != length) return false; for (int i=0; i&lt;length; i++) if (a[i] != a2[i]) return false; return true; &#125; public static boolean equals(...) &#123;...&#125; // 数据填充 public static void fill(int[] a, int val) &#123; for (int i = 0, len = a.length; i &lt; len; i++) a[i] = val; &#125; public static void fill(...) &#123;...&#125; // 数组拷贝 public static int[] copyOf(int[] original, int newLength) &#123; int[] copy = new int[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; public static int[] copyOf(...) &#123;...&#125; public static int[] copyOfRange(int[] original, int from, int to) &#123;...&#125; // 数组转换为列表 public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123;...&#125; // 数组计算 hashCode public static int hashCode(int a[]) &#123; if (a == null) return 0; int result = 1; for (int element : a) result = 31 * result + element; return result; &#125; public static int hashCode(...) &#123;...&#125; public static void setAll(int[] array, IntUnaryOperator generator) &#123; Objects.requireNonNull(generator); for (int i = 0; i &lt; array.length; i++) array[i] = generator.applyAsInt(i); &#125; public static void parallelSetAll(int[] array, IntUnaryOperator generator) &#123; Objects.requireNonNull(generator); IntStream.range(0, array.length) .parallel() .forEach(i -&gt; &#123; array[i] = generator.applyAsInt(i); &#125;); &#125; public static void setAll(...) &#123;...&#125; public static void parallelSetAll(...) &#123;...&#125; // 转换为流 public static IntStream stream(int[] array) &#123; return stream(array, 0, array.length); &#125; public static ... stream(...) &#123;...&#125; ...&#125; Arrays 主要提供的功能： sort 排序：使用 DualPivotQuicksort 对数组快速排序 parallelSort 并行排序：数据足够大时，使用 ArraysParallelSortHelpers 来排序，通过 ForkJoinTask 多线程排序 parallelPrefix 并行计算：对数组的每个元素，执行 BinaryOperator 二元计算（计算结果参与下一个元素继续计算）；也是多线程操作 binarySearch 对有序数组进行二分查找 equals 对给定两个数组进行比较，数组元素是否完全相同 fill 使用给定值对数组进行填充 copyOf 拷贝：将原有数组拷贝到指定新长度的数组中；数组动态扩容经常会有数组拷贝 asList 数组转换为列表 hashCode 计算给定数组的 hashCode setAll/parallelSetAll 根据给定计算公式，更新数组每个元素 stream 数组转换为流 Collections1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Collections &#123; public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)&#123; list.sort(null); &#125; public static &lt;T&gt; int binarySearch(...) &#123;...&#125; public static void reverse(List&lt;?&gt; list) &#123;...&#125; public static void shuffle(List&lt;?&gt; list) &#123;...&#125; public static void swap(List&lt;?&gt; list, int i, int j) &#123;...&#125; public static &lt;T&gt; void fill(List&lt;? super T&gt; list, T obj) &#123;...&#125; public static &lt;T&gt; void copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src) &#123;...&#125; public static void rotate(List&lt;?&gt; list, int distance) &#123;...&#125; public static &lt;T&gt; boolean replaceAll(List&lt;T&gt; list, T oldVal, T newVal) &#123;...&#125; public static int indexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target)&#123;...&#125; public static int lastIndexOfSubList(List&lt;?&gt; source, List&lt;?&gt; target) &#123;...&#125; public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) &#123;...&#125; public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) &#123;...&#125; public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection( Collection&lt;? extends T&gt; c) &#123; return new UnmodifiableCollection&lt;&gt;(c); &#125; public static &lt;T&gt; ...&lt;T&gt; unmodifiable...(...)&#123;...&#125; public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection( Collection&lt;T&gt; c) &#123; return new SynchronizedCollection&lt;&gt;(c); &#125; public static &lt;T&gt; ...&lt;T&gt; synchronized...(...)&#123;...&#125; public static &lt;E&gt; Collection&lt;E&gt; checkedCollection( Collection&lt;E&gt; c, Class&lt;E&gt; type) &#123; return new CheckedCollection&lt;&gt;(c, type); &#125; public static &lt;E&gt; ...&lt;E&gt; checked...(...)&#123;...&#125; public static final &lt;T&gt; List&lt;T&gt; emptyList() &#123; return (List&lt;T&gt;) EMPTY_LIST; &#125; public static final &lt;T&gt; ...&lt;T&gt; empty...() &#123;...&#125; public static &lt;T&gt; List&lt;T&gt; singletonList(T o) &#123; return new SingletonList&lt;&gt;(o); &#125; public static &lt;T&gt; ...&lt;T&gt; singleton...(...) &#123;...&#125; public static int frequency(Collection&lt;?&gt; c, Object o) &#123;...&#125; public static boolean disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2) &#123;...&#125; public static &lt;T&gt; Queue&lt;T&gt; asLifoQueue(Deque&lt;T&gt; deque) &#123; return new AsLIFOQueue&lt;&gt;(deque); &#125; ...&#125; Collections 主要提供的功能： sort 列表按照给定比较器排序 binarySearch 已经排好序的列表，二分查找 reverse 反转列表中的元素 shuffle 将列表随机移位；特别是算法中，避免出现最坏时间复杂度，通常需要将输入序列打乱 swap 交换列表中的两个元素 fill 列表中填充指定元素 copy 拷贝列表中的元素到另一个列表 rotate 将列表中的元素循环移位 distance ，默认向左移动 indexOfSubList 如果子列表存在，返回索引值 replaceAll 将列表中所有指定旧元素替换为新元素 min, max 找出集合中的最小值，最大值 unmodifiableCollection 根据给定集合，返回一个不可修改的集合；相当于集合每个元素及状态 final synchronizedCollection 根据给定集合，返回一个同步操作的集合；该集合上所有的操作都是同步的，线程安全的 checkedCollection 根据给定集合，返回一个类型检查的集合；集合上的添加等操作，会做类型检查 emptyList 返回一个空的列表；返回空集合操作 singletonList 返回单个元素列表；单个元素集合操作 frequency 返回集合中元素出现的次数 disjoint 判断两个集合是否有共同元素；有则返回 true asLifoQueue 双端队列转换为 LIFO 先进先出队列 集合间异同集合和数组 数组大小固定，同一个数组只能存放一种基本类型或者对象。定义时需要声明存储类型。 集合大小动态改变，只能存储对象。集合是对数组的封装，所以数组比集合存取速度要快。 12345678// 1. 数组int[] a = new int[5];String[] s = new String[1];// 2. 集合List&lt;String&gt; list = new ArrayList&lt;String&gt;();Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();// List存放Map数据列表List&lt;Map&lt;String, Object&gt;&gt; myData = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); List 接口 AbstractList, AbstractSequentialListAbstractList 既支持随机访问，也支持顺序访问；AbstractSequentialList 只支持顺序访问。 ArrayList数组列表，支持数组动态扩容；数组特性：访问效率高，插入和删除需要移动数据效率低；非线程安全。 LinkedList链表列表，双向链表；链表特性：插入和删除效率高，访问效率低；非线程安全。 Vector数组列表的同步实现，拥有 ArrayList 使用特性，但是是线程安全的。 Stack继承 Vector，模拟了栈的特性 LIFO ，是线程安全的。 Map 接口 Map, SortedMap, NavigableMapMap 的三个基本接口；SoretedMap 表示存储有序的键值对；NavigableMap 继承了 SoretedMap ，额外提供键值对导航方法，支持大于、小于、小于等于等操作。 HashMap基于拉链法实现的散列表，使用数组+链表存储键值对；链表长度大于 8 时转换为红黑树；非线程安全。 HashTable线程安全的散列表，不过通常建议使用并发包中的 ConcurrentHashMap 来代替。 TreeMap红黑树的 Java 实现，散列表中存储的键值对是无序的，但按大小排序；非线程安全。 LinkedHashMap实现方式为：链表+散列表；HashMap 存储数据，链表保持元素的有序性；非线程安全。 Set 接口 HashSetHashSet 依赖于 HashMap，它实际上是通过 HashMap 实现的。HashSet 中的元素是无序的；非线程安全。 TreeSetTreeSet 依赖于 TreeMap，它实际上是通过 TreeMap 实现的。TreeSet 中的元素是无序的，但按大小排序；非线程安全。 LinkedHashSetHashSet 依赖于 LinkedHashMap，它实际上是通过 LinkedHashMap 实现的。LinkedHashSet 的元素是有序的；非线程安全。 Queue/Deque 接口 LinkedList双端队列的链表实现。 ArrayDeque双端队列的数组实现。 PriorityQueue优先队列的 Java 实现，默认为小根堆。 小结在使用中，集合的选取主要从多线程环境、数据访问的特性（数组、链表）、有序性、使用哪种接口来考虑。 其他有序无序有序、无序是指在进行插入操作时，插入位置的顺序性；先加入的元素位置在前，后加入的元素位置在后，这就是有序，反之为无序。所以通常所说 List 是有序的，指的是加入和删除元素都是按照加入顺序进行；而 Set 通常是通过 Map 来实现的，元素加入顺序为随机的。而和有序性容易混淆的是排序，排序是指集合内的元素是否按照升序或降序来排序，和插入顺序并没有关系。 动态扩容特性如果使用数组来存储元素，集合默认都是支持动态扩容的，但是动态扩容涉及到整个数组拷贝，所以在使用集合前，预估集合数据大小，减少扩容次数能提高效率。 线程安全java.util 包中的集合大部分都不是线程安全的：ArrayList, LinkedList, HashMap, TreeMap, HashSet, TreeSet, ArrayDeque, PriorityQueue 等，只有 Vector, Stack, HashTable 是线程安全的。在多线程环境下，建议使用并发包中的集合：CopyOnWriterArrayList, ConcurrentHashMap 等。 遍历通常 Collection 接口实现类都使用 for-each 遍历；Map 接口实现类使用 entrySet 来遍历。 12345678910111213141516// 1. 遍历 CollectionArrayList&lt;Integer&gt; lists = new ArrayList&lt;&gt;();...for (Integer element : lists)&#123; System.out.print(element + " ");&#125;// 2. 遍历 Map Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();...for(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123; String key = entry.getKey(); String value = entry.getValue(); // 也可以通过key，获取value // String value = map.get(key);&#125; 后续 每个集合类源码分析 并发包中的集合 Google Guava 中的集合 参考文档 Java tutorial Java 8 API Java 8 API: Collection Java 8 API: Map Java 集合框架 集合类图 IBM 系列：Java 集合框架 Java集合之LinkedHashMap Java集合类: Set、List、Map、Queue使用场景梳理 Java 集合常见问题 Java 集合系列 Java8 增强工具类 Arrays 笔记 集合系列 Arrays和Collections工具类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Executor 框架]]></title>
    <url>%2F2017%2F11%2F17%2F0007-java-executor%2F</url>
    <content type="text"><![CDATA[背景大多数并发应用程序都是围绕“任务执行（Task Execution）”来构造的：任务通常是些抽象且离散的工作单元。任务执行时应该选择清晰的任务边界以及明确的任务执行策略。执行策略有如下几种： 串行执行在多任务中执行性能太差，只能一个个顺序处理，无法提高吞吐率或快速响应性 显示创建线程new Thread(task).start()：显示创建。但是大量创建会有如下问题：线程生命周期开销非常高；资源消耗：尤其是内存，当可运行线程数量多于处理器数量时，会出现大量闲置进程，会占用很多内存，线程竞争 CPU 资源时也会产生性能消耗；稳定性； 使用并发框架如：Executor 框架 Executor 框架简介该框架基于生产者-消费者模式，支持多种不同类型的任务执行策略，提供了标准方法将任务的提交和执行解耦，并用 Runnable 来表示任务。提供了对生命周期的支持，以及统计信息收集，程序管理和性能监视等。 接口定义123public interface Executor &#123; void execute(Runnable command);&#125; 执行策略在执行策略中定义了任务执行的“What, Where, When, How”等方面： 在什么（What）线程中执行任务？ 任务按照什么（What）顺序执行（FIFO, LIFO，优先级）？ 有多少个（How Many）任务能并发执行？ 在队列中有多少个（How Many）任务在等待执行？ 如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？ 执行策略是资源管理工具，最佳策略取决于可用的计算资源以及服务质量的需求。通过限制并发任务的数量，可用确保应用程序不会由于资源耗尽而失败，或者由于资源竞争影响性能。 Executor 框架类图结构 Executor接口定义了一个接收 Runnable 对象的方法 execute ExecutorService比 Executor 使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回 Future 的方法 AbstractExecutorService抽象类，ExecutorService 执行方法的默认实现 ScheduledExecutorService接口，可定时调度任务 ThreadPoolExecutor线程池的核心实现类，用来执行被提交的任务 ScheduledThreadPoolExecutor继承 ThreadPoolExecutor并实现ScheduledExecutorService ，一个可定时调度任务的线程池 Executors提供了一系列静态工厂方法和共用方法，创建 Executor 框架的相关类：ExecutorService, ScheduledExecuorSevice, ThreadFactor, Callable... 初识线程池线程池是指管理一组同构工作线程的资源池，其中工作队列（Work Queue）保存了所有等待执行的任务，工作者线程（Worker Thread）的任务很简单：从工作队列中获取一个任务，执行任务，然后返回线程池并等待下一个任务。通过重用线程池中现有线程而不是创建新线程，可以在处理多个请求时分摊线程创建和销毁的巨大开销；另外任务请求到达时，工作线程已经存在，提高了响应性；调整线程池大小，可以防止过多线程相互竞争资源导致耗尽内存 基本接口Runnable 接口定义123public interface Runnable &#123; public abstract void run();&#125; 可以看到 Runnable 是没有返回值的 Callable 接口定义123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 在多线程并发中，我们需要获取任务的执行结果，显然 Runnable 无法实现。所以重新定义了 Callable 返回任务结果 V 或者抛出异常。 Future 接口定义12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; Future 表示异步执行的结果。可以对具体的 Runnable 或者 Callable 任务进行取消、查询是否取消/完成、获取结果。通过 get 方法获取执行结果，该方法会阻塞直到任务返回结果。 RunnableFuture 接口定义123public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; RunnableFuture 可被执行并能异步获取结果。 FutureTask 类RunnableAdapter 类123456789101112static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; 作用：将 Runnable 和 result 封装成 Callable。这个适配器很简单，就是简单的实现了 Callable 接口，在 call() 实现中调用Runnable.run() 方法，然后把传入的 result 作为任务的结果返回。 FutureTask 类定义1234public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; public FutureTask(Callable&lt;V&gt; callable) &#123;...&#125; public FutureTask(Runnable runnable, V result) &#123;...&#125;&#125; 可以通过构造函数注入 Runnable 或 Callable。如果传入的是 Runnable 和 result， 将通过 RunnableAdapter 封装成 Callable。 FutureTask 是 RunnableFuture 的实现类，既能当做一个 Runnable 直接被 Thread 执行，也能作为 Future 用来得到执行结果（构造函数传入的 Callable 的结果）或者抛出异常。通常作为任务提交后的异步返回的结果，也可以用来取消任务等。 任务运行的状态及转换FutureTask 在任务执行过程中，记录了如下 7 种状态： NEW：新建 COMPLETING任务已经执行完成，但是任务的结果还在保存中 NORMAL任务执行完后的结果正常 EXCEPTIONAL任务执行完后的结果异常 CANCELLED：取消任务还没开始执行或者已经开始执行但是还没有执行完成的时候被取消 INTERRUPTING：中断中 INTERRUPTED：已经被中断 可能出现的状态转换： 1234NEW -&gt; COMPLETING -&gt; NORMALNEW -&gt; COMPLETING -&gt; EXCEPTIONALNEW -&gt; CANCELLEDNEW -&gt; INTERRUPTING -&gt; INTERRUPTED 任务在构造函数中初始化的状态都是 NEW，所有流程都是以此为起点。 任务执行任务执行是执行者调用的，不用主动去执行 1234567891011121314151617181920212223242526272829303132public void run() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 可以从源码中得到这几个信息： 任务运行前，状态一定是 NEW 调用传入的Callable.call 执行任务 正确执行，保存执行结果 Callable 的 result 抛出异常时，保存异常 Throwable ExecutorService生命周期ExecutorService 的生命周期有三种状态：运行，关闭和终止。 生命周期管理ExecutorService 提供了管理 Executor 生命周期的方法： 123456void shutdown();List&lt;Runnable&gt; shutdownNow();boolean isShutdown();boolean isTerminated();boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; ExecutorService 在初始创建时处于运行状态 shutdown 方法将会执行平缓的关闭过程：不再接受新的任务，同时等待提交的任务执行完成（包含那些还未开始执行的任务） shutdownNow 方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，而且不再启动队列中尚未开始执行的任务。 提交任务123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); 不管是 Runnable 还是 Callable 都可以作为任务提交，在执行 submit 时都会将任务封装成 Future 的实现类实例，调用 Executor.execute 来执行，并同时作为结果返回。 线程池类定义及构造方法12345678public class ThreadPoolExecutor extends AbstractExecutorService &#123; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;...&#125; ...&#125; 参数说明： corePoolSize核心池线程数大小 maximumPoolSize线程池允许创建线程数最大值 keepAliveTime空闲线程存活时间：如果工作线程数多于 corePoolSize，则这些多的线程的空闲时间超过 keepAliveTime 时将被终止 unitkeepAliveTime 参数的时间单位 workQueue缓存任务的阻塞队列 threadFactory使用 ThreadFactory 创建新线程，默认使用 defaultThreadFactory 创建线程 handle定义处理被拒绝任务的策略，默认使用 ThreadPoolExecutor.AbortPolicy，任务被拒绝时将抛出 RejectExecutorException 几个重要成员变量1234567891011121314151617181920212223// 核心线程池大小private volatile int corePoolSize; // 线程池最大值private volatile int maximumPoolSize; // 超过 corePoolSize外的线程空闲存活之间private volatile long keepAliveTime; // 任务缓存队列，用来保存等待中的任务，等待 worker 线程空闲时执行任务private final BlockingQueue&lt;Runnable&gt; workQueue; // 线程工厂，用来新建线程private volatile ThreadFactory threadFactory; // 任务拒绝策略private volatile RejectedExecutionHandler handler; // 更新 poolSize, corePoolSize,maximumPoolSize, runState, and workers set 时需要持有这个锁private final ReentrantLock mainLock = new ReentrantLock(); // 用来保存工作中的执行线程private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); // 是否对 corePoolSize 内的线程设置空闲存活时间private volatile boolean allowCoreThreadTimeOut; // 记录线程池中出现过的最大线程数大小private int largestPoolSize;// 已经执行完的线程数private long completedTaskCount; 线程池的优势合理利用线程池能够带来三个好处： 降低资源消耗通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 线程池的大小一般需要根据任务的类型来配置线程池大小： CPU 密集型任务就需要尽量压榨 CPU，参考值可以设为 NCPU + 1 IO 密集型任务参考值可以设置为 2*NCPU 可以先将线程池大小设置为参考值，再观察任务运行情况和系统负载、资源利用率来进行适当调整。 线程池计数及状态定义123456789101112131415private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;// Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 计数及状态解析使用 AtomicInteger ctl 一个值，来同时表示当前线程数和线程池的状态。其中： runState： 高 3 位，表示线程池状态 workerCount：剩下的 29 位，表示当前线程池的工作线程数 COUNT_BITS：表示线程数计数的位数为 29 CAPACITY：表示最大的工作线程数计数容量 ctlOf：表示将状态和计数组合成一个值 runStateOf：从 ctl 中解析状态 workerCountOf：从 ctl 中解析线程计数 计数增减使用 CAS: Compare And Set 算法（无锁算法）实现共享变量 ctl 的自增自减（复合）操作，尽量确保多线程安全： 123456789101112131415private boolean compareAndIncrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect + 1);&#125;private boolean compareAndDecrementWorkerCount(int expect) &#123; return ctl.compareAndSet(expect, expect - 1);&#125;/** * Decrements the workerCount field of ctl. This is called only on * abrupt termination of a thread (see processWorkerExit). Other * decrements are performed within getTask. */private void decrementWorkerCount() &#123; do &#123;&#125; while (! compareAndDecrementWorkerCount(ctl.get()));&#125; 五种状态 RUNNING接受新任务并处理队列中的任务 SHUTDOWN不接受新任务但仍然处理队列中的任务 STOP不接受新任务，也不处理队列中的任务，并且设置正在进行中任务的中断标志位 TIDYING所有任务都结束了，wokrCount 设置为 0，并调用钩子方法 terminated() TERMINATED钩子方法 terminated() 执行完毕 状态转移及其含义 RUNNING -&gt; SHUTDOWN调用 shutdown()，可能出现在 finalize 中调用 (RUNNING or SHUTDOWN) -&gt; STOP调用 shutdownNow() STOP -&gt; TIDYING当线程池为空时 TIDYING -&gt; TERMINATED当钩子方法 terminated() 执行完毕时 线程池中线程创建及任务执行Worker 工作线程类类定义 12345678910111213141516private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; runWorker(this); &#125; ...&#125; AQS: AbstractQueuedSynchronizer： 用来做锁控制的，分为：独享功能和共享功能 Worker 实现了 AQS 独占锁功能，主要维护任务执行线程的中断控制状态 Worker 实现了 Runnable 并封装了任务（Runnable）和线程 线程池的所有线程都是在 Worker 的构造方法中通过线程工厂新建的 Worker.run 直接调用了线程池的 runWorker(this)，可以参考后面的分析 任务提交及线程创建策略12345678910111213141516171819public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; else if (!addWorker(command, false)) reject(command);&#125; 任务执行 execute 源码很短，流程也很清晰：异步执行一个指定的任务，可以新开一个线程或者线程池中已有的线程来执行。如果线程池已经处于关闭状态（不是RUNNING 状态，只有该状态才会接受新任务）或者已经达到最大容量（maximumPoolSize），将会拒绝该任务。源码分析： 如果任务为空，直接抛出空指针异常 workerCount/wc = workerCountOf(ctl.get())：线程池中的当前线程数 如果 workerCount &lt; corePoolSize，每次都会新建一个 Worker 线程去执行这个任务 如果 workerCount &gt;= corePoolSize，则每来一个任务会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行 如果队列添加失败（一般来说是任务缓存队列已满），直接尝试新建线程（前提条件：workerCount &lt; maximumPoolSize）执行该任务，如果新建失败拒绝服务 线程创建12345678910111213141516171819202122232425262728293031323334353637383940414243444546private boolean addWorker(Runnable firstTask, boolean core) &#123; ... // 状态判断 RUNNING 才能接受新任务 // 线程数计数判断 workerCount, wc &gt;= (core ? corePoolSize : maximumPoolSize) boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; // 新建 Worker 工作线程 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); // 添加到 set 中 workers.add(w); int s = workers.size(); // 线程池大小存在动态调整，记录largestPoolSize if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; // 添加成功后，开启线程准备异步执行 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) add 源码中可以看到，在新建的 Worker 工作线程开始执行前，会反复确认线程池状态（RUNNING），并且加锁二次判断后，添加到 HashSet 中保存所有的执行线程，添加成功则开始执行任务，同时记录线程池曾经出现的最大线程数 largestPoolSize。 任务运行123456789101112131415161718192021222324252627282930313233343536373839404142434445final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; // 如果任务不为空，执行当前任务； // 如果任务为空，线程复用，从缓冲队列中拿出任务执行 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; // 钩子方法，任务执行前调用 beforeExecute(wt, task); Throwable thrown = null; try &#123; // 任务正式开始运行 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; // 钩子方法，任务执行后调用 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; 源码可以看出： Worker 线程先执行当前任务，如果执行完毕会复用该线程，从阻塞队列中获取排队的任务继续执行 任务执行前会将当前 Worker 加锁，避免在任务执行过程中被线程池中断 任务执行前后有钩子方法可以调用 beforeExecute/afterExecute 从缓冲队列中获取任务123456789101112131415161718192021222324252627private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; // 状态检查 ... int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; // 线程数检查 ... try &#123; Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 源码分析： 取任务前先对线程池状态和当前线程数做判断，是否符合要求 如果允许空闲线程存活 allowCoreThreadTimeOut || wc &gt; corePoolSize，则缓存队列最多等待 keepAliveTime 时间任务入队；否则队列中阻塞等待取出任务 阻塞队列在线程池中的作用 队列大小和最大池大小可能需要相互折衷： 大型队列 + 小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。 小型队列 + 大型池CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 常见队列及特性在前面我们多次提到了任务缓存队列，即 workQueue，它用来存放等待执行的任务。workQueue 的类型为 BlockingQueue&lt;Runnable&gt;，通常可以取下面三种类型： ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小 LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为 Integer.MAX_VALUE，是一个无界队列 synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务 拒绝策略在线程池中的作用四个策略都在线程池中都是内部类。 常见策略及特性12private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize，如果还有任务到来就会采取任务拒绝策略，通常有以下四种策略： ThreadPoolExecutor.AbortPolicy丢弃任务并抛出 RejectedExecutionException 异常。 ThreadPoolExecutor.DiscardPolicy不能执行的任务被丢弃，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。 ThreadPoolExecutor.CallerRunsPolicy调用线程处理该任务，线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。 使用方式原理通信机制Executors创建常见线程池 固定长度线程池1234567891011public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; 创建一个固定长度的线程池，每提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化（除非某个线程异常结束后会补充一个新线程）。特点：可以重用固定数量线程的线程池，处理一个共享的无边界队列 。任何时间点，最多有 nThreads 个线程会处于活动状态执行任务。如果当所有线程都是活动时，有多的任务被提交过来，那么它会一致在队列中等待直到有线程可用。如果任何线程在执行过程中因为错误而中止，新的线程会替代它的位置来执行后续的任务。所有线程都会一致存于线程池中，直到显式的执行 ExecutorService.shutdown() 关闭。LinkedBlockingQueue 作为线程池的工作队列，是一个无界队列，当线程池的线程数达到 corePoolSize 后，新任务将在无界队列中等待，因此线程池的线程数量不会超过 corePoolSize，同时 maxiumPoolSize 也就变成了一个无效的参数，并且运行中的线程池并不会拒绝任务。 可缓存无限容量线程池 1234567891011public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; corePoolSize = 0; maxiumPoolSize = Integer.MAX_VALUE，即线程池的规模不做限制是无界的。在线程可用时，重用之前构造好的池中线程。这个线程池在执行大量短生命周期的异步任务时（many short-lived asynchronous task），可以显著提高程序性能。调用 execute 时，可以重用之前已构造的可用线程，如果不存在可用线程，那么会重新创建一个新的线程并将其加入到线程池中。如果线程超过 60 秒还未被使用，就会被中止并从缓存中移除。因此线程池在长时间空闲后不会消耗任何资源。 单线程池 12345678910111213public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125; 特殊的固定长度线程池，只有一个线程来执行任务，可以确保任务按照队列中的顺序串行执行。使用单个工作线程来执行一个无边界的队列。（如果单个线程在执行过程中因为某些错误中止，新的线程会替代它执行后续线程）。它可以保证认为是按顺序执行的，任何时候都不会有多于一个的任务处于活动状态。和 newFixedThreadPool(1) 的区别在于，如果线程遇到错误中止，它是无法使用替代线程的。 延时线程池 12345678910111213141516public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1));&#125;public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) &#123; return new DelegatedScheduledExecutorService (new ScheduledThreadPoolExecutor(1, threadFactory));&#125;public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 延迟线程池的构造函数中：maxiumPoolSize = Integer.MAX_VALUE，表明线程池最大容量是无界的。以延迟或定时的方式来执行任务。 示例先简单总结下 Runnable, Callable, Future, FutureTask 和 ExecutorService.submit 的关系和概念： Runnable：作为 submit 的参数，不需要返回值 Callable：作为 submit 的参数，并定义返回值类型 Future表示异步执行的返回值。作为 submit 的返回值，实际是对 Callable 返回值的一个再次封装。 FutureTask作为 submit 的参数，但是因为实现了 Future 所以同时包含了 submit 的返回值。查看源码发现上面的 Runnable, Callable 都会先被封装成 FutureTask 再去执行 submit。 Runnable并不关心返回结果。 1234567891011121314151617181920212223public class TestRunnable &#123; public static void main(String[] args) &#123; ExecutorService single = Executors.newSingleThreadExecutor(); single.submit(new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println("TestRunnable::run..."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); single.shutdown(); System.out.println("TestRunnable::main exit."); &#125;&#125;// 运行结果TestRunnable::main exit.TestRunnable::run... Callable + FutureCallable 作为参数传入，Future 作为异步结果返回。通过 Future.get() 来同步等待获取线程执行的结果。 123456789101112131415161718192021222324252627public class TestCallableFuture &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService single = Executors.newSingleThreadExecutor(); Future&lt;String&gt; stringFuture = single.submit(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(200); System.out.println("TestCallableFuture::Callable::call"); return "TestCallableFuture::Callable::Call::result"; &#125; &#125;); single.shutdown(); System.out.println("TestCallableFuture::main, wait"); String result = stringFuture.get(); System.out.println("TestCallableFuture:: result = " + result); System.out.println("TestCallableFuture::main, exit."); &#125;&#125;// 执行结果TestCallableFuture::main, waitTestCallableFuture::Callable::callTestCallableFuture:: result = TestCallableFuture::Callable::Call::resultTestCallableFuture::main, exit. Callable 转换为 FutureTaskCallable 先转换为 FutureTask，作为参数传入，等待执行完毕后能够通过 FutureTask.get() 同步等待获取结果。 123456789101112131415161718192021222324252627public class TestCallableFutureTask &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService single = Executors.newSingleThreadExecutor(); FutureTask&lt;String&gt; stringFutureTask = new FutureTask&lt;String&gt;( new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(200); System.out.println("*::FutureTask::Callable::call"); return "*::FutureTask::Callable::call:result"; &#125; &#125;); single.submit(stringFutureTask); single.shutdown(); System.out.println("TestCallableFutureTask::wait..."); String result = stringFutureTask.get(); System.out.println("TestCallableFutureTask::main,result =" + result); System.out.println("TestCallableFutureTask::main, exit."); &#125;&#125;// 执行结果TestCallableFutureTask::wait...TestCallableFutureTask::FutureTask::Callable::callTestCallableFutureTask::main, result = *::FutureTask::Callable::call:resultTestCallableFutureTask::main, exit. 参考文档 Java线程池（ThreadPool）详解 ThreadPool用法与优势 java并发编程–Executor框架 Executor框架的详解 深入学习FutureTask Java 并发]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Concurrent</tag>
        <tag>Executor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM：深入理解Java虚拟机--读书笔记]]></title>
    <url>%2F2017%2F11%2F06%2F0006-jvm-java-virtual-machine%2F</url>
    <content type="text"><![CDATA[锁在Java程序运行时环境中，JVM需要对两类线程共享的数据进行协调：1）保存在堆中的实例变量2）保存在方法区中的类变量 这两类数据是被所有线程共享的。 死锁产生死锁 4 个必要条件 互斥条件一个资源每次只能被一个进程使用 保持和等待条件一个进程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件进程已获得的资源，在未使用完之前，不能强行剥夺 环路等待条件若干进程之间形成一种头尾相接的循环等待资源关系 示例解除死锁的方法破坏 4 个条件同时成立：A．进程互斥，m&lt;nw时可能会出现死锁，其中m表示资源总数，n表示互斥进程数，w表示每个进程需要的资源数B．在m&lt;nw时，避免死锁的方法，先均匀分配1个资源，剩下的全都分给某一个进程，确保这个进程能获取足够多的资源完成并退出。C. 也就是说B中是理想避免死锁的方法，但还是可能出现死锁，比如剩下部分并没有全部分给单个进程，而是再次均匀分配就出现死锁了。D. 当两个进程都在请求资源，但是没有资源可用时，则称这两个进程为阻塞节点，资源图称为是不可以简化的、是死锁的。 volatile 关键字synchronize 关键字synchronized的字节码表示：synchronized关键字及实现细节在 Java 语言中存在两种内建的 synchronized 语法： synchronized 语句对于 synchronized 语句当 Java 源代码被 javac 编译成 bytecode 的时候，会在同步块的入口位置和退出位置分别插入 monitorenter 和 monitorexit 字节码指令 synchronized 方法而 synchronized 方法则会被翻译成普通的方法调用和返回指令。如: invokevirtual、areturn 指令，在 JVM 字节码层面并没有任何特别的指令来实现被 synchronized 修饰的方法，而是在 Class 文件的方法表中将该方法的 access_flags 字段中的 synchronized 标志位置 1 ，表示该方法是同步方法并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 做为锁对象。 并发主要关注那些问题线程安全，内存管理及垃圾回收，java并发 JVM 内存模型及多线程并发原子性，可见性，有序性 同步和Java内存模型 Java线程安全总结 JVM内存模型 volatile和synchronized的区别 Java 运行时数据区域介绍 程序计数器、虚拟机栈，本地方法栈的生命周期都和当前线程保持一致，这三块区域属于当前线程私有的。而方法区、堆、常量池是所有线程共享的数据区 程序计数器 The pc RegisterJava 虚拟机栈 Java Virtual Machine Stacks每个方法在执行时都会创建一个栈帧存储：局部变量表、操作数栈、动态链接、方法返回地址等。常说的 Java 内存分为堆内存 Heap 和栈内存 Stack，这里的栈指的就是虚拟机栈，或者说是虚拟机栈中的局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型，对象引用（reference 类型）和 returnAddress 类型（指向一条字节码指令的地址） 基本数据类型boolean, byte, char, short, int, float, long, double 存储空间其中 64 位长度的 long 和 double 类型的数据会占用 2 个局部变量空间，其余的数据类型只占用 1 个（比如 32 位虚拟机，一个变量空间占用32位）。根据 long 和 double 的非原子性协议，把这两个数据类型分割为两次 32 位读写操作（即需求读取两次）。不过局部变量是线程私有数据，即使两次读写也不会引起数据安全问题。 本地方法栈 Native Method Stacks堆 Heap所有对象的实例及数组都是在堆上分配的。 方法区 Method Area别名：Non Heap， 运行时常量池 Run-Time Constant Pool异常 StackOverFlowError如果现场请求的栈深度大于虚拟机所允许的深度，将抛出该异常虚拟机栈和本地方法栈区域可能会抛出该异常 OutOfMemoryError如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，将抛出该异常只有程序计数器中不会抛出 OutOfMemory，其他数据区域都可能会抛出 引用Java 引用分为：强引用、软引用、弱引用、虚引用。这 4 种引用强度一次逐渐减弱。垃圾回收时会根据引用类型来决定是否回收这些内存 强引用 Strong Reference最常见的应用： Object obj = new Object()，这类引用就是强引用，也就是我们一般声明对象是时虚拟机生成的引用。垃圾回收时需要严格判断当前对象是否被强引用，只要强引用还存在，则不会被垃圾回收。 软引用 Soft Reference使用 SoftReference 类来实现软引用，用来描述有用但并非必需的对象。对于软引用关联着的对象在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。在系统要发生内存溢出异常之前，会将这些对象进行回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。换句话说，虚拟机在发生 OutOfMemory 时，肯定是没有软引用存在的。 弱引用 Weak Reference使用 WeakReference 类来实现弱引用，用来描述非必需对象，但是强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾回收发生时，无论当前内存是否足够，被弱引用关联的对象都会被回收，因此其生命周期只存在于一个垃圾回收周期内。 虚引用 Phantom Reference使用 PhantomReference 类来实现虚引用，唯一目的是对象在被回收时能收到一个系统通知。也称为幽灵引用或者幻影引用，是最弱的一种引用关系。虚引用完全不会影响对象的生存时间，也无法通过虚引用来取得对象的实例 总结软引用：当虚拟机内存不足时，会回收它指向的对象弱引用：随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收软引用多用作来实现缓存机制（cache），而弱引用一般用来防止内存泄漏，要保证内存被虚拟机回收 类加载Class 文件的魔数魔数为： 0xCAFEBABE，即 Class 文件的前 4 个字节固定为这串数字 65536 方法数常量池包含 14 种常量类型（每个都有各自的数据结构），其中包含一个 CONSANT_Utf8_info 类型的常量： u1 type; u2 length; u1 bytes。Class 文件中的方法，字段等都是该常量来描述的，所有该常量的最大长度也就是 Java 中方法、字段名的最大长度。length 的最大值即为 u2 类型能表达的最大值 65536 。所以 Java 程序如果定义了超过 64KB 英文字符的变量、方法名、方法数等，将无法编译 类加载前的初始化有且只有 5 种情况必须对类进行初始化 遇到 new, getstatic, putstatic, invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这几条指令的场景为：使用 new 关键字实例化对象；读取或设置类的静态字段（但是被 final 或者进入常量池的静态字段除外）；调用一个类的静态方法 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，需要先触发初始化 初始化一个类的时候，如果发现父类还没有初始化，先触发父类初始化 用户指定要执行额主类：即包含 main 主类的先初始化 如果 java.lang.invoke.MethodHandle 实例最后解析的结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，如果没有初始化会触发其初始化 类变量类中被 static 修饰的变量，会被赋值两次。 类加载准备阶段准备阶段赋值为系统初始值，如：int=0;reference=null 类加载初始化阶段初始化阶段赋值为执行 Java 语句的赋值，即类变量真实的值 类加载器类的加载器的 3 种分类 启动类加载器 Bootstrap ClassLoader这个是 C++ 实现，虚拟机的一部分，负责将 JAVA_HOME\lib 目录下的类库加载到虚拟机内存中，无法被用户直接使用 扩展类加载器 Extension ClassLoader由 sun.misc.Launcher$ExtClassLoader 实现，负责加载 JAVA_HOME\lib\ext 中的类库，用户可以直接使用这些扩展类加载器 应用程序类加载器 Application ClassLoader由 sun.misc.Launcher$AppClassLoader 实现，负责加载 CLASSPATH 中的类库。这个类加载器是 ClassLoader.getSystemClassLoader() 的返回值，所以一般称为系统类加载器，用户可以直接使用 双亲委派模型 Parents Delegation Model 上图所示的类加载器之间的层次关系，称为类加载器的双亲委派模型。该模型要求除了顶层启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里的父子关系不是继承关系，而是组合关系来复用父类代码。双亲委派模型原则：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 方法调用：分派方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（具体调用哪个方法）。Class 文件的编译过程中不包含链接步骤，所有的方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址。方法调用在类加载期间，甚至运行期间才能确定目标方法的入口地址（直接引用)。 变量静态类型和实际类型先看一段代码：Human man = new Man() 静态类型 Static Type其中 Human 称为变量的静态类型，或者叫外观类型 Apparent Type。静态类型仅仅在使用时有可能会出现改变，但在编译期能够明确最终的静态类型 实际类型 Actual Type其中 Man 称为变量的实际类型。实际类型在运行期才能确定，编译器无法判定对象的实际类型是什么 示例 123456// 实际类型变化，运行时才能确定 Human man = new Man();man = new Woman();// 静态类型变化，使用时就确定了sr.sayHello((Man) man);sr.sayHello((Woman) man); 引申根据内存模型，man 是存储在虚拟栈中，属于局部变量表中的引用变量；而 new Man() 表示在堆中分配一块存储区，引用变量的值为指向这块堆的指针 重载与重写及分派 重载编译器在编译阶段通过参数的静态类型来作为重载的判断依据： 12345public void sayHello(Human guy)&#123;...&#125;public void syaHello(Man guy)&#123;...&#125;// 根据静态类型的特点，调用的是 sayHello(Human)Human man = new Man();sayHello(man); 重写只有在运行时根据实际类型，虚拟机才能确定调用哪个重写的方法 12345678910111213class Man extends Human&#123; @Override void sayHello()&#123;...&#125;&#125;class Woman extends Human&#123; @Override void sayHello()&#123;...&#125;&#125;Human man = new Man();Human woman = new Woman();// 根据实际类型的特点，调用子类的方法man.sayHello();woman.sayHello(); 静态分派依赖静态类型来定位方法具体执行哪个版本（重载时），这个分派动作称为静态分派。典型应用：重载。在静态分派过程中，如果没有指定显示的静态类型，会发生类型的自动转换来匹配最可能的类型， 如：sayHello(&#39;a&#39;)，如果没有明确重载 sayHello(char c) 方法，会按照 ：char -&gt; int -&gt; long -&gt; float -&gt; double -&gt;Character -&gt;Serializable --&gt; Object 的顺序转型。其中： char 转为 int： 表示 a 除了代表字符串，还可以代表数字 97 char 转为它的封装类型 Character ：是一次自动装箱过程 char 转为 Serializable 是因为 Character 实现了序列化和可比较但是如果同时重载了 sayHello(Serializable s) 和 sayHello(Comparable c) 会提示类型模糊，编译报错 动态分派在运行期根据实际类型确定方法执行哪个版本（重写），这个分派过程称为动态分派 泛型本质是参数化类型 Parametersized Type 的应用，也就是说操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别被称为泛型类、泛型接口和泛型方法。Java 的泛型只在源码中存在，在编译后的字节码文件中都会被替换为原生类型 Raw Type，并且在相应的地方插入了强制转型代码。 Java 语言泛型的实现方法称为类型擦除（Type Erasure），这种实现也被称为伪泛型。 12345678// 源码Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();map.put("hello", "world");System.out.println(map.get("hello"));// 反编译结果：类型擦除后在使用时做强行转换Map map = new HashMap();map.put("hello", "world");System.out.println((String) map.get("hello")); 特征签名方法特征签名：仅仅包括方法名称、参数类型以及参数顺序。（不包含返回值） Class 文件格式中方法表包含的几个重要字段：名称、描述符、属性组等 名称全限定名：比如 com/google/dagger/DaggerClass; 是这个类的全限定名，仅仅是把类全名的 . 替换为 / 而已，再以分号结束简单名称：指没有类型和参数修饰的方法或者字段名称，比如这个类中的 inc() 方法和 m 字段，简单名称分别为 inc 和 mClass 文件格式方法表中的 name_index 指的就是简单名称 描述符描述符的作用用来描述字段的数据类型、方法的参数列表（包含数量、类型和顺序）和返回值。根据描述符规则：基本数据类型和无返回值的 Void 类型都用首字母大写来表示；对象类型使用字符 L 加对象的全限定名来表示；数组类型每一个维度使用一个前置 [ 字符来描述。示例： 12345int[] --&gt; [Ijava.lang.String[][] --&gt; [[Ljava/lang/String;void inc() --&gt; ()Vjava.lang.String.toString() --&gt; ()Ljava/lang/String;int indexOf(char[] source, int offset, int Count) --&gt; ([CII)I 只有描述符不一致的两个方法才能再同一个 Class 文件中共存 属性组每个方法可以有任意个与之相关的属性（20 个） Sigature 属性：在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量或者参数化类型，则 Signature 属性会记录泛型签名信息。所以类型擦除仅仅是对方法的字节码进行了擦除，实际上 Signature 属性保留了泛型信息 泛型重载 源码方法 mytest 重载，参数类型都是泛型 List&lt;E&gt; 1234567891011121314151617import java.util.List;import java.util.ArrayList;public class TestGeneric&#123; public static int mytest(List&lt;Integer&gt; s) &#123; return 0; &#125; public static String mytest(List&lt;String&gt; s) &#123; return ""; &#125; public static void main(String[]agrs)&#123; mytest(new ArrayList&lt;String&gt;()); mytest(new ArrayList&lt;Integer&gt;()); &#125;&#125; 编译根据特征签名的定义（不包含返回值），以及泛型的类型擦除特性，mytest 特征签名是一样的，所以在编译过程中报错：name clash: mytest(List&lt;String&gt;) and mytest(List&lt;Integer&gt;) have the same erasure 123456789101112131415161718// java 7及以上不能编译通过xmt@server005:~/test/java$ java -versionjava version "1.7.0_91"OpenJDK Runtime Environment (IcedTea 2.6.3) (7u91-2.6.3-0ubuntu0.12.04.1)OpenJDK 64-Bit Server VM (build 24.91-b01, mixed mode)xmt@server005:~/test/java$ javac TestGeneric.javaTestGeneric.java:9: error: name clash: mytest(List&lt;String&gt;) and mytest(List&lt;Integer&gt;) have the same erasure public static String mytest(List&lt;String&gt; s) &#123; ^1 error// java 6可以编译通过xmt@server005:~/test/java$ java -versionjava version "1.6.0_31"Java(TM) SE Runtime Environment (build 1.6.0_31-b04)Java HotSpot(TM) 64-Bit Server VM (build 20.6-b01, mixed mode)xmt@server005:~/test/java$ javac TestGeneric.javaxmt@server005:~/test/java$ java TestGeneric 其中 Java 6 能通过编译的原因，是因为 class 文件只需要描述符（返回值不同）不一致就可以共存，并且 Singture 属性保留了泛型信息，所以能正常编译和运行。但是 Java 7 开始，从编译开始就检查泛型的特征签名，所以无法编译通过参考： Java 泛型重载 jdk 1.7，描述符与特征签名 自动装箱和拆箱 （Boxing and Unboxing Conversation）基本类型自动转换为对应的封装类型（对象）即为自动装箱（Auto Boxing Conversation）；反之，封装类型自动转换为基本类型为拆箱（Unboxing Conversation） 类型及转换 对应类型boolean, byte, short, char, int, long, float, double 对应的封装类型：Boolean, Byte, Short, Character, Integer, Long, Float, Double 转换过程装箱： *.valueOf(*)拆箱：*.intValue() 源码如下，展示了常见的自动装箱和拆箱的用法 12345678910// 自动装箱Integer i = 1; // 自动拆箱int j = i;List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;();// 自动装箱intList.add(1);// 自动拆箱int number = intList.get(0); 经过反编译后，可以明确看到装箱和拆箱的动作： 123456Integer localInteger = Integer.valueOf(1); // 装箱int i = localInteger.intValue(); // 拆箱ArrayList localArrayList = new ArrayList();localArrayList.add(Integer.valueOf(1)); // 装箱int j = ((Integer)localArrayList.get(0)).intValue(); // 拆箱 自动装箱后的比较 因为是对象比较，所以建议直接使用 equal 而不是 == == 比较的是对象的首地址。但是 Java 做了部分优化，在如下范围内使用的是相同的对象（封装类型的缓存），范围外则在装箱的过程中重新生成一个对象。 char[\u0000, \u007f]：即 ASCII 码表中的 128 个字符 byte/short/int/long[-128, 128)：在 -128 &lt;= x &lt; 128 范围内，共用相同的对象（缓存），即 byte 能够表达的范围 float/double没有缓存，直接重新生成一个新对象 示例 12345678910111213141516171819// charCharacter ca = '\u007f', cb = '\u007f';Character cc = '\u0080', cd = '\u0080';System.out.println(ca == cb); //tureSystem.out.println(cc == cd); //false// byte, short, int, long: [-128, 128)Short sa = -128, sb = -128;Short sc = -129, sd = -129;Integer ia = 1, ib = 1;Integer ic = 128, id = 128;Long la = 1L, lb = 1L;Long lc = 128L, ld = 128L;System.out.println(sa == sb); //trueSystem.out.println(sc == sd); //fasleSystem.out.println(ia == ib); //trueSystem.out.println(ic == id); //fasleSystem.out.println(la == lb); //trueSystem.out.println(lc == ld); //false String 的自动拆装箱概念：Java 中的 &quot;abc&quot; 对应的实际是常量，存储在常量池中 1234567891011// 对应的都是常量池中 "abc" 的地址String str1 = "abc";String str2 = "abc";System.out.println(str2==str1); //输出为 true System.out.println(str2.equals(str1)); //输出为 true // 重新分配了一个对象，所以对象的首地址并不一样String str3 =new String("abc");String str4 =new String("abc"); System.out.println(str3 == str4); //输出为 false System.out.println(str3.equals(str4)); //输出为 true 注意事项 内存空间自动装箱涉及到重新生成对象，所以频繁大量的使用会创建很多无用的对象，增加 GC 压力，拉低程序的性能 拆箱空指针异常如果封装类型并没有初始化，在拆箱时会报空指针异常，因为编译过程无法检测到，只能在运行时出现，需要特别注意 内存泄露和内存溢出 内存泄露 Memory Leak内存泄露是对象在内存中还活着占用内存，但是无法被垃圾回收。指对象到 GC Roots 的引用链 内存溢出 Memory Overflow无法申请到足够的内存 垃圾回收finalize 方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。 Java中所有类都从Object类中继承finalize()方法。 当垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法。值得C++程序员注意的是，finalize()方法并不能等同与析构函数。Java中是没有析构函数的。C++的析构函数是在对象消亡时运行的。由于C++没有垃圾回收，对象空间手动回收，所以一旦对象用不到时，程序员就应当把它delete()掉。所以析构函数中经常做一些文件保存之类的收尾工作。但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 常见问题多线程并发时，提到 long 和 double 类型避免脏数据，需要使用 volatile 修饰？long 和 double 的非原子协定：Java 的内存模型要求，变量的读取操作和写入操作都必须是原子操作的，但是对于非 volatile 类型的 long, double 有些不同，因为这两个变量是 64 位存储，JVM 允许将 64 位的读操作或写操作分解为 2 个 32 位的操作。这样，当在多线程环境中读取一个非 volatile 的 long, double 变量时，可能会出现读取到这个变量一个值的高 32 位和另一个值的低 32 位，从而导致数据出问题。但是商用虚拟机基本不会出现这种情况，可以不用过于担心。 多线程并发时需锁住内存模型中的哪一块数据？并发只影响共享变量：堆内存或方法全局变量。其他线程独享的数据不必关心，比如方法内部变量等等 图书 Java多线程编程核心技术 深入理解Java虚拟机:JVM高级特性与最佳实践 第2版 Java 规范官方文档包含语言规范和 JVM 规范 java并发编程的艺术 参考文档 Java深入学习 Java各种锁 synchronized关键字及实现细节 Java对象锁和类锁全面解析 java线程安全总结 Java中的多线程 同步和Java内存模型 Java线程安全总结 JVM内存模型 jvm并发算法blog]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jvm</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 多线程并发]]></title>
    <url>%2F2017%2F11%2F02%2F0005-java-concurrent%2F</url>
    <content type="text"><![CDATA[线程常用 API thread.start() ：启动 thread.isAlive()判断当前线程是否处于活动状态 thread.sleep()在指定毫秒数内让当前正在执行的线程休眠 thread.getId()：获取线程 ID yield放弃当前的 CPU 资源，但放弃多长时间不确定 thread.interrupt()中断，仅仅是在该线程中打了一个停止的标记，并不是真的停止线程 thread.setPriority()设置优先级，并不会马上优先执行。线程优先级的代码影响较小，但是优先级高的确实会获取更多的 CPU 资源和执行速度 suspend()/resume暂停和恢复， 作废 stop停止线程，作废。暴力停止进程，会导致内存无法清理干净，锁的释放也会导致数据不一致 thread.wait()释放当前锁并等待，执行前必须确保已经获取该对象锁 thread.notify()/.notifyAll()也必须在同步代码块呢，通知该对象处于锁等待的线程/通知所有。注意：一次 notify 只能被一个处于 wait 的线程接受，即使该对象锁一直空闲，其他 wait 线程也收不到通知，除非使用 notifyAll。notify 后代码块并不会马上释放锁，而是需要将这个 synchronized 代码块执行完毕才会释放锁 thread.join等待指定线程对象销毁，但是当前线程会进入阻塞状态 Thread.currentThread()获得当前线程的引用 线程状态机线程有六种状态： 123456789// java.lang.Thread.javapublic enum State &#123; NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;&#125; 状态说明 NEW这种情况指的是，通过 New 关键字创建了 Thread 类（或其子类）的对象，该对象此时就处于 NEW 的状态 RUNNABLE线程正在正常运行中，当然可能会有某种耗时计算 I/O 等待的操作 CPU 时间片切换等，这个状态下发生的等待一般是其他系统资源, 而不是锁， Sleep 等 BLOCKED多个线程有同步操作的场景，等待获取同步锁。比如正在等待另一个线程的 synchronized 块的执行释放，也就是线程在等待进入临界区 WAITING线程拥有了某个锁之后调用了 wait 方法，等待 notify/notifyAll 后才能执行下一步操作。这里要区分 BLOCKED 和 WATING 的区别：一个是在临界点外面等待获取锁进入；一个是 wait 后等待 notify TIMED_WAITING有时间限制的 WAITING TERMINATED线程已经执行完毕了 状态转换图 线程几个特性进程和线程线程也被称为轻量级进程。CPU 的基本调度单位是线程而不是进程。同一个进程中所有线程共享进程的内存地址空间，因此这些线程都能访问相同的变量并在同一个堆上分配对象 并发执行顺序在多线程中，线程的调用具有随机性。也就是 Thread.start() 的执行顺序并不是按照代码顺序来执行的，而是随机的。参考示例： 1234567891011121314151617181920212223242526public class TestThreadStart &#123; private static final int THREAD_COUNT = 20; public static class MyThread extends Thread&#123; private int i = 0; public MyThread(int i) &#123; super(); this.i = i; &#125; @Override public void run() &#123; System.out.println(i); &#125; &#125; public static void main(String[] agrs) &#123; Thread[] threads = new Thread[THREAD_COUNT]; for (int i = 0; i &lt; THREAD_COUNT; i++)&#123; threads[i] = new MyThread(i); threads[i].start(); &#125; &#125;&#125; 执行结果是随机的： 123456789101112131415161718192021xmt@server005:~/test/java$ java TestThreadStart010987654321191815171614131211 并发对共享变量的影响根据 Java 内存模型，共享变量必须同时满足：原子性，可见性，有序性，或者满足先行发生原则，在并发情况下才是安全的，否则会出现数据异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class TestThreadConcurrent &#123; private static final int THREAD_COUNT = 5; public static class RunnableNotSafe implements Runnable&#123; private int count = 5; @Override public void run() &#123; count--; System.out.println("Thread name: " + Thread.currentThread().getName() + ", count = " + count); &#125; &#125; public static class RunnableSafe implements Runnable&#123; private int count = 5; // 使用了同步，确保数据一致 @Override public synchronized void run() &#123; count--; System.out.println("Thread name: " + Thread.currentThread().getName() + ", count = " + count); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread[] threads = new Thread[THREAD_COUNT]; Runnable notSafe = new RunnableNotSafe(); Runnable safe = new RunnableSafe(); // 并发时共享变量的数据异常 for (int i = 0; i &lt; THREAD_COUNT; i++)&#123; threads[i] = new Thread(notSafe, String.valueOf(i)); threads[i].start(); &#125; Thread.sleep(1000); // 使用同步后，能正常输出 for (int i = 0; i &lt; THREAD_COUNT; i++)&#123; threads[i] = new Thread(safe, String.valueOf((char)(i + 'A'))); threads[i].start(); &#125; &#125;&#125; 测试结果： 1234567891011121314xmt@server005:~/test/java$ javac TestThreadConcurrent.javaxmt@server005:~/test/java$ java TestThreadConcurrent// 并发时读取脏数据Thread name: 0, count = 3Thread name: 4, count = 0Thread name: 3, count = 1Thread name: 2, count = 2Thread name: 1, count = 3// 同步块输出的正确结果Thread name: A, count = 4Thread name: C, count = 3Thread name: B, count = 2Thread name: D, count = 1Thread name: E, count = 0 从示例中，可以看到共享变量 RunnableNotSafe 实例中 count 的自减操作是复合运算，这段代码不具有原子性，而且也不满足先行发生原则，所以是并发不安全的。通过增加 synchronized 关键字修饰后，run() 这段代码满足了：原子性，可见性，有序性，所以并发时安全 线程名称 API this.getName()当前线程的名称，即 new 出来的线程实例对应的名称 Thread.currentThread().getName()当前执行线程的名称 thread.setName()设置当前执行线程的名称 示例： 123456789101112131415161718192021222324252627282930public class TestThreadName &#123; public static class ThreadName extends Thread&#123; public ThreadName()&#123; System.out.println("Constructor begin!"); System.out.println("Thread.currentThread().getName(): " + Thread.currentThread().getName()); System.out.println("this.getName(): " + this.getName()); System.out.println("Constructor end!"); &#125; @Override public void run() &#123; System.out.println("Run begin!"); System.out.println("Thread.currentThread().getName(): " + Thread.currentThread().getName()); System.out.println("this.getName(): " + this.getName()); System.out.println("Run end!"); &#125; &#125; public static void main(String[] args)&#123; ThreadName threadName = new ThreadName(); System.out.println("#####################"); Thread thread = new Thread(threadName); thread.setName("Test"); thread.start(); &#125;&#125; 执行结果： 1234567891011xmt@server005:~/test/java$ javac TestThreadName.javaxmt@server005:~/test/java$ java TestThreadNameConstructor begin!Thread.currentThread().getName(): mainthis.getName(): Thread-0Constructor end!#####################Run begin!Thread.currentThread().getName(): Testthis.getName(): Thread-0Run end! 程序解读： ThreadName threadName = new ThreadName();new 的第一个线程：ThreadName 对象，该操作是在主线程中执行的，所以构造函数中 Thread.currentThread.getName 打印的是 main 主线程。而 threadName 对象也就是 this.getName 的值为默认初始值 Thread-0。输出： 1234Constructor begin!Thread.currentThread().getName(): mainthis.getName(): Thread-0Constructor end! Thread thread = new Thread(threadName);这里 new 了第二个线程，本示例比较特殊，仅仅是把 ThreadName 对象当做有名字的 Runnable 在使用。thread 对象名字默认值为 Thread-1 thread.setName(&quot;Test&quot;);修改 thread 对象的名字为 Test，所以该线程在执行时（Thread.currentThread().getName()）对应的名字被修改为 Test thread.start();thread 对象开始执行，上一步已经将名称修改为 Test，所以输出：Thread.currentThread().getName(): Test （如果没有上一步修改名称，此处输出 Thread-1）因为是调用 threadName 对象的 run() 方法，所以 this.getName 表示 threadName 对象的名字，所以输出：this.getName(): Thread-0 yieldpublic static native void yield(); 放弃当前的 CPU 资源，但放弃多长时间不确定 1234567891011121314public static class RunnableYield implements Runnable&#123; @Override public void run() &#123; long begin = System.currentTimeMillis(); int count = 0; for (int i = 0; i &lt; 100000; i++)&#123; //Thread.yield(); count += (i + 1); &#125; long end = System.currentTimeMillis(); System.out.println("Take time: " + (end - begin)); &#125;&#125; 结果分析：如果注释掉 Thread.yield，整个程序执行时间只有 1 毫秒；但是执行 yield 后，执行时间并不固定，有时 15 毫秒，有时 17 毫秒等 线程优先级Java 中线程的优先级有 10 个等级，优先级越高的线程得到的资源越多，CPU 优先执行优先级较高的线程对象中的任务。线程先级有如下几个特点： 继承性如果 A 线程启动 B 线程，那么 A 和 B 拥有相同的线程优先级 规则性线程的优先级和代码执行顺序无关，并不表示优先级高先执行完了再执行优先级低的线程，他们是并发执行的，只是优先级高的可能会先执行完 随机性优先级高的并不是每次都会先执行完，具有随机性，特别是优先级差别不大的时候 总结： 整体来说，线程优先级的代码影响较小，但是优先级高的确实会获取更多的 CPU 资源和执行速度 守护线程 DaemonJava 线程有两种：用户线程和守护线程守护线程是一种特殊的线程，它的特性有“陪伴”的意义，陪伴用户线程。当该用户线程不存在了，对应的守护线程也自动销毁。典型的守护线程就是垃圾回收线程（GC）定义：public final void setDaemon(boolean on)，注意事项： thread.setDaemon(true) 必须在 thread.start() 之前设置，否则会跑出一个 IllegalThreadStateException 异常。即：不能把正在运行的常规线程设置为守护线程 在 Daemon 线程中产生的新线程也是 Daemon 的，具有传递性 守护线程做耗时操作时，一定要注意用户线程必须等待它结束后才推出。否则用户线程先退出，守护进程来不及执行完毕就会跟随销毁 123456789101112131415161718192021222324private static class ThreadDaemon extends Thread&#123; @Override public void run() &#123; try &#123; int i = 0; while (true) &#123; i++; System.out.println(i); Thread.sleep(1000); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;ThreadDaemon threadDaemon = new ThreadDaemon();// 先设置守护线程，再开启线程threadDaemon.setDaemon(true);threadDaemon.start();// 主线程等待守护线程执行一段时间Thread.sleep(5000);System.out.println("Main end, then thread daemon will be destroyed."); 线程停止interrupt 方法 功能调用 interrupt() 方法，并不能马上就将线程停止，仅仅是在该线程中打了一个停止的标记，并不是真的停止线程。 有什么用既然不能直接停止线程，它的作用是什么呢？中断并不能直接终止另一个线程，而需要被中断的线程自己处理中断。 判断线程是否是中断状态两种方法： Thread.interrupted() 123public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125; 它是 static 的，表示测试当前执行线程是否已经中断。同时，执行后当前执行线程的中断状态标志会被清除，也就是说连续调用两次，如果第一次返回 true，第二次因为前面被清除会返回 fasle。 thread.isInterrupted() 123public boolean isInterrupted() &#123; return isInterrupted(false);&#125; 表示某个线程对象是否已经中断，不会清除中断状态标志。 interrupt 对sleep 的影响不管是线程先休眠后被打上停止标志，还是先被打上停止标志后执行休眠，都会触发异常 InterruptedException stop() 方法该方法在 API 中已经被废弃，属于暴力停止进程，同时会抛出 java.lang.ThreadDeath 异常。stop 会导致内存清理工作无法完成，并且对锁定的对象进行了解锁，导致数据无法同步处理，出现数据不一致的问题。 join 等待等待指定线程对象销毁，但是当前线程会进入阻塞状态 原理123456789101112131415public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis)&#123; ... while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; ...&#125; 从源代码可以看出 join 是一个同步方法，需要获取当前对象的锁，并且通过 wait 方法来实现延时，并释放锁。线程对象 threadA.join 执行后，threadA 内的所有 synchronized 方法将都需要等待。或者说 threadA 中的同步方法执行后，join 将不会马上执行，需要等待获取同步锁，参考示例： 123456789101112131415161718192021222324private static class MyThread extends Thread&#123; public synchronized void syncMethod()&#123; try &#123; System.out.println("MyThread begin"); Thread.sleep(3000); System.out.println("MyThread exit"); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; syncMethod(); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; System.out.println("main begin"); MyThread myThread = new MyThread(); myThread.start(); myThread.join(1000); System.out.println("main exit");&#125; 输出结果为： 1234main beginMyThread beginMyThread exitmain exit 也就是主线程虽然设置了，只等待 myThread 线程 1 秒，但是因为 myThread 中执行的是同步方法，所以 join 因为拿不到对象锁，只能直到同步方法执行完后才能执行 join 等待。但是 join 等待时会判断当前线程是否还存活，因为线程已经执行完退出，所以 join 并没有调用 wait 来等待。 join/sleep/yield 的区别 join(long) 使用了 synchronized 来同步，并通过 wait 实现延时，具有释放锁的特点 sleep(long) 使用的是 native 的方法实现的，并不会释放锁，而是一直阻塞到指定时间 yield() 仅仅是放弃当前的 CPU 资源，但放弃多长时间不确定，并不涉及到锁，也不会释放锁。执行后线程状态仍然是 RUNNABLE 状态 synchronized 关键字可以在任意对象及方法上加锁，而加锁的这段代码被称为“互斥区”或“临界区”。在执行这段代码时上锁，执行完毕后释放锁；其他线程访问时需要先检查代码是否上锁，如果上锁则等待直到锁被释放。在 synchronized 方法或者代码块中的代码，是同步执行的；否则就是异步执行 锁对象锁是针对这个对象的，比如对象有两部分代码都有 synchonized 修饰，只有当第一部分代码执行完释放锁后，第二部分代码才能执行。也就是同一个对象的同步代码，只能串行执行；同一时间只有一个线程能执行。注意：指的是同一个对象 修饰代码块synchronized (this) 修饰代码块，即获取当前对象锁： 123456789101112131415private static class MyObject&#123; public void doLongTimeTask()&#123; for (int i = 0; i &lt; 50; i++)&#123; System.out.println("Thread Name: " + Thread.currentThread().getName() + ", i = " + i); &#125; synchronized (this)&#123; for (int j = 0; j &lt; 50; j++)&#123; System.out.println("Thread Name: " + Thread.currentThread().getName() + ", j = " + j); &#125; &#125; &#125;&#125; MyObject 的同一个实例，在执行 doLongTimeTask 时， i 的输出是线程并发执行输出的，而 j 的输出这部分代码被修饰为同步，所以 j 只能同步打印。输出结果： 12345678910111213141516171819// i 的输出是并发的Thread Name: A, i = 14Thread Name: A, i = 15Thread Name: B, i = 0Thread Name: A, i = 16Thread Name: B, i = 1Thread Name: A, i = 17Thread Name: B, i = 2Thread Name: A, i = 18Thread Name: B, i = 3// j 的输出是串行输出，顺序执行Thread Name: A, j = 47Thread Name: A, j = 48Thread Name: A, j = 49Thread Name: B, j = 0Thread Name: B, j = 1Thread Name: B, j = 2Thread Name: B, j = 3 synchronized (this)使用当前实例对象锁定 synchronized (otherObject)使用其他对象锁定，这是因为如果一个类中有多个 synchronized 代码段，在大量并发时，不管是否有前后逻辑关系，都需要等待当前对象释放锁才能执行下一个同步代码，所以可以通过锁其他对象来实现并行处理 synchronized(class)使用当前类锁定，锁定的是当前类，所以所有的 static 同步方法都共用同一个锁 synchronized(String)String 比较特殊，涉及到常量池特性，当锁定对象为常量池字符串时，实际上是同一个对象。见示例： 1234567891011public void method(String value)&#123; synchronized (value) &#123;...&#125;&#125;// "AA" 为常量池字符串，所以是同一个对象，同步执行 method("AA");method("AA");// 显示 new 了两个不同的 String 对象，会并发执行method(new String(AA));method(new String(AA)); synchronized(wrapperclass)包装类需要特别注意自动装箱时：数字类型和字符型的包装类在特定范围内共用的是相同对象。char 的 [\u0000, \u007f]：即 ASCII 码表中的 128 个字符；byte/short/int/long 的 [-128, 128)：即 -128 &lt;= x &lt; 128 范围内，共用相同的对象（缓存），示例： 1234567891011121314151617public void method(Object value)&#123; synchronized (value) &#123;...&#125;&#125;// 范围内自动装箱Integer integer1 = 1;Integer integer2 = 1;// integer1 == integer2 is true, 即同一个对象，所以同步执行method(integer1);method(integer2);// 范围外自动装箱Long long1 = 128L;Long long2 = 128L;// long1 == long2 is false, 超出范围即不同对象，并发执行method(long1);method(long2); 修饰普通方法synchronized 直接修饰方法，等同于 synchronized(this) 修饰方法的整段代码，是给当前实例对象上锁： 1234private static class MyObject&#123; public synchronized void methodA()&#123;...&#125; public synchronized void methodB()&#123;...&#125;&#125; MyObject 的同一个实例中，并发调用了 methodA 和 methodB，这两个方法只能串行执行。比如先执行完 methodA 再执行 methodB 修饰静态方法synchronized 修饰静态方法，是给当前 Class 类上锁，等同于 synchronized(class)，和给当前对象实例上锁是不一样的 12345678private static class MyObject&#123; public synchronized static void methodA()&#123;...&#125; public synchronized static void methodB()&#123;...&#125; public synchronized void methodC()&#123;...&#125; public void methodD()&#123; synchronized (MyObject.class)&#123;...&#125; &#125;&#125; 其中：methodA, methodB, methodD 都是 MyObject 类锁，所以只能同步执行；但是 methodC 实例对象锁，是可以和他们并发执行的 锁重入当一个线程获取对象的锁后，再没有释放的情况下可以再次获取这个对象锁，但是其他线程在锁没有释放的前提下是无法获取的。比如： synchronized 修饰方法时的 methodA 中可以直接调用 methodB synchronized(Object) lock.lock() 同时，锁重入支持类继承 锁对象的改变 锁对象属性的改变仅仅是属性的变化，锁对象并没有变，所以同步执行 锁对象改变因为对象已经改变，所以锁的是不同对象，并发执行 示例： 123456789101112131415161718// 同一个锁对象，仅仅属性 name/age 的改变，不会影响锁，同步执行private static class CombinationObject&#123; private String name; private int age; public synchronized static void methodA()&#123;...&#125; public synchronized static void methodB()&#123;...&#125;&#125;// 锁对象已经改变，并发执行private static class SimpleObject&#123; private String lock = "aaa"; public void method()&#123; synchronized (lock)&#123; lock = "bbb"; ... &#125; &#125;&#125; volatile 关键字关键字 volatile 可以理解为 Java 虚拟机提供的最轻量级同步机制。根据 Java 内存模型，每个线程都有自己的工作线程，会从共享内存中读取出共享变量到自己的线程中，这个时候对共享变量的修改涉及到可见性，否则会出现数据同步异常。但是 volatilte 无法保证操作的原子性，所以需要满足特定的规则才能保证线程安全 特性 保证此变量对所有线程的可见性 禁止指令重排序优化 规则使用 volatile 保证并发安全需要符合如下两条规则： 运算结果并不依赖变量的当前值，或者确保只有单一线程修改变量的值 变量不需要与其他状态变量共同参与不变约束 示例使用 volatile 修饰后，可以保证变量的可见性，在不同线程中修改，可以立即可见 123456789101112131415161718192021private static class VolatileThread extends Thread&#123; private volatile boolean isRunning = true; public boolean isRunning()&#123; return isRunning; &#125; public void setRunning(boolean running)&#123; isRunning = running; &#125; @Override public void run() &#123; while (isRunning)&#123;&#125; &#125;&#125;// 主线程中修改 isRunning 的值，子线程中立即可见public static void main(String[] args) throws InterruptedException &#123; VolatileThread volatileThread = new VolatileThread(); volatileThread.start(); Thread.sleep(500); volatileThread.setRunning(false);&#125; 线程间通信线程之间的通信机制有两种：共享内存和消息传递。在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。Java 的并发采用的是共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。如果编写多线程程序不理解隐式进行的线程之间通信的工作机制，很可能会遇到各种奇怪的内存可见性问题。 等待/通知机制方法： thread.wait() thread.notify() thread.notifyAll() 注意事项： 执行前必须已经获取该对象锁，否则会抛出 IllegalMonitorStateException，也就是需要在 synchronized 同步代码块中才能执行 wait 释放当前锁并等待 wait 处于该状态下的对象锁，如果主动 interrupt 后会抛出异常。所以 wait 语句需要 catch InterruptedException wait(time) 操作 time 后自动唤醒继续执行 notify 通知该对象处于锁等待的线程。一次 notify 只能随机通知一个 wait 的对象，即使该对象锁一直空闲，其他 wait 对象也收不到通知，除非使用 notifyAll notify 后代码块并不会马上释放锁，而是需要将这个 synchronized 代码块执行完毕才会释放锁 代码编写时，确保 notify 在 wait 之后执行，否则会陷于持续等待的过程 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class TestCommWaitNotify &#123; private static class ThreadA extends Thread&#123; private Object lock; public ThreadA(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; synchronized (lock)&#123; try &#123; lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private static class ThreadB extends Thread&#123; private Object lock; public ThreadB(Object lock) &#123; this.lock = lock; &#125; @Override public void run() &#123; synchronized (lock) &#123; lock.notify(); for (int i = 0; i &lt; 5; i++)&#123;...&#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Object object = new Object(); ThreadA threadA = new ThreadA(object); threadA.setName("A"); threadA.start(); // 线程 A 先执行并处于等待过程 Thread.sleep(200); // 线程 B 开始运行并通知 ThreadB threadB = new ThreadB(object); threadB.setName("B"); threadB.start(); &#125;&#125; 管道在 Java 中提供了各种各样的输入/输出流 Stream，其中管道流 pipeStream 是一种特殊的柳，用于不同线程间直接传送数据。一个线程发送数据到输出管道，另一个线程从输入管道读取数据。通过管道实现线程间通信，不用借助任何临时文件。常见类： PipedInputSteam/PipedOutputStream管道字节流 PipedReader/PipedWriter管道字符流 基于等待/通知机制的读写读阻塞直到有数据写入才唤醒 1234567891011121314public synchronized int read() throws IOException &#123; ... while (in &lt; 0) &#123; ... /* might be a writer waiting */ notifyAll(); try &#123; wait(1000); &#125; catch (InterruptedException ex) &#123; throw new java.io.InterruptedIOException(); &#125; &#125; ...&#125; 连接 connectwrite/read 管道需要连接后，才能确保两个线程使用了相同管道 1234567PipedOutputStream pipedOutputStream = new PipedOutputStream();PipedInputStream pipedInputStream = new PipedInputStream();pipedOutputStream.connect(pipedInputStream);PipedWriter pipedWriter = new PipedWriter();PipedReader pipedReader = new PipedReader();pipedWriter.connect(pipedReader); 管道字节流通信示例 初始化 PipedOutputStream/PipedInputStream 并连接 开读线程进入读等待，开写线程写入数据 1234567891011121314151617181920212223// 读阻塞byte[] bytes = new byte[20];int readLength = inputStream.read(bytes);while (readLength != -1)&#123; String newData = new String(bytes, 0, readLength); readLength = inputStream.read(bytes);&#125;inputStream.close();// 写数据for (int i = 0; i &lt; 300; i++)&#123; String outData = "" + (i + 1); outputStream.write(outData.getBytes());&#125;outputStream.close();// 读线程ThreadRead threadRead = new ThreadRead(readData, pipedInputStream);threadRead.start();// 写线程ThreadWrite threadWrite = new ThreadWrite(writeData, pipedOutputStream);threadWrite.start(); 管道字符流通信示例流程和字节流通信一样，部分参考代码 1234567891011121314151617181920212223// 写数据for (int i = 0; i &lt; 300; i++) &#123; String data = "" + (i + 1); pipedWriter.write(data);&#125;pipedWriter.close();// 读等待char[] chars = new char[20];int readLength = pipedReader.read(chars);while (readLength != -1)&#123; String data = new String(chars, 0, readLength); readLength = pipedReader.read(chars);&#125;pipedReader.close();// 读线程 ThreadRead threadRead = new ThreadRead(readDataCharacter, pipedReader);threadRead.start();// 写线程ThreadWrite threadWrite = new ThreadWrite(writeDataCharacter, pipedWriter);threadWrite.start(); ThreadLocal 和 InheritableThreadLocal基本方法12threadLocal.set(value);threadLocal.get(); 特点 ThreadLocal 共享变量，具有线程隔离性，每个线程存储的值都是私有的 InheritableThreadLocal 共享变量，会继承父线程设置的值 实现原理 线程隔离性从源码可以看出，线程隔离是因为值存储通过 ThreadLocalMap 来实现的，key 就是当前执行线程，所以不同的线程对应的 value 将会不一样 12345678910111213141516171819202122public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 值继承主线程在 set 时，创建 t.inheritableThreadLocals，子线程在初始化时会拷贝一份主线程设置的值，所以在 get 时能看到值继承效果。但是子线程修改 InheritableThreadLocal 变量的值，主线程中并不会跟着改变 123456789101112131415ThreadLocalMap getMap(Thread t) &#123; return t.inheritableThreadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);&#125;private void init(...) &#123; ... if (parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); ...&#125; 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private static ThreadLocal sThreadLocal = new ThreadLocal();private static InheritableThreadLocal sInheritableThreadLocal = new InheritableThreadLocal();private static class ThreadA extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;ThreadA begin: &quot; + sThreadLocal.get()); sThreadLocal.set(&quot;It is ThreadA running&quot;); System.out.println(&quot;ThreadA exit: &quot; + sThreadLocal.get()); &#125;&#125;private static class ThreadB extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;ThreadB begin: &quot; + sThreadLocal.get()); sThreadLocal.set(&quot;It is ThreadB running&quot;); System.out.println(&quot;ThreadB exit: &quot; + sThreadLocal.get()); &#125;&#125;private static class ThreadC extends Thread&#123; @Override public void run() &#123; System.out.println(&quot;ThreadC begin: &quot; + sInheritableThreadLocal.get() + &quot;, inheritable from main&quot;); sInheritableThreadLocal.set(&quot;It is ThreadC running&quot;); System.out.println(&quot;ThreadC exit: &quot; + sInheritableThreadLocal.get()); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; ThreadA threadA = new ThreadA(); threadA.start(); Thread.sleep(300); ThreadB threadB = new ThreadB(); threadB.start(); Thread.sleep(300); System.out.println(&quot;Main thread: begin set value&quot;); sInheritableThreadLocal.set(&quot;It is main thread.&quot;); System.out.println(sInheritableThreadLocal.get()); ThreadC threadC = new ThreadC(); threadC.start(); Thread.sleep(300); System.out.println(&quot;Main thread: exit, get value&quot;); System.out.println(sInheritableThreadLocal.get());&#125; 运行结果： 1234567891011121314ThreadA begin: nullThreadA exit: It is ThreadA running// 线程 A 和 B 对共享变量的修改隔离，不会相互影响ThreadB begin: nullThreadB exit: It is ThreadB running// 主线程修改 InheritableThreadLocal 变量Main thread: begin set valueIt is main thread.// 子线程继承值ThreadC begin: It is main thread., inheritable from mainThreadC exit: It is ThreadC runningMain thread: exit, get value// 子线程对 InheritableThreadLocal 变量的修改，主线程并不会跟着改变It is main thread. lockLock 是 java.util.concurrent.locks 包下的接口，实现提供了比 synchronized 方法和语句可获得的更广泛的锁定操作，它能以更灵活的方式处理线程同步问题。它允许把锁定的实现作为 Java 类，而不是作为语言的特性来实现。 ReentrantLockReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，但是添加了类似锁投票、定时锁等候和可中断锁等候的一些特性；它是一种独占锁。初始化： private Lock lock = new ReentrantLock(); ，常见方法： public void lock() {...}获取锁对象，类似 synchronized(object) ，必须用 try 包起来 public void unlock() {...}释放锁对象，必须在 finally 中执行，如果 try 后面有 catch 捕捉异常，则必须在 unlock 前增加是否 lock 的判断。否则释放锁时因为并没有持有锁抛出异常 IllegalMonitorStateException 123456789101112try &#123; lock.lock() Thread.sleep(200); ...&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125; finally &#123; // 释放前先判断是否持有 if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); &#125;&#125; public int getHoldCount() {...}当前线程持有锁的个数，也就是调用 lock 的次数 public final int getQueueLength() {...}获取等待锁释放的线程估计数，是一个估计值。即 5 个线程并发 lock 方法，1 个正在执行 lock 后的操作，那么返回值为 4 个在等待 lock 释放 public int getWaitQueueLength(Condition condition) {...}获取等待 condition.await 的线程估计数，也是一个估计值，必须在 lock.lock() 中执行，否则会抛出 IllegalMonitorStateException。即 5 个线程并发都执行了 condition.await ，返回值为 5 public final boolean hasQueuedThreads(Thread thread) {...}查询指定线程是否正在等待获取此锁定 public final boolean hasQueuedThreads() {...}查询是否有线程正在等待获取此锁定 public boolean hasWaiters(Condition condition) {...}查询是否有线程在的等待与此锁定有关的 condition public final boolean isFair() {...}判断是不是公平锁 public boolean isHeldByCurrentThread() {...}查询当前线程是否持有此锁定 public boolean isLocked() {...}查询此锁定是否被任意线程持有 public void lockInterruptibly() throws InterruptedException{...}当前线程未被中断则获取此锁定，如果已经被中断则抛出异常 public boolean tryLock() {...}如果锁定没有被其他线程持有，才获取该锁定 public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException如果锁定在给定等待时间内没有被其他线程持有，且线程未被中断，则获取该锁定 ConditionCondition 替代了 Object 监视器方法的使用（wait/notify/notifyAll），同样代码必须在 lock.lock/lock.unlock 之间，类似 wait/notify 必须要在synchronized 代码段中执行。在 wait/notify/notifyAll 方法进行通知时，通知线程是有 JVM 随机选择的。但是 Condition 拥有更好的灵活性，可以实现多路通知，可以选择性进行线程通知，在调度线程上更加灵活。 功能类比： condition.await --&gt; object.wait condition.signal --&gt; object.notify condition.signalAll --&gt; object.notifyAll 常见方法： void awaitUninterruptibly();不能被打断的等待，直到 signal 信号出现 boolean awaitUntil(Date deadline) throws InterruptedException;在 await 基础上加了个等待的时间限制 ReentrantLock 和 Condition 结合示例生产者消费者模型： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private static final int NUM = 5;private static class MyObject &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); private boolean hasValue = false; public void produce()&#123; try &#123; lock.lock(); while (hasValue)&#123; condition.await(); &#125; System.out.println("produce: **"); hasValue = true; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume()&#123; try &#123; lock.lock(); while (!hasValue)&#123; condition.await(); &#125; System.out.println("consume: ##"); hasValue = false; condition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125;private static class ThreadProduce extends Thread&#123; private MyObject myObject; public ThreadProduce(MyObject myObject) &#123; this.myObject = myObject; &#125; @Override public void run() &#123; for (int i = 0; i &lt; NUM; i++) &#123; myObject.produce(); &#125; &#125;&#125;private static class ThreadConsume extends Thread&#123; private MyObject myObject; public ThreadConsume(MyObject myObject) &#123; this.myObject = myObject; &#125; @Override public void run() &#123; for (int i = 0; i &lt; NUM; i++) &#123; myObject.consume(); &#125; &#125;&#125;public static void main(String[] args) &#123; MyObject myObject = new MyObject(); ThreadProduce threadProduce = new ThreadProduce(myObject); threadProduce.start(); ThreadConsume threadConsume = new ThreadConsume(myObject); threadConsume.start();&#125; 实现效果：生产者和消费者交替执行，每生产一个就消费掉 123456produce: **consume: ##produce: **consume: ##produce: **consume: ## 公平锁和非公平锁 公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得 FIFO 的先进先出顺序 非公平锁一种获取锁的抢占机制，是随机获取锁。Java 中默认都是非公平锁 示例： 123// true 表示公平锁，false 表示非公平锁 private Lock lock = new ReentrantLock(true);private Lock lock = new ReentrantLock(false); ReentrantReadWriteLock 读写锁ReentrantLock 具有完全互斥排他的效果，即同一个时间只有一个线程能执行 lock 后的任务，虽然保证了共享变量的线程安全性，但是效率较低。而ReentrantReadWriteLock 具有读写锁特性（有两个锁），可以提高效率。基本概念及特性： 读锁读相关的锁（`reentrantReadWriteLock.readLock()），共享锁，读锁不互斥 写锁写相关的锁（`reentrantReadWriteLock.writeLock()），排他锁。读锁与写锁互斥，写锁与写锁互斥；只要持有了写锁，不管是先写后读还是先读后写，都会互斥 单例模式多线程立即加载/饿汉模式类加载的时候就直接将对象创建并立即初始化（static），因为对象创建的比较急，即使不需要使用也会被初始化，即所谓的“饿汉”模式。特点： 优点：线程安全 缺点：即使不需要也会被实例化，大量使用会造成资源浪费 示例： 123456789101112// 饿汉式，static，定义时直接初始化private static MyObject myObject = new MyObject();// 或者使用静态加载//static &#123;// myObject = new MyObject();//&#125;// 使用时，因为在类加载过程中就已经实例化，并发调用安全public static MyObject getInstance()&#123; return myObject;&#125; 延迟加载/懒汉模式在需要实例时才初始化，延迟加载即所谓的“懒汉”模式。特点： 缺点：线程不安全，需要加锁确保并发安全 优点：需要使用时才实例化，提高资源利用率 基本用法，存在线程不安全问题： 1234567private static MyObject myObject;public static MyObject getInstance()&#123; if (myObject == null)&#123; myObject = new MyObject(); &#125; return myObject;&#125; 懒汉模式：synchronized 修饰方法懒汉模式中使用 synchronized 修饰方法，可以解决并发安全问题。缺点：如果单例已经被初始化完毕，每次使用时却还需要同步获取，效率并不高。 1234567private static MyObject myObject;public synchronized static MyObject getInstance()&#123; if (myObject == null)&#123; myObject = new MyObject(); &#125; return myObject;&#125; 懒汉模式：synchronized 同步代码块，双检锁懒汉模式中使用 synchronized 同步代码块，必须使用双检锁的模式，才能确保线程并发安全。双检锁：DCL- Dounble Check Lock，正确示例： 12345678910111213// volatile 禁止指令重排序private volatile static MyObject myObject;public static MyObject getInstance()&#123; if (myObject == null)&#123; //step1 synchronized (MyObject.class) &#123; //step2 if (myObject == null) &#123; //step3 myObject = new MyObject(); //step4 &#125; &#125; &#125; return myObject;&#125; 代码解析： step1/step3 两次检测非空，即双检锁 step2 只有在初始化时加锁，提高效率 step4 在 JMM 内存模型中，存在编译器对指令的优化。这一步并非原子操作，实际上被分解为三步：给实例分配存储空间；new 初始化存储空间；myObject 指向存储空间（此时 myObject 为非空了）。在指令优化时第二步和第三步是乱序的，所以当正在执行 step4 的线程在乱序的情况下，先执行了指向存储空间，导致 myObject 非空，其他线程在读取时认为非空就直接使用了会出错。所以针对这个问题，需要使用 volatile 关键字来修饰 myObject 共享变量，禁止指令重排序。 懒汉模式：静态内置类实现饿汉模式中使用静态内置类来初始化实例，静态内置类只有在第一次引用时才会被加载到内存，间接实现了懒汉模式。示例： 1234567891011121314private static class MyObject&#123; // 静态内置类，只有在第一次引用时才加载 private static class MyObjectHandler&#123; private static MyObject myObject = new MyObject(); &#125; private MyObject()&#123; &#125; public static MyObject getInstance()&#123; return MyObjectHandler.myObject; &#125;&#125; 序列化与反序列化对静态内置类的影响使用静态内置类实现懒汉模式，提供了资源利用率。但是在序列化和反序列化中，反序列化会克隆这个实例，不满足单例模式的特性了。解决方案：在类中实现 readResolve 方法。该方法是 ObjectInputStream.readObject() 读取时，会判断类中是否定义了，如果定义则会通过反射调用 readResolve 返回的对象替换反序列化中创建的对象，这样就做到了确保单例模式的唯一性。 1234567891011121314151617private static class MyObject implements Serializable&#123; private static final long serialVersionUID = -6683402613942762249L; private static class MyObjectHandler&#123; private static MyObject myObject = new MyObject(); &#125; private MyObject()&#123;...&#125; public static MyObject getInstance()&#123; return MyObjectHandler.myObject; &#125; // ObjectInputStream.readObject() --&gt; readOrdinaryObject private Object readResolve() throws ObjectStreamException &#123; return MyObjectHandler.myObject; &#125;&#125; 懒汉模式：枚举类的实现枚举中我们明确了构造方法限制为私有，在我们访问枚举实例时会执行构造方法，同时每个枚举实例都是 static final 类型的，也就表明只能被实例化一次。枚举也提供了序列化机制，所以不存在内部静态类在读取时需要重写 readResolve 的问题。在《Effective Java》 中提到：单元素的枚举类型已经成为实现 Singleton 的最佳方法。 123456789101112131415161718192021222324252627282930// 实现方法一：枚举类作为帮助类实现单例private static class MyObject&#123; private enum Helper&#123; INSTANCE; private MyObject myObject; Helper()&#123; myObject = new MyObject(); &#125; public MyObject getInstance()&#123; return myObject; &#125; &#125; private MyObject()&#123;...&#125; public static MyObject getInstance()&#123; return Helper.INSTANCE.getInstance(); &#125;&#125;// 方法二：直接设计一个枚举类，并且支持序列化和反序列化private enum MyObjectSerializable &#123; INSTANCE; public void method() &#123; &#125;&#125; 线程组概念 作用可以批量管理线程或线程组对象，有效的对线程或线程组对象进行组织。 结构图 线程对象关联线程组 1 级关联父对象中有子对象，但不创建孙对象。非常常用，我们在线程池技术中，线程工厂创建线程时基本都是 1 级关联，可以对零散的线程进行有效的组织和规划。 多级关联父对象中有子对象，子对象中还有子对象，也就是出现了子孙对象。多级关联就是结构图中的树结构，但是这种级联方式并不常见，层次过多会导致管理复杂。 1 级关联示例： 123456789101112RunnableA runnableA = new RunnableA();RunnableB runnableB = new RunnableB();ThreadGroup threadGroup = new ThreadGroup("TestThreadGroup");Thread threadA = new Thread(threadGroup, runnableA);Thread threadB = new Thread(threadGroup, runnableB);threadA.start();threadB.start();System.out.println("ThreadGroup Active Count: " + threadGroup.activeCount());System.out.println("ThreadGruop Name: " + threadGroup.getName());Thread.sleep(3000);threadGroup.interrupt(); 常用 API threadGroup.getName()：获取线程组名称 threadGroup.activeCount()：获取线程组中活动线程估计数 threadGroup.interrupt()：中断线程组中所有线程 threadGroup.getParent()：获取线程组的父线程组 自动归属特性线程组在构造时，如果不显示指定父线程组，默认为自动归属到当前线程组。ThreadGroup threadGroup = new ThreadGroup(&quot;TestThreadGroup&quot;);：自动归属到当前 main 线程组中。 参考文档 Java多线程编程核心技术–高洪岩 图文并茂简单易懂的博客1 图文并茂简单易懂的博客2]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内存模型]]></title>
    <url>%2F2017%2F10%2F25%2F0004-java-memory-model%2F</url>
    <content type="text"><![CDATA[Java 内存模型（Java Memory Model, JMM），本文主要参考 JSR -133 内存模型 基本概念共享变量 堆内存：包含类实例、静态字段和数组元素 方法区：类字段（全局变量）堆内存中的变量和方法区的全局变量，在线程之间共享，这些统称为共享变量。其他如虚拟机栈帧（局部变量表，方法返回值）等都是线程私有的 抽象示意图内存模型决定一个线程对共享变量的写入何时对另一个线程可见，从抽象的角度来看：线程之间的共享变量存储在主内存中，每个线程都有一个私有的工作内存，工作内存中存储了该线程以读/写共享变量的副本。这里仅仅将 JMM 作为一个抽象概念，并不和物理实际内存、高速缓存、寄存器等做一一对应。内存模型抽象示意图： 内存间交互操作定义了 8 中操作，每种都是原子的、不可再分的（对于 double 和 long 来说理论上有例外，但是商用虚拟机上不会存在这个现象） lock 锁定：作用于主内存的变量，标注该变量为一条线程独占状态 unlock 解锁：作用于主内存的变量，标注该变量被解锁，其他线程能使用 read 读取：作用于主内存的变量，它把变量从主内存传输到线程的工作内存中，供 load 使用 load 载入：作用于工作内存的变量，它把 read 操作的变量放入工作内存的变量副本中 use 使用：作用于工作内存的变量，每当虚拟机需要使用该变量时，传递给执行引擎 assign 赋值：作用于工作内存的变量，每当虚拟机需要给变量赋值时，从执行引擎中读取并赋值给工作内存变量副本 store 存储：作用于工作内存的变量，它把工作内存的变量副本传递给主内存中，供 write 使用 write 写入：作用于主内存的变量，它把 store 操作从工作内存中得到的变量放入主内存的变量中 long 和 double 的非原子协定long 和 double 的非原子协定（Nonatomic Treatment of double and long Variables）：对于 64 位的 long 和 double 类型，允许虚拟机将没有被 volatile 修饰的数据，在读写操作时划分为两次 32 的操作来进行，即不保证它们的 load, store, read, write 是原子性的。这会导致多线程中同时对他们读写，可能会出现某个线程读取到的既不是原值，也不是被其他线程修改过的值，而是读到了各一半的混合值，但是这种情况在商用虚拟机中并不会出现，因此代码中一般并不会对这两种类型专门申明为 volatile 原子性、可见性、有序性原子性（Atomicity）在 Java 内存模型中所有的基本数据类型读写访问具备原子性（long/double 虽然有非原子协议，但是商用虚拟机不会出现）。如果需要需要保证代码块的原子性，需要使用 synchronized 关键字 可见性（Visibility）指一个线程修改了共享变量的值，其他线程能够立即得到这个修改后的值。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。关键字 volatile, synchronized, final 都能实现可见性 volatilevolatile 修饰的变量通过反汇编发现会多执行一个 lock 前缀的操作，这个操作相当于内存屏障（Memory Barrier or Memory Fence），作用是使得本 CPU 的 Cache 写入内存，同时会引起其他 CPU Cache 变得无效；相当于 Java 内存模式中的 store/write 操作，所以可以确保 volatile 变量的修过对其他 CPU 立即可见 synchronized同步块对一个变量的执行 unlock 操作前，必须先把此变量同步写回主内存中 final变量在构造器中一旦初始化完成，那在其他线程中就能看到这个字段的值 有序性（Ordering）如果在本线程中观察，所有的操作都是有序的（As-If-Serial 语义） ；如果在一个线程中观察另外一个线程，所有的操作都是无序的（重排序，包括指令重排序和内存同步延迟） 关键字 volatile 和 synchronized 两个关键字来保证线程之间的操作的有序性： volatile关键字禁止了指令重排序 synchronized一个变量在同一个时刻只允许一条线程对其进行 lock 操作，决定了持有同一个锁的两个同步块只能串行地进入 总结synchronized 关键字能满足三种特性；volatile 能部分满足，在有条件情况下可以满足并发安全 重排序概念在执行程序时为了提高性能，编译器和处理器常常会改变指令执行顺序或者内存操作顺序，也就是重排序。重排序分三种类型： 编译器优化的重排序编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序 指令级并行的重排序现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序 内存系统的同步延迟由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行 其中：1 属于编译器重排序，2 和 3 属于处理器重排序 影响 重排序都可能会导致多线程程序出现内存可见性问题 JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证 原则不管怎么重排序，单线程程序执行的结果不能改变。也就是内存模型中描述的：线程内表现为串行的语义（Within-Thread As-If-Serial Semantics）。 示例 指令执行重排序 12int a = 1;int b = 2; 如上两条指令无论是在编译器优化重排序，还是处理器优化并发执行，并不会影响重排序后的执行结果 内存操作重排序根据 JMM 定义，各线程会使用写缓冲区来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致 12345Processor A Processor Ba = 1; //A1 b = 2; //B1x = b; //A2 y = a; //B2初始状态：a = b = 0处理器允许执行后得到结果：x = y = 0 处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果 数据依赖性指当前操作依赖前一次操作的结果。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。注意：数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑 先行发生原则 happens-before作用及意义如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这些先行发生原则，可以确保两个操作在不需任何同步协助下并发是安全的。 实质先行发生原则的实质就是禁止重排序 规则 程序次序规则（Program Order Rule）在同一个线程中，按照程序代码顺序和控制流顺序操作 管程锁定规则（Monitor Lock Rule）针对同一个锁， unlock 操作在时间上先发生于后面对该锁的 lock 操作 volatile 变量规则（Volatile Variable Rule）对 volatile 变量的写操作在时间上先行发生于后面对改变的读操作 传递性（Transitivity）如果操作 A 先行发生于操作 B ，操作 B 先行发生于操作 C，则操作 A 先行发生于操作 C 对象终结规则（Finalizer Rule）对象的初始化先行发生于它的 finalize 线程启动规则（Thread Start Rule）Thread 对象的 start() 方法先发生于此线程的每个动作 线程终止规则（Thread Termination Rule）线程中的所有操作都先行发生于对此线程的终止检测。可以通过 Thread.join()/Thread.isAlive() 来检测到线程已经终止 线程中断规则（Thread Interruption Rule）对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件发生，可以通过 Thread.interrupted() 方法检测是否中断发生 时间上的先后顺序与先行发生的差异happens-before 关系，并不是说时间上前一个操作必须要先在后一个操作之前执行！而是仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。 示例 123456789private int value = 0;public void setValue(int value)&#123; this.value = value;&#125;public int getValue()&#123; return value;&#125; 这是一个简单的 getter/setter 方法，假设线程 A 在时间上先调用了 setValue(1) ，线程 B 调用了同一个对象的 getValue ，那么线程 B 的返回值是什么？ 根据 happens-before 的各项规则，可以看到 8 项规则都不符合，也就是这个操作是并不是线程安全的。 想一个具体的例子来演示错误，并且给出修改方案及测试结果? 结论时间先后顺序与先行发生原则之间基本没有太大的关系，所以衡量安全并发不要受到时间顺序干扰，必须以先行发生原则为准 volatile 关键字关键字 volatile 可以理解为 Java 虚拟机提供的最轻量级同步机制。有两种特性： 保证此变量对所有线程的可见性 禁止指令重排序优化 可见性保证此变量对所有线程的可见性，但是在 Java 中变量复合运算并非原子操作，所以 volatile 变量在并发中是不安全的。保证并发安全需要符合如下两条规则： 运算结果并不依赖变量的当前值，或者确保只有单一线程修改变量的值 变量不需要与其他状态变量共同参与不变约束 禁止指令重排序优化总结volatile 变量读操作的性能消耗与普通变量几乎没有区别，写操作可能会慢一些，但是总体开销要比锁低。 参考文档： The Java Language Specification, Java SE 7 Edition-jmm JSR-133: Java Memory Model and Thread Specification 深入理解 Java 内存模型 深入理解 Java 虚拟机]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 命令行操作]]></title>
    <url>%2F2017%2F10%2F23%2F0003-java-command%2F</url>
    <content type="text"><![CDATA[编译执行相关javac编译 Java 文件，生成 .class 二进制文件 12345public class HelloWorld &#123; public static void main(String[]agrs) &#123; System.out.println("HelloWorld!"); &#125;&#125; 编译并生成： 1234// -d 参数表示指定目录，默认为当前目录xmt@server005:~/test/java$ javac -d . HelloWorld.java xmt@server005:~/test/java$ lsHelloWorld.class HelloWorld.java java执行 .class 文件，先判断 HelloWorld.java 文件中是包含包名： 不包含包名，直接执行 12xmt@server005:~/test/java$ java HelloWorldHelloWorld! 包含包名，需要显示指定包路径比如包名为：com.company.department 12xmt@server005:~/test/java$ java com/company/department/HelloWorldHelloWorld! 执行 jar 包中的某个 .class 文件java -cp jarPath com.***.Test，其中 jarPath 为 jar 包完整路径名，.class 文件需要完整包名加类名。 注意： 包名之间是反斜杠 /，特别是 Windows 环境中。 javap反汇编器，可以查看编译器为我们生成的字节码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// -c -v 命令为反编译xmt@server005:~/test/java$ javap -c -v HelloWorld.classClassfile /home/xmt/test/java/HelloWorld.class Last modified Oct 23, 2017; size 425 bytes MD5 checksum 214f120295cc6d0d5e7983866ad7e1ba Compiled from "HelloWorld.java"public class HelloWorld SourceFile: "HelloWorld.java" minor version: 0 major version: 51 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #6.#15 // java/lang/Object."&lt;init&gt;":()V #2 = Fieldref #16.#17 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #18 // HelloWorld! #4 = Methodref #19.#20 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #21 // HelloWorld #6 = Class #22 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 main #12 = Utf8 ([Ljava/lang/String;)V #13 = Utf8 SourceFile #14 = Utf8 HelloWorld.java #15 = NameAndType #7:#8 // "&lt;init&gt;":()V #16 = Class #23 // java/lang/System #17 = NameAndType #24:#25 // out:Ljava/io/PrintStream; #18 = Utf8 HelloWorld! #19 = Class #26 // java/io/PrintStream #20 = NameAndType #27:#28 // println:(Ljava/lang/String;)V #21 = Utf8 HelloWorld #22 = Utf8 java/lang/Object #23 = Utf8 java/lang/System #24 = Utf8 out #25 = Utf8 Ljava/io/PrintStream; #26 = Utf8 java/io/PrintStream #27 = Utf8 println #28 = Utf8 (Ljava/lang/String;)V&#123; public HelloWorld(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 1: 0 public static void main(java.lang.String[]); flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String HelloWorld! 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 3: 0 line 4: 8&#125; 调试jpsjps(Java Virtual Machine Process Status Tool) 是 JDK 1.5 提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前 java 进程的一些简单情况。命令路径：JAVA_HOME/bin/java 程序在启动以后，会在 java.io.tmpdir 指定的目录下，就是临时文件夹里，生成一个类似于 hsperfdata_User 的文件夹，这个文件夹里（在 Linux 中为 /tmp/hsperfdata_{userName}/）的文件，名字就是进程的 pid。因此列出当前运行的 java 进程，只是把这个目录里的文件名列一下而已。 至于系统的参数等，就可以解析这几个文件获得。 遇到的问题现象：用 ps -ef|grep java 能看到启动的 java 进程，但是用 jps 查看却不存在该进程的 id，jconsole、jvisualvm 可能无法监控该进程，其他 java 自带工具也可能无法使用分析：jps、jconsole、jvisualvm 等工具的数据来源就是这个文件（ /tmp/hsperfdata_userName/pid )。所以当该文件不存在或是无法读取时就会出现 jps 无法查看该进程号，jconsole 无法监控等问题。可以检查该文件权限，或者确定文件是否异常 示例 123xmt@server005:/tmp/hsperfdata_xmt$ jps130257 MyDeadLock130413 Jps jstack语法格式： jstack &lt;pid&gt; 可以用 jps 查看 java 进程 idjstack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。 我们能看到： * 线程的状态： waiting on condition * 线程的调用栈 * 线程的当前锁住的资源： &lt;0x*&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253xmt@server005:/tmp/hsperfdata_xmt$ jps130257 MyDeadLock130413 Jpsxmt@server005:/tmp/hsperfdata_xmt$ jstack -l 1302572017-10-30 14:45:07Full thread dump OpenJDK 64-Bit Server VM (24.91-b01 mixed mode):"Attach Listener" daemon prio=10 tid=0x00007f0b8c001000 nid=0x1fd6c waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None"DestroyJavaVM" prio=10 tid=0x00007f0c6400a000 nid=0x1fcd2 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None"2" prio=10 tid=0x00007f0c64130000 nid=0x1fd02 waiting for monitor entry [0x00007f0bf8ada000] java.lang.Thread.State: BLOCKED (on object monitor) at MyDeadLock$MyRunnable.run(MyDeadLock.java:42) - waiting to lock &lt;0x00000006b0f51b18&gt; (a java.lang.Object) - locked &lt;0x00000006b0f51b28&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:745) Locked ownable synchronizers: - None"1" prio=10 tid=0x00007f0c6412e000 nid=0x1fd01 waiting for monitor entry [0x00007f0bf8bdb000] java.lang.Thread.State: BLOCKED (on object monitor) at MyDeadLock$MyRunnable.run(MyDeadLock.java:30) - waiting to lock &lt;0x00000006b0f51b28&gt; (a java.lang.Object) - locked &lt;0x00000006b0f51b18&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:745) Locked ownable synchronizers: - None...Found one Java-level deadlock:============================="2": waiting to lock monitor 0x00007f0b900062c8 (object 0x00000006b0f51b18, a java.lang.Object), which is held by "1""1": waiting to lock monitor 0x00007f0b90004e28 (object 0x00000006b0f51b28, a java.lang.Object), which is held by "2"Java stack information for the threads listed above:==================================================="2": at MyDeadLock$MyRunnable.run(MyDeadLock.java:42) - waiting to lock &lt;0x00000006b0f51b18&gt; (a java.lang.Object) - locked &lt;0x00000006b0f51b28&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:745)"1": at MyDeadLock$MyRunnable.run(MyDeadLock.java:30) - waiting to lock &lt;0x00000006b0f51b28&gt; (a java.lang.Object) - locked &lt;0x00000006b0f51b18&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:745)Found 1 deadlock. JVM 常见参数 选项 描述 -XX:+TraceClassLoading 打印类加载日志，别名 -verbose:class -Xms 初始堆大小。如：-Xms256m -Xmx 最大堆大小。如：-Xmx512m -Xmn 新生代大小。通常为最大堆的 1/3 或 1/4。新生代 = Eden + 2 个 Survivor 空间。实际可用空间为 = Eden + From，即 90% 的空间 -XX:NewRatio 新生代与老年代的比例，如 –XX:NewRatio=2，则新生代占整个堆空间的 1/3，老年代占 2/3 -XX:SurvivorRatio 新生代中 Eden 与 Survivor 的比值。默认值为 8。即 Eden 占新生代空间的 8/10，另外两个 Survivor 各占 1/10 -XX:PretenureSizeThreshold 老年代门限值，大小大于这个值的对象直接分配进老年代，这个参数只对 Serial 和 ParNew 收集器生效 -XX:MaxTenuringThreshold 对象从新生代晋升到老年代的年龄阀值，默认为 15 -XX:+PrintGC 开启 GC 打印简单信息，别名 -verbose:gc -XX:+PrintGCDetails 打印 GC 详细信息，通常默认会包含 -XX:+PrintGC 的信息 -XX:+PrintHeapAtGC 打印 GC 前后的堆信息 -Xss JDK1.5+ 每个线程堆栈大小为 1M 。如果超出抛出 StackOverflowError -XX:PermSize 永久代（方法区）的初始大小，Java 8 中已经使用元空间，降级 -XX:MaxPermSize 永久代（方法区）的最大值，Java 8 中已经使用元空间，降级 -XX:+HeapDumpOnOutOfMemoryError 让虚拟机在发生内存溢出时 Dump 出当前的内存堆转储快照，以便分析用 -XX:+UseSerialGC 使用 Serial + Serial Old 收集器组合回收内存 -XX:+UseParNewGC 使用 ParNew + Serial Old 收集器组合回收内存 -XX:+UseConcMarkSweepGC 使用 ParNew + CMS + Serial Old 收集器组合回收内存，Serial Old 作为 CMS 失败时的备用收集器 -XX:+UseParallelGC 使用 Parallel Scavenge 收集新生代 -XX:+UseParallelOldGC 使用 Parallel Old 收集老年代，默认同时开启 -XX:+UseParallelGC 其他常见命令javadocjavadoc 用来生成 Java 注释和 API 文档。格式：javadoc -d targetDirectory package.name 。示例：javadoc -d mydoc com.android.mycode 。 123456789101112131415161718192021xmt@server005:~/$ javadoc -d mydoc annotation.subdirCreating destination directory: "mydoc/"Loading source files for package annotation.subdir...Constructing Javadoc information...Standard Doclet version 1.7.0_91Building tree for all the packages and classes...Generating mydoc/annotation/subdir/Testable.html...Generating mydoc/annotation/subdir/TestJavaDoc.html...Generating mydoc/annotation/subdir/package-frame.html...Generating mydoc/annotation/subdir/package-summary.html...Generating mydoc/annotation/subdir/package-tree.html...Generating mydoc/constant-values.html...Building index for all the packages and classes...Generating mydoc/overview-tree.html...Generating mydoc/index-all.html...Generating mydoc/deprecated-list.html...Building index for all classes...Generating mydoc/allclasses-frame.html...Generating mydoc/allclasses-noframe.html...Generating mydoc/index.html...Generating mydoc/help-doc.html...]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 相关操作]]></title>
    <url>%2F2017%2F10%2F12%2F0002-git-guide%2F</url>
    <content type="text"><![CDATA[设置全局设置全局设置使用 gig config --global 参数，全局配置文件路径 ~/.gitconfig ，即家目录下。 中文文件名或路径被转义在使用git的时候，经常会碰到有一些中文文件名或者路径被转义成 \xx\xx\xx 之类的示例：fang/\344\272\244\346\230\223\346\265\201\347\250\213/解决方案： xmt@server005:~$ git config --global core.quotepath false Windows 中回车换行符的处理github处理回车换行git config --global core.autocrlf true 别名或者短命令 alias对于比较长的命令可以使用 tab 键补全，也可以通过 alias 定制命令的别名来缩短：格式：git config --global alias.新名称 &#39;完整命令&#39; 。示例：git config --global alias.l &#39;log -1&#39; ，即 git log -1 查看最近一条提交记录，可以使用短命令 git l 来实现。 也可以直接打开 ~/.gitconfig 文件，批量修改： 123456[core] quotepath = false autocrlf = true[alias] l = log -1 co = checkout 当前仓库设置使用 git config 时不带 --global 参数，可以针对每个仓库做定制化。配置文件在每个仓库下面：.git/config 用户名和邮箱 12xmt@server005:~$ git config user.name xmtxmt@server005:~$ git config user.email xmt@company.com 分支查看所有分支(本地和远程)git branch -a 或者 git branch -av 新建分支 git branch test_branch git checkout –b test_branch 新建空分支git checkout --orphan empty_branch空分支不会有任何提交历史，通常可以用来新建 todo 或者 docs 分支。git rm -rf . ;git commit -m &#39;new empty branch，在提交修改后（也就是生成一次提交记录），分支才能通过 git branch -a 查看到。 删除分支git branch -d test_branch 或者 git branch -D test_branch 新建远程分支git push origin &lt;branchName&gt;:&lt;branchName&gt;注释：origin 是默认的远程版本库名称，事实上 git push origin master 的意思是 git push origin master:master 。将本地的 master 分支推送至远端的 master 分支，如果没有就新建一个 删除远程分支和 tag 方法 1 12git push origin --delete &lt;branchName&gt;git push origin --delete tag &lt;tagname&gt; 方法 2 123git push origin :&lt;branchName&gt;git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt; 提交重命名目录12git mv ipc 005_ipcrenamed: docs/ipc/Serializable_Parcelable.md -&gt; docs/005_ipc/Serializable_Parcelable.md 提交到 stack回退与恢复本地修改回退git reset --hard ab2b3747704c204bd5a810d5c445d4394647cbfb--hard 表示将本地所有修改回退到这个 commit 处 回退 unstage12345Changes to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: .gitignore new file: data/jobs.txt 比如上面的 .gitignore, data/jobs.txt 两个文件已经通过 git add 添加，但是还没有提交 commit；可以通过 git reset HEAD 回退到 unstage 状态。 修复已提交的错误已提交是指 commit 后但是没有 push 到远程仓库。如果已经 push 到远程仓库，无法修改。 修复后新建一个 commit 提交这种方法是最简单的，但是会形成多余的 commit 。 共用上次错误提交的 commit不管是想修改文件还是提交记录，都可以使用 git commit --amend 来修复上次错误提交。如果仅仅是修改提交记录，直接执行重新编辑提交记录即可。如果是修改代码，需要先 add 再执行： 123ubuntu$ vim a.txt // 修改代码ubuntu$ git add a.txt // 添加到 stageubuntu$ git commit --amend // 使用上次的 commit 重新提交这次修改 恢复误操作 reflog 先查看所有的修改记录 git reflog 123$ git reflog570b79a HEAD@&#123;0&#125;: reset: moving to 70b79a71fdf388eaa0cf4bc57849cf5aae6212d0dab5ea HEAD@&#123;1&#125;: commit: add use case framework. 其中 570b79a 为误操作 回退这个误操作git reset --hard 0dab5ea 合并 mergecherry-pick 将分支 A 的提交合入到分支 B 查看分支 A 上的 commitid，如：7eef2cda41edc07c8ee2c5ba5dbc9f1602144c88 切换到分支 B ，合入这个 commitid的修改 git cherry-pick 7eef2cda41edc07c8ee2c5ba5dbc9f1602144c88 ,合入后会重新生成 id 查看提交查看 log 基本命令 git log 按照指定格式显示 示例：git log --pretty=format:&quot;%an %ae %ad %cn %ce %cd %cr %s&quot; 12345678910111213141516选项 说明%H 提交对象（commit）的完整哈希字串%h 提交对象的简短哈希字串%T 树对象（tree）的完整哈希字串%t 树对象的简短哈希字串%P 父对象（parent）的完整哈希字串%p 父对象的简短哈希字串%an 作者（author）的名字%ae 作者的电子邮件地址%ad 作者修订日期（可以用 -date= 选项定制格式）%ar 作者修订日期，按多久以前的方式显示%cn 提交者(committer)的名字%ce 提交者的电子邮件地址%cd 提交日期%cr 提交日期，按多久以前的方式显示%s 提交说明 示例：按照 commit，作者，提交说明这三项查看 log，并通过 | 分隔，方便分析git log --pretty=format:&quot;%H | %an | %s&quot; &gt; log 查看某次提交 基本命令：git show commit_id 12345678910xmt@server005:~$ git show 8593d90fd5c35ef6a9d88910651e528116914dd0commit 8593d90fd5c35ef6a9d88910651e528116914dd0Author: xmt &lt;xmt@30d99328-7319-4b8f-a506-b34d821aa509&gt;Date: Fri Dec 5 08:52:39 2014 +0000 解决耳机识别问题 git-svn-id: http://10.1.1.253/android/Marvell/pxa1908/branches/PO9041/trunk/po9041_trunk@83 30d99328-7319-4b8f-a506-b34d821aa509 如果不带 commit_id ，默认为查看最近一次 查看某次提交修改了哪些文件，参数 -numstatgit show –numstat 8593d90fd5c35ef6a9d88910651e528116914dd0 查看修改状态基本命令：git whatchanged 。示例：查看该次提交文件修改状态，如增加，修改，删除等git whatchanged -1 8593d90fd5c35ef6a9d88910651e528116914dd0 修改提交后的作者信息使用了错误的账号提交 commit 后，需要修改作者信息，参考步骤如下。 修改上次提交的作者信息 当前 git 仓库设置正确的作者信息git config user.name/email *** ，设置正确的作者信息。 修改上次提交的作者信息git commit --amend --reset-author ，使用当前作者信息，重新修改上次提交。 修改某次提交的作者信息 找到需要修改的提交 idgit log 查看并找到需要修改的提交 id ，比如如下记录中，需要修改第二条提交记录 b9b1f623bab552c47e4f0e78d159fa282bd95632 。 1234567891011121314151617commit ac5da90b4095d391701a74ab77eada36c35dc015Author: red &lt;red@mail.com&gt;Date: Mon Feb 18 14:23:46 2019 +0800 update b to ccommit b9b1f623bab552c47e4f0e78d159fa282bd95632Author: red &lt;red@mail.com&gt;Date: Mon Feb 18 14:23:21 2019 +0800 update a to bcommit da8a5a3c1039c77146eb9181bbe1778bcebcd797Author: red &lt;red@mail.com&gt;Date: Mon Feb 18 14:20:34 2019 +0800 add a.txt 使用 git rebase -i 命令rebase -i 指定到被修改 id 的前一个 id: （或者使用 git rebase -i HEAD~n ，其中 n 为倒数第几个提交记录）： 123456git rebase -i da8a5a3c1039c77146eb9181bbe1778bcebcd797// 在弹出的编辑框中，将第二条记录前的 pick 修改为 edit，保存退出edit b9b1f62 update a to b // 目标 id，重置这条记录的作者信息pick ac5da90 update b to c# Rebase da8a5a3..ac5da90 onto da8a5a3 修改完毕后，目标 id 提交记录在当前仓库中，成为最后一条提交记录。（那原本的最后一条提交记录呢？？向后看） 修改上次提交的作者信息使用 git commit --amend --reset-author 命令，重置上次提交记录（也就是当前目标 id ）的作者信息。 使用 git rebase --continue 命令使用 rebase --continue 命令，将分支恢复（即将最后一条提交记录复原）。 12345678910111213141516171819$ git rebase --continueSuccessfully rebased and updated refs/heads/master.$ git logcommit 63df1273b7cc28905e73af4579346fc0d4f3e950Author: red &lt;red@mail.com&gt;Date: Mon Feb 18 14:23:46 2019 +0800 update b to c// 目标 id 的作者信息已经被修改commit a3c971465967df8332acb8ec5d5117541a892085Author: modify &lt;modify@mail.com&gt;Date: Mon Feb 18 14:39:33 2019 +0800 update a to bcommit da8a5a3c1039c77146eb9181bbe1778bcebcd797Author: red &lt;red@mail.com&gt;Date: Mon Feb 18 14:20:34 2019 +0800 Patch 相关操作制作 patch 制作单次提交的 patchgit format-patch -1 ab2b3747704c204bd5a810d5c445d4394647cbfb其中：-1 表示单次提交 某次提交后的所有修改，每次提交都生成一个 patchgit format-patch -s ab2b3747704c204bd5a810d5c445d4394647cbfb其中：-s 表示某次提交后的所有修改。但不包含当前 commit 的这次修改 合入 patchgit am patchname.patch 将多个 commit 合并为一个 patch 分别将这几个 commit 生成对应的 patch 新建两个分支 patches_branch 和 merge_branchpatches_branch：用于提交多个分散的patchmerge_branch：用于将 patches_branche 上的修改 merge 过来，生成单独 patch 两个分支都回退到第一个 commit 之前git reset --hard ab2b3747704c204bd5a810d5c445d4394647cbfb--hard 表示将本地所有修改回退到这个 commit 处 patches_branch 分支上，通过 git am 合入第一步生成的所有 patch 文件 merge_branch 分支上，将所有修改 merge 过来，提交并生成一个新的 commitgit merge patches_branch –squash其中：参数 –squash 表示放弃修改的历史信息 将这个 commit 制作成新的 patch 。至此，所有修改生成单个 patch 文件完成 制作两个分支之间差异 patch从 master 新建 dev 分支，并在 dev 分支上做多次修改提交后，比较 dev 和 master 两个分支间的差异，并生成 patch 文件。 比较两个分支间的差异git log master..dev ，查看有多少次修改记录。 将两个分支间的差异生成多个 patch 文件git format-patch master..dev ，每次修改提交都生成一个 patch 文件。 将两个分支间的差异生成一个总的 patch 文件git diff master..dev &gt; new.patch ，生成单独文件。 注意： master 和 dev 的顺序不能反，否则不会有任何文件生成。 仓库相关提交到远程仓库 push 默认提交git push 默认提交到远程仓库 origin 的 master 分支，默认提交实际对应的命令为 git push origin master:master 。 提交单独分支git push origin dev:dev ，提交 dev 分支到远程仓库。注意这条命令如果冒号 : 前面为空，表示删除远程仓库的 dev 分支。 提交所有分支 --allgit push --all origin ，将本地所有分支都提交到远程仓库。 远程仓库地址切换如原始地址为：https://username@163.com@github.com切换到：git@github.com:username/SoundRecorder.git 查看地址 123git remote -vorigin https://github.com/username/SoundRecorder (fetch)origin https://github.com/username/SoundRecorder (push) 切换地址git remote set-url origin git@github.com:username/SoundRecorder.git 再次查看确认 123git remote -vorigin git@github.com:username/SoundRecorder.git (fetch)origin git@github.com:username/SoundRecorder.git (push) 使用两个远程仓库地址同时备份示例：同时在 github,gitlab 上新建两个 git 仓库 从 github 下载仓库git clone git@github.com:username/SoundRecorder.git 在当前 git 目录下，远程添加新仓库分支git remote set-url --add origin git@gitlab.com:username/SoundRecorder.git在 .git/config 文件中查看： 1234[remote &quot;origin&quot;] fetch = +refs/heads/*:refs/remotes/origin/* url = git@github.com:username/SoundRecorder.git url = git@gitlab.com:username/SoundRecorder.git 获取新仓库分支信息git fetch git@gitlab.com:username/SoundRecorder.git 同步新仓库最新文件git pull git@gitlab.com:username/SoundRecorder.git 同步两个仓库，并提交到服务器上git push origin master 后续每次更新后，push 到服务器上时，会同时备份到两个远程仓库git push 使用两个远程仓库地址分别备份依然使用上面的例子，但是在添加第二个仓库地址时使用 git remote add : 从 github 下载仓库git clone git@github.com:username/SoundRecorder.git 在当前 git 目录下，远程添加新仓库分支git remote add gitlab git@gitlab.com:username/SoundRecorder.git在 .git/config 文件中查看，除了默认的远程版本仓库 origin 外，还多了一个新加的 gitlab 远程仓库名： 123456[remote &quot;origin&quot;] fetch = +refs/heads/*:refs/remotes/origin/* url = git@github.com:username/SoundRecorder.git[remote &quot;gitlab&quot;] fetch = +refs/heads/*:refs/remotes/origin/* url = git@gitlab.com:username/SoundRecorder.git 后续每次更新后，需要 push 2 次，每次备份一个远程仓库github 仓库备份：git push origingitlab 仓库备份：git push gitlab上面两条命令仅仅是提交 master 分支。如果 github 上需要提交的正式修改，而 gitlab 上希望备份本地所有分支及其临时修改。可以使用 --all 强制提交所有分支，或者使用 --mirror 直接备份所有修改：git push --all gitlab 或者 git push --mirror git@gitlab.com:username/SoundRecorder.git 。并且 --mirror 备份的方式并不需要新建远程仓库，使用假名在当前本地仓库上（不要设置全局参数）新建一个短命令非常高效，推荐使用 --mirror 的方式。 远程默认仓库 origin缺省情况下，不需要修改，默认就是 origin 。如果出现了以外，可以通过命令参数 -u 改回来：git push -u origin master 提交。对应的配置文件为 branch.master.remote=origin 。 仓库迁移 clone 裸仓库git clone --bare https://github.com/exampleuser/old-repository.git push mirror 12cd old-repository.gitgit push --mirror https://github.com/exampleuser/new-repository.git 仓库镜像并更新 镜像仓库git clone --mirror https://github.com/exampleuser/old-repository.git 镜像同步更新 12cd old-repository.gitgit remote update // 同步更新镜像仓库的命令]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>git</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitlab 搭建个人 Blog]]></title>
    <url>%2F2017%2F10%2F11%2F0001-setup-gitlab-blog%2F</url>
    <content type="text"><![CDATA[介绍Gitlab 已经越来越强大，同时也可以使用它提供的 pages 搭建个人静态博客官网 pages 介绍官网 doc 搭建步骤 Fork 官网推荐模板模板支持很多种静态博客：hugo, hexo, jekyll 等这里选用 hexo：hexo模板链接 Enable shared Runners在 Settings -- CI / CD -- Runners settings 中检查，是否打开该功能 Configure your project (optional)在 Settings -- General -- Advanced settings -- Rename repository中，将仓库名称和路径都修改为 username.gitlab.io Manually run a pipeline下载该仓库修改并提交后，触发一次自动编译在 CI / CD -- Pipelines 中，查看任务是否执行成功 Visit your site!搭建完毕！直接访问 https://username.gitlab.io 即可如果无法访问，可能会存在一点延时，过几分钟后再访问 Hexo 环境搭建介绍Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内即可利用靓丽的主题生成静态网页。 安装 Node.js 和 gitHexo 安装依赖 Node.js 和 git，所以需要先安装这两个环境 Node.jsNode.js 官网 下载 Windows 下的稳定安装包，一路 Next 安装完毕后，重新开启 window cmd 终端，查看版本号测试是否安装成功： 12$ npm --version3.10.10 gitwindows 工具 git-scm 官网 安装 HexoWindows 下的 Node.js 和 git 环境准备好后，在 windows cmd 终端中，只需一条命令就可以安装 Hexo ：npm install -g hexo-cli官网安装文档 windows cmd 终端中查看版本号： 123456789101112$ hexo --versionhexo-cli: 1.0.3os: Windows_NT 6.1.7601 win32 x64http_parser: 2.7.0node: 6.11.4v8: 5.1.281.108uv: 1.11.0zlib: 1.2.11ares: 1.10.1-DEVicu: 58.2modules: 48openssl: 1.0.2l gitlab 博客本地环境预览本地安装好 Hexo 环境后，可以本地预览 gitlab 中写的博客了。Hexo 相关命令建议在 windows cmd 中输入，打印信息会比 git bash 中的多 hexo 初始化博客目录cmd 中执行如下命令，等待初始化完毕，并产生 node_modules 目录E:\01_work\00_My\06_blog&gt; hexo init username.gitlab.io 安装 hexo-serverHexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用：npm install hexo-server --save注意：搭建时如果没有先安装该模块，也可以直接执行 hexo server ；但是当安装完本地搜索 hexo-generator-searchdb 后，提示需要安装该模块，而此时再安装 hexo-server ，会导致 hexo server 运行后，无法预览网页。 下载博客git-bash 在同级目录中下载 gitlab 博客仓库：git clone git@gitlab.com:username/username.gitlab.io.git username.gitlab 重命名博客目录并拷贝第一步生成的 node_modules 目录将前面 hexo 命令生成的 username.gitlab.io 目录重命名 delete将 git 下载的博客目录由 username.gitlab 更换为 username.gitlab.io将 delete 目录中的 node_modules 拷贝到 username.gitlab.io 中也就是从 gitlab 中下载的博客目录需要 hexo 初始化命令生成的 node_modules（这里也可以简单的使用比较工具 BeyondCompare 将 git 管理的仓库，合入到 hexo 建立的博客目录中，这样效率比较高） cmd 开启服务验证 123E:\01_work\00_My\06_blog\username.gitlab.io&gt;hexo server -lINFO Start processingINFO Hexo is running at http://localhost:4000/username.gitlab.io/. Press Ctrl+C to stop. 浏览器中打开 http://localhost:4000/username.gitlab.io 验证！如果有时读取失败或者读取的内容不对，可以清空浏览器的缓存，再重新登录查看！ 设置主题和样式 NexT介绍Hexo 可以非常方便的更换主题，而且官网及第三方精美主题也很多，本博客选用了国内最流行主题之一： NexTHexo 官网及主题NexT githubNexT 文档NexT 作者博客 下载 NexT 主题Hexo 所有主题都在目录 theme\ 下，直接下载 NexT 主题到该目录：git clone --branch v5.1.3 https://github.com/iissnan/hexo-theme-next themes/next下载好后，删掉目录中的 .git, .github 目录，并将该目录整体提交到博客仓库中 更换博客主题修改站点配置文件，仓库根目录下 _config.yml ，更换主题为 next ： 1234567891011diff --git a/_config.yml b/_config.ymlindex 5cb4781..fcb21db 100644--- a/_config.yml+++ b/_config.yml@@ -64,7 +64,8 @@ pagination_dir: page # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/-theme: landscape+#theme: landscape+theme: next 更换博客样式修改主题配置文件，文件路径 theme\next\_config.yml，本博客采用和主题作者一直的样式 Pisces ： 1234567891011121314diff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex f12e1a1..7bc85a8 100644--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -99,9 +99,9 @@ menu_icons: # --------------------------------------------------------------- # Schemes-scheme: Muse+#scheme: Muse #scheme: Mist-#scheme: Pisces+scheme: Pisces #scheme: Gemini 参考官网文档对这几种样式有基本的介绍及效果展示： Muse默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白XiaMo | OAwan | Hui Wang MistMuse 的紧凑版本，整洁有序的单栏外观Jeff | uchuhimo | xirong Pisces双栏 Scheme，小家碧玉似的清新Vi | Acris | Rainy GeminiIvan.Nginx | Alynx | Raincal 设置语言，支持中文修改站点配置文件，仓库根目录下 _config.yml ，设置语言为 zh-Hans 支持中文： 1234567891011diff --git a/_config.yml b/_config.ymlindex fcb21db..486f8b5 100644--- a/_config.yml+++ b/_config.yml@@ -7,7 +7,7 @@ title: Hexo subtitle: description: author: John Doe-language:+language: zh-Hans timezone: 设置菜单常见菜单有：主页、标签、分类、归档，NexT 默认只有主页和归档，需要添加标签和分类 新建页面Hexo 的分类与标签文档，官网上有详细的新建流程 12345678910111213// 1. hexo 命令新建标签页面E:\01_work\00_My\06_blog\username.gitlab.io&gt;hexo new page tagsINFO Created: E:\01_work\00_My\06_blog\username.gitlab.io\source\tags\index.md// 2. 修改产生的文件，添加页面类型// 在 source\tags\index.md 文件中添加 'type: "tags"' ，将页面的类型设置为 tags---title: tagsdate: 2017-10-12 09:54:34type: "tags"---// 3. 同样方式新建分类页面 添加新菜单支持修改主题配置文件，文件路径 theme\next\_config.yml，把 tags 和 categories 注释取消掉 123456789menu: home: / || home #about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 添加本地搜索添加百度/谷歌/本地 自定义站点内容搜索 安装 hexo-generator-searchdb在站点的根目录下执行以下命令： 12345E:\01_work\00_My\06_blog\username.gitlab.io&gt;npm install hexo-generator-searchdb --savehexo-site@0.0.0 E:\01_work\00_My\06_blog\username.gitlab.io`-- hexo-generator-searchdb@1.0.8 +-- ejs@1.0.0 `-- striptags@3.1.0 编辑站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，启用本地搜索功能： 123# Local searchlocal_search: enable: true 设置站点相关信息修改站点配置文件，仓库根目录下 _config.yml ，添加站点相关信息： 1234567# Sitetitle: Earth Guardiansubtitle: You are not LATE!You are not EARLY!description: 地球卫士author: redspider110language: zh-Hanstimezone: Asia/Shanghai 其他主题设置修改主题配置文件，文件路径 theme\next\_config.yml 站点建立时间取消如下字段的注释： since: 2017 开启页面统计找到 busuanzi_count 设置项，按照如下方法修改 123456789101112131415161718192021222324252627$ git diff themes/next/_config.ymldiff --git a/themes/next/_config.yml b/themes/next/_config.ymlindex e9b0371..2d757eb 100644--- a/themes/next/_config.yml+++ b/themes/next/_config.yml@@ -478,18 +478,19 @@ leancloud_visitors: # Get more information on http://ibruce.info/2015/04/04/busuanzi/ busuanzi_count: # count values only if the other configs are false- enable: false+ enable: true # custom uv span for the whole site- site_uv: true+ site_uv: false site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site- site_pv: true+ site_pv: false site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true- page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;+ #page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt;+ page_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 阅读次数 page_pv_footer: 开启页面阅读进度scrollpercent: true gitlab/github 混合发布最近（2018.3.1之后） gitlab pages 功能异常，每次提交后 CI/CD 都会出错，提示 hexo 找不到，具体错误如下： 123456789├── moment@2.21.0├── cheerio@0.20.0 (entities@1.1.1, dom-serializer@0.1.0, css-select@1.2.0, htmlparser2@3.8.3, jsdom@7.2.2)├── warehouse@2.2.0 (graceful-fs@4.1.11, is-plain-object@2.0.4, JSONStream@1.3.2, cuid@1.3.8)└── lodash@4.17.5npm info ok $ hexo deployERROR Local hexo not found in /builds/***/hexoERROR Try running: &apos;npm install hexo --save&apos;ERROR: Job failed: exit code 1 提了个 issues ，后期再找解决方案。当前先采用 gitlab/github 混合发布的方法提交： github发布的时候，提交上去的只有转换好的 html 文件，当做 pages 使用。 gitlab保存文本及所有提交记录，方便后续追溯。 环境准备按照上面的方法搭建 gitlab 环境及 hexo 博客，参考静态博客搭建指南 搭建 github pages，生成对应的仓库，并添加 ssh-key。 修改配置文件上一步拿到了 github pages 仓库地址：git@github.com:***/***.github.io.git，修改当前博客的配置文件 _config.yml： 1234567891011121314151617181920212223242526diff --git a/_config.yml b/_config.ymlindex a7356be..e3ea455 100644--- a/_config.yml+++ b/_config.yml@@ -12,9 +12,11 @@ timezone: Asia/Shanghai # URL ## If your site is put in a subdirectory, # set url as 'http://yoursite.com/child' and root as '/child/'-url: /-root: "/***.gitlab.io/"+url: http://***.github.io+root: / permalink: :year/:month/:day/:title/ permalink_defaults:@@ -79,9 +81,9 @@ theme: next # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy:- type:git- repo:git@gitlab.com:***/***.gitlab.io.git- branch:master+ type: git+ repo: git@github.com:***/***.github.io.git+ branch: master 注意：有些公司可能会屏蔽 github 的 ssh 连接，因此 repo 中需要使用 https 的免密方式来访问 github 。 问题描述使用 ssh 来测试是否能正确访问 github ，提示 22 端口被 reset ；原因是公司可能开防火墙等封了这种访问方式。 12$ ssh -T git@github.comConnection reset by 52.74.223.119 port 22 解决方案在 _config.xml 中使用 https 方式，显示指定账号密码来访问： 12# repo: git@github.com:***/***.github.io.git repo: https://username:password@github.com/username/username.github.io.git 安装 hexo-deployer-git 安装npm install --save hexo-deployer-git ，安装 hexo-deployer-git 发布工具。 配置安装完 hexo-deployer-git 工具后，执行 hexo d -g 后会在当前 blog 目录下，生成 .deployer-git 目录，它是一个 .git 仓库，我们使用 hexo d 命令发布时，也就是将该 .git 仓库提交到远程目标仓库上。使用 git config user.name/email 配置远程仓库的访问账号。 提交和发布 提交提交是指提交到 gitlab 中，使用常用的 git 命令 commit 就行。 发布发布是指发布到 github pages 中，使用 hexo d -g 命令发布，同时会在 github 中生成提交记录，但这个提交记录可读性非常差，通常为生成 html 更新所有目录。 遇到的问题css is missing访问博客时，没有任何 css 样式，解决方案为在 _config.yml 文件中修改 root 目录： 1234567891011diff --git a/_config.yml b/_config.ymlindex 78c62ed..5cb4781 100644--- a/_config.yml+++ b/_config.yml@@ -13,7 +13,8 @@ timezone: # URL ## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/' url: /-root: "/hexo/"+#root: "/hexo/"+root: "/yourusernname.gitlab.io/" hexo version 查看版本号提示本地没有 hexo错误信息如下，查看版本提示并没有 hexo 命令？ 123E:\01_work\00_My\06_blog&gt; hexo versionERROR Local hexo not found in E:\01_work\00_My\06_blogERROR Try running: 'npm install hexo --save' 这是因为当前博客目录已经包含了 hexo 相关配置文件了，需要重新在 Windows cmd 终端中运行上述命令，生成 node_modules 目录]]></content>
      <categories>
        <category>myTools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Gitlab</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[New York is 3 hours ahead of California. But it does not make California slow. Someone graduated at the age of 22, but waited 5 years before securing a good job! Some became a CEO at 25, and died at 50. While another became a CEO at 50, and lived to 90 years. Someone is still single, while someone else got marred. Obama retires at 55, but Trump starts at 70. Absolutely everyone in this world works based on their Time zone. People around you might seem to go ahead of you, some might seem to be behind you. But everyone is running their own RACE, in their own TIME. Do not envy them or mock them. They are in their TIME ZONE, and you are in yours! Life is about waiting for the right moment to act. So, Relax. You are not LATE. You are not EARLY. You are very much ON TIME, an in your TIME ZONE.]]></content>
  </entry>
</search>
